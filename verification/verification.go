// Verify instances of AAS classes.
//
// The main function is [Verify].
//
// Other verification functions are left for modularity, in case you want to do
// something fancy in your code. However, in the large majority of the cases,
// you only call [Verify].

package verification

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import (
	"fmt"
	"math"
	"strconv"
	aascommon "github.com/aas-core-works/aas-core3.0-golang/common"
	aasreporting "github.com/aas-core-works/aas-core3.0-golang/reporting"
	aastypes "github.com/aas-core-works/aas-core3.0-golang/types"
)

// Represent a verification violation.
//
// Implements `error`.
type VerificationError struct{
	Path: *aasreporting.Path,
	Message: string
}

func newVerificationError(message string) *VerificationError {
	return &VerificationError{
		Path: &aasreporting.Path{},
		Message: message
	}
}

func (ve *VerificationError) Error() string {
	return fmt.Sprintf(
		"%s: %s",
		ve.PathString(),
		ve.Message
	)
}

// Render the path as a string.
func (ve *VerificationError) PathString() string {
	return aasreporting.ToGolangPath(ve.Path)
}

func constructMatchesIDShort() *regexp.Regexp {
	pattern := "^[a-zA-Z][a-zA-Z0-9_]*$"

	return regexp.MustCompile(
	pattern
	)
}

matchesIDShortRe := constructMatchesIDShort()

// Check that text is a valid short ID.
func MatchesIDShort(text string) bool {
	return matchesIDShortRe.MatchString(
		text
	)
}

func constructMatchesVersionType() *regexp.Regexp {
	pattern := "^(0|[1-9][0-9]*)$"

	return regexp.MustCompile(
	pattern
	)
}

matchesVersionTypeRe := constructMatchesVersionType()

// Check that text is a valid version string.
func MatchesVersionType(text string) bool {
	return matchesVersionTypeRe.MatchString(
		text
	)
}

func constructMatchesRevisionType() *regexp.Regexp {
	pattern := "^(0|[1-9][0-9]*)$"

	return regexp.MustCompile(
	pattern
	)
}

matchesRevisionTypeRe := constructMatchesRevisionType()

// Check that text is a valid revision string.
func MatchesRevisionType(text string) bool {
	return matchesRevisionTypeRe.MatchString(
		text
	)
}

func constructMatchesXsDateTimeUTC() *regexp.Regexp {
	digit := "[0-9]"
	yearFrag := aascommon.Concat(
		"-?(([1-9]",
		digit,
		digit,
		digit,
		"+)|(0",
		digit,
		digit,
		digit,
		"))"
	)
	monthFrag := "((0[1-9])|(1[0-2]))"
	dayFrag := aascommon.Concat(
		"((0[1-9])|([12]",
		digit,
		")|(3[01]))"
	)
	hourFrag := aascommon.Concat(
		"(([01]",
		digit,
		")|(2[0-3]))"
	)
	minuteFrag := aascommon.Concat(
		"[0-5]",
		digit
	)
	secondFrag := aascommon.Concat(
		"([0-5]",
		digit,
		")(\\.",
		digit,
		"+)?"
	)
	endOfDayFrag := "24:00:00(\\.0+)?"
	timezoneFrag := "(Z|\\+00:00|-00:00)"
	dateTimeLexicalRep := aascommon.Concat(
		yearFrag,
		"-",
		monthFrag,
		"-",
		dayFrag,
		"T((",
		hourFrag,
		":",
		minuteFrag,
		":",
		secondFrag,
		")|",
		endOfDayFrag,
		")",
		timezoneFrag
	)
	pattern := aascommon.Concat(
		"^",
		dateTimeLexicalRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsDateTimeUTCRe := constructMatchesXsDateTimeUTC()

// Check that text conforms to the pattern of an `xs:dateTime`.
//
// The time zone must be fixed to UTC. We verify only that the `text` matches
// a pre-defined pattern. We do not verify that the day of month is
// correct nor do we check for leap seconds.
//
// See: https://www.w3.org/TR/xmlschema-2/#dateTime
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDateTimeUTC(text string) bool {
	return matchesXsDateTimeUTCRe.MatchString(
		text
	)
}

// Check that `value` is a valid `xs:dateTime` with
// the time zone set to UTC.
func IsXsDateTimeUTC(value string) bool {
	if !MatchesXsDateTime(value) {
		return false
	}

	date, _, ok := strings.Cut(value, "T")
	if !ok {
		panic(
			fmt.Sprintf(
				"Expected 'T' in the date-time if it matches the expected regex, " +
				"but got: %s",
				value
			)
		)
	}
	return IsXsDate(date)
}

func constructMatchesMIMEType() *regexp.Regexp {
	tchar := "[!#$%&'*+\\-.^_`|~0-9a-zA-Z]"
	token := aascommon.Concat(
		"(",
		tchar,
		")+"
	)
	type := aascommon.Concat(
		token
	)
	subtype := aascommon.Concat(
		token
	)
	ows := "[ \\t]*"
	obsText := "[\\x80-\\xff]"
	qdText := aascommon.Concat(
		"([\\t !#-\\[\\]-~]|",
		obsText,
		")"
	)
	quotedPair := aascommon.Concat(
		"\\\\([\\t !-~]|",
		obsText,
		")"
	)
	quotedString := aascommon.Concat(
		"\"(",
		qdText,
		"|",
		quotedPair,
		")*\""
	)
	parameter := aascommon.Concat(
		token,
		"=(",
		token,
		"|",
		quotedString,
		")"
	)
	mediaType := aascommon.Concat(
		"^",
		type,
		"/",
		subtype,
		"(",
		ows,
		";",
		ows,
		parameter,
		")*$"
	)

	return regexp.MustCompile(
	mediaType
	)
}

matchesMIMETypeRe := constructMatchesMIMEType()

// Check that text conforms to the pattern of MIME type.
//
// The definition has been taken from:
// https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1,
// https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3 and
// https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6.
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesMIMEType(text string) bool {
	return matchesMIMETypeRe.MatchString(
		text
	)
}

func constructMatchesRFC8089Path() *regexp.Regexp {
	h16 := "[0-9A-Fa-f]{1,4}"
	decOctet := "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
	ipv4address := aascommon.Concat(
		decOctet,
		"\\.",
		decOctet,
		"\\.",
		decOctet,
		"\\.",
		decOctet
	)
	ls32 := aascommon.Concat(
		"(",
		h16,
		":",
		h16,
		"|",
		ipv4address,
		")"
	)
	ipv6address := aascommon.Concat(
		"((",
		h16,
		":){6}",
		ls32,
		"|::(",
		h16,
		":){5}",
		ls32,
		"|(",
		h16,
		")?::(",
		h16,
		":){4}",
		ls32,
		"|((",
		h16,
		":)?",
		h16,
		")?::(",
		h16,
		":){3}",
		ls32,
		"|((",
		h16,
		":){2}",
		h16,
		")?::(",
		h16,
		":){2}",
		ls32,
		"|((",
		h16,
		":){3}",
		h16,
		")?::",
		h16,
		":",
		ls32,
		"|((",
		h16,
		":){4}",
		h16,
		")?::",
		ls32,
		"|((",
		h16,
		":){5}",
		h16,
		")?::",
		h16,
		"|((",
		h16,
		":){6}",
		h16,
		")?::)"
	)
	unreserved := "[a-zA-Z0-9\\-._~]"
	subDelims := "[!$&'()*+,;=]"
	ipvfuture := aascommon.Concat(
		"[vV][0-9A-Fa-f]+\\.(",
		unreserved,
		"|",
		subDelims,
		"|:)+"
	)
	ipLiteral := aascommon.Concat(
		"\\[(",
		ipv6address,
		"|",
		ipvfuture,
		")\\]"
	)
	pctEncoded := "%[0-9A-Fa-f][0-9A-Fa-f]"
	regName := aascommon.Concat(
		"(",
		unreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		")*"
	)
	host := aascommon.Concat(
		"(",
		ipLiteral,
		"|",
		ipv4address,
		"|",
		regName,
		")"
	)
	fileAuth := aascommon.Concat(
		"(localhost|",
		host,
		")"
	)
	pchar := aascommon.Concat(
		"(",
		unreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		"|[:@])"
	)
	segmentNz := aascommon.Concat(
		"(",
		pchar,
		")+"
	)
	segment := aascommon.Concat(
		"(",
		pchar,
		")*"
	)
	pathAbsolute := aascommon.Concat(
		"/(",
		segmentNz,
		"(/",
		segment,
		")*)?"
	)
	authPath := aascommon.Concat(
		"(",
		fileAuth,
		")?",
		pathAbsolute
	)
	localPath := aascommon.Concat(
		pathAbsolute
	)
	fileHierPart := aascommon.Concat(
		"(//",
		authPath,
		"|",
		localPath,
		")"
	)
	fileScheme := "file"
	fileUri := aascommon.Concat(
		fileScheme,
		":",
		fileHierPart
	)
	pattern := aascommon.Concat(
		"^",
		fileUri,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesRFC8089PathRe := constructMatchesRFC8089Path()

// Check that text is a path conforming to the pattern of RFC 8089.
//
// The definition has been taken from:
// https://datatracker.ietf.org/doc/html/rfc8089
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesRFC8089Path(text string) bool {
	return matchesRFC8089PathRe.MatchString(
		text
	)
}

func constructMatchesBCP47() *regexp.Regexp {
	alphanum := "[a-zA-Z0-9]"
	singleton := "[0-9A-WY-Za-wy-z]"
	extension := aascommon.Concat(
		singleton,
		"(-(",
		alphanum,
		"){2,8})+"
	)
	extlang := "[a-zA-Z]{3}(-[a-zA-Z]{3}){2}"
	irregular := "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)"
	regular := "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)"
	grandfathered := aascommon.Concat(
		"(",
		irregular,
		"|",
		regular,
		")"
	)
	language := aascommon.Concat(
		"([a-zA-Z]{2,3}(-",
		extlang,
		")?|[a-zA-Z]{4}|[a-zA-Z]{5,8})"
	)
	script := "[a-zA-Z]{4}"
	region := "([a-zA-Z]{2}|[0-9]{3})"
	variant := aascommon.Concat(
		"((",
		alphanum,
		"){5,8}|[0-9](",
		alphanum,
		"){3})"
	)
	privateuse := aascommon.Concat(
		"[xX](-(",
		alphanum,
		"){1,8})+"
	)
	langtag := aascommon.Concat(
		language,
		"(-",
		script,
		")?(-",
		region,
		")?(-",
		variant,
		")*(-",
		extension,
		")*(-",
		privateuse,
		")?"
	)
	languageTag := aascommon.Concat(
		"(",
		langtag,
		"|",
		privateuse,
		"|",
		grandfathered,
		")"
	)
	pattern := aascommon.Concat(
		"^",
		languageTag,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesBCP47Re := constructMatchesBCP47()

// Check that text is a valid BCP 47 language tag.
//
// See: https://en.wikipedia.org/wiki/IETF_language_tag
func MatchesBCP47(text string) bool {
	return matchesBCP47Re.MatchString(
		text
	)
}

// Check that `langStrings` are specified each for a unique language.
func LangStringsHaveUniqueLanguages[L aastypes.IAbstractLangString](
	langStrings []L) {
	languageSet := make(map[string]struct{})

	for _, langString := range langStrings {
		language := langString.Language()
		_, has := languageSet[language]
		if has {
			return false
		}

		languageSet[language] = struct{}{}
	}

	return true
}

// Check that there are no duplicate [aastypes.IQualifier.Type]'s in
// the `qualifiers`.
func QualifierTypesAreUnique[Q aastypes.IQualifier](
	qualifiers []Q) bool {
	typeSet := make(map[string]struct{})
	for _, qualifier := range qualifiers {
		t := qualifier.Type()

		_, has := typeSet[t]
		if has {
			return false
		}
		typeSet[t] = struct{}{}
	}
	return true
}

func constructMatchesXMLSerializableString() *regexp.Regexp {
	pattern := "^[\\x09\\x0a\\x0d\\x20-\\ud7ff\\ue000-\\ufffd\\U00010000-\\U0010ffff]*$"

	return regexp.MustCompile(
	pattern
	)
}

matchesXMLSerializableStringRe := constructMatchesXMLSerializableString()

// Check that text conforms to the pattern of the Constraint AASd-130.
//
// Ensures that encoding is possible and interoperability between different
// serializations is possible.
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXMLSerializableString(text string) bool {
	return matchesXMLSerializableStringRe.MatchString(
		text
	)
}

func constructMatchesXsAnyURI() *regexp.Regexp {
	scheme := "[a-zA-Z][a-zA-Z0-9+\\-.]*"
	ucschar := "[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd]"
	iunreserved := aascommon.Concat(
		"([a-zA-Z0-9\\-._~]|",
		ucschar,
		")"
	)
	pctEncoded := "%[0-9A-Fa-f][0-9A-Fa-f]"
	subDelims := "[!$&'()*+,;=]"
	iuserinfo := aascommon.Concat(
		"(",
		iunreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		"|:)*"
	)
	h16 := "[0-9A-Fa-f]{1,4}"
	decOctet := "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])"
	ipv4address := aascommon.Concat(
		decOctet,
		"\\.",
		decOctet,
		"\\.",
		decOctet,
		"\\.",
		decOctet
	)
	ls32 := aascommon.Concat(
		"(",
		h16,
		":",
		h16,
		"|",
		ipv4address,
		")"
	)
	ipv6address := aascommon.Concat(
		"((",
		h16,
		":){6}",
		ls32,
		"|::(",
		h16,
		":){5}",
		ls32,
		"|(",
		h16,
		")?::(",
		h16,
		":){4}",
		ls32,
		"|((",
		h16,
		":)?",
		h16,
		")?::(",
		h16,
		":){3}",
		ls32,
		"|((",
		h16,
		":){2}",
		h16,
		")?::(",
		h16,
		":){2}",
		ls32,
		"|((",
		h16,
		":){3}",
		h16,
		")?::",
		h16,
		":",
		ls32,
		"|((",
		h16,
		":){4}",
		h16,
		")?::",
		ls32,
		"|((",
		h16,
		":){5}",
		h16,
		")?::",
		h16,
		"|((",
		h16,
		":){6}",
		h16,
		")?::)"
	)
	unreserved := "[a-zA-Z0-9\\-._~]"
	ipvfuture := aascommon.Concat(
		"[vV][0-9A-Fa-f]+\\.(",
		unreserved,
		"|",
		subDelims,
		"|:)+"
	)
	ipLiteral := aascommon.Concat(
		"\\[(",
		ipv6address,
		"|",
		ipvfuture,
		")\\]"
	)
	iregName := aascommon.Concat(
		"(",
		iunreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		")*"
	)
	ihost := aascommon.Concat(
		"(",
		ipLiteral,
		"|",
		ipv4address,
		"|",
		iregName,
		")"
	)
	port := "[0-9]*"
	iauthority := aascommon.Concat(
		"(",
		iuserinfo,
		"@)?",
		ihost,
		"(:",
		port,
		")?"
	)
	ipchar := aascommon.Concat(
		"(",
		iunreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		"|[:@])"
	)
	isegment := aascommon.Concat(
		"(",
		ipchar,
		")*"
	)
	ipathAbempty := aascommon.Concat(
		"(/",
		isegment,
		")*"
	)
	isegmentNz := aascommon.Concat(
		"(",
		ipchar,
		")+"
	)
	ipathAbsolute := aascommon.Concat(
		"/(",
		isegmentNz,
		"(/",
		isegment,
		")*)?"
	)
	ipathRootless := aascommon.Concat(
		isegmentNz,
		"(/",
		isegment,
		")*"
	)
	ipathEmpty := aascommon.Concat(
		"(",
		ipchar,
		"){0}"
	)
	ihierPart := aascommon.Concat(
		"(//",
		iauthority,
		ipathAbempty,
		"|",
		ipathAbsolute,
		"|",
		ipathRootless,
		"|",
		ipathEmpty,
		")"
	)
	iprivate := "[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]"
	iquery := aascommon.Concat(
		"(",
		ipchar,
		"|",
		iprivate,
		"|[/?])*"
	)
	ifragment := aascommon.Concat(
		"(",
		ipchar,
		"|[/?])*"
	)
	isegmentNzNc := aascommon.Concat(
		"(",
		iunreserved,
		"|",
		pctEncoded,
		"|",
		subDelims,
		"|@)+"
	)
	ipathNoscheme := aascommon.Concat(
		isegmentNzNc,
		"(/",
		isegment,
		")*"
	)
	irelativePart := aascommon.Concat(
		"(//",
		iauthority,
		ipathAbempty,
		"|",
		ipathAbsolute,
		"|",
		ipathNoscheme,
		"|",
		ipathEmpty,
		")"
	)
	irelativeRef := aascommon.Concat(
		irelativePart,
		"(\\?",
		iquery,
		")?(#",
		ifragment,
		")?"
	)
	iri := aascommon.Concat(
		scheme,
		":",
		ihierPart,
		"(\\?",
		iquery,
		")?(#",
		ifragment,
		")?"
	)
	iriReference := aascommon.Concat(
		"(",
		iri,
		"|",
		irelativeRef,
		")"
	)
	pattern := aascommon.Concat(
		"^",
		iriReference,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsAnyURIRe := constructMatchesXsAnyURI()

// Check that text conforms to the pattern of an `xs:anyURI`.
//
// See: https://www.w3.org/TR/xmlschema-2/#anyURI and
// https://datatracker.ietf.org/doc/html/rfc3987
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsAnyURI(text string) bool {
	return matchesXsAnyURIRe.MatchString(
		text
	)
}

func constructMatchesXsBase64Binary() *regexp.Regexp {
	b04Char := "[AQgw]"
	b04 := aascommon.Concat(
		b04Char,
		"\\x20?"
	)
	b16Char := "[AEIMQUYcgkosw048]"
	b16 := aascommon.Concat(
		b16Char,
		"\\x20?"
	)
	b64Char := "[A-Za-z0-9+/]"
	b64 := aascommon.Concat(
		b64Char,
		"\\x20?"
	)
	b64quad := aascommon.Concat(
		"(",
		b64,
		b64,
		b64,
		b64,
		")"
	)
	b64FinalQuad := aascommon.Concat(
		"(",
		b64,
		b64,
		b64,
		b64Char,
		")"
	)
	padded8 := aascommon.Concat(
		b64,
		b04,
		"= ?="
	)
	padded16 := aascommon.Concat(
		b64,
		b64,
		b16,
		"="
	)
	b64final := aascommon.Concat(
		"(",
		b64FinalQuad,
		"|",
		padded16,
		"|",
		padded8,
		")"
	)
	base64Binary := aascommon.Concat(
		"(",
		b64quad,
		"*",
		b64final,
		")?"
	)
	pattern := aascommon.Concat(
		"^",
		base64Binary,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsBase64BinaryRe := constructMatchesXsBase64Binary()

// Check that text conforms to the pattern of an `xs:base64Binary`.
//
// See: https://www.w3.org/TR/xmlschema-2/#base64Binary
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsBase64Binary(text string) bool {
	return matchesXsBase64BinaryRe.MatchString(
		text
	)
}

func constructMatchesXsBoolean() *regexp.Regexp {
	pattern := "^(true|false|1|0)$"

	return regexp.MustCompile(
	pattern
	)
}

matchesXsBooleanRe := constructMatchesXsBoolean()

// Check that text conforms to the pattern of an `xs:boolean`.
//
// See: https://www.w3.org/TR/xmlschema-2/#boolean
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsBoolean(text string) bool {
	return matchesXsBooleanRe.MatchString(
		text
	)
}

func constructMatchesXsDate() *regexp.Regexp {
	digit := "[0-9]"
	yearFrag := aascommon.Concat(
		"-?(([1-9]",
		digit,
		digit,
		digit,
		"+)|(0",
		digit,
		digit,
		digit,
		"))"
	)
	monthFrag := "((0[1-9])|(1[0-2]))"
	dayFrag := aascommon.Concat(
		"((0[1-9])|([12]",
		digit,
		")|(3[01]))"
	)
	minuteFrag := aascommon.Concat(
		"[0-5]",
		digit
	)
	timezoneFrag := aascommon.Concat(
		"(Z|(\\+|-)(0",
		digit,
		"|1[0-3]):",
		minuteFrag,
		"|14:00)"
	)
	dateLexicalRep := aascommon.Concat(
		yearFrag,
		"-",
		monthFrag,
		"-",
		dayFrag,
		timezoneFrag,
		"?"
	)
	pattern := aascommon.Concat(
		"^",
		dateLexicalRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsDateRe := constructMatchesXsDate()

// Check that text conforms to the pattern of an `xs:date`.
//
// See: https://www.w3.org/TR/xmlschema-2/#date
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDate(text string) bool {
	return matchesXsDateRe.MatchString(
		text
	)
}

func constructMatchesXsDateTime() *regexp.Regexp {
	digit := "[0-9]"
	yearFrag := aascommon.Concat(
		"-?(([1-9]",
		digit,
		digit,
		digit,
		"+)|(0",
		digit,
		digit,
		digit,
		"))"
	)
	monthFrag := "((0[1-9])|(1[0-2]))"
	dayFrag := aascommon.Concat(
		"((0[1-9])|([12]",
		digit,
		")|(3[01]))"
	)
	hourFrag := aascommon.Concat(
		"(([01]",
		digit,
		")|(2[0-3]))"
	)
	minuteFrag := aascommon.Concat(
		"[0-5]",
		digit
	)
	secondFrag := aascommon.Concat(
		"([0-5]",
		digit,
		")(\\.",
		digit,
		"+)?"
	)
	endOfDayFrag := "24:00:00(\\.0+)?"
	timezoneFrag := aascommon.Concat(
		"(Z|(\\+|-)(0",
		digit,
		"|1[0-3]):",
		minuteFrag,
		"|14:00)"
	)
	dateTimeLexicalRep := aascommon.Concat(
		yearFrag,
		"-",
		monthFrag,
		"-",
		dayFrag,
		"T((",
		hourFrag,
		":",
		minuteFrag,
		":",
		secondFrag,
		")|",
		endOfDayFrag,
		")",
		timezoneFrag,
		"?"
	)
	pattern := aascommon.Concat(
		"^",
		dateTimeLexicalRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsDateTimeRe := constructMatchesXsDateTime()

// Check that text conforms to the pattern of an `xs:dateTime`.
//
// See: https://www.w3.org/TR/xmlschema-2/#dateTime
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDateTime(text string) bool {
	return matchesXsDateTimeRe.MatchString(
		text
	)
}

// Check that `value` is a valid `xs:dateTime`.
//
// Year 1 BCE is the last leap BCE year.
// See https://www.w3.org/TR/xmlschema-2/#dateTime.
func IsXsDateTime(value string) bool {
	// NOTE (mristin, 2023-05-09):
  	// We can not use date functions from the standard library as it does not
	// handle years BCE (*e.g.*, `-0003-01-02`).

	if !MatchesXsDateTime(value) {
		return false
	}

	date, _, ok := strings.Cut(value, "T")
	if !ok {
		panic(
			fmt.Sprintf(
				"Expected 'T' in the date-time if it matches the expected regex, " +
				"but got: %s",
				value
			)
		)
	}
	return IsXsDate(date)
}

func constructMatchesXsDecimal() *regexp.Regexp {
	digit := "[0-9]"
	unsignedNoDecimalPtNumeral := aascommon.Concat(
		digit,
		"+"
	)
	noDecimalPtNumeral := aascommon.Concat(
		"(\\+|-)?",
		unsignedNoDecimalPtNumeral
	)
	fracFrag := aascommon.Concat(
		digit,
		"+"
	)
	unsignedDecimalPtNumeral := aascommon.Concat(
		"(",
		unsignedNoDecimalPtNumeral,
		"\\.",
		fracFrag,
		"|\\.",
		fracFrag,
		")"
	)
	decimalPtNumeral := aascommon.Concat(
		"(\\+|-)?",
		unsignedDecimalPtNumeral
	)
	decimalLexicalRep := aascommon.Concat(
		"(",
		decimalPtNumeral,
		"|",
		noDecimalPtNumeral,
		")"
	)
	pattern := aascommon.Concat(
		"^",
		decimalLexicalRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsDecimalRe := constructMatchesXsDecimal()

// Check that text conforms to the pattern of an `xs:decimal`.
//
// See: https://www.w3.org/TR/xmlschema-2/#decimal
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDecimal(text string) bool {
	return matchesXsDecimalRe.MatchString(
		text
	)
}

func constructMatchesXsDouble() *regexp.Regexp {
	doubleRep := "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)"
	pattern := aascommon.Concat(
		"^",
		doubleRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsDoubleRe := constructMatchesXsDouble()

// Check that text conforms to the pattern of an `xs:double`.
//
// See: https://www.w3.org/TR/xmlschema-2/#double
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDouble(text string) bool {
	return matchesXsDoubleRe.MatchString(
		text
	)
}

func constructMatchesXsDuration() *regexp.Regexp {
	durationRep := "-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))"
	pattern := aascommon.Concat(
		"^",
		durationRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsDurationRe := constructMatchesXsDuration()

// Check that text conforms to the pattern of an `xs:duration`.
//
// See: https://www.w3.org/TR/xmlschema-2/#duration
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsDuration(text string) bool {
	return matchesXsDurationRe.MatchString(
		text
	)
}

func constructMatchesXsFloat() *regexp.Regexp {
	floatRep := "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)"
	pattern := aascommon.Concat(
		"^",
		floatRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsFloatRe := constructMatchesXsFloat()

// Check that text conforms to the pattern of an `xs:float`.
//
// See: https://www.w3.org/TR/xmlschema-2/#float
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsFloat(text string) bool {
	return matchesXsFloatRe.MatchString(
		text
	)
}

func constructMatchesXsGDay() *regexp.Regexp {
	gDayLexicalRep := "---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gDayLexicalRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsGDayRe := constructMatchesXsGDay()

// Check that text conforms to the pattern of an `xs:gDay`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gDay
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGDay(text string) bool {
	return matchesXsGDayRe.MatchString(
		text
	)
}

func constructMatchesXsGMonth() *regexp.Regexp {
	gMonthLexicalRep := "--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gMonthLexicalRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsGMonthRe := constructMatchesXsGMonth()

// Check that text conforms to the pattern of an `xs:gMonth`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gMonth
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGMonth(text string) bool {
	return matchesXsGMonthRe.MatchString(
		text
	)
}

func constructMatchesXsGMonthDay() *regexp.Regexp {
	gMonthDayRep := "--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gMonthDayRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsGMonthDayRe := constructMatchesXsGMonthDay()

// Check that text conforms to the pattern of an `xs:gMonthDay`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gMonthDay
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGMonthDay(text string) bool {
	return matchesXsGMonthDayRe.MatchString(
		text
	)
}

func constructMatchesXsGYear() *regexp.Regexp {
	gYearRep := "-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gYearRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsGYearRe := constructMatchesXsGYear()

// Check that text conforms to the pattern of an `xs:gYear`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gYear
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGYear(text string) bool {
	return matchesXsGYearRe.MatchString(
		text
	)
}

func constructMatchesXsGYearMonth() *regexp.Regexp {
	gYearMonthRep := "-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		gYearMonthRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsGYearMonthRe := constructMatchesXsGYearMonth()

// Check that text conforms to the pattern of an `xs:gYearMonth`.
//
// See: https://www.w3.org/TR/xmlschema-2/#gYearMonth
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsGYearMonth(text string) bool {
	return matchesXsGYearMonthRe.MatchString(
		text
	)
}

func constructMatchesXsHexBinary() *regexp.Regexp {
	hexBinary := "([0-9a-fA-F]{2})*"
	pattern := aascommon.Concat(
		"^",
		hexBinary,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsHexBinaryRe := constructMatchesXsHexBinary()

// Check that text conforms to the pattern of an `xs:hexBinary`.
//
// See: https://www.w3.org/TR/xmlschema-2/#hexBinary
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsHexBinary(text string) bool {
	return matchesXsHexBinaryRe.MatchString(
		text
	)
}

func constructMatchesXsTime() *regexp.Regexp {
	timeRep := "(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?"
	pattern := aascommon.Concat(
		"^",
		timeRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsTimeRe := constructMatchesXsTime()

// Check that text conforms to the pattern of an `xs:time`.
//
// See: https://www.w3.org/TR/xmlschema-2/#time
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsTime(text string) bool {
	return matchesXsTimeRe.MatchString(
		text
	)
}

func constructMatchesXsInteger() *regexp.Regexp {
	integerRep := "[-+]?[0-9]+"
	pattern := aascommon.Concat(
		"^",
		integerRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsIntegerRe := constructMatchesXsInteger()

// Check that text conforms to the pattern of an `xs:integer`.
//
// See: https://www.w3.org/TR/xmlschema-2/#integer
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsInteger(text string) bool {
	return matchesXsIntegerRe.MatchString(
		text
	)
}

func constructMatchesXsLong() *regexp.Regexp {
	longRep := "[-+]?0*[0-9]{1,20}"
	pattern := aascommon.Concat(
		"^",
		longRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsLongRe := constructMatchesXsLong()

// Check that text conforms to the pattern of an `xs:long`.
//
// See: https://www.w3.org/TR/xmlschema-2/#long
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsLong(text string) bool {
	return matchesXsLongRe.MatchString(
		text
	)
}

func constructMatchesXsInt() *regexp.Regexp {
	intRep := "[-+]?0*[0-9]{1,10}"
	pattern := aascommon.Concat(
		"^",
		intRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsIntRe := constructMatchesXsInt()

// Check that text conforms to the pattern of an `xs:int`.
//
// See: https://www.w3.org/TR/xmlschema-2/#int
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsInt(text string) bool {
	return matchesXsIntRe.MatchString(
		text
	)
}

func constructMatchesXsShort() *regexp.Regexp {
	shortRep := "[-+]?0*[0-9]{1,5}"
	pattern := aascommon.Concat(
		"^",
		shortRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsShortRe := constructMatchesXsShort()

// Check that text conforms to the pattern of an `xs:short`.
//
// See: https://www.w3.org/TR/xmlschema-2/#short
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsShort(text string) bool {
	return matchesXsShortRe.MatchString(
		text
	)
}

func constructMatchesXsByte() *regexp.Regexp {
	byteRep := "[-+]?0*[0-9]{1,3}"
	pattern := aascommon.Concat(
		"^",
		byteRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsByteRe := constructMatchesXsByte()

// Check that text conforms to the pattern of an `xs:byte`.
//
// See: https://www.w3.org/TR/xmlschema-2/#byte
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsByte(text string) bool {
	return matchesXsByteRe.MatchString(
		text
	)
}

func constructMatchesXsNonNegativeInteger() *regexp.Regexp {
	nonNegativeIntegerRep := "(-0|\\+?[0-9]+)"
	pattern := aascommon.Concat(
		"^",
		nonNegativeIntegerRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsNonNegativeIntegerRe := constructMatchesXsNonNegativeInteger()

// Check that text conforms to the pattern of an `xs:nonNegativeInteger`.
//
// See: https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsNonNegativeInteger(text string) bool {
	return matchesXsNonNegativeIntegerRe.MatchString(
		text
	)
}

func constructMatchesXsPositiveInteger() *regexp.Regexp {
	positiveIntegerRep := "\\+?0*[1-9][0-9]*"
	pattern := aascommon.Concat(
		"^",
		positiveIntegerRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsPositiveIntegerRe := constructMatchesXsPositiveInteger()

// Check that text conforms to the pattern of an `xs:positiveInteger`.
//
// See: https://www.w3.org/TR/xmlschema-2/#positiveInteger
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsPositiveInteger(text string) bool {
	return matchesXsPositiveIntegerRe.MatchString(
		text
	)
}

func constructMatchesXsUnsignedLong() *regexp.Regexp {
	unsignedLongRep := "(-0|\\+?0*[0-9]{1,20})"
	pattern := aascommon.Concat(
		"^",
		unsignedLongRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsUnsignedLongRe := constructMatchesXsUnsignedLong()

// Check that text conforms to the pattern of an `xs:unsignedLong`.
//
// See: https://www.w3.org/TR/xmlschema-2/#unsignedLong
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsUnsignedLong(text string) bool {
	return matchesXsUnsignedLongRe.MatchString(
		text
	)
}

func constructMatchesXsUnsignedInt() *regexp.Regexp {
	unsignedIntRep := "(-0|\\+?0*[0-9]{1,10})"
	pattern := aascommon.Concat(
		"^",
		unsignedIntRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsUnsignedIntRe := constructMatchesXsUnsignedInt()

// Check that text conforms to the pattern of an `xs:unsignedInt`.
//
// See: https://www.w3.org/TR/xmlschema-2/#unsignedInt
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsUnsignedInt(text string) bool {
	return matchesXsUnsignedIntRe.MatchString(
		text
	)
}

func constructMatchesXsUnsignedShort() *regexp.Regexp {
	unsignedShortRep := "(-0|\\+?0*[0-9]{1,5})"
	pattern := aascommon.Concat(
		"^",
		unsignedShortRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsUnsignedShortRe := constructMatchesXsUnsignedShort()

// Check that text conforms to the pattern of an `xs:unsignedShort`.
//
// See: https://www.w3.org/TR/xmlschema-2/#unsignedShort
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsUnsignedShort(text string) bool {
	return matchesXsUnsignedShortRe.MatchString(
		text
	)
}

func constructMatchesXsUnsignedByte() *regexp.Regexp {
	unsignedByteRep := "(-0|\\+?0*[0-9]{1,3})"
	pattern := aascommon.Concat(
		"^",
		unsignedByteRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsUnsignedByteRe := constructMatchesXsUnsignedByte()

// Check that text conforms to the pattern of an `xs:unsignedByte`.
//
// See: https://www.w3.org/TR/xmlschema-2/#unsignedByte
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsUnsignedByte(text string) bool {
	return matchesXsUnsignedByteRe.MatchString(
		text
	)
}

func constructMatchesXsNonPositiveInteger() *regexp.Regexp {
	nonPositiveIntegerRep := "(\\+0|0|-[0-9]+)"
	pattern := aascommon.Concat(
		"^",
		nonPositiveIntegerRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsNonPositiveIntegerRe := constructMatchesXsNonPositiveInteger()

// Check that text conforms to the pattern of an `xs:nonPositiveInteger`.
//
// See: https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsNonPositiveInteger(text string) bool {
	return matchesXsNonPositiveIntegerRe.MatchString(
		text
	)
}

func constructMatchesXsNegativeInteger() *regexp.Regexp {
	negativeIntegerRep := "(-0*[1-9][0-9]*)"
	pattern := aascommon.Concat(
		"^",
		negativeIntegerRep,
		"$"
	)

	return regexp.MustCompile(
	pattern
	)
}

matchesXsNegativeIntegerRe := constructMatchesXsNegativeInteger()

// Check that text conforms to the pattern of an `xs:negativeInteger`.
//
// See: https://www.w3.org/TR/xmlschema-2/#negativeInteger
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsNegativeInteger(text string) bool {
	return matchesXsNegativeIntegerRe.MatchString(
		text
	)
}

func constructMatchesXsString() *regexp.Regexp {
	pattern := "^[\\x09\\x0a\\x0d\\x20-\\ud7ff\\ue000-\\ufffd\\U00010000-\\U0010ffff]*$"

	return regexp.MustCompile(
	pattern
	)
}

matchesXsStringRe := constructMatchesXsString()

// Check that text conforms to the pattern of an `xs:string`.
//
// See: https://www.w3.org/TR/xmlschema-2/#string
//
//   • `text`: Text to be checked
//   • Return True if the text conforms to the pattern
func MatchesXsString(text string) bool {
	return matchesXsStringRe.MatchString(
		text
	)
}

// Check if `year` is a leap year.
func isLeapYear(year int) bool {
	// We consider the years B.C. to be one-off.
	//
	// See the note at: https://www.w3.org/TR/xmlschema-2/#dateTime:
	// "'-0001' is the lexical representation of the year 1 Before Common Era
	// (1 BCE, sometimes written "1 BC")."
	//
	// Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.
	if year < 0 {
		year = -year - 1
	}

	// See: https://en.wikipedia.org/wiki/Leap_year#Algorithm
	if year % 4 > 0 {
		return false
	}

	if year % 100 > 0 {
		return true
	}

	if year % 400 > 0 {
		return false
	}

	return true
}

var daysInMonth = []int{
	// Month 0 is not defined.
	-1, // 0
	31, // 1
	// Please use isLeapYear if you need to check whether
	// a concrete February has 28 or 29 days.
	29, // 2
	31, // 3
	30, // 4
	31, // 5
	30, // 6
	31, // 7
	31, // 8
	30, // 9
	31, // 10
	30, // 11
	31, // 12
}

var datePrefixRe = regexp.MustCompile("^(-?[0-9]+)-([0-9]{2})-([0-9]{2})")

// Check that `value` is a valid `xs:date`.
func IsXsDate(value string) bool {
	if !MatchesXsDate(value) {
		return false
	}

	// NOTE (mristin, 2023-05-10):
	// We can not use the date functions from the standard library as we have
	// to handle years BCE according to the XML date type.

	// NOTE (mristin, 2023-05-12):
    // We need to match the prefix as zone offsets are allowed in the dates. Optimally,
    // we would re-use the pattern matching from `matches_xs_date`, but this
    // would make the code generation and constraint inference for schemas much more
    // difficult. Hence, we sacrifice the efficiency a bit for the clearer code & code
    // generation.

	match := datePrefixRe.FindStringSubmatch(value)
	if len(match) == 0 {
		panic(
			fmt.Sprintf(
				"Expected value to match %v if we got thus far, " +
				"but it does not: %s",
				datePrefixRe, value
			)
		)
	}

	yearStr := match[1]
	monthStr := match[2]
	dayStr := match[3]

	year, err := strconv.Atoi(yearStr)
	if err != nil {
		panic(
			fmt.Sprintf(
				"Failed to convert the year from %s: %s",
				yearStr, err.Error(),
			),
		)
	}
	
	month, err := strconv.Atoi(monthStr)
	if err != nil {
		panic(
			fmt.Sprintf(
				"Failed to convert the month from %s: %s",
				monthStr, err.Error(),
			),
		)
	}
	
	day, err := strconv.Atoi(dayStr)
	if err != nil {
		panic(
			fmt.Sprintf(
				"Failed to convert the day from %s: %s",
				dayStr, err.Error(),
			),
		)
	}

	// We do not accept year zero,
	// see the note at: https://www.w3.org/TR/xmlschema-2/#dateTime
	if year == 0 {
		return false
	}

	if day <= 0 {
		return false
	}

	if month <= 0 || month >= 13 {
		return false
	}

	var maxDays int
	if month == 2 {
		if isLeapYear(year) {
			maxDays = 29
		} else {
			maxDays = 28
		}
	} else {
		maxDays = daysInMonth[month]
	}

	if day > maxDays {
		return false
	}

	return true
}

// Check that `value` is a valid `xs:double`.
func IsXsDouble(value string) bool {
	// We need to check explicitly for the regular expression since
	// strconv.ParseFloat is too permissive. For example, it accepts "nan"
	// although only "NaN" is valid.
	// See: https://www.w3.org/TR/xmlschema-2/#double
	if !MatchesXsDouble(value) {
		return false
	}

	converted, err = strconv.ParseFloat(value, 64)
	if err != nil {
		panic(
			fmt.Sprintf(
				"Failed to parse float from value %s: %s",
				value, err.Error(),
			),
		)
	}

	// Check that the value is either "INF" or "-INF".
	// Otherwise, the value is a decimal which is too big
	// to be represented as a double-precision floating point
	// number.
	//
	// strconv.ParseFloat rounds up/down to `INF` and `-INF`, respectively,
	// if the number is too large. For example: `strconv.ParseFloat("1e400", 64)`
	// will give you `INF`.

	if math.IsInf(converted, 0) && value != "INF" && value != "-INF" {
		return false
	}

	// NOTE (2023-05-12):
	// We explicitly do not check for loss of precision, as the majority of people will
	// use string representation of the floating point numbers ignoring the precision
	// issues. For example, the closest double-precision number to the number `359.9` is
	// `359.8999999999999772626324556767940521240234375`, but most people will simply
	// give `359.9` as the value.

	return true
}

// Check that `value` is a valid `xs:float`.
func IsXsFloat(value string) bool {
	// We need to check explicitly for the regular expression since
	// strconv.ParseFloat is too permissive. For example, it accepts "nan"
	// although only "NaN" is valid.
	// See: https://www.w3.org/TR/xmlschema-2/#double
	if !MatchesXsDouble(value) {
		return false
	}

	converted, err = strconv.ParseFloat(value, 32)
	if err != nil {
		panic(
			fmt.Sprintf(
				"Failed to parse float from value %s: %s",
				value, err.Error(),
			),
		)
	}

	// Check that the value is either "INF" or "-INF".
	// Otherwise, the value is a decimal which is too big
	// to be represented as a single-precision floating point
	// number.
	//
	// strconv.ParseFloat rounds up/down to `INF` and `-INF`, respectively,
	// if the number is too large. For example: `strconv.ParseFloat("1e400", 64)`
	// will give you `INF`.

	if math.IsInf(converted, 0) && value != "INF" && value != "-INF" {
		return false
	}

	// NOTE (2023-05-12):
	// We explicitly do not check for loss of precision, as the majority of people will
	// use string representation of the floating point numbers ignoring the precision
	// issues. For example, `float64(float32(3.2)) == 3.2` is false in Golang, but "3.2"
	// is totally expected as a value.

	return true
}

// Check that `value` is a valid `xs:gMonthDay`.
func IsXsGMonthDay(value string) bool {
	if !MatchesXsGMonthDay(value) {
		return false
	}

	month, err := strconv.Atoi(value[2:4])
	if err != nil {
		panic(
			fmt.Sprintf(
				"Unexpected fail to parse the month %s: %s",
				value[2:4], err.Error(),
			),
		)
	}

	var day int
	day, err = strconv.Atoi(value[5:7])
	if err != nil {
		panic(
			fmt.Sprintf(
				"Unexpected fail to parse the day %s: %s",
				value[5:7], err.Error(),
			),
		)
	}

	maxDays := daysInMonth[month]
	return day <= maxDays
}

// Check that `value` is a valid `xs:long`.
func IsXsLong(value string) bool {
	if !MatchesXsLong(value) {
		return false
	}

	_, err := strconv.ParseInt(value, 10, 64)
	return err != nil
}

// Check that `value` is a valid `xs:int`.
func IsXsInt(value string) bool {
	if !MatchesXsInt(value) {
		return false
	}

	_, err := strconv.ParseInt(value, 10, 32)
	return err != nil
}

// Check that `value` is a valid `xs:short`.
func IsXsShort(value string) bool {
	if !MatchesXsShort(value) {
		return false
	}

	_, err := strconv.ParseInt(value, 10, 16)
	return err != nil
}

// Check that `value` is a valid `xs:byte`.
func IsXsByte(value string) bool {
	if !MatchesXsByte(value) {
		return false
	}

	_, err := strconv.ParseInt(value, 10, 8)
	return err != nil
}

// Check that `value` is a valid `xs:unsignedLong`.
func IsXsUnsignedLong(value string) bool {
	if !MatchesXsUnsignedLong(value) {
		return false
	}

	_, err := strconv.ParseUint(value, 10, 64)
	return err != nil
}

// Check that `value` is a valid `xs:unsignedInt`.
func IsXsUnsignedInt(value string) bool {
	if !MatchesXsUnsignedInt(value) {
		return false
	}

	_, err := strconv.ParseUint(value, 10, 32)
	return err != nil
}

// Check that `value` is a valid `xs:unsignedShort`.
func IsXsUnsignedShort(value string) bool {
	if !MatchesXsUnsignedShort(value) {
		return false
	}

	_, err := strconv.ParseUint(value, 10, 16)
	return err != nil
}

// Check that `value` is a valid `xs:unsignedByte`.
func IsXsUnsignedByte(value string) bool {
	if !MatchesXsUnsignedByte(value) {
		return false
	}

	_, err := strconv.ParseUint(value, 10, 8)
	return err != nil
}

// Check that `value` is consistent with the given `valueType`.
func valueConsistentWithXSDType(
	value string,
	valueType aastypes.DataTypeDefXSD
) bool {
	switch valueType {
		case aastypes.DataTypeDefXSDAnyURI:
			return MatchesXsAnyURI(value)
		case aastypes.DataTypeDefXSDBase64Binary:
			return MatchesXsBase64Binary(value)
		case aastypes.DataTypeDefXSDBoolean:
			return MatchesXsBoolean(value)
		case aastypes.DataTypeDefXSDByte:
			return IsXsByte(value)
		case aastypes.DataTypeDefXSDDate:
			return IsXsDate(value)
		case aastypes.DataTypeDefXSDDateTime:
			return IsXsDateTime(value)
		case aastypes.DataTypeDefXSDDecimal:
			return MatchesXsDecimal(value)
		case aastypes.DataTypeDefXSDDouble:
			return IsXsDouble(value)
		case aastypes.DataTypeDefXSDDuration:
			return MatchesXsDuration(value)
		case aastypes.DataTypeDefXSD.FLOAT:
		 	return IsXsFloat(value)
		case aastypes.DataTypeDefXSDGDay:
			return MatchesXsGDay(value)
		case aastypes.DataTypeDefXSDGMonth:
			return MatchesXsGMonth(value)
		case aastypes.DataTypeDefXSDGMonthDay:
			return IsXsGMonthDay(value)
		case aastypes.DataTypeDefXSDGYear:
			return MatchesXsGYear(value)
		case aastypes.DataTypeDefXSDGYearMonth:
			return MatchesXsGYearMonth(value)
		case aastypes.DataTypeDefXSDHexBinary:
			return MatchesXsHexBinary(value)
		case aastypes.DataTypeDefXSDInt:
			return IsXsInt(value)
		case aastypes.DataTypeDefXSDInteger:
			return MatchesXsInteger(value)
		case aastypes.DataTypeDefXSDLong:
			return IsXsLong(value)
		case aastypes.DataTypeDefXSDNegativeInteger:
			return MatchesXsNegativeInteger(value)
		case aastypes.DataTypeDefXSDNonNegativeInteger:
			return MatchesXsNonNegativeInteger(value)
		case aastypes.DataTypeDefXSDNonPositiveInteger:
			return MatchesXsNonPositiveInteger(value)
		case aastypes.DataTypeDefXSDPositiveInteger:
			return MatchesXsPositiveInteger(value)
		case aastypes.DataTypeDefXSDShort:
			return IsXsShort(value)
		case aastypes.DataTypeDefXSDString:
			return MatchesXsString(value)
		case aastypes.DataTypeDefXSDTime:
			return MatchesXsTime(value)
		case aastypes.DataTypeDefXSDUnsignedByte:
			return IsXsUnsignedByte(value)
		case aastypes.DataTypeDefXSDUnsignedInt:
			return IsXsUnsignedInt(value)
		case aastypes.DataTypeDefXSDUnsignedLong:
			return IsXsUnsignedLong(value)
		case aastypes.DataTypeDefXSDUnsignedShort:
			return IsXsUnsignedShort(value)
		default:
			panic(fmt.Sprintf("Unhandled value type: %v", valueType))
	}
}

// Check that the target of the model reference matches the expectedType.
func IsModelReferenceTo(
	reference aastypes.IReference,
	expectedType aastypes.KeyTypes
) bool {

	return reference.Type() == ReferenceTypesModelReference&&
	len(reference.Keys()) != 0&&
	reference.Keys()[len(reference.Keys()) - 1].Type() == expectedType;
}

// Check that the target of the reference matches a [aasconstants.AASReferables].
func IsModelReferenceToReferable(
	reference aastypes.IReference
) bool {

	return reference.Type() == ReferenceTypesModelReference&&
	len(reference.Keys()) != 0&&
	aascommon.MapContains(
		aasconstants.AASReferables,
		reference.Keys()[len(reference.Keys()) - 1].Type()
	);
}

// Check that all [aastypes.IReferable.IDShort] are unique among
// `referables`.
func ExtensionNamesAreUnique[R aastypes.IReferable](
	referables []R) bool {
	idShortSet := make(map[string]struct{})

	for _, referable := range referables {
		idShort := referable.IDShort()

		if idShort == nil {
			continue
		}

		_, has := idShortSet[*idShort]
		if has {
			return false
		}

		idShortSet[*idShort] = struct{}{}
	}
	return true
}

// Check that [aastypes.IReferable.IDShort]'s among all the `inputVariables`,
// `outputVariables` and `inoutputVariables` are unique.
func IDShortsOfVariablesAreUnique[O1 aastypes.IOperationVariable,
		O2 aastypes.IOperationVariable,
		O3 aastypes.IOperationVariable] (
	inputVariables []O1,
	outputVariables []O2,
	inoutputVariables []O3) {
	idShortSet := make(map[string]struct{})

	var has bool

	if inputVariables != nil {
		for _, variable := range inputVariables {
			idShort := variable.Value().IDShort()

			if idShort != nil {
				_, has = idShortSet[*idShort]
				if has {
					return true
				}

				idShortSet[*idShort] = struct{}{}
			}
		}
	}

	if outputVariables != nil {
		for _, variable := range outputVariables {
			idShort := variable.Value().IDShort()

			if idShort != nil {
				_, has = idShortSet[*idShort]
				if has {
					return true
				}

				idShortSet[*idShort] = struct{}{}
			}
		}
	}

	if inoutputVariables != nil {
		for _, variable := range inoutputVariables {
			idShort := variable.Value().IDShort()

			if idShort != nil {
				_, has = idShortSet[*idShort]
				if has {
					return true
				}

				idShortSet[*idShort] = struct{}{}
			}
		}
	}

	return true
}

// Check that all [aastypes.IExtension.Name] are unique among
// `extensions`.
func ExtensionNamesAreUnique[E aastypes.IExtension](
	extensions []E) bool {
	nameSet := make(map[string]struct{})

	for _, extension := range extensions {
		name := extension.Name()
		_, has := nameSet[name]
		if has {
			return false
		}

		nameSet[name] = struct{}{}
	}
	return true
}

// Check that all `elements` have the identical [aastypes.IHasSemantics.SemanticID].
func SubmodelElementsHaveIdenticalSemanticID[S aastypes.ISubmodelElement](
	elements: []S) bool {
	var thatSemanticID aastypes.IReference

	for _, element := range elements {
		thisSemanticID := element.SemanticID()

		if thisSemanticID == nil {
			continue
		}

		if thatSemanticID == nil {
			thatSemanticID = thisSemanticID
			continue
		}

		thisKeys = thisSemanticID.Keys()
		thatKeys = thatSemanticID.Keys()

		if len(thisKeys) != len(thatKeys) {
			return false
		}

		for i, thisKey := range thisKeys {
			thatKey := thatKeys[i]

			if thisKey.Value() != thatKey.Value() {
				return false
			}
		}
	}
	return true
}

var modelTypeToAASSubmodelElements = map[aastypes.ModelType]aastypes.AASSubmodelElements{
	aastypes.ModelTypeAnnotatedRelationshipElement: aastypes.AASSubmodelElementsAnnotatedRelationshipElement,
	aastypes.ModelTypeBasicEventElement: aastypes.AASSubmodelElementsBasicEventElement,
	aastypes.ModelTypeBlob: aastypes.AASSubmodelElementsBlob,
	aastypes.ModelTypeCapability: aastypes.AASSubmodelElementsCapability,
	aastypes.ModelTypeDataElement: aastypes.AASSubmodelElementsDataElement,
	aastypes.ModelTypeEntity: aastypes.AASSubmodelElementsEntity,
	aastypes.ModelTypeEventElement: aastypes.AASSubmodelElementsEventElement,
	aastypes.ModelTypeFile: aastypes.AASSubmodelElementsFile,
	aastypes.ModelTypeMultiLanguageProperty: aastypes.AASSubmodelElementsMultiLanguageProperty,
	aastypes.ModelTypeOperation: aastypes.AASSubmodelElementsOperation,
	aastypes.ModelTypeProperty: aastypes.AASSubmodelElementsProperty,
	aastypes.ModelTypeRange: aastypes.AASSubmodelElementsRange,
	aastypes.ModelTypeReferenceElement: aastypes.AASSubmodelElementsReferenceElement,
	aastypes.ModelTypeRelationshipElement: aastypes.AASSubmodelElementsRelationshipElement,
	aastypes.ModelTypeSubmodelElement: aastypes.AASSubmodelElementsSubmodelElement,
	aastypes.ModelTypeSubmodelElementList: aastypes.AASSubmodelElementsSubmodelElementList,
	aastypes.ModelTypeSubmodelElementCollection: aastypes.AASSubmodelElementsSubmodelElementCollection,
}

// Check that `element` is an instance of the interface corresponding to
// `expectedType`.
func SubmodelElementIsOfType(
	element aastypes.ISubmodelElement,
	expectedType aastypes.AASSubmodelElements) bool {
	gotType, ok := modelTypeToAASSubmodelElements[element.ModelType()]
	
	if !ok {
		panic(
			fmt.Sprintf(
				"Model type not covered in modelTypeToAASSubmodelElements: %v",
				element.ModelType()
			)
		)
	}
	
	return gotType == expectedType
}

// Check that `elements` which are [aastypes.IProperty] or [aastypes.IRange]
// have the given `valueType`.
func PropertiesOrRangesHaveValueType[E aastypes.ISubmodelElement](
	elements []E,
	valueType aastypes.DataTypeDefXSD) bool {
	for _, element := range elements {
		switch element.(type) {
			case aastypes.IProperty:
				if element.ValueType() != valueType {
					return false
				}
			case aastypes.IRange:
				if element.ValueType() != valueType {
					return false
				}
			default:
				// pass
		}
	}
	return true
}

// Check that the two references, `that` and `other`, are equal by
// comparing their [aastypes.Reference.Keys] by [aastypes.Key.Value]'s.
func ReferenceKeyValuesEqual(
	that aastypes.IReference,
	other aastypes.IReference) bool {
	thatKeys := that.Keys()
	otherKeys := other.Keys()

	if len(thatKeys) != len(otherKeys) {
		return false
	}

	for i, thatKey := range thatKeys {
		otherKey = otherKeys[i]

		if thatKey.Value() != otherKey.Value() {
			return false
		}
	}

	return true
}

// Check that [aastypes.DataSpecificationIec61360.DataType]
// is defined appropriately for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sForPropertyOrValueHaveAppropriateDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		iec61360, ok := eds.DataSpecificationContent().(aastypes.DataSpecificationIEC61360)
		if !ok {
			continue
		}

		dt := iec61360.DataType()
		if dt == nil ||
			!aascommon.MapContains(aasconstants.DataTypeIEC61360ForPropertyOrValue, *dt) {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.DataType]
// is defined appropriately for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sForReferenceHaveAppropriateDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		iec61360, ok := eds.DataSpecificationContent().(aastypes.DataSpecificationIEC61360)
		if !ok {
			continue
		}

		dt := iec61360.DataType()
		if dt == nil ||
			!aascommon.MapContains(aasconstants.DataTypeIEC61360ForReference, *dt) {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.DataType]
// is defined appropriately for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sForDocumentHaveAppropriateDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		iec61360, ok := eds.DataSpecificationContent().(aastypes.DataSpecificationIEC61360)
		if !ok {
			continue
		}

		dt := iec61360.DataType()
		if dt == nil ||
			!aascommon.MapContains(aasconstants.DataTypeIEC61360ForDocument, *dt) {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.DataType]
// is defined for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sHaveDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		iec61360, ok := eds.DataSpecificationContent().(aastypes.DataSpecificationIEC61360)
		if !ok {
			continue
		}

		dt := iec61360.DataType()
		if dt == nil {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.Value]
// is defined for all data specifications whose content is given as
// IEC 61360.
func DataSpecificationIEC61360sHaveValue(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		iec61360, ok := eds.DataSpecificationContent().(aastypes.DataSpecificationIEC61360)
		if !ok {
			continue
		}

		v := iec61360.Value()
		if v == nil {
			return false
		}
	}
	return true
}

// Check that [aastypes.DataSpecificationIec61360.Definition]
// is defined for all data specifications whose content is given as
// IEC 61360 at least in English.
func DataSpecificationIEC61360sHaveDataType(
	embeddedDataSpecifications []aastypes.IEmbeddedDataSpecification) bool {
	for _, eds := range embeddedDataSpecifications {
		iec61360, ok := eds.DataSpecificationContent().(aastypes.DataSpecificationIEC61360)
		if !ok {
			continue
		}

		definition := iec61360.Definition()
		if definition == nil {
			return false
		}

		noEnglish := true
		for _, langString := range definition {
			if IsBCP47ForEnglish(langString.Language()) {
				noEnglish = false
				break
			}
		}

		if noEnglish {
			return false
		}
	}
	return true
}

func constructIsBCP47ForEnglish() *regexp.Regexp {
	pattern := "^(en|EN)(-.*)?$"

	return regexp.MustCompile(
	pattern
	)
}

isBCP47ForEnglishRe := constructIsBCP47ForEnglish()

// Check that the text corresponds to a BCP47 code for english.
func IsBCP47ForEnglish(text string) bool {
	return isBCP47ForEnglishRe.MatchString(
		text
	)
}

// Verify `that` instance of [aastypes.IExtension].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyExtension(
	that aastypes.IExtension,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.RefersTo() != nil)
		|| (len(that.RefersTo()) >= 1)
	) {
		err = newVerificationError(
			"Refers-to must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Value()) != nil)
		|| ValueConsistentWithXSDType(
			that.Value(),
			that.ValueTypeOrDefault()
		)
	) {
		err = newVerificationError(
			"The value must match the value type."	)
		abort = onError(err)
		if abort {
			return
		}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	abort = VerifyNameType(
		that.Name(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Name"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if that.ValueType() != nil {
		if (
			that.ValueType() < aastypes.DataTypeDefXSDAnyURI
			|| that.ValueType() > aastypes.DataTypeDefXSDUnsignedShort
		) {
			err = newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for DataTypeDefXSD: %v",
					that.ValueType()
				)
			)
			err.Path.Prepend(
				&aasreporting.NameSegment{
					Name: "ValueType"
				}
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		abort = VerifyValueDataType(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.RefersTo() != nil {
		for i, v := range that.RefersTo() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "RefersTo"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IAdministrativeInformation].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyAdministrativeInformation(
	that aastypes.IAdministrativeInformation,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Revision()) != nil)
		|| (*(that.Version()) != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-005: If version is not specified then also " +
			"revision shall be unspecified. This means, a revision " +
			"requires a version. If there is no version there is no " +
			"revision either. Revision is optional."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Version() != nil {
		abort = VerifyVersionType(
			that.Version(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Version"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Revision() != nil {
		abort = VerifyRevisionType(
			that.Revision(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Revision"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Creator() != nil {
		abort = VerifyReference(
			that.Creator(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Creator"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.TemplateID() != nil {
		abort = VerifyIdentifier(
			that.TemplateID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "TemplateID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IQualifier].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyQualifier(
	that aastypes.IQualifier,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Value()) != nil)
		|| ValueConsistentWithXSDType(
			that.Value(),
			that.ValueType()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-020: The value shall be consistent to " +
			"the data type as defined in value type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Kind() != nil {
		if (
			that.Kind() < aastypes.QualifierKindValueQualifier
			|| that.Kind() > aastypes.QualifierKindTemplateQualifier
		) {
			err = newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for QualifierKind: %v",
					that.Kind()
				)
			)
			err.Path.Prepend(
				&aasreporting.NameSegment{
					Name: "Kind"
				}
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	abort = VerifyQualifierType(
		that.Type(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Type"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if (
		that.ValueType() < aastypes.DataTypeDefXSDAnyURI
		|| that.ValueType() > aastypes.DataTypeDefXSDUnsignedShort
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for DataTypeDefXSD: %v",
				that.ValueType()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "ValueType"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.Value() != nil {
		abort = VerifyValueDataType(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.ValueID() != nil {
		abort = VerifyReference(
			that.ValueID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IAssetAdministrationShell].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyAssetAdministrationShell(
	that aastypes.IAssetAdministrationShell,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Submodels() != nil)
		|| (len(that.Submodels()) >= 1)
	) {
		err = newVerificationError(
			"Submodels must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DerivedFrom() != nil)
		|| IsModelReferenceTo(
			that.DerivedFrom(),
			KeyTypesAssetAdministrationShell
		)
	) {
		err = newVerificationError(
			"Derived-from must be a model reference to an asset " +
			"administration shell."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Submodels() != nil)
		|| (
			aascommon.All(
				func(Reference reference) {
					IsModelReferenceTo(reference, KeyTypesSubmodel)
				},
				that.Submodels()
			)
		)
	) {
		err = newVerificationError(
			"All submodels must be model references to a submodel."	)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Administration() != nil {
		abort = VerifyAdministrativeInformation(
			that.Administration(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	abort = VerifyIdentifier(
		that.ID(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.DerivedFrom() != nil {
		abort = VerifyReference(
			that.DerivedFrom(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DerivedFrom"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.AssetInformation() == nil {
		err = newVerificationError(
			"Required property not set: AssetInformation"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyAssetInformation(
			that.AssetInformation(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "AssetInformation"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Submodels() != nil {
		for i, v := range that.Submodels() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Submodels"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IAssetInformation].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyAssetInformation(
	that aastypes.IAssetInformation,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.SpecificAssetIDs() != nil)
		|| (
			aascommon.All(
				func(Specific_asset_ID specific_asset_ID) {
					specificAssetID.Name() != "globalAssetId"||
					(
						specificAssetID.Name() == "globalAssetId"&&
						specificAssetID.Value() == *(that.GlobalAssetID())
					)
				},
				that.SpecificAssetIDs()
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-116: ``globalAssetId`` is a reserved key. " +
			"If used as value for the name of specific asset ID then " +
			"the value of specific asset ID shall be identical to " +
			"the global asset ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		(
			(*(that.GlobalAssetID()) != nil)&&
			(that.SpecificAssetIDs() == nil)
		)||
		(
			(*(that.GlobalAssetID()) == nil)&&
			(that.SpecificAssetIDs() != nil)&&
			len(that.SpecificAssetIDs()) >= 1
		)
	) {
		err = newVerificationError(
			"Constraint AASd-131: Either the global asset ID shall be " +
			"defined or at least one specific asset ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SpecificAssetIDs() != nil)
		|| (len(that.SpecificAssetIDs()) >= 1)
	) {
		err = newVerificationError(
			"Specific asset IDs must be either not set or have at least " +
			"one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if (
		that.AssetKind() < aastypes.AssetKindType
		|| that.AssetKind() > aastypes.AssetKindNotApplicable
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for AssetKind: %v",
				that.AssetKind()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "AssetKind"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.GlobalAssetID() != nil {
		abort = VerifyIdentifier(
			that.GlobalAssetID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "GlobalAssetID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SpecificAssetIDs() != nil {
		for i, v := range that.SpecificAssetIDs() {
			abort = VerifySpecificAssetID(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SpecificAssetIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.AssetType() != nil {
		abort = VerifyIdentifier(
			that.AssetType(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "AssetType"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DefaultThumbnail() != nil {
		abort = VerifyResource(
			that.DefaultThumbnail(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DefaultThumbnail"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IResource].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyResource(
	that aastypes.IResource,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	abort = VerifyPathType(
		that.Path(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Path"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if that.ContentType() != nil {
		abort = VerifyContentType(
			that.ContentType(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ContentType"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ISpecificAssetID].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifySpecificAssetID(
	that aastypes.ISpecificAssetID,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.ExternalSubjectID() != nil)
		|| (that.ExternalSubjectID().Type() == ReferenceTypesExternalReference)
	) {
		err = newVerificationError(
			"Constraint AASd-133: External subject ID shall be " +
			"an external reference."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	abort = VerifyLabelType(
		that.Name(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Name"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	abort = VerifyIdentifier(
		that.Value(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if that.ExternalSubjectID() != nil {
		abort = VerifyReference(
			that.ExternalSubjectID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ExternalSubjectID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ISubmodel].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifySubmodel(
	that aastypes.ISubmodel,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SubmodelElements() != nil)
		|| (len(that.SubmodelElements()) >= 1)
	) {
		err = newVerificationError(
			"Submodel elements must be either not set or have at least " +
			"one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SubmodelElements() != nil)
		|| (
			aascommon.All(
				func(Submodel_element item) {
					*(item.IDShort()) != nil
				},
				that.SubmodelElements()
			)
		)
	) {
		err = newVerificationError(
			"ID-shorts need to be defined for all the items of submodel " +
			"elements according to AASd-117 (ID-short of Referables not " +
			"being a direct child of a Submodel element list shall be " +
			"specified)."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SubmodelElements() != nil)
		|| IDShortsAreUnique(that.SubmodelElements())
	) {
		err = newVerificationError(
			"Constraint AASd-022: ID-short of non-identifiable " +
			"referables within the same name space shall be unique " +
			"(case-sensitive)."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SubmodelElements() != nil)
		|| (
			!(*(that.Kind()) != ModellingKindTemplate)
			|| (
				aascommon.All(
					func(Submodel_element submodel_element) {
						!(submodelElement.Qualifiers() != nil)
						|| (
							aascommon.All(
								func(Qualifier qualifier) {
									qualifier.KindOrDefault() != QualifierKindTemplateQualifier
								},
								submodelElement.Qualifiers()
							)
						)
					},
					that.SubmodelElements()
				)
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-129: If any qualifier kind value of " +
			"a Submodel element qualifier (attribute qualifier inherited " +
			"via Qualifiable) is equal to Template Qualifier then " +
			"the submodel element shall be part of a submodel template, " +
			"i.e. a Submodel with submodel kind (attribute kind " +
			"inherited via Has-Kind) value is equal to Template."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (
			!(
				aascommon.Some(
					func(Qualifier qualifier) {
						qualifier.KindOrDefault() == QualifierKindTemplateQualifier
					},
					that.Qualifiers()
				)
			)
			|| (that.KindOrDefault() == ModellingKindTemplate)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-119: If any qualifier kind value of " +
			"a qualifiable qualifier is equal to template qualifier and " +
			"the qualified element has kind then the qualified element " +
			"shall be of kind template."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Administration() != nil {
		abort = VerifyAdministrativeInformation(
			that.Administration(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	abort = VerifyIdentifier(
		that.ID(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if that.Kind() != nil {
		if (
			that.Kind() < aastypes.ModellingKindTemplate
			|| that.Kind() > aastypes.ModellingKindInstance
		) {
			err = newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for ModellingKind: %v",
					that.Kind()
				)
			)
			err.Path.Prepend(
				&aasreporting.NameSegment{
					Name: "Kind"
				}
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SubmodelElements() != nil {
		for i, v := range that.SubmodelElements() {
			abort = VerifySubmodelElement(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SubmodelElements"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IRelationshipElement].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyRelationshipElement(
	that aastypes.IRelationshipElement,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.First() == nil {
		err = newVerificationError(
			"Required property not set: First"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.First(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "First"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Second() == nil {
		err = newVerificationError(
			"Required property not set: Second"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.Second(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Second"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ISubmodelElementList].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifySubmodelElementList(
	that aastypes.ISubmodelElementList,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| (len(that.Value()) >= 1)
	) {
		err = newVerificationError(
			"Value must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			(that.Value() != nil)&&
			(that.SemanticIDListElement() != nil)
		)
		|| (
			aascommon.All(
				func(Submodel_element child) {
					!(child.SemanticID() != nil)
					|| ReferenceKeyValuesEqual(
						child.SemanticID(),
						that.SemanticIDListElement()
					)
				},
				that.Value()
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-107: If a first level child element has " +
			"a semantic ID it shall be identical to semantic ID list " +
			"element."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| SubmodelElementsHaveIdenticalSemanticIDs(
			that.Value()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-114: If two first level child elements have " +
			"a semantic ID then they shall be identical."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| (
			aascommon.All(
				func(Submodel_element element) {
					SubmodelElementIsOfType(
						element,
						that.TypeValueListElement()
					)
				},
				that.Value()
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-108: All first level child elements shall " +
			"have the same submodel element type as specified in type " +
			"value list element."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			(that.Value() != nil)&&
			(
				that.TypeValueListElement() == AASSubmodelElementsProperty||
				that.TypeValueListElement() == AASSubmodelElementsRange
			)
		)
		|| (
			(*(that.ValueTypeListElement()) != nil)&&
			PropertiesOrRangesHaveValueType(
				that.Value(),
				that.ValueTypeListElement()
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-109: If type value list element is equal to " +
			"Property or Range value type list element shall be set and " +
			"all first level child elements shall have the value type as " +
			"specified in value type list element."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| (
			aascommon.All(
				func(Submodel_element element) {
					*(element.IDShort()) == nil
				},
				that.Value()
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-120: ID-short of submodel elements being " +
			"a direct child of a  Submodel element list shall not be " +
			"specified."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticIDListElement() != nil {
		abort = VerifyReference(
			that.SemanticIDListElement(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticIDListElement"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if (
		that.TypeValueListElement() < aastypes.AASSubmodelElementsAnnotatedRelationshipElement
		|| that.TypeValueListElement() > aastypes.AASSubmodelElementsSubmodelElementCollection
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for AASSubmodelElements: %v",
				that.TypeValueListElement()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "TypeValueListElement"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.ValueTypeListElement() != nil {
		if (
			that.ValueTypeListElement() < aastypes.DataTypeDefXSDAnyURI
			|| that.ValueTypeListElement() > aastypes.DataTypeDefXSDUnsignedShort
		) {
			err = newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for DataTypeDefXSD: %v",
					that.ValueTypeListElement()
				)
			)
			err.Path.Prepend(
				&aasreporting.NameSegment{
					Name: "ValueTypeListElement"
				}
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		for i, v := range that.Value() {
			abort = VerifySubmodelElement(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Value"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.ISubmodelElementCollection].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifySubmodelElementCollection(
	that aastypes.ISubmodelElementCollection,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| (len(that.Value()) >= 1)
	) {
		err = newVerificationError(
			"Value must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| (
			aascommon.All(
				func(Submodel_element item) {
					*(item.IDShort()) != nil
				},
				that.Value()
			)
		)
	) {
		err = newVerificationError(
			"ID-shorts need to be defined for all the items of value " +
			"according to AASd-117 (ID-short of Referables not being " +
			"a direct child of a Submodel element list shall be " +
			"specified)."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| IDShortsAreUnique(that.Value())
	) {
		err = newVerificationError(
			"ID-shorts of the value must be unique."	)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		for i, v := range that.Value() {
			abort = VerifySubmodelElement(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Value"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IProperty].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyProperty(
	that aastypes.IProperty,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Category()) != nil)
		|| aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			that.Category()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-090: For data elements category shall be " +
			"one of the following values: CONSTANT, PARAMETER or " +
			"VARIABLE."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Value()) != nil)
		|| ValueConsistentWithXSDType(
			that.Value(),
			that.ValueType()
		)
	) {
		err = newVerificationError(
			"Value must be consistent with the value type."	)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if (
		that.ValueType() < aastypes.DataTypeDefXSDAnyURI
		|| that.ValueType() > aastypes.DataTypeDefXSDUnsignedShort
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for DataTypeDefXSD: %v",
				that.ValueType()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "ValueType"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.Value() != nil {
		abort = VerifyValueDataType(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.ValueID() != nil {
		abort = VerifyReference(
			that.ValueID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IMultiLanguageProperty].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyMultiLanguageProperty(
	that aastypes.IMultiLanguageProperty,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Category()) != nil)
		|| aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			that.Category()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-090: For data elements category shall be " +
			"one of the following values: CONSTANT, PARAMETER or " +
			"VARIABLE."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| LangStringsHaveUniqueLanguages(that.Value())
	) {
		err = newVerificationError(
			"Value specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Value() != nil)
		|| (len(that.Value()) >= 1)
	) {
		err = newVerificationError(
			"Value must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		for i, v := range that.Value() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Value"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.ValueID() != nil {
		abort = VerifyReference(
			that.ValueID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IRange].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyRange(
	that aastypes.IRange,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Category()) != nil)
		|| aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			that.Category()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-090: For data elements category shall be " +
			"one of the following values: CONSTANT, PARAMETER or " +
			"VARIABLE."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Max()) != nil)
		|| ValueConsistentWithXSDType(
			that.Max(),
			that.ValueType()
		)
	) {
		err = newVerificationError(
			"Max must be consistent with the value type."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Min()) != nil)
		|| ValueConsistentWithXSDType(
			that.Min(),
			that.ValueType()
		)
	) {
		err = newVerificationError(
			"Min must be consistent with the value type."	)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if (
		that.ValueType() < aastypes.DataTypeDefXSDAnyURI
		|| that.ValueType() > aastypes.DataTypeDefXSDUnsignedShort
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for DataTypeDefXSD: %v",
				that.ValueType()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "ValueType"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.Min() != nil {
		abort = VerifyValueDataType(
			that.Min(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Min"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Max() != nil {
		abort = VerifyValueDataType(
			that.Max(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Max"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IReferenceElement].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyReferenceElement(
	that aastypes.IReferenceElement,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Category()) != nil)
		|| aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			that.Category()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-090: For data elements category shall be " +
			"one of the following values: CONSTANT, PARAMETER or " +
			"VARIABLE."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		abort = VerifyReference(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IBlob].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyBlob(
	that aastypes.IBlob,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Category()) != nil)
		|| aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			that.Category()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-090: For data elements category shall be " +
			"one of the following values: CONSTANT, PARAMETER or " +
			"VARIABLE."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		abort = VerifyBlobType(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	abort = VerifyContentType(
		that.ContentType(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ContentType"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.IFile].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyFile(
	that aastypes.IFile,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(*(that.Category()) != nil)
		|| aascommon.MapContains(
			aasconstants.ValidCategoriesForDataElement,
			that.Category()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-090: For data elements category shall be " +
			"one of the following values: CONSTANT, PARAMETER or " +
			"VARIABLE."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Value() != nil {
		abort = VerifyPathType(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	abort = VerifyContentType(
		that.ContentType(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ContentType"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.IAnnotatedRelationshipElement].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyAnnotatedRelationshipElement(
	that aastypes.IAnnotatedRelationshipElement,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Annotations() != nil)
		|| (len(that.Annotations()) >= 1)
	) {
		err = newVerificationError(
			"Annotations must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Annotations() != nil)
		|| (
			aascommon.All(
				func(Data_element item) {
					*(item.IDShort()) != nil
				},
				that.Annotations()
			)
		)
	) {
		err = newVerificationError(
			"ID-shorts need to be defined for all the items of " +
			"annotations according to AASd-117 (ID-short of Referables " +
			"not being a direct child of a Submodel element list shall " +
			"be specified)."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.First() == nil {
		err = newVerificationError(
			"Required property not set: First"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.First(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "First"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Second() == nil {
		err = newVerificationError(
			"Required property not set: Second"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.Second(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Second"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Annotations() != nil {
		for i, v := range that.Annotations() {
			abort = VerifyDataElement(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Annotations"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IEntity].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyEntity(
	that aastypes.IEntity,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Statements() != nil)
		|| (len(that.Statements()) >= 1)
	) {
		err = newVerificationError(
			"Statements must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Statements() != nil)
		|| (
			aascommon.All(
				func(Submodel_element item) {
					*(item.IDShort()) != nil
				},
				that.Statements()
			)
		)
	) {
		err = newVerificationError(
			"ID-shorts need to be defined for all the items of " +
			"statements according to AASd-117 (ID-short of Referables " +
			"not being a direct child of a Submodel element list shall " +
			"be specified)."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		(
			that.EntityType() == EntityTypeSelfManagedEntity&&
			(
				(
					(*(that.GlobalAssetID()) != nil)&&
					(that.SpecificAssetIDs() == nil)
				)||
				(
					(*(that.GlobalAssetID()) == nil)&&
					(that.SpecificAssetIDs() != nil)&&
					len(that.SpecificAssetIDs()) >= 1
				)
			)
		)||
		(
			that.EntityType() != EntityTypeSelfManagedEntity&&
			(*(that.GlobalAssetID()) == nil)&&
			(that.SpecificAssetIDs() == nil)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-014: Either the attribute global asset ID " +
			"or specific asset ID must be set if entity type is set to " +
			"self-managed entity. They are not existing otherwise."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SpecificAssetIDs() != nil)
		|| (len(that.SpecificAssetIDs()) >= 1)
	) {
		err = newVerificationError(
			"Specific asset IDs must be either not set or have at least " +
			"one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Statements() != nil {
		for i, v := range that.Statements() {
			abort = VerifySubmodelElement(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Statements"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if (
		that.EntityType() < aastypes.EntityTypeCoManagedEntity
		|| that.EntityType() > aastypes.EntityTypeSelfManagedEntity
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for EntityType: %v",
				that.EntityType()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "EntityType"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.GlobalAssetID() != nil {
		abort = VerifyIdentifier(
			that.GlobalAssetID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "GlobalAssetID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SpecificAssetIDs() != nil {
		for i, v := range that.SpecificAssetIDs() {
			abort = VerifySpecificAssetID(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SpecificAssetIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IEventPayload].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyEventPayload(
	that aastypes.IEventPayload,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		IsModelReferenceTo(
			that.Source(),
			KeyTypesEventElement
		)||
		IsModelReferenceTo(
			that.Source(),
			KeyTypesBasicEventElement
		)
	) {
		err = newVerificationError(
			"Source must be a model reference to an Event element."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		IsModelReferenceToReferable(
			that.ObservableReference()
		)
	) {
		err = newVerificationError(
			"Observable reference must be a model reference to " +
			"a referable."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Source() == nil {
		err = newVerificationError(
			"Required property not set: Source"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.Source(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Source"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SourceSemanticID() != nil {
		abort = VerifyReference(
			that.SourceSemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SourceSemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.ObservableReference() == nil {
		err = newVerificationError(
			"Required property not set: ObservableReference"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.ObservableReference(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ObservableReference"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.ObservableSemanticID() != nil {
		abort = VerifyReference(
			that.ObservableSemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ObservableSemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Topic() != nil {
		abort = VerifyMessageTopicType(
			that.Topic(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Topic"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SubjectID() != nil {
		abort = VerifyReference(
			that.SubjectID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SubjectID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	abort = VerifyDateTimeUTC(
		that.TimeStamp(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "TimeStamp"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if that.Payload() != nil {
		abort = VerifyBlobType(
			that.Payload(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Payload"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IBasicEventElement].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyBasicEventElement(
	that aastypes.IBasicEventElement,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Direction() == DirectionInput)
		|| (*(that.MaxInterval()) == nil)
	) {
		err = newVerificationError(
			"Max. interval is not applicable for input direction."	)
		abort = onError(err)
		if abort {
			return
		}

	if !IsModelReferenceToReferable(that.Observed()) {
		err = newVerificationError(
			"Observed must be a model reference to a referable."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.MessageBroker() != nil)
		|| IsModelReferenceToReferable(that.MessageBroker())
	) {
		err = newVerificationError(
			"Message broker must be a model reference to a referable."	)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Observed() == nil {
		err = newVerificationError(
			"Required property not set: Observed"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.Observed(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Observed"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if (
		that.Direction() < aastypes.DirectionInput
		|| that.Direction() > aastypes.DirectionOutput
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for Direction: %v",
				that.Direction()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "Direction"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if (
		that.State() < aastypes.StateOfEventOn
		|| that.State() > aastypes.StateOfEventOff
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for StateOfEvent: %v",
				that.State()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "State"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.MessageTopic() != nil {
		abort = VerifyMessageTopicType(
			that.MessageTopic(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MessageTopic"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.MessageBroker() != nil {
		abort = VerifyReference(
			that.MessageBroker(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MessageBroker"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.LastUpdate() != nil {
		abort = VerifyDateTimeUTC(
			that.LastUpdate(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "LastUpdate"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.MinInterval() != nil {
		abort = VerifyDuration(
			that.MinInterval(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MinInterval"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.MaxInterval() != nil {
		abort = VerifyDuration(
			that.MaxInterval(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "MaxInterval"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IOperation].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyOperation(
	that aastypes.IOperation,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		IDShortsOfVariablesAreUnique(
			that.InputVariables(),
			that.OutputVariables(),
			that.InoutputVariables()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-134: For an Operation the ID-short of all " +
			"values of input, output and in/output variables."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.InputVariables() != nil)
		|| (len(that.InputVariables()) >= 1)
	) {
		err = newVerificationError(
			"Input variables must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.OutputVariables() != nil)
		|| (len(that.OutputVariables()) >= 1)
	) {
		err = newVerificationError(
			"Output variables must be either not set or have at least " +
			"one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.InoutputVariables() != nil)
		|| (len(that.InoutputVariables()) >= 1)
	) {
		err = newVerificationError(
			"Inoutput variables must be either not set or have at least " +
			"one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.InputVariables() != nil {
		for i, v := range that.InputVariables() {
			abort = VerifyOperationVariable(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "InputVariables"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.OutputVariables() != nil {
		for i, v := range that.OutputVariables() {
			abort = VerifyOperationVariable(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "OutputVariables"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.InoutputVariables() != nil {
		for i, v := range that.InoutputVariables() {
			abort = VerifyOperationVariable(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "InoutputVariables"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IOperationVariable].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyOperationVariable(
	that aastypes.IOperationVariable,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(*(that.Value().IDShort()) != nil) {
		err = newVerificationError(
			"Value must have the ID-short specified according to " +
			"Constraint AASd-117 (ID-short of Referables not being " +
			"a direct child of a Submodel element list shall be " +
			"specified)."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Value() == nil {
		err = newVerificationError(
			"Required property not set: Value"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifySubmodelElement(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ICapability].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyCapability(
	that aastypes.ICapability,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (len(that.SupplementalSemanticIDs()) >= 1)
	) {
		err = newVerificationError(
			"Supplemental semantic IDs must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.SupplementalSemanticIDs() != nil)
		|| (that.SemanticID() != nil)
	) {
		err = newVerificationError(
			"Constraint AASd-118: If there are supplemental semantic IDs " +
			"defined then there shall be also a main semantic ID."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| (len(that.Qualifiers()) >= 1)
	) {
		err = newVerificationError(
			"Qualifiers must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Qualifiers() != nil)
		|| QualifierTypesAreUnique(that.Qualifiers())
	) {
		err = newVerificationError(
			"Constraint AASd-021: Every qualifiable can only have one " +
			"qualifier with the same type."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.SemanticID() != nil {
		abort = VerifyReference(
			that.SemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SupplementalSemanticIDs() != nil {
		for i, v := range that.SupplementalSemanticIDs() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "SupplementalSemanticIDs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Qualifiers() != nil {
		for i, v := range that.Qualifiers() {
			abort = VerifyQualifier(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Qualifiers"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IConceptDescription].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyConceptDescription(
	that aastypes.IConceptDescription,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.Extensions() != nil)
		|| (len(that.Extensions()) >= 1)
	) {
		err = newVerificationError(
			"Extensions must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Extensions() != nil)
		|| ExtensionNamesAreUnique(that.Extensions())
	) {
		err = newVerificationError(
			"Constraint AASd-077: The name of an extension within " +
			"Has-Extensions needs to be unique."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| (len(that.Description()) >= 1)
	) {
		err = newVerificationError(
			"Description must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Description() != nil)
		|| LangStringsHaveUniqueLanguages(that.Description())
	) {
		err = newVerificationError(
			"Description specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| (len(that.DisplayName()) >= 1)
	) {
		err = newVerificationError(
			"Display name must be either not set or have at least one " +
			"item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.DisplayName() != nil)
		|| LangStringsHaveUniqueLanguages(that.DisplayName())
	) {
		err = newVerificationError(
			"Display name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (len(that.EmbeddedDataSpecifications()) >= 1)
	) {
		err = newVerificationError(
			"Embedded data specifications must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.IsCaseOf() != nil)
		|| (len(that.IsCaseOf()) >= 1)
	) {
		err = newVerificationError(
			"Is-case-of must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.EmbeddedDataSpecifications() != nil)
		|| (
			DataSpecificationIEC61360sHaveDefinitionAtLeastInEnglish(
				that.EmbeddedDataSpecifications()
			)||
			DataSpecificationIEC61360sHaveValue(
				that.EmbeddedDataSpecifications()
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASc-3a-008: For a concept description using " +
			"data specification template IEC 61360, the definition is " +
			"mandatory and shall be defined at least in English. " +
			"Exception: The concept description describes a value."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			(*(that.Category()) != nil)&&
			that.Category() == "QUALIFIER_TYPE"&&
			(that.EmbeddedDataSpecifications() != nil)
		)
		|| DataSpecificationIEC61360sHaveDataType(
			that.EmbeddedDataSpecifications()
		)
	) {
		err = newVerificationError(
			"Constraint AASc-3a-007: For a concept description with " +
			"category QUALIFIER_TYPE using data specification IEC 61360, " +
			"the data type of the data specification is mandatory and " +
			"shall be defined."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			(*(that.Category()) != nil)&&
			that.Category() == "DOCUMENT"&&
			(that.EmbeddedDataSpecifications() != nil)
		)
		|| DataSpecificationIEC61360sForDocumentHaveAppropriateDataType(
			that.EmbeddedDataSpecifications()
		)
	) {
		err = newVerificationError(
			"Constraint AASc-3a-006: For a concept description with " +
			"category DOCUMENT using data specification IEC 61360, " +
			"the data type of the data specification shall be one of: " +
			"FILE, BLOB, HTML."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			(*(that.Category()) != nil)&&
			that.Category() == "REFERENCE"&&
			(that.EmbeddedDataSpecifications() != nil)
		)
		|| DataSpecificationIEC61360sForReferenceHaveAppropriateDataType(
			that.EmbeddedDataSpecifications()
		)
	) {
		err = newVerificationError(
			"Constraint AASc-3a-005: For a concept description with " +
			"category REFERENCE using data specification IEC 61360, " +
			"the data type of the data specification shall be one of: " +
			"STRING, IRI, IRDI."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			(*(that.Category()) != nil)&&
			(
				that.Category() == "PROPERTY"||
				that.Category() == "VALUE"
			)&&
			(that.EmbeddedDataSpecifications() != nil)
		)
		|| DataSpecificationIEC61360sForPropertyOrValueHaveAppropriateDataType(
			that.EmbeddedDataSpecifications()
		)
	) {
		err = newVerificationError(
			"Constraint AASc-3a-004: For a concept description with " +
			"category PROPERTY or VALUE using data specification IEC " +
			"61360, the data type of the data specification is mandatory " +
			"and shall be one of: DATE, STRING, STRING_TRANSLATABLE, " +
			"INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, " +
			"REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, " +
			"RATIONAL_MEASURE, TIME, TIMESTAMP."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.Extensions() != nil {
		for i, v := range that.Extensions() {
			abort = VerifyExtension(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Extensions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Category() != nil {
		abort = VerifyNameType(
			that.Category(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Category"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.IDShort() != nil {
		abort = VerifyIDShortType(
			that.IDShort(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "IDShort"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DisplayName() != nil {
		for i, v := range that.DisplayName() {
			abort = VerifyLangStringNameType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "DisplayName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Description() != nil {
		for i, v := range that.Description() {
			abort = VerifyLangStringTextType(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Description"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Administration() != nil {
		abort = VerifyAdministrativeInformation(
			that.Administration(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Administration"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	abort = VerifyIdentifier(
		that.ID(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "ID"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if that.EmbeddedDataSpecifications() != nil {
		for i, v := range that.EmbeddedDataSpecifications() {
			abort = VerifyEmbeddedDataSpecification(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "EmbeddedDataSpecifications"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.IsCaseOf() != nil {
		for i, v := range that.IsCaseOf() {
			abort = VerifyReference(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "IsCaseOf"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IReference].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyReference(
	that aastypes.IReference,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(len(that.Keys()) >= 1) {
		err = newVerificationError(
			"Keys must contain at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(len(that.Keys()) >= 1)
		|| aascommon.MapContains(
			aasconstants.GloballyIdentifiables,
			that.Keys()[0].Type()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-121: For References the value of type of " +
			"the first key of keys shall be one of Globally " +
			"Identifiables."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			that.Type() == ReferenceTypesExternalReference&&
			len(that.Keys()) >= 1
		)
		|| aascommon.MapContains(
			aasconstants.GenericGloballyIdentifiables,
			that.Keys()[0].Type()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-122: For external references the value of " +
			"type of the first key of keys shall be one of Generic " +
			"Globally Identifiables."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			that.Type() == ReferenceTypesModelReference&&
			len(that.Keys()) >= 1
		)
		|| aascommon.MapContains(
			aasconstants.AASIdentifiables,
			that.Keys()[0].Type()
		)
	) {
		err = newVerificationError(
			"Constraint AASd-123: For model references the value of type " +
			"of the first key of keys shall be one of AAS identifiables."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			that.Type() == ReferenceTypesExternalReference&&
			len(that.Keys()) >= 1
		)
		|| (
			aascommon.MapContains(
				aasconstants.GenericGloballyIdentifiables,
				that.Keys()[len(that.Keys()) - 1].Type()
			)||
			aascommon.MapContains(
				aasconstants.GenericFragmentKeys,
				that.Keys()[len(that.Keys()) - 1].Type()
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-124: For external references the last key " +
			"of keys shall be either one of Generic Globally " +
			"Identifiables or one of Generic Fragment Keys."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			that.Type() == ReferenceTypesModelReference&&
			len(that.Keys()) > 1
		)
		|| (
			aascommon.AllRange(
				func(length i) {
					aascommon.MapContains(
						aasconstants.FragmentKeys,
						that.Keys()[i].Type()
					)
				},
				1,
				len(that.Keys())
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-125: For model references with more than " +
			"one key in keys the value of type of each of the keys " +
			"following the first key of keys shall be one of Fragment " +
			"Keys."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			that.Type() == ReferenceTypesModelReference&&
			len(that.Keys()) > 1
		)
		|| (
			aascommon.AllRange(
				func(length i) {
					!aascommon.MapContains(
						aasconstants.GenericFragmentKeys,
						that.Keys()[i].Type()
					)
				},
				0,
				len(that.Keys()) - 1
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-126: For model references with more than " +
			"one key in keys the value of type of the last key in " +
			"the reference key chain may be one of Generic Fragment Keys " +
			"or no key at all shall have a value out of Generic Fragment " +
			"Keys."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			that.Type() == ReferenceTypesModelReference&&
			len(that.Keys()) > 1&&
			that.Keys()[len(that.Keys()) - 1].Type() == KeyTypesFragmentReference
		)
		|| (
			that.Keys()[len(that.Keys()) - 2].Type() == KeyTypesFile||
			that.Keys()[len(that.Keys()) - 2].Type() == KeyTypesBlob
		)
	) {
		err = newVerificationError(
			"Constraint AASd-127: For model references, with more than " +
			"one key in keys a key with type Fragment Reference shall be " +
			"preceded by a key with type File or Blob."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			that.Type() == ReferenceTypesModelReference&&
			len(that.Keys()) > 2
		)
		|| (
			aascommon.AllRange(
				func(length i) {
					!(that.Keys()[i].Type() == KeyTypesSubmodelElementList)
					|| MatchesXsPositiveInteger(that.Keys()[i + 1].Value())
				},
				0,
				len(that.Keys()) - 1
			)
		)
	) {
		err = newVerificationError(
			"Constraint AASd-128: For model references, the value of " +
			"a key preceded by a key with type Submodel element list is " +
			"an integer number denoting the position in the array of " +
			"the submodel element list."
		)
		abort = onError(err)
		if abort {
			return
		}

	if (
		that.Type() < aastypes.ReferenceTypesExternalReference
		|| that.Type() > aastypes.ReferenceTypesModelReference
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for ReferenceTypes: %v",
				that.Type()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "Type"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	if that.ReferredSemanticID() != nil {
		abort = VerifyReference(
			that.ReferredSemanticID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ReferredSemanticID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Keys() == nil {
		err = newVerificationError(
			"Required property not set: Keys"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		for i, v := range that.Keys() {
			abort = VerifyKey(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Keys"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IKey].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyKey(
	that aastypes.IKey,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if (
		that.Type() < aastypes.KeyTypesAnnotatedRelationshipElement
		|| that.Type() > aastypes.KeyTypesSubmodelElementList
	) {
		err = newVerificationError(
			fmt.Sprintf(
				"Invalid literal value for KeyTypes: %v",
				that.Type()
			)
		)
		err.Path.Prepend(
			&aasreporting.NameSegment{
				Name: "Type"
			}
		)
		abort = onError(err)
		if abort {
			return
		}
	}

	abort = VerifyIdentifier(
		that.Value(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringNameType].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringNameType(
	that aastypes.ILangStringNameType,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 128) {
		err = newVerificationError(
			"String shall have a maximum length of 128 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringTextType].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringTextType(
	that aastypes.ILangStringTextType,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 1023) {
		err = newVerificationError(
			"String shall have a maximum length of 1023 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.IEnvironment].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyEnvironment(
	that aastypes.IEnvironment,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		!(that.ConceptDescriptions() != nil)
		|| (len(that.ConceptDescriptions()) >= 1)
	) {
		err = newVerificationError(
			"Concept descriptions must be either not set or have at " +
			"least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Submodels() != nil)
		|| (len(that.Submodels()) >= 1)
	) {
		err = newVerificationError(
			"Submodels must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.AssetAdministrationShells() != nil)
		|| (len(that.AssetAdministrationShells()) >= 1)
	) {
		err = newVerificationError(
			"Asset administration shells must be either not set or have " +
			"at least one item."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.AssetAdministrationShells() != nil {
		for i, v := range that.AssetAdministrationShells() {
			abort = VerifyAssetAdministrationShell(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "AssetAdministrationShells"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Submodels() != nil {
		for i, v := range that.Submodels() {
			abort = VerifySubmodel(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Submodels"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.ConceptDescriptions() != nil {
		for i, v := range that.ConceptDescriptions() {
			abort = VerifyConceptDescription(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "ConceptDescriptions"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.IEmbeddedDataSpecification].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyEmbeddedDataSpecification(
	that aastypes.IEmbeddedDataSpecification,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if that.DataSpecification() == nil {
		err = newVerificationError(
			"Required property not set: DataSpecification"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.DataSpecification(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DataSpecification"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DataSpecificationContent() == nil {
		err = newVerificationError(
			"Required property not set: DataSpecificationContent"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyDataSpecificationContent(
			that.DataSpecificationContent(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "DataSpecificationContent"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.ILevelType].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLevelType(
	that aastypes.ILevelType,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	// No verification has been defined for ILevelType.

	return
}

// Verify `that` instance of [aastypes.IValueReferencePair].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyValueReferencePair(
	that aastypes.IValueReferencePair,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	abort = VerifyValueTypeIEC61360(
		that.Value(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Value"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	if that.ValueID() == nil {
		err = newVerificationError(
			"Required property not set: ValueID"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		abort = VerifyReference(
			that.ValueID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify `that` instance of [aastypes.IValueList].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyValueList(
	that aastypes.IValueList,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(len(that.ValueReferencePairs()) >= 1) {
		err = newVerificationError(
			"Value reference pair types must contain at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if that.ValueReferencePairs() == nil {
		err = newVerificationError(
			"Required property not set: ValueReferencePairs"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		for i, v := range that.ValueReferencePairs() {
			abort = VerifyValueReferencePair(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "ValueReferencePairs"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringPreferredNameTypeIEC61360].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringPreferredNameTypeIEC61360(
	that aastypes.ILangStringPreferredNameTypeIEC61360,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 255) {
		err = newVerificationError(
			"String shall have a maximum length of 1023 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringShortNameTypeIEC61360].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringShortNameTypeIEC61360(
	that aastypes.ILangStringShortNameTypeIEC61360,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 18) {
		err = newVerificationError(
			"String shall have a maximum length of 1023 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.ILangStringDefinitionTypeIEC61360].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLangStringDefinitionTypeIEC61360(
	that aastypes.ILangStringDefinitionTypeIEC61360,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(len(that.Text()) <= 1023) {
		err = newVerificationError(
			"String shall have a maximum length of 1023 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	abort = VerifyBCP47LanguageTag(
		that.Language(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Language"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	abort = VerifyNonEmptyXMLSerializableString(
		that.Text(),
		func(err *VerificationError) bool {
			err.Path.PrependName(
				&aasreporting.NameSegment{
					Name: "Text"
				}
			)
			return onError(err)
		}
	)
	if abort {
		return
	}

	return
}

// Verify `that` instance of [aastypes.IDataSpecificationIEC61360].
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyDataSpecificationIEC61360(
	that aastypes.IDataSpecificationIEC61360,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !(
		(
			(*(that.Value()) != nil)&&
			(that.ValueList() == nil)
		)||
		(
			(*(that.Value()) == nil)&&
			(that.ValueList() != nil)&&
			len(that.ValueList().ValueReferencePairs()) >= 1
		)
	) {
		err = newVerificationError(
			"Constraint AASc-3a-010: If value is not empty then value " +
			"list shall be empty and vice versa."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(
			(*(that.DataType()) == nil)&&
			aascommon.MapContains(
				aasconstants.IEC61360DataTypesWithUnit,
				*(that.DataType())
			)
		)
		|| (
			(*(that.Unit()) != nil)||
			(that.UnitID() != nil)
		)
	) {
		err = newVerificationError(
			"Constraint AASc-3a-009: If data type is a an integer, real " +
			"or rational with a measure or currency, unit or unit ID " +
			"shall be defined."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Definition() != nil)
		|| (len(that.Definition()) >= 1)
	) {
		err = newVerificationError(
			"Definition must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.Definition() != nil)
		|| LangStringsHaveUniqueLanguages(that.Definition())
	) {
		err = newVerificationError(
			"Definition specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.ShortName() != nil)
		|| (len(that.ShortName()) >= 1)
	) {
		err = newVerificationError(
			"Short name must be either not set or have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		!(that.ShortName() != nil)
		|| LangStringsHaveUniqueLanguages(that.ShortName())
	) {
		err = newVerificationError(
			"Short name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that.PreferredName()) >= 1) {
		err = newVerificationError(
			"Preferred name must have at least one item."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		LangStringsHaveUniqueLanguages(that.PreferredName())
	) {
		err = newVerificationError(
			"Preferred name specifies no duplicate languages."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(
		aascommon.Some(
			func(Lang_string_preferred_name_type_IEC_61360 lang_string) {
				IsBCP47ForEnglish(langString.Language())
			},
			that.PreferredName()
		)
	) {
		err = newVerificationError(
			"Constraint AASc-002: preferred name shall be provided at " +
			"least in English."
		)
		abort = onError(err)
		if abort {
			return
		}

	if that.PreferredName() == nil {
		err = newVerificationError(
			"Required property not set: PreferredName"
		)
		abort = onError(err)
		if abort {
			return
		}
	} else {
		for i, v := range that.PreferredName() {
			abort = VerifyLangStringPreferredNameTypeIEC61360(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "PreferredName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.ShortName() != nil {
		for i, v := range that.ShortName() {
			abort = VerifyLangStringShortNameTypeIEC61360(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "ShortName"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.Unit() != nil {
		abort = VerifyNonEmptyXMLSerializableString(
			that.Unit(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Unit"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.UnitID() != nil {
		abort = VerifyReference(
			that.UnitID(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "UnitID"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.SourceOfDefinition() != nil {
		abort = VerifyNonEmptyXMLSerializableString(
			that.SourceOfDefinition(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "SourceOfDefinition"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Symbol() != nil {
		abort = VerifyNonEmptyXMLSerializableString(
			that.Symbol(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Symbol"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.DataType() != nil {
		if (
			that.DataType() < aastypes.DataTypeIEC61360Date
			|| that.DataType() > aastypes.DataTypeIEC61360Blob
		) {
			err = newVerificationError(
				fmt.Sprintf(
					"Invalid literal value for DataTypeIEC61360: %v",
					that.DataType()
				)
			)
			err.Path.Prepend(
				&aasreporting.NameSegment{
					Name: "DataType"
				}
			)
			abort = onError(err)
			if abort {
				return
			}
		}
	}

	if that.Definition() != nil {
		for i, v := range that.Definition() {
			abort = VerifyLangStringDefinitionTypeIEC61360(
				v,
				func(err *VerificationError) bool {
					err.Path.PrependIndex(
						&aasreporting.IndexSegment{
							Index: i
						}
					)

					err.Path.PrependName(
						&aasreporting.NameSegment{
							Name: "Definition"
						}
					)

					return onError(err)
				}
			)
			if abort {
				return
			}
		}
	}

	if that.ValueFormat() != nil {
		abort = VerifyNonEmptyXMLSerializableString(
			that.ValueFormat(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueFormat"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.ValueList() != nil {
		abort = VerifyValueList(
			that.ValueList(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "ValueList"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.Value() != nil {
		abort = VerifyValueTypeIEC61360(
			that.Value(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "Value"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	if that.LevelType() != nil {
		abort = VerifyLevelType(
			that.LevelType(),
			func(err *VerificationError) bool {
				err.Path.PrependName(
					&aasreporting.NameSegment{
						Name: "LevelType"
					}
				)
				return onError(err)
			}
		)
		if abort {
			return
		}
	}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyNonEmptyXMLSerializableString(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyDateTimeUTC(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXsDateTimeUTC(that) {
		err = newVerificationError(
			"The value must match the pattern of xs:dateTime with " +
			"the time zone fixed to UTC."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !IsXsDateTimeUTC(that) {
		err = newVerificationError(
			"The value must represent a valid xs:dateTime with the time " +
			"zone fixed to UTC."
		)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyDuration(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXsDuration(that) {
		err = newVerificationError(
			"The value must match the pattern of xs:duration."	)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyBlobType(
	that []byte,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	// There is no verification specified.

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyIdentifier(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 2000) {
		err = newVerificationError(
			"Identifier shall have a maximum length of 2000 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyValueTypeIEC61360(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 2000) {
		err = newVerificationError(
			"Value type IEC 61360 shall have a maximum length of 2000 " +
			"characters."
		)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyNameType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 128) {
		err = newVerificationError(
			"Name type shall have a maximum length of 128 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyVersionType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !MatchesVersionType(that) {
		err = newVerificationError(
			"Version type shall match the version pattern."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 4) {
		err = newVerificationError(
			"Version type shall have a maximum length of 4 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyRevisionType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !MatchesRevisionType(that) {
		err = newVerificationError(
			"Revision type shall match the revision pattern."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 4) {
		err = newVerificationError(
			"Revision type shall have a maximum length of 4 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyLabelType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 64) {
		err = newVerificationError(
			"Label type shall have a maximum length of 64 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyMessageTopicType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 255) {
		err = newVerificationError(
			"Message topic type shall have a maximum length of 255 " +
			"characters."
		)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyBCP47LanguageTag(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesBCP47(that) {
		err = newVerificationError(
			"The value must represent a value language tag conformant to " +
			"BCP 47."
		)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyContentType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 100) {
		err = newVerificationError(
			"Content type shall have a maximum length of 100 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	if !MatchesMIMEType(that) {
		err = newVerificationError(
			"The value must represent a valid content MIME type " +
			"according to RFC 2046."
		)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyPathType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 2000) {
		err = newVerificationError(
			"Identifier shall have a maximum length of 2000 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	if !MatchesRFC8089Path(that) {
		err = newVerificationError(
			"The value must represent a valid file URI scheme according " +
			"to RFC 8089."
		)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyQualifierType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 128) {
		err = newVerificationError(
			"Name type shall have a maximum length of 128 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyValueDataType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	// There is no verification specified.

	return
}

// Verify the constraints of `that` value.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func VerifyIDShortType(
	that string,
	onError func(*VerificationError) bool
) (abort bool) {
	abort = false

	if !MatchesXMLSerializableString(that) {
		err = newVerificationError(
			"Constraint AASd-130: An attribute with data type 'string' " +
			"shall consist of these characters only: " +
			"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
		)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) >= 1) {
		err = newVerificationError(
			"The value must not be empty."	)
		abort = onError(err)
		if abort {
			return
		}

	if !(len(that) <= 128) {
		err = newVerificationError(
			"Name type shall have a maximum length of 128 characters."	)
		abort = onError(err)
		if abort {
			return
		}

	if !MatchesIDShort(that) {
		err = newVerificationError(
			"ID-short of Referables shall only feature letters, digits, " +
			"underscore (``_``); starting mandatory with a letter. " +
			"*I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``."
		)
		abort = onError(err)
		if abort {
			return
		}

	return
}

// Verify ``that`` instance.
//
// You have to supply the callback `onError` to iterate over the errors.
// If `onError` returns abort `true`, this function will abort
// further verification as well, and return abort `true`. Otherwise,
// abort `false` is returned.
func Verify(
	that: aastypes.IClass,
	onError: func(*VerificationError) bool
) (abort bool) {
	switch that.ModelType() {
	case aastypes.ModelTypeExtension:
		abort = VerifyExtension(
			that,
			onError
		)
	case aastypes.ModelTypeAdministrativeInformation:
		abort = VerifyAdministrativeInformation(
			that,
			onError
		)
	case aastypes.ModelTypeQualifier:
		abort = VerifyQualifier(
			that,
			onError
		)
	case aastypes.ModelTypeAssetAdministrationShell:
		abort = VerifyAssetAdministrationShell(
			that,
			onError
		)
	case aastypes.ModelTypeAssetInformation:
		abort = VerifyAssetInformation(
			that,
			onError
		)
	case aastypes.ModelTypeResource:
		abort = VerifyResource(
			that,
			onError
		)
	case aastypes.ModelTypeSpecificAssetID:
		abort = VerifySpecificAssetID(
			that,
			onError
		)
	case aastypes.ModelTypeSubmodel:
		abort = VerifySubmodel(
			that,
			onError
		)
	case aastypes.ModelTypeRelationshipElement:
		abort = VerifyRelationshipElement(
			that,
			onError
		)
	case aastypes.ModelTypeSubmodelElementList:
		abort = VerifySubmodelElementList(
			that,
			onError
		)
	case aastypes.ModelTypeSubmodelElementCollection:
		abort = VerifySubmodelElementCollection(
			that,
			onError
		)
	case aastypes.ModelTypeProperty:
		abort = VerifyProperty(
			that,
			onError
		)
	case aastypes.ModelTypeMultiLanguageProperty:
		abort = VerifyMultiLanguageProperty(
			that,
			onError
		)
	case aastypes.ModelTypeRange:
		abort = VerifyRange(
			that,
			onError
		)
	case aastypes.ModelTypeReferenceElement:
		abort = VerifyReferenceElement(
			that,
			onError
		)
	case aastypes.ModelTypeBlob:
		abort = VerifyBlob(
			that,
			onError
		)
	case aastypes.ModelTypeFile:
		abort = VerifyFile(
			that,
			onError
		)
	case aastypes.ModelTypeAnnotatedRelationshipElement:
		abort = VerifyAnnotatedRelationshipElement(
			that,
			onError
		)
	case aastypes.ModelTypeEntity:
		abort = VerifyEntity(
			that,
			onError
		)
	case aastypes.ModelTypeEventPayload:
		abort = VerifyEventPayload(
			that,
			onError
		)
	case aastypes.ModelTypeBasicEventElement:
		abort = VerifyBasicEventElement(
			that,
			onError
		)
	case aastypes.ModelTypeOperation:
		abort = VerifyOperation(
			that,
			onError
		)
	case aastypes.ModelTypeOperationVariable:
		abort = VerifyOperationVariable(
			that,
			onError
		)
	case aastypes.ModelTypeCapability:
		abort = VerifyCapability(
			that,
			onError
		)
	case aastypes.ModelTypeConceptDescription:
		abort = VerifyConceptDescription(
			that,
			onError
		)
	case aastypes.ModelTypeReference:
		abort = VerifyReference(
			that,
			onError
		)
	case aastypes.ModelTypeKey:
		abort = VerifyKey(
			that,
			onError
		)
	case aastypes.ModelTypeLangStringNameType:
		abort = VerifyLangStringNameType(
			that,
			onError
		)
	case aastypes.ModelTypeLangStringTextType:
		abort = VerifyLangStringTextType(
			that,
			onError
		)
	case aastypes.ModelTypeEnvironment:
		abort = VerifyEnvironment(
			that,
			onError
		)
	case aastypes.ModelTypeEmbeddedDataSpecification:
		abort = VerifyEmbeddedDataSpecification(
			that,
			onError
		)
	case aastypes.ModelTypeLevelType:
		abort = VerifyLevelType(
			that,
			onError
		)
	case aastypes.ModelTypeValueReferencePair:
		abort = VerifyValueReferencePair(
			that,
			onError
		)
	case aastypes.ModelTypeValueList:
		abort = VerifyValueList(
			that,
			onError
		)
	case aastypes.ModelTypeLangStringPreferredNameTypeIEC61360:
		abort = VerifyLangStringPreferredNameTypeIEC61360(
			that,
			onError
		)
	case aastypes.ModelTypeLangStringShortNameTypeIEC61360:
		abort = VerifyLangStringShortNameTypeIEC61360(
			that,
			onError
		)
	case aastypes.ModelTypeLangStringDefinitionTypeIEC61360:
		abort = VerifyLangStringDefinitionTypeIEC61360(
			that,
			onError
		)
	case aastypes.ModelTypeDataSpecificationIEC61360:
		abort = VerifyDataSpecificationIEC61360(
			that,
			onError
		)
	default:
		err = newVerificationError(
			fmt.Sprintf(
				"Unexpected model type literal: %v",
				modelType
		)
		abort = onError(err)
	}
	return
}

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
