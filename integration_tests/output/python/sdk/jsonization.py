"""
Provide de/serialization of AAS classes to/from JSON.

We can not use one-pass deserialization for JSON since the object
properties do not have fixed order, and hence we can not read
``modelType`` property ahead of the remaining properties.
"""


# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.


import base64
import collections.abc
import sys
from typing import (
    cast,
    Any,
    Callable,
    Iterable,
    List,
    Mapping,
    MutableMapping,
    Optional,
    Sequence,
    Union,
)

if sys.version_info >= (3, 8):
    from typing import Final
else:
    from typing_extensions import Final

import sdk.common as aas_common
import sdk.stringification as aas_stringification
import sdk.types as aas_types


class PropertySegment:
    """Represent a property on a path to the erroneous value."""

    #: Instance that contains the property
    instance: Final[Mapping[str, Any]]

    #: Name of the property
    name: Final[str]

    def __init__(
            self,
            instance: Mapping[str, Any],
            name: str
    ) -> None:
        """Initialize with the given values."""
        self.instance = instance
        self.name = name


class IndexSegment:
    """Represent an index access on a path to the erroneous value."""

    #: Container that contains the item
    container: Final[Iterable[Any]]

    #: Index of the item
    index: Final[int]

    def __init__(
            self,
            container: Iterable[Any],
            index: int
    ) -> None:
        """Initialize with the given values."""
        self.container = container
        self.index = index


Segment = Union[PropertySegment, IndexSegment]


class Path:
    """Represent the relative path to the erroneous value."""

    def __init__(self) -> None:
        """Initialize as an empty path."""
        self._segments = []  # type: List[Segment]

    @property
    def segments(self) -> Sequence[Segment]:
        """Get the segments of the path."""
        return self._segments

    def _prepend(self, segment: Segment) -> None:
        """Insert the :paramref:`segment` in front of other segments."""
        self._segments.insert(0, segment)

    def __str__(self) -> str:
        if len(self._segments) == 0:
            return ""

        parts = []  # type: List[str]

        iterator = iter(self._segments)
        first = next(iterator)
        if isinstance(first, PropertySegment):
            parts.append(f"{first.name}")
        elif isinstance(first, IndexSegment):
            parts.append(f"[{first.index}]")
        else:
            aas_common.assert_never(first)

        for segment in iterator:
            if isinstance(segment, PropertySegment):
                parts.append(f".{segment.name}")
            elif isinstance(segment, IndexSegment):
                parts.append(f"[{segment.index}]")
            else:
                aas_common.assert_never(segment)

        return "".join(parts)


class DeserializationException(Exception):
    """Signal that the JSON de-serialization could not be performed."""

    #: Human-readable explanation of the exception's cause
    cause: Final[str]

    #: Relative path to the erroneous value
    path: Final[Path]

    def __init__(
            self,
            cause: str
    ) -> None:
        """Initialize with the given :paramref:`cause` and an empty path."""
        self.cause = cause
        self.path = Path()


# NOTE (mristin, 2022-10-03):
# Recursive definitions are not yet available in mypy
# (see https://github.com/python/mypy/issues/731). We have to use ``Any``
# here, instead of recursive type annotations.
Jsonable = Union[
    bool,
    int,
    float,
    str,
    Sequence[Any],
    Mapping[str, Any]
]


MutableJsonable = Union[
    bool,
    int,
    float,
    str,
    List[Any],
    MutableMapping[str, Any]
]


# region De-serialization


def _bool_from_jsonable(
    jsonable: Jsonable
) -> bool:
    """
    Parse :paramref:`jsonable` as a boolean.

    :param jsonable: JSON-able structure to be parsed
    :return: parsed boolean
    :raise: :py:class:`DeserializationException` if unexpected :paramref:`jsonable`
    """
    if not isinstance(jsonable, bool):
        raise DeserializationException(
            f"Expected a bool, but got: {type(jsonable)}"
        )
    return jsonable


def _int_from_jsonable(
    jsonable: Jsonable
) -> int:
    """
    Parse :paramref:`jsonable` as an integer.

    :param jsonable: JSON-able structure to be parsed
    :return: parsed integer
    :raise: :py:class:`DeserializationException` if unexpected :paramref:`jsonable`
    """
    if not isinstance(jsonable, int):
        raise DeserializationException(
            f"Expected an int, but got: {type(jsonable)}"
        )
    return jsonable


def _float_from_jsonable(
    jsonable: Jsonable
) -> float:
    """
    Parse :paramref:`jsonable` as a floating-point number.

    :param jsonable: JSON-able structure to be parsed
    :return: parsed floating-point number
    :raise: :py:class:`DeserializationException` if unexpected :paramref:`jsonable`
    """
    if not isinstance(jsonable, float):
        raise DeserializationException(
            f"Expected a float, but got: {type(jsonable)}"
        )
    return jsonable


def _str_from_jsonable(
    jsonable: Jsonable
) -> str:
    """
    Parse :paramref:`jsonable` as a string.

    :param jsonable: JSON-able structure to be parsed
    :return: parsed string
    :raise: :py:class:`DeserializationException` if unexpected :paramref:`jsonable`
    """
    if not isinstance(jsonable, str):
        raise DeserializationException(
            f"Expected a str, but got: {type(jsonable)}"
        )
    return jsonable


def _bytes_from_jsonable(
    jsonable: Jsonable
) -> bytes:
    """
    Decode :paramref:`jsonable` as base64 string to a ``bytearray``.

    :param jsonable: JSON-able structure to be decoded
    :return: decoded bytearray
    :raise: :py:class:`DeserializationException` if unexpected :paramref:`jsonable`
    """
    if not isinstance(jsonable, str):
        raise DeserializationException(
            f"Expected a str, but got: {type(jsonable)}"
        )

    return base64.b64decode(
        jsonable.encode('ascii')
    )


def _try_to_cast_to_array_like(
    jsonable: Jsonable
) -> Optional[Iterable[Any]]:
    """
    Try to cast the ``jsonable`` to something like a JSON array.

    In particular, we explicitly check that the ``jsonable`` is not a mapping, as we
    do not want to mistake dictionaries (*i.e.* de-serialized JSON objects) for lists.

    >>> assert _try_to_cast_to_array_like(True) is None

    >>> assert _try_to_cast_to_array_like(0) is None

    >>> assert _try_to_cast_to_array_like(2.2) is None

    >>> assert _try_to_cast_to_array_like("hello") is None

    >>> assert _try_to_cast_to_array_like(b"hello") is None

    >>> _try_to_cast_to_array_like([1, 2])
    [1, 2]

    >>> assert _try_to_cast_to_array_like({"a": 3}) is None

    >>> assert _try_to_cast_to_array_like(collections.OrderedDict()) is None

    >>> _try_to_cast_to_array_like(range(1, 2))
    range(1, 2)

    >>> _try_to_cast_to_array_like((1, 2))
    (1, 2)

    >>> assert _try_to_cast_to_array_like({1, 2, 3}) is None
    """
    if (
        
        not isinstance(jsonable, (str, bytearray, bytes))
        and hasattr(jsonable, "__iter__")
        and not hasattr(jsonable, "keys")
        # NOTE (mristin):
        # There is no easy way to check for sets as opposed to sequence except
        # for checking for direct inheritance. A sequence also inherits from
        # a collection, so both sequences and sets provide ``__contains__`` method.
        #
        # See: https://docs.python.org/3/library/collections.abc.html
        and not isinstance(jsonable, collections.abc.Set)
    ):
        return cast(Iterable[Any], jsonable)

    return None


class _SetterForMyClass:
    """Provide de-serialization-setters for properties."""

    def __init__(self) -> None:
        """Initialize with all the properties unset."""
        self.string_prop: Optional[str] = None
        self.int_prop: Optional[int] = None
        self.bool_prop: Optional[bool] = None

    def ignore(self, jsonable: Jsonable) -> None:
        """Ignore :paramref:`jsonable` and do not set anything."""
        pass

    def set_string_prop_from_jsonable(
            self,
            jsonable: Jsonable
    ) -> None:
        """
        Parse :paramref:`jsonable` as the value of :py:attr:`~string_prop`.

        :param jsonable: input to be parsed
        """
        self.string_prop = _str_from_jsonable(
            jsonable
        )

    def set_int_prop_from_jsonable(
            self,
            jsonable: Jsonable
    ) -> None:
        """
        Parse :paramref:`jsonable` as the value of :py:attr:`~int_prop`.

        :param jsonable: input to be parsed
        """
        self.int_prop = _int_from_jsonable(
            jsonable
        )

    def set_bool_prop_from_jsonable(
            self,
            jsonable: Jsonable
    ) -> None:
        """
        Parse :paramref:`jsonable` as the value of :py:attr:`~bool_prop`.

        :param jsonable: input to be parsed
        """
        self.bool_prop = _bool_from_jsonable(
            jsonable
        )


def my_class_from_jsonable(
        jsonable: Jsonable
) -> aas_types.MyClass:
    """
    Parse an instance of :py:class:`.types.MyClass` from the JSON-able
    structure :paramref:`jsonable`.

    :param jsonable: structure to be parsed
    :return: Parsed instance of :py:class:`.types.MyClass`
    :raise: :py:class:`DeserializationException` if unexpected :paramref:`jsonable`
    """
    if not isinstance(jsonable, collections.abc.Mapping):
        raise DeserializationException(
            f"Expected a mapping, but got: {type(jsonable)}"
        )

    setter = _SetterForMyClass()

    for key, jsonable_value in jsonable.items():
        setter_method = (
            _SETTER_MAP_FOR_MY_CLASS.get(key)
        )
        if setter_method is None:
            raise DeserializationException(
                f"Unexpected property: {key}"
            )

        try:
            setter_method(setter, jsonable_value)
        except DeserializationException as exception:
            exception.path._prepend(
                PropertySegment(
                    jsonable_value,
                    key
                )
            )
            raise exception

    if setter.string_prop is None:
        raise DeserializationException(
            "The required property 'stringProp' is missing"
        )

    if setter.int_prop is None:
        raise DeserializationException(
            "The required property 'intProp' is missing"
        )

    if setter.bool_prop is None:
        raise DeserializationException(
            "The required property 'boolProp' is missing"
        )

    return aas_types.MyClass(
        setter.string_prop,
        setter.int_prop,
        setter.bool_prop
    )


class _SetterForRoot:
    """Provide de-serialization-setters for properties."""

    def __init__(self) -> None:
        """Initialize with all the properties unset."""
        self.foo: Optional[aas_types.MyClass] = None
        self.foos: Optional[List[aas_types.MyClass]] = None
        self.strings: Optional[List[str]] = None
        self.integers: Optional[List[int]] = None
        self.booleans: Optional[List[bool]] = None

    def ignore(self, jsonable: Jsonable) -> None:
        """Ignore :paramref:`jsonable` and do not set anything."""
        pass

    def set_foo_from_jsonable(
            self,
            jsonable: Jsonable
    ) -> None:
        """
        Parse :paramref:`jsonable` as the value of :py:attr:`~foo`.

        :param jsonable: input to be parsed
        """
        self.foo = my_class_from_jsonable(
            jsonable
        )

    def set_foos_from_jsonable(
            self,
            jsonable: Jsonable
    ) -> None:
        """
        Parse :paramref:`jsonable` as the value of :py:attr:`~foos`.

        :param jsonable: input to be parsed
        """
        array_like = _try_to_cast_to_array_like(jsonable)
        if array_like is None:
            raise DeserializationException(
                f"Expected something array-like, but got: {type(jsonable)}"
            )

        items: List[
            aas_types.MyClass
        ] = []
        for i, jsonable_item in enumerate(array_like):
            try:
                item = my_class_from_jsonable(
                    jsonable_item
                )
            except DeserializationException as exception:
                exception.path._prepend(
                    IndexSegment(
                        array_like,
                        i
                    )
                )
                raise

            items.append(item)

        self.foos = items

    def set_strings_from_jsonable(
            self,
            jsonable: Jsonable
    ) -> None:
        """
        Parse :paramref:`jsonable` as the value of :py:attr:`~strings`.

        :param jsonable: input to be parsed
        """
        array_like = _try_to_cast_to_array_like(jsonable)
        if array_like is None:
            raise DeserializationException(
                f"Expected something array-like, but got: {type(jsonable)}"
            )

        items: List[
            str
        ] = []
        for i, jsonable_item in enumerate(array_like):
            try:
                item = _str_from_jsonable(
                    jsonable_item
                )
            except DeserializationException as exception:
                exception.path._prepend(
                    IndexSegment(
                        array_like,
                        i
                    )
                )
                raise

            items.append(item)

        self.strings = items

    def set_integers_from_jsonable(
            self,
            jsonable: Jsonable
    ) -> None:
        """
        Parse :paramref:`jsonable` as the value of :py:attr:`~integers`.

        :param jsonable: input to be parsed
        """
        array_like = _try_to_cast_to_array_like(jsonable)
        if array_like is None:
            raise DeserializationException(
                f"Expected something array-like, but got: {type(jsonable)}"
            )

        items: List[
            int
        ] = []
        for i, jsonable_item in enumerate(array_like):
            try:
                item = _int_from_jsonable(
                    jsonable_item
                )
            except DeserializationException as exception:
                exception.path._prepend(
                    IndexSegment(
                        array_like,
                        i
                    )
                )
                raise

            items.append(item)

        self.integers = items

    def set_booleans_from_jsonable(
            self,
            jsonable: Jsonable
    ) -> None:
        """
        Parse :paramref:`jsonable` as the value of :py:attr:`~booleans`.

        :param jsonable: input to be parsed
        """
        array_like = _try_to_cast_to_array_like(jsonable)
        if array_like is None:
            raise DeserializationException(
                f"Expected something array-like, but got: {type(jsonable)}"
            )

        items: List[
            bool
        ] = []
        for i, jsonable_item in enumerate(array_like):
            try:
                item = _bool_from_jsonable(
                    jsonable_item
                )
            except DeserializationException as exception:
                exception.path._prepend(
                    IndexSegment(
                        array_like,
                        i
                    )
                )
                raise

            items.append(item)

        self.booleans = items


def root_from_jsonable(
        jsonable: Jsonable
) -> aas_types.Root:
    """
    Parse an instance of :py:class:`.types.Root` from the JSON-able
    structure :paramref:`jsonable`.

    :param jsonable: structure to be parsed
    :return: Parsed instance of :py:class:`.types.Root`
    :raise: :py:class:`DeserializationException` if unexpected :paramref:`jsonable`
    """
    if not isinstance(jsonable, collections.abc.Mapping):
        raise DeserializationException(
            f"Expected a mapping, but got: {type(jsonable)}"
        )

    setter = _SetterForRoot()

    for key, jsonable_value in jsonable.items():
        setter_method = (
            _SETTER_MAP_FOR_ROOT.get(key)
        )
        if setter_method is None:
            raise DeserializationException(
                f"Unexpected property: {key}"
            )

        try:
            setter_method(setter, jsonable_value)
        except DeserializationException as exception:
            exception.path._prepend(
                PropertySegment(
                    jsonable_value,
                    key
                )
            )
            raise exception

    if setter.foo is None:
        raise DeserializationException(
            "The required property 'foo' is missing"
        )

    if setter.foos is None:
        raise DeserializationException(
            "The required property 'foos' is missing"
        )

    if setter.strings is None:
        raise DeserializationException(
            "The required property 'strings' is missing"
        )

    if setter.integers is None:
        raise DeserializationException(
            "The required property 'integers' is missing"
        )

    if setter.booleans is None:
        raise DeserializationException(
            "The required property 'booleans' is missing"
        )

    return aas_types.Root(
        setter.foo,
        setter.foos,
        setter.strings,
        setter.integers,
        setter.booleans
    )


_SETTER_MAP_FOR_MY_CLASS: Mapping[
    str,
    Callable[
        [_SetterForMyClass, Jsonable],
        None
    ]
] = {
    'stringProp':
        _SetterForMyClass.set_string_prop_from_jsonable,
    'intProp':
        _SetterForMyClass.set_int_prop_from_jsonable,
    'boolProp':
        _SetterForMyClass.set_bool_prop_from_jsonable,
    'modelType':
        _SetterForMyClass.ignore
}


_SETTER_MAP_FOR_ROOT: Mapping[
    str,
    Callable[
        [_SetterForRoot, Jsonable],
        None
    ]
] = {
    'foo':
        _SetterForRoot.set_foo_from_jsonable,
    'foos':
        _SetterForRoot.set_foos_from_jsonable,
    'strings':
        _SetterForRoot.set_strings_from_jsonable,
    'integers':
        _SetterForRoot.set_integers_from_jsonable,
    'booleans':
        _SetterForRoot.set_booleans_from_jsonable,
    'modelType':
        _SetterForRoot.ignore
}


# endregion


# region Serialization


def _bytes_to_base64_str(
    value: bytes
) -> str:
    """
    Encode :paramref:`value` as a base64 string.

    :param value: to be encoded
    :return: encoded :paramref:`value` in base64
    """
    # We need to decode as ascii as ``base64.b64encode`` returns bytes,
    # not a string!
    return base64.b64encode(value).decode('ascii')


class _Serializer(
        aas_types.AbstractTransformer[MutableJsonable]
):
    """Transform the instance to its JSON-able representation."""

    # noinspection PyMethodMayBeStatic
    def transform_my_class(
        self,
        that: aas_types.MyClass
    ) -> MutableJsonable:
        """Serialize :paramref:`that` to a JSON-able representation."""
        jsonable: MutableMapping[str, MutableJsonable] = dict()

        jsonable['stringProp'] = that.string_prop

        jsonable['intProp'] = that.int_prop

        jsonable['boolProp'] = that.bool_prop

        return jsonable

    def transform_root(
        self,
        that: aas_types.Root
    ) -> MutableJsonable:
        """Serialize :paramref:`that` to a JSON-able representation."""
        jsonable: MutableMapping[str, MutableJsonable] = dict()

        jsonable['foo'] = self.transform(that.foo)

        jsonable['foos'] = [
            self.transform(item)
            for item in that.foos
        ]

        jsonable['strings'] = [
            item
            for item in that.strings
        ]

        jsonable['integers'] = [
            item
            for item in that.integers
        ]

        jsonable['booleans'] = [
            item
            for item in that.booleans
        ]

        return jsonable


_SERIALIZER = _Serializer()


def to_jsonable(that: aas_types.Class) -> MutableJsonable:
    """
    Convert :paramref:`that` to a JSON-able structure.

    :param that:
        AAS data to be recursively converted to a JSON-able structure
    :return:
        JSON-able structure which can be further encoded with, *e.g.*, :py:mod:`json`
    """
    return _SERIALIZER.transform(that)


# endregion


# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.
