// De/serialize enumerations from and to string representations.

package stringification

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

import (
	"fmt"
	aastypes "github.com/aas-core-works/aas-core3.0-golang/types"
)

var modellingKindFromStringMap = map[string]aastypes.ModellingKind {
	"Template": aastypes.ModellingKindTemplate,
	"Instance": aastypes.ModellingKindInstance,
}

// Parse `text` as a string representation of [aastypes.ModellingKind].
//
// If not ok, the literal result is undefined.
func ModellingKindFromString(
	text string,
) (literal aastypes.ModellingKind, ok bool) {
	literal, ok = modellingKindFromStringMap[text]
	return
}

var modellingKindToStringArray = [...]string {
	"Template",
	"Instance",
}

// Translate `value` from [aastypes.ModellingKind] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func ModellingKindToString(
	value aastypes.ModellingKind,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(modellingKindToStringArray)

	if !ok {
		return
	}
	result = modellingKindToStringArray[value]
	return
}

// Translate the `value` from [aastypes.ModellingKind] to a string.
//
// Panic if the given value is invalid.
func MustModellingKindToString(
	value aastypes.ModellingKind,
) string {
	result, ok := ModellingKindToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of ModellingKind: %v",
				value,
			),
		)
	}
	return result
}

var qualifierKindFromStringMap = map[string]aastypes.QualifierKind {
	"ValueQualifier": aastypes.QualifierKindValueQualifier,
	"ConceptQualifier": aastypes.QualifierKindConceptQualifier,
	"TemplateQualifier": aastypes.QualifierKindTemplateQualifier,
}

// Parse `text` as a string representation of [aastypes.QualifierKind].
//
// If not ok, the literal result is undefined.
func QualifierKindFromString(
	text string,
) (literal aastypes.QualifierKind, ok bool) {
	literal, ok = qualifierKindFromStringMap[text]
	return
}

var qualifierKindToStringArray = [...]string {
	"ValueQualifier",
	"ConceptQualifier",
	"TemplateQualifier",
}

// Translate `value` from [aastypes.QualifierKind] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func QualifierKindToString(
	value aastypes.QualifierKind,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(qualifierKindToStringArray)

	if !ok {
		return
	}
	result = qualifierKindToStringArray[value]
	return
}

// Translate the `value` from [aastypes.QualifierKind] to a string.
//
// Panic if the given value is invalid.
func MustQualifierKindToString(
	value aastypes.QualifierKind,
) string {
	result, ok := QualifierKindToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of QualifierKind: %v",
				value,
			),
		)
	}
	return result
}

var assetKindFromStringMap = map[string]aastypes.AssetKind {
	"Type": aastypes.AssetKindType,
	"Instance": aastypes.AssetKindInstance,
	"NotApplicable": aastypes.AssetKindNotApplicable,
}

// Parse `text` as a string representation of [aastypes.AssetKind].
//
// If not ok, the literal result is undefined.
func AssetKindFromString(
	text string,
) (literal aastypes.AssetKind, ok bool) {
	literal, ok = assetKindFromStringMap[text]
	return
}

var assetKindToStringArray = [...]string {
	"Type",
	"Instance",
	"NotApplicable",
}

// Translate `value` from [aastypes.AssetKind] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func AssetKindToString(
	value aastypes.AssetKind,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(assetKindToStringArray)

	if !ok {
		return
	}
	result = assetKindToStringArray[value]
	return
}

// Translate the `value` from [aastypes.AssetKind] to a string.
//
// Panic if the given value is invalid.
func MustAssetKindToString(
	value aastypes.AssetKind,
) string {
	result, ok := AssetKindToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of AssetKind: %v",
				value,
			),
		)
	}
	return result
}

var aasSubmodelElementsFromStringMap = map[string]aastypes.AASSubmodelElements {
	"AnnotatedRelationshipElement": aastypes.AASSubmodelElementsAnnotatedRelationshipElement,
	"BasicEventElement": aastypes.AASSubmodelElementsBasicEventElement,
	"Blob": aastypes.AASSubmodelElementsBlob,
	"Capability": aastypes.AASSubmodelElementsCapability,
	"DataElement": aastypes.AASSubmodelElementsDataElement,
	"Entity": aastypes.AASSubmodelElementsEntity,
	"EventElement": aastypes.AASSubmodelElementsEventElement,
	"File": aastypes.AASSubmodelElementsFile,
	"MultiLanguageProperty": aastypes.AASSubmodelElementsMultiLanguageProperty,
	"Operation": aastypes.AASSubmodelElementsOperation,
	"Property": aastypes.AASSubmodelElementsProperty,
	"Range": aastypes.AASSubmodelElementsRange,
	"ReferenceElement": aastypes.AASSubmodelElementsReferenceElement,
	"RelationshipElement": aastypes.AASSubmodelElementsRelationshipElement,
	"SubmodelElement": aastypes.AASSubmodelElementsSubmodelElement,
	"SubmodelElementList": aastypes.AASSubmodelElementsSubmodelElementList,
	"SubmodelElementCollection": aastypes.AASSubmodelElementsSubmodelElementCollection,
}

// Parse `text` as a string representation of [aastypes.AASSubmodelElements].
//
// If not ok, the literal result is undefined.
func AASSubmodelElementsFromString(
	text string,
) (literal aastypes.AASSubmodelElements, ok bool) {
	literal, ok = aasSubmodelElementsFromStringMap[text]
	return
}

var aasSubmodelElementsToStringArray = [...]string {
	"AnnotatedRelationshipElement",
	"BasicEventElement",
	"Blob",
	"Capability",
	"DataElement",
	"Entity",
	"EventElement",
	"File",
	"MultiLanguageProperty",
	"Operation",
	"Property",
	"Range",
	"ReferenceElement",
	"RelationshipElement",
	"SubmodelElement",
	"SubmodelElementList",
	"SubmodelElementCollection",
}

// Translate `value` from [aastypes.AASSubmodelElements] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func AASSubmodelElementsToString(
	value aastypes.AASSubmodelElements,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(aasSubmodelElementsToStringArray)

	if !ok {
		return
	}
	result = aasSubmodelElementsToStringArray[value]
	return
}

// Translate the `value` from [aastypes.AASSubmodelElements] to a string.
//
// Panic if the given value is invalid.
func MustAASSubmodelElementsToString(
	value aastypes.AASSubmodelElements,
) string {
	result, ok := AASSubmodelElementsToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of AASSubmodelElements: %v",
				value,
			),
		)
	}
	return result
}

var entityTypeFromStringMap = map[string]aastypes.EntityType {
	"CoManagedEntity": aastypes.EntityTypeCoManagedEntity,
	"SelfManagedEntity": aastypes.EntityTypeSelfManagedEntity,
}

// Parse `text` as a string representation of [aastypes.EntityType].
//
// If not ok, the literal result is undefined.
func EntityTypeFromString(
	text string,
) (literal aastypes.EntityType, ok bool) {
	literal, ok = entityTypeFromStringMap[text]
	return
}

var entityTypeToStringArray = [...]string {
	"CoManagedEntity",
	"SelfManagedEntity",
}

// Translate `value` from [aastypes.EntityType] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func EntityTypeToString(
	value aastypes.EntityType,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(entityTypeToStringArray)

	if !ok {
		return
	}
	result = entityTypeToStringArray[value]
	return
}

// Translate the `value` from [aastypes.EntityType] to a string.
//
// Panic if the given value is invalid.
func MustEntityTypeToString(
	value aastypes.EntityType,
) string {
	result, ok := EntityTypeToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of EntityType: %v",
				value,
			),
		)
	}
	return result
}

var directionFromStringMap = map[string]aastypes.Direction {
	"input": aastypes.DirectionInput,
	"output": aastypes.DirectionOutput,
}

// Parse `text` as a string representation of [aastypes.Direction].
//
// If not ok, the literal result is undefined.
func DirectionFromString(
	text string,
) (literal aastypes.Direction, ok bool) {
	literal, ok = directionFromStringMap[text]
	return
}

var directionToStringArray = [...]string {
	"input",
	"output",
}

// Translate `value` from [aastypes.Direction] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func DirectionToString(
	value aastypes.Direction,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(directionToStringArray)

	if !ok {
		return
	}
	result = directionToStringArray[value]
	return
}

// Translate the `value` from [aastypes.Direction] to a string.
//
// Panic if the given value is invalid.
func MustDirectionToString(
	value aastypes.Direction,
) string {
	result, ok := DirectionToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of Direction: %v",
				value,
			),
		)
	}
	return result
}

var stateOfEventFromStringMap = map[string]aastypes.StateOfEvent {
	"on": aastypes.StateOfEventOn,
	"off": aastypes.StateOfEventOff,
}

// Parse `text` as a string representation of [aastypes.StateOfEvent].
//
// If not ok, the literal result is undefined.
func StateOfEventFromString(
	text string,
) (literal aastypes.StateOfEvent, ok bool) {
	literal, ok = stateOfEventFromStringMap[text]
	return
}

var stateOfEventToStringArray = [...]string {
	"on",
	"off",
}

// Translate `value` from [aastypes.StateOfEvent] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func StateOfEventToString(
	value aastypes.StateOfEvent,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(stateOfEventToStringArray)

	if !ok {
		return
	}
	result = stateOfEventToStringArray[value]
	return
}

// Translate the `value` from [aastypes.StateOfEvent] to a string.
//
// Panic if the given value is invalid.
func MustStateOfEventToString(
	value aastypes.StateOfEvent,
) string {
	result, ok := StateOfEventToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of StateOfEvent: %v",
				value,
			),
		)
	}
	return result
}

var referenceTypesFromStringMap = map[string]aastypes.ReferenceTypes {
	"ExternalReference": aastypes.ReferenceTypesExternalReference,
	"ModelReference": aastypes.ReferenceTypesModelReference,
}

// Parse `text` as a string representation of [aastypes.ReferenceTypes].
//
// If not ok, the literal result is undefined.
func ReferenceTypesFromString(
	text string,
) (literal aastypes.ReferenceTypes, ok bool) {
	literal, ok = referenceTypesFromStringMap[text]
	return
}

var referenceTypesToStringArray = [...]string {
	"ExternalReference",
	"ModelReference",
}

// Translate `value` from [aastypes.ReferenceTypes] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func ReferenceTypesToString(
	value aastypes.ReferenceTypes,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(referenceTypesToStringArray)

	if !ok {
		return
	}
	result = referenceTypesToStringArray[value]
	return
}

// Translate the `value` from [aastypes.ReferenceTypes] to a string.
//
// Panic if the given value is invalid.
func MustReferenceTypesToString(
	value aastypes.ReferenceTypes,
) string {
	result, ok := ReferenceTypesToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of ReferenceTypes: %v",
				value,
			),
		)
	}
	return result
}

var keyTypesFromStringMap = map[string]aastypes.KeyTypes {
	"AnnotatedRelationshipElement": aastypes.KeyTypesAnnotatedRelationshipElement,
	"AssetAdministrationShell": aastypes.KeyTypesAssetAdministrationShell,
	"BasicEventElement": aastypes.KeyTypesBasicEventElement,
	"Blob": aastypes.KeyTypesBlob,
	"Capability": aastypes.KeyTypesCapability,
	"ConceptDescription": aastypes.KeyTypesConceptDescription,
	"DataElement": aastypes.KeyTypesDataElement,
	"Entity": aastypes.KeyTypesEntity,
	"EventElement": aastypes.KeyTypesEventElement,
	"File": aastypes.KeyTypesFile,
	"FragmentReference": aastypes.KeyTypesFragmentReference,
	"GlobalReference": aastypes.KeyTypesGlobalReference,
	"Identifiable": aastypes.KeyTypesIdentifiable,
	"MultiLanguageProperty": aastypes.KeyTypesMultiLanguageProperty,
	"Operation": aastypes.KeyTypesOperation,
	"Property": aastypes.KeyTypesProperty,
	"Range": aastypes.KeyTypesRange,
	"Referable": aastypes.KeyTypesReferable,
	"ReferenceElement": aastypes.KeyTypesReferenceElement,
	"RelationshipElement": aastypes.KeyTypesRelationshipElement,
	"Submodel": aastypes.KeyTypesSubmodel,
	"SubmodelElement": aastypes.KeyTypesSubmodelElement,
	"SubmodelElementCollection": aastypes.KeyTypesSubmodelElementCollection,
	"SubmodelElementList": aastypes.KeyTypesSubmodelElementList,
}

// Parse `text` as a string representation of [aastypes.KeyTypes].
//
// If not ok, the literal result is undefined.
func KeyTypesFromString(
	text string,
) (literal aastypes.KeyTypes, ok bool) {
	literal, ok = keyTypesFromStringMap[text]
	return
}

var keyTypesToStringArray = [...]string {
	"AnnotatedRelationshipElement",
	"AssetAdministrationShell",
	"BasicEventElement",
	"Blob",
	"Capability",
	"ConceptDescription",
	"DataElement",
	"Entity",
	"EventElement",
	"File",
	"FragmentReference",
	"GlobalReference",
	"Identifiable",
	"MultiLanguageProperty",
	"Operation",
	"Property",
	"Range",
	"Referable",
	"ReferenceElement",
	"RelationshipElement",
	"Submodel",
	"SubmodelElement",
	"SubmodelElementCollection",
	"SubmodelElementList",
}

// Translate `value` from [aastypes.KeyTypes] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func KeyTypesToString(
	value aastypes.KeyTypes,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(keyTypesToStringArray)

	if !ok {
		return
	}
	result = keyTypesToStringArray[value]
	return
}

// Translate the `value` from [aastypes.KeyTypes] to a string.
//
// Panic if the given value is invalid.
func MustKeyTypesToString(
	value aastypes.KeyTypes,
) string {
	result, ok := KeyTypesToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of KeyTypes: %v",
				value,
			),
		)
	}
	return result
}

var dataTypeDefXSDFromStringMap = map[string]aastypes.DataTypeDefXSD {
	"xs:anyURI": aastypes.DataTypeDefXSDAnyURI,
	"xs:base64Binary": aastypes.DataTypeDefXSDBase64Binary,
	"xs:boolean": aastypes.DataTypeDefXSDBoolean,
	"xs:byte": aastypes.DataTypeDefXSDByte,
	"xs:date": aastypes.DataTypeDefXSDDate,
	"xs:dateTime": aastypes.DataTypeDefXSDDateTime,
	"xs:decimal": aastypes.DataTypeDefXSDDecimal,
	"xs:double": aastypes.DataTypeDefXSDDouble,
	"xs:duration": aastypes.DataTypeDefXSDDuration,
	"xs:float": aastypes.DataTypeDefXSDFloat,
	"xs:gDay": aastypes.DataTypeDefXSDGDay,
	"xs:gMonth": aastypes.DataTypeDefXSDGMonth,
	"xs:gMonthDay": aastypes.DataTypeDefXSDGMonthDay,
	"xs:gYear": aastypes.DataTypeDefXSDGYear,
	"xs:gYearMonth": aastypes.DataTypeDefXSDGYearMonth,
	"xs:hexBinary": aastypes.DataTypeDefXSDHexBinary,
	"xs:int": aastypes.DataTypeDefXSDInt,
	"xs:integer": aastypes.DataTypeDefXSDInteger,
	"xs:long": aastypes.DataTypeDefXSDLong,
	"xs:negativeInteger": aastypes.DataTypeDefXSDNegativeInteger,
	"xs:nonNegativeInteger": aastypes.DataTypeDefXSDNonNegativeInteger,
	"xs:nonPositiveInteger": aastypes.DataTypeDefXSDNonPositiveInteger,
	"xs:positiveInteger": aastypes.DataTypeDefXSDPositiveInteger,
	"xs:short": aastypes.DataTypeDefXSDShort,
	"xs:string": aastypes.DataTypeDefXSDString,
	"xs:time": aastypes.DataTypeDefXSDTime,
	"xs:unsignedByte": aastypes.DataTypeDefXSDUnsignedByte,
	"xs:unsignedInt": aastypes.DataTypeDefXSDUnsignedInt,
	"xs:unsignedLong": aastypes.DataTypeDefXSDUnsignedLong,
	"xs:unsignedShort": aastypes.DataTypeDefXSDUnsignedShort,
}

// Parse `text` as a string representation of [aastypes.DataTypeDefXSD].
//
// If not ok, the literal result is undefined.
func DataTypeDefXSDFromString(
	text string,
) (literal aastypes.DataTypeDefXSD, ok bool) {
	literal, ok = dataTypeDefXSDFromStringMap[text]
	return
}

var dataTypeDefXSDToStringArray = [...]string {
	"xs:anyURI",
	"xs:base64Binary",
	"xs:boolean",
	"xs:byte",
	"xs:date",
	"xs:dateTime",
	"xs:decimal",
	"xs:double",
	"xs:duration",
	"xs:float",
	"xs:gDay",
	"xs:gMonth",
	"xs:gMonthDay",
	"xs:gYear",
	"xs:gYearMonth",
	"xs:hexBinary",
	"xs:int",
	"xs:integer",
	"xs:long",
	"xs:negativeInteger",
	"xs:nonNegativeInteger",
	"xs:nonPositiveInteger",
	"xs:positiveInteger",
	"xs:short",
	"xs:string",
	"xs:time",
	"xs:unsignedByte",
	"xs:unsignedInt",
	"xs:unsignedLong",
	"xs:unsignedShort",
}

// Translate `value` from [aastypes.DataTypeDefXSD] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func DataTypeDefXSDToString(
	value aastypes.DataTypeDefXSD,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(dataTypeDefXSDToStringArray)

	if !ok {
		return
	}
	result = dataTypeDefXSDToStringArray[value]
	return
}

// Translate the `value` from [aastypes.DataTypeDefXSD] to a string.
//
// Panic if the given value is invalid.
func MustDataTypeDefXSDToString(
	value aastypes.DataTypeDefXSD,
) string {
	result, ok := DataTypeDefXSDToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of DataTypeDefXSD: %v",
				value,
			),
		)
	}
	return result
}

var dataTypeIEC61360FromStringMap = map[string]aastypes.DataTypeIEC61360 {
	"DATE": aastypes.DataTypeIEC61360Date,
	"STRING": aastypes.DataTypeIEC61360String,
	"STRING_TRANSLATABLE": aastypes.DataTypeIEC61360StringTranslatable,
	"INTEGER_MEASURE": aastypes.DataTypeIEC61360IntegerMeasure,
	"INTEGER_COUNT": aastypes.DataTypeIEC61360IntegerCount,
	"INTEGER_CURRENCY": aastypes.DataTypeIEC61360IntegerCurrency,
	"REAL_MEASURE": aastypes.DataTypeIEC61360RealMeasure,
	"REAL_COUNT": aastypes.DataTypeIEC61360RealCount,
	"REAL_CURRENCY": aastypes.DataTypeIEC61360RealCurrency,
	"BOOLEAN": aastypes.DataTypeIEC61360Boolean,
	"IRI": aastypes.DataTypeIEC61360IRI,
	"IRDI": aastypes.DataTypeIEC61360IRDI,
	"RATIONAL": aastypes.DataTypeIEC61360Rational,
	"RATIONAL_MEASURE": aastypes.DataTypeIEC61360RationalMeasure,
	"TIME": aastypes.DataTypeIEC61360Time,
	"TIMESTAMP": aastypes.DataTypeIEC61360Timestamp,
	"FILE": aastypes.DataTypeIEC61360File,
	"HTML": aastypes.DataTypeIEC61360HTML,
	"BLOB": aastypes.DataTypeIEC61360Blob,
}

// Parse `text` as a string representation of [aastypes.DataTypeIEC61360].
//
// If not ok, the literal result is undefined.
func DataTypeIEC61360FromString(
	text string,
) (literal aastypes.DataTypeIEC61360, ok bool) {
	literal, ok = dataTypeIEC61360FromStringMap[text]
	return
}

var dataTypeIEC61360ToStringArray = [...]string {
	"DATE",
	"STRING",
	"STRING_TRANSLATABLE",
	"INTEGER_MEASURE",
	"INTEGER_COUNT",
	"INTEGER_CURRENCY",
	"REAL_MEASURE",
	"REAL_COUNT",
	"REAL_CURRENCY",
	"BOOLEAN",
	"IRI",
	"IRDI",
	"RATIONAL",
	"RATIONAL_MEASURE",
	"TIME",
	"TIMESTAMP",
	"FILE",
	"HTML",
	"BLOB",
}

// Translate `value` from [aastypes.DataTypeIEC61360] to a string.
//
// If the value is not valid, the OK is false and the string representation is
// undefined.
func DataTypeIEC61360ToString(
	value aastypes.DataTypeIEC61360,
) (result string, ok bool) {
	i := int(value)
	ok =
		i >= 0 &&
		i < len(dataTypeIEC61360ToStringArray)

	if !ok {
		return
	}
	result = dataTypeIEC61360ToStringArray[value]
	return
}

// Translate the `value` from [aastypes.DataTypeIEC61360] to a string.
//
// Panic if the given value is invalid.
func MustDataTypeIEC61360ToString(
	value aastypes.DataTypeIEC61360,
) string {
	result, ok := DataTypeIEC61360ToString(value)
	if !ok {
		panic(
			fmt.Sprintf(
				"Invalid value of DataTypeIEC61360: %v",
				value,
			),
		)
	}
	return result
}

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
