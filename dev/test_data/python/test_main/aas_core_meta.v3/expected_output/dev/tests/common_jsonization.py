"""Provide common functionality for JSON de/serialization in tests."""


# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.


# pylint: disable=missing-docstring


import collections.abc
import json
import pathlib
import sys
from typing import Callable, Iterator, Mapping, Type


if sys.version_info >= (3, 8):
    from typing import Final
else:
    from typing_extensions import Final


import aas_core3.common as aas_common
import aas_core3.jsonization as aas_jsonization
import aas_core3.types as aas_types


class Difference:
    """Represent a single difference between two JSON-ables."""

    #: Human-readable description of the difference
    message: Final[str]

    #: Path in the expected JSON-able value which is different from
    #: the obtained JSON-able value
    path: Final[aas_jsonization.Path]

    def __init__(self, message: str) -> None:
        """Initialize with the given message and empty path."""
        self.message = message
        self.path = aas_jsonization.Path()

    def __str__(self) -> str:
        return f"#{self.path}: {self.message}"


def check_equal(
    expected: aas_jsonization.Jsonable,
    got: aas_jsonization.Jsonable,
) -> Iterator[Difference]:
    """
    Compare recursively two JSON-able values for equality.

    :param expected: expected JSON-able value
    :param got: obtained JSON-able value
    :yield: differences
    """
    if isinstance(expected, (bool, int, float, str, bytes)):
        if type(expected) != type(got):  # pylint: disable=unidiomatic-typecheck
            yield Difference(f"Expected {type(expected)}, but got {type(got)}")

        if expected != got:
            yield Difference(f"Expected {expected!r}, but got {got!r}")
    elif isinstance(expected, collections.abc.Sequence):
        if not isinstance(got, collections.abc.Sequence):
            yield Difference(f"Expected a sequence, but got {type(got)}")
        else:
            if len(expected) != len(got):
                yield Difference(
                    f"Expected a sequence of {len(expected)} item(s), "
                    f"but got {len(got)} item(s)"
                )

            for i, (expected_item, got_item) in enumerate(zip(expected, got)):
                for difference in check_equal(expected_item, got_item):
                    difference.path._prepend(aas_jsonization.IndexSegment(expected, i))
                    yield difference

    elif isinstance(expected, collections.abc.Mapping):
        if not isinstance(got, collections.abc.Mapping):
            yield Difference(f"Expected a mapping, but got {type(got)}")
        else:
            if not all(isinstance(key, str) for key in expected.keys()):
                raise ValueError(
                    f"Expected all keys in the expected JSON-able value to be strings, "
                    f"but got: {list(expected.keys())}"
                )

            if not all(isinstance(key, str) for key in got.keys()):
                yield Difference(
                    f"Expected all keys in a mapping to be strings, "
                    f"but got: {list(got.keys())}"
                )

            expected_key_set = set(expected.keys())
            got_key_set = set(got.keys())

            expected_got_diff = expected_key_set.difference(got_key_set)
            if expected_got_diff:
                yield Difference(f"Expected key(s) {sorted(expected_got_diff)} missing")

            got_expected_diff = got_key_set.difference(expected_key_set)
            if got_expected_diff:
                yield Difference(f"Unexpected key(s) {sorted(got_expected_diff)}")

            for key, expected_value in expected.items():
                got_value = got[key]

                for difference in check_equal(expected_value, got_value):
                    difference.path._prepend(
                        aas_jsonization.PropertySegment(expected, key)
                    )
                    yield difference
    else:
        aas_common.assert_never(expected)


_MODEL_TYPE_TO_FROM_JSONABLE: Mapping[
    str,
    Callable[[aas_jsonization.Jsonable], aas_types.Class]
] = {
    'AdministrativeInformation':
        aas_jsonization.administrative_information_from_jsonable,
    'AnnotatedRelationshipElement':
        aas_jsonization.annotated_relationship_element_from_jsonable,
    'AssetAdministrationShell':
        aas_jsonization.asset_administration_shell_from_jsonable,
    'AssetInformation':
        aas_jsonization.asset_information_from_jsonable,
    'BasicEventElement':
        aas_jsonization.basic_event_element_from_jsonable,
    'Blob':
        aas_jsonization.blob_from_jsonable,
    'Capability':
        aas_jsonization.capability_from_jsonable,
    'ConceptDescription':
        aas_jsonization.concept_description_from_jsonable,
    'DataSpecificationIec61360':
        aas_jsonization.data_specification_iec_61360_from_jsonable,
    'EmbeddedDataSpecification':
        aas_jsonization.embedded_data_specification_from_jsonable,
    'Entity':
        aas_jsonization.entity_from_jsonable,
    'Environment':
        aas_jsonization.environment_from_jsonable,
    'EventPayload':
        aas_jsonization.event_payload_from_jsonable,
    'Extension':
        aas_jsonization.extension_from_jsonable,
    'File':
        aas_jsonization.file_from_jsonable,
    'Key':
        aas_jsonization.key_from_jsonable,
    'LangStringDefinitionTypeIec61360':
        aas_jsonization.lang_string_definition_type_iec_61360_from_jsonable,
    'LangStringNameType':
        aas_jsonization.lang_string_name_type_from_jsonable,
    'LangStringPreferredNameTypeIec61360':
        aas_jsonization.lang_string_preferred_name_type_iec_61360_from_jsonable,
    'LangStringShortNameTypeIec61360':
        aas_jsonization.lang_string_short_name_type_iec_61360_from_jsonable,
    'LangStringTextType':
        aas_jsonization.lang_string_text_type_from_jsonable,
    'LevelType':
        aas_jsonization.level_type_from_jsonable,
    'MultiLanguageProperty':
        aas_jsonization.multi_language_property_from_jsonable,
    'Operation':
        aas_jsonization.operation_from_jsonable,
    'OperationVariable':
        aas_jsonization.operation_variable_from_jsonable,
    'Property':
        aas_jsonization.property_from_jsonable,
    'Qualifier':
        aas_jsonization.qualifier_from_jsonable,
    'Range':
        aas_jsonization.range_from_jsonable,
    'Reference':
        aas_jsonization.reference_from_jsonable,
    'ReferenceElement':
        aas_jsonization.reference_element_from_jsonable,
    'RelationshipElement':
        aas_jsonization.relationship_element_from_jsonable,
    'Resource':
        aas_jsonization.resource_from_jsonable,
    'SpecificAssetId':
        aas_jsonization.specific_asset_id_from_jsonable,
    'Submodel':
        aas_jsonization.submodel_from_jsonable,
    'SubmodelElementCollection':
        aas_jsonization.submodel_element_collection_from_jsonable,
    'SubmodelElementList':
        aas_jsonization.submodel_element_list_from_jsonable,
    'ValueList':
        aas_jsonization.value_list_from_jsonable,
    'ValueReferencePair':
        aas_jsonization.value_reference_pair_from_jsonable
}


_MODEL_TYPE_TO_CLASS: Mapping[
    str,
    Type[aas_types.Class]
] = {
    'AdministrativeInformation':
        aas_types.AdministrativeInformation,
    'AnnotatedRelationshipElement':
        aas_types.AnnotatedRelationshipElement,
    'AssetAdministrationShell':
        aas_types.AssetAdministrationShell,
    'AssetInformation':
        aas_types.AssetInformation,
    'BasicEventElement':
        aas_types.BasicEventElement,
    'Blob':
        aas_types.Blob,
    'Capability':
        aas_types.Capability,
    'ConceptDescription':
        aas_types.ConceptDescription,
    'DataSpecificationIec61360':
        aas_types.DataSpecificationIEC61360,
    'EmbeddedDataSpecification':
        aas_types.EmbeddedDataSpecification,
    'Entity':
        aas_types.Entity,
    'Environment':
        aas_types.Environment,
    'EventPayload':
        aas_types.EventPayload,
    'Extension':
        aas_types.Extension,
    'File':
        aas_types.File,
    'Key':
        aas_types.Key,
    'LangStringDefinitionTypeIec61360':
        aas_types.LangStringDefinitionTypeIEC61360,
    'LangStringNameType':
        aas_types.LangStringNameType,
    'LangStringPreferredNameTypeIec61360':
        aas_types.LangStringPreferredNameTypeIEC61360,
    'LangStringShortNameTypeIec61360':
        aas_types.LangStringShortNameTypeIEC61360,
    'LangStringTextType':
        aas_types.LangStringTextType,
    'LevelType':
        aas_types.LevelType,
    'MultiLanguageProperty':
        aas_types.MultiLanguageProperty,
    'Operation':
        aas_types.Operation,
    'OperationVariable':
        aas_types.OperationVariable,
    'Property':
        aas_types.Property,
    'Qualifier':
        aas_types.Qualifier,
    'Range':
        aas_types.Range,
    'Reference':
        aas_types.Reference,
    'ReferenceElement':
        aas_types.ReferenceElement,
    'RelationshipElement':
        aas_types.RelationshipElement,
    'Resource':
        aas_types.Resource,
    'SpecificAssetId':
        aas_types.SpecificAssetID,
    'Submodel':
        aas_types.Submodel,
    'SubmodelElementCollection':
        aas_types.SubmodelElementCollection,
    'SubmodelElementList':
        aas_types.SubmodelElementList,
    'ValueList':
        aas_types.ValueList,
    'ValueReferencePair':
        aas_types.ValueReferencePair
}


def must_load(
    path: pathlib.Path,
    model_type: str
) -> aas_types.Class:
    """
    Load an instance from ``path``.

    The class of the instance must correspond to the ``model_type``.
    """
    try:
        jsonable = json.loads(
            path.read_text(encoding='utf-8')
        )
    except Exception as exception:
        raise RuntimeError(f"Failed to read from {path}") from exception

    from_jsonable = _MODEL_TYPE_TO_FROM_JSONABLE.get(model_type, None)
    if from_jsonable is None:
        raise AssertionError(
            "The model type is not mapped to "
            f"the from_jsonable function: {model_type!r}"
        )

    try:
        instance = from_jsonable(jsonable)
    except Exception as exception:
        raise RuntimeError(
            "Failed to parse the instance "
            f"with model type {model_type} from {path}"
        ) from exception

    cls = _MODEL_TYPE_TO_CLASS.get(model_type, None)
    if cls is None:
        raise AssertionError(
            "The model type is not mapped to the class: {model_type!r}"
        )

    if not isinstance(instance, cls):
        raise RuntimeError(
            f"Expected an instance with model type {model_type!r}, "
            f"corresponding to class {cls}, "
            f"but got an instance {instance}"
        )

    return instance


# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.
