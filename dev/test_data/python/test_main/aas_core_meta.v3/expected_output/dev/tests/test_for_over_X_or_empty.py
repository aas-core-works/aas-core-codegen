"""Test ``over_X_or_empty`` methods."""


# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.


# pylint: disable=missing-docstring


import pathlib
import unittest


import aas_core3.types as aas_types


import tests.common_xmlization


class TestExtension(unittest.TestCase):
    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'extension'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Extension
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'extension'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_refers_to_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'extension'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Extension
            )

            log = [
                tests.common.trace(
                    list(instance.over_refers_to_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'extension'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_refers_to_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestAdministrativeInformation(unittest.TestCase):
    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'administrativeInformation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AdministrativeInformation
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'administrativeInformation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestQualifier(unittest.TestCase):
    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'qualifier'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Qualifier
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'qualifier'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestAssetAdministrationShell(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'assetAdministrationShell'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AssetAdministrationShell
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'assetAdministrationShell'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'assetAdministrationShell'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AssetAdministrationShell
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'assetAdministrationShell'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'assetAdministrationShell'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AssetAdministrationShell
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'assetAdministrationShell'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'assetAdministrationShell'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AssetAdministrationShell
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'assetAdministrationShell'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_submodels_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'assetAdministrationShell'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AssetAdministrationShell
            )

            log = [
                tests.common.trace(
                    list(instance.over_submodels_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'assetAdministrationShell'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_submodels_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestAssetInformation(unittest.TestCase):
    def test_over_specific_asset_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'assetInformation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AssetInformation
            )

            log = [
                tests.common.trace(
                    list(instance.over_specific_asset_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'assetInformation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_specific_asset_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestSpecificAssetID(unittest.TestCase):
    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'specificAssetId'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SpecificAssetID
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'specificAssetId'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestSubmodel(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodel'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Submodel
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodel'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodel'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Submodel
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodel'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodel'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Submodel
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodel'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodel'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Submodel
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodel'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodel'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Submodel
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodel'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodel'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Submodel
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodel'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_submodel_elements_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodel'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Submodel
            )

            log = [
                tests.common.trace(
                    list(instance.over_submodel_elements_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodel'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_submodel_elements_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestRelationshipElement(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'relationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.RelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'relationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'relationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.RelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'relationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'relationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.RelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'relationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'relationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.RelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'relationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'relationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.RelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'relationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'relationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.RelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'relationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestSubmodelElementList(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementList'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementList
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementList'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementList'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementList
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementList'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementList'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementList
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementList'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementList'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementList
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementList'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementList'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementList
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementList'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementList'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementList
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementList'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_value_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementList'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementList
            )

            log = [
                tests.common.trace(
                    list(instance.over_value_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementList'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_value_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestSubmodelElementCollection(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementCollection'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementCollection
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementCollection'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementCollection'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementCollection
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementCollection'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementCollection'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementCollection
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementCollection'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementCollection'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementCollection
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementCollection'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementCollection'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementCollection
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementCollection'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementCollection'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementCollection
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementCollection'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_value_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'submodelElementCollection'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.SubmodelElementCollection
            )

            log = [
                tests.common.trace(
                    list(instance.over_value_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'submodelElementCollection'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_value_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestProperty(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'property'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Property
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'property'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'property'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Property
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'property'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'property'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Property
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'property'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'property'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Property
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'property'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'property'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Property
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'property'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'property'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Property
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'property'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestMultiLanguageProperty(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'multiLanguageProperty'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.MultiLanguageProperty
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'multiLanguageProperty'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'multiLanguageProperty'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.MultiLanguageProperty
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'multiLanguageProperty'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'multiLanguageProperty'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.MultiLanguageProperty
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'multiLanguageProperty'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'multiLanguageProperty'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.MultiLanguageProperty
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'multiLanguageProperty'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'multiLanguageProperty'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.MultiLanguageProperty
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'multiLanguageProperty'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'multiLanguageProperty'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.MultiLanguageProperty
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'multiLanguageProperty'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_value_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'multiLanguageProperty'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.MultiLanguageProperty
            )

            log = [
                tests.common.trace(
                    list(instance.over_value_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'multiLanguageProperty'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_value_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestRange(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'range'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Range
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'range'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'range'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Range
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'range'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'range'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Range
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'range'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'range'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Range
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'range'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'range'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Range
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'range'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'range'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Range
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'range'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestReferenceElement(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'referenceElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ReferenceElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'referenceElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'referenceElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ReferenceElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'referenceElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'referenceElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ReferenceElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'referenceElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'referenceElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ReferenceElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'referenceElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'referenceElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ReferenceElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'referenceElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'referenceElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ReferenceElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'referenceElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestBlob(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'blob'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Blob
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'blob'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'blob'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Blob
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'blob'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'blob'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Blob
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'blob'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'blob'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Blob
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'blob'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'blob'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Blob
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'blob'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'blob'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Blob
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'blob'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestFile(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'file'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.File
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'file'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'file'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.File
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'file'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'file'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.File
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'file'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'file'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.File
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'file'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'file'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.File
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'file'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'file'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.File
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'file'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestAnnotatedRelationshipElement(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'annotatedRelationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AnnotatedRelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'annotatedRelationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'annotatedRelationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AnnotatedRelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'annotatedRelationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'annotatedRelationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AnnotatedRelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'annotatedRelationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'annotatedRelationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AnnotatedRelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'annotatedRelationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'annotatedRelationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AnnotatedRelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'annotatedRelationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'annotatedRelationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AnnotatedRelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'annotatedRelationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_annotations_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'annotatedRelationshipElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.AnnotatedRelationshipElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_annotations_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'annotatedRelationshipElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_annotations_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestEntity(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'entity'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Entity
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'entity'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'entity'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Entity
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'entity'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'entity'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Entity
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'entity'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'entity'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Entity
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'entity'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'entity'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Entity
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'entity'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'entity'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Entity
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'entity'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_statements_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'entity'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Entity
            )

            log = [
                tests.common.trace(
                    list(instance.over_statements_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'entity'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_statements_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_specific_asset_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'entity'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Entity
            )

            log = [
                tests.common.trace(
                    list(instance.over_specific_asset_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'entity'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_specific_asset_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestBasicEventElement(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'basicEventElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.BasicEventElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'basicEventElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'basicEventElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.BasicEventElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'basicEventElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'basicEventElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.BasicEventElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'basicEventElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'basicEventElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.BasicEventElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'basicEventElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'basicEventElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.BasicEventElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'basicEventElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'basicEventElement'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.BasicEventElement
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'basicEventElement'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestOperation(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_input_variables_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_input_variables_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_input_variables_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_output_variables_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_output_variables_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_output_variables_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_inoutput_variables_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'operation'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Operation
            )

            log = [
                tests.common.trace(
                    list(instance.over_inoutput_variables_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'operation'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_inoutput_variables_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestCapability(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'capability'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Capability
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'capability'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'capability'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Capability
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'capability'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'capability'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Capability
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'capability'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_supplemental_semantic_ids_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'capability'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Capability
            )

            log = [
                tests.common.trace(
                    list(instance.over_supplemental_semantic_ids_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'capability'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_supplemental_semantic_ids_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_qualifiers_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'capability'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Capability
            )

            log = [
                tests.common.trace(
                    list(instance.over_qualifiers_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'capability'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_qualifiers_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'capability'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Capability
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'capability'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestConceptDescription(unittest.TestCase):
    def test_over_extensions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'conceptDescription'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ConceptDescription
            )

            log = [
                tests.common.trace(
                    list(instance.over_extensions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'conceptDescription'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_extensions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_display_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'conceptDescription'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ConceptDescription
            )

            log = [
                tests.common.trace(
                    list(instance.over_display_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'conceptDescription'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_display_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_description_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'conceptDescription'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ConceptDescription
            )

            log = [
                tests.common.trace(
                    list(instance.over_description_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'conceptDescription'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_description_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_embedded_data_specifications_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'conceptDescription'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ConceptDescription
            )

            log = [
                tests.common.trace(
                    list(instance.over_embedded_data_specifications_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'conceptDescription'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_embedded_data_specifications_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_is_case_of_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'conceptDescription'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.ConceptDescription
            )

            log = [
                tests.common.trace(
                    list(instance.over_is_case_of_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'conceptDescription'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_is_case_of_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestEnvironment(unittest.TestCase):
    def test_over_asset_administration_shells_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'environment'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Environment
            )

            log = [
                tests.common.trace(
                    list(instance.over_asset_administration_shells_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'environment'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_asset_administration_shells_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_submodels_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'environment'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Environment
            )

            log = [
                tests.common.trace(
                    list(instance.over_submodels_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'environment'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_submodels_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_concept_descriptions_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'environment'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.Environment
            )

            log = [
                tests.common.trace(
                    list(instance.over_concept_descriptions_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'environment'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_concept_descriptions_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


class TestDataSpecificationIEC61360(unittest.TestCase):
    def test_over_short_name_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'dataSpecificationIec61360'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.DataSpecificationIEC61360
            )

            log = [
                tests.common.trace(
                    list(instance.over_short_name_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'dataSpecificationIec61360'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_short_name_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)

    def test_over_definition_or_empty_against_recorded(self) -> None:
        for minimal_or_maximal in ["minimal", "maximal"]:
            instance = tests.common_xmlization.must_load(
                pathlib.Path(
                    tests.common.TEST_DATA_DIR
                    / "Xml"
                    / "Expected"
                    / 'dataSpecificationIec61360'
                    / f"{minimal_or_maximal}.xml"
                )
            )

            assert isinstance(
                instance,
                aas_types.DataSpecificationIEC61360
            )

            log = [
                tests.common.trace(
                    list(instance.over_definition_or_empty())
                )
            ]

            got_text = tests.common.trace_log_as_text_file_content(log)

            expected_path = pathlib.Path(
                tests.common.TEST_DATA_DIR
                / "test_over_X_or_empty"
                / 'dataSpecificationIec61360'
                / f"on_{minimal_or_maximal}.xml"
                / 'over_definition_or_empty.trace'
            )

            tests.common.record_or_check(expected_path, got_text)


if __name__ == "__main__":
    unittest.main()


# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.
