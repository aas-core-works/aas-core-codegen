#ifndef AAS_CORE_AAS_3_0_TYPES_GUARD_
#define AAS_CORE_AAS_3_0_TYPES_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"

#pragma warning(push, 0)
#include <cstddef>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup types Define data structures corresponding to the meta-model.
 * @{
 */
namespace types {

// region Enumerations

/**
 * Enumerate the model types for faster type switches.
 *
 * For example, switch statements can be implemented as jump tables.
 */
enum class ModelType : std::uint32_t {
  kMyClass = 0,
  kListOfPrimitives = 1
};

// endregion Enumerations

// region Forward declaration of interfaces

// endregion Forward declaration of interfaces

class IMyClass;

class IListOfPrimitives;

// region Class interfaces

/**
 * Model the most general instance of the model.
 */
class IClass {
 public:
  /**
   * Indicate the runtime model type.
   */
  virtual ModelType model_type() const = 0;
  virtual ~IClass() = default;
};

class IMyClass
    : virtual public IClass {
 public:
  virtual ~IMyClass() = default;
};

class IListOfPrimitives
    : virtual public IClass {
 public:
  virtual const std::vector<std::wstring>& strings() const = 0;

  virtual std::vector<std::wstring>& mutable_strings() = 0;

  virtual void set_strings(
    std::vector<std::wstring> value
  ) = 0;

  virtual const std::vector<int64_t>& integers() const = 0;

  virtual std::vector<int64_t>& mutable_integers() = 0;

  virtual void set_integers(
    std::vector<int64_t> value
  ) = 0;

  virtual const std::vector<bool>& booleans() const = 0;

  virtual std::vector<bool>& mutable_booleans() = 0;

  virtual void set_booleans(
    std::vector<bool> value
  ) = 0;

  virtual const std::vector<
    std::shared_ptr<IMyClass>
  >& classes() const = 0;

  virtual std::vector<
    std::shared_ptr<IMyClass>
  >& mutable_classes() = 0;

  virtual void set_classes(
    std::vector<
      std::shared_ptr<IMyClass>
    > value
  ) = 0;

  virtual ~IListOfPrimitives() = default;
};

// endregion

// region Definitions of concrete classes

class MyClass
    : public IMyClass {
 public:
  MyClass() {}

  ModelType model_type() const override;

  ~MyClass() override = default;
};

class ListOfPrimitives
    : public IListOfPrimitives {
 public:
  ListOfPrimitives(
    std::vector<std::wstring> strings,
    std::vector<int64_t> integers,
    std::vector<bool> booleans,
    std::vector<
      std::shared_ptr<IMyClass>
    > classes
  );

  ModelType model_type() const override;

  // region Get and set strings_

  const std::vector<std::wstring>& strings() const override;

  std::vector<std::wstring>& mutable_strings() override;

  void set_strings(
    std::vector<std::wstring> value
  ) override;

  // endregion

  // region Get and set integers_

  const std::vector<int64_t>& integers() const override;

  std::vector<int64_t>& mutable_integers() override;

  void set_integers(
    std::vector<int64_t> value
  ) override;

  // endregion

  // region Get and set booleans_

  const std::vector<bool>& booleans() const override;

  std::vector<bool>& mutable_booleans() override;

  void set_booleans(
    std::vector<bool> value
  ) override;

  // endregion

  // region Get and set classes_

  const std::vector<
    std::shared_ptr<IMyClass>
  >& classes() const override;

  std::vector<
    std::shared_ptr<IMyClass>
  >& mutable_classes() override;

  void set_classes(
    std::vector<
      std::shared_ptr<IMyClass>
    > value
  ) override;

  // endregion

  ~ListOfPrimitives() override = default;

 private:
  std::vector<std::wstring> strings_;

  std::vector<int64_t> integers_;

  std::vector<bool> booleans_;

  std::vector<
    std::shared_ptr<IMyClass>
  > classes_;
};

// endregion

// region Is-a functions

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IMyClass.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IMyClass
 */
bool IsMyClass(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IListOfPrimitives.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IListOfPrimitives
 */
bool IsListOfPrimitives(
  const IClass& that
);

// endregion Is-a functions

}  // namespace types
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_TYPES_GUARD_
