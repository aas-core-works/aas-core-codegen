// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/constants.hpp"
#include "aas_core/aas_3_0/pattern.hpp"
#include "aas_core/aas_3_0/revm.hpp"
#include "aas_core/aas_3_0/verification.hpp"

#pragma warning(push, 0)
#include <map>
#include <set>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {
namespace verification {

// region struct Error

Error::Error(
  std::wstring a_cause
) :
  cause(std::move(a_cause)) {
  // Intentionally empty.
}

Error::Error(
  std::wstring a_cause,
  iteration::Path a_path
) :
  cause(std::move(a_cause)),
  path(std::move(a_path)) {
  // Intentionally empty.
}

// endregion struct Error

// region class AlwaysDoneVerificator

class AlwaysDoneVerificator : public impl::IVerificator {
 public:
  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;
  std::unique_ptr<impl::IVerificator> Clone() const override;

  virtual ~AlwaysDoneVerificator() = default;
};  // class AlwaysDoneVerificator

void AlwaysDoneVerificator::Start() {
  // Intentionally empty.
}

void AlwaysDoneVerificator::Next() {
  throw std::logic_error(
    "You want to move an AlwaysDoneVerificator, "
    "but the verificator is always done, as its name suggests."
  );
}

bool AlwaysDoneVerificator::Done() const {
  return true;
}

const Error& AlwaysDoneVerificator::Get() const {
    throw std::logic_error(
      "You want to get from an AlwaysDoneVerificator, "
      "but the verificator is always done, as its name suggests."
    );
}

Error& AlwaysDoneVerificator::GetMutable() {
    throw std::logic_error(
      "You want to get mutable from an AlwaysDoneVerificator, "
      "but the verificator is always done, as its name suggests."
    );
}

long AlwaysDoneVerificator::Index() const {
  return -1;
}

std::unique_ptr<impl::IVerificator> AlwaysDoneVerificator::Clone() const {
  return common::make_unique<AlwaysDoneVerificator>(*this);
}

// endregion class AlwaysDoneVerificator

/**
 * Produce a non-recursive verificator of the instance given its runtime model type.
 */
std::unique_ptr<impl::IVerificator> NewNonRecursiveVerificator(
  const std::shared_ptr<types::IClass>& instance
);

// region Non-recursive verificators

namespace non_recursive_verificator {

class OfMyClass : public impl::IVerificator {
 public:
  OfMyClass(
    const std::shared_ptr<types::IClass>& instance
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfMyClass() override = default;
};  // class OfMyClass

OfMyClass::OfMyClass(
  const std::shared_ptr<types::IClass>&
) {
  // Intentionally empty.
}

void OfMyClass::Start() {
  // Intentionally empty.
}

void OfMyClass::Next() {
  throw std::logic_error(
    "You want to move "
    "a verificator OfMyClass, "
    "but the verificator is always done as "
    "IMyClass "
    "has no invariants defined."
  );
}

bool OfMyClass::Done() const {
  return true;
}

const Error& OfMyClass::Get() const {
  throw std::logic_error(
    "You want to get from "
    "a verificator OfMyClass, "
    "but the verificator is always done as "
    "IMyClass "
    "has no invariants defined."
  );
}

Error& OfMyClass::GetMutable() {
  throw std::logic_error(
    "You want to get mutable from "
    "a verificator OfMyClass, "
    "but the verificator is always done as "
    "IMyClass "
    "has no invariants defined."
  );
}

long OfMyClass::Index() const {
  return -1;
}

std::unique_ptr<impl::IVerificator> OfMyClass::Clone() const {
  return common::make_unique<
    OfMyClass
  >(*this);
}

class OfListOfPrimitives : public impl::IVerificator {
 public:
  OfListOfPrimitives(
    const std::shared_ptr<types::IClass>& instance
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfListOfPrimitives() override = default;
};  // class OfListOfPrimitives

OfListOfPrimitives::OfListOfPrimitives(
  const std::shared_ptr<types::IClass>&
) {
  // Intentionally empty.
}

void OfListOfPrimitives::Start() {
  // Intentionally empty.
}

void OfListOfPrimitives::Next() {
  throw std::logic_error(
    "You want to move "
    "a verificator OfListOfPrimitives, "
    "but the verificator is always done as "
    "IListOfPrimitives "
    "has no invariants defined."
  );
}

bool OfListOfPrimitives::Done() const {
  return true;
}

const Error& OfListOfPrimitives::Get() const {
  throw std::logic_error(
    "You want to get from "
    "a verificator OfListOfPrimitives, "
    "but the verificator is always done as "
    "IListOfPrimitives "
    "has no invariants defined."
  );
}

Error& OfListOfPrimitives::GetMutable() {
  throw std::logic_error(
    "You want to get mutable from "
    "a verificator OfListOfPrimitives, "
    "but the verificator is always done as "
    "IListOfPrimitives "
    "has no invariants defined."
  );
}

long OfListOfPrimitives::Index() const {
  return -1;
}

std::unique_ptr<impl::IVerificator> OfListOfPrimitives::Clone() const {
  return common::make_unique<
    OfListOfPrimitives
  >(*this);
}

}  // namespace non_recursive_verificator

std::unique_ptr<impl::IVerificator> NewNonRecursiveVerificator(
  const std::shared_ptr<types::IClass>& instance
) {
  switch (instance->model_type()) {
    case types::ModelType::kMyClass:
      return common::make_unique<
        non_recursive_verificator::OfMyClass
      >(
        instance
      );
    case types::ModelType::kListOfPrimitives:
      return common::make_unique<
        non_recursive_verificator::OfListOfPrimitives
      >(
        instance
      );
    default:
      throw std::logic_error(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(instance->model_type())
          )
        )
      );
  }
}

// endregion Non-recursive verificators

// region Recursive verificators

class RecursiveVerificator : public impl::IVerificator {
 public:
  RecursiveVerificator(
    const std::shared_ptr<types::IClass>& instance
  );

  RecursiveVerificator(const RecursiveVerificator& other);
  RecursiveVerificator(RecursiveVerificator&& other);
  RecursiveVerificator& operator=(const RecursiveVerificator& other);
  RecursiveVerificator& operator=(RecursiveVerificator&& other);

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~RecursiveVerificator() override = default;

 private:
  // NOTE(mristin):
  // We use a pointer to a shared pointer here so that we can implement
  // copy-assignment and move-assignment. Otherwise, if we used a constant
  // reference here, the assignments could not be implemented as C++ does not
  // allow re-binding of constant references.
  const std::shared_ptr<types::IClass>* instance_;

  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> verificator_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  common::optional<iteration::Iterator> iterator_;
  common::optional<iteration::Iterator> iterator_end_;

  void Execute();
};  // class RecursiveVerificator

RecursiveVerificator::RecursiveVerificator(
  const std::shared_ptr<types::IClass>& instance
) : instance_(&instance) {
  // Intentionally empty.
}

RecursiveVerificator::RecursiveVerificator(const RecursiveVerificator& other) {
  instance_ = other.instance_;
  state_ = other.state_;
  verificator_ = other.verificator_->Clone();
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*(other.error_));
  iterator_ = other.iterator_;
  iterator_end_ = other.iterator_end_;
}

RecursiveVerificator::RecursiveVerificator(RecursiveVerificator&& other) {
  instance_ = other.instance_;
  state_ = other.state_;
  verificator_ = std::move(other.verificator_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  iterator_ = std::move(other.iterator_);
  iterator_end_ = std::move(other.iterator_end_);
}

RecursiveVerificator& RecursiveVerificator::operator=(
  const RecursiveVerificator& other
) {
  return *this = RecursiveVerificator(other);
}

RecursiveVerificator& RecursiveVerificator::operator=(RecursiveVerificator&& other) {
  if (this != &other) {
    instance_ = other.instance_;
    state_ = other.state_;
    verificator_ = std::move(other.verificator_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    iterator_ = std::move(other.iterator_);
    iterator_end_ = std::move(other.iterator_end_);
  }

  return *this;
}

void RecursiveVerificator::Start() {
  state_ = 0;
  Execute();
}

void RecursiveVerificator::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a RecursiveVerificator, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool RecursiveVerificator::Done() const {
  return done_;
}

const Error& RecursiveVerificator::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a RecursiveVerificator, "
      "but the verificator is done."
    );
  }
  #endif

  return *error_;
}

Error& RecursiveVerificator::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a RecursiveVerificator, "
      "but the verificator is done."
    );
  }
  #endif

  return *error_;
}

long RecursiveVerificator::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done RecursiveVerificator, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> RecursiveVerificator::Clone() const {
  return common::make_unique<RecursiveVerificator>(*this);
}

void RecursiveVerificator::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        error_ = nullptr;
        index_ = -1;
        done_ = false;

        verificator_ = NewNonRecursiveVerificator(*instance_);
        verificator_->Start();
      }

      case 1: {
        if (!(!verificator_->Done())) {
          state_ = 3;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            verificator_->GetMutable()
          )
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        verificator_->Next();

        state_ = 1;
        continue;
      }

      case 3: {
        verificator_ = nullptr;

        {
          // NOTE (mristin):
          // We will not need descent, so we introduce it in the scope.
          iteration::Descent descent(
            *instance_
          );
          iterator_ = std::move(descent.begin());

          // NOTE (mristin):
          // descent.end() is a constant reference, so we make an explicit
          // copy here.
          iterator_end_ = descent.end();
        }
      }

      case 4: {
        if (!(*iterator_ != *iterator_end_)) {
          state_ = 8;
          continue;
        }

        verificator_ = NewNonRecursiveVerificator(
          *(*iterator_)
        );
        verificator_->Start();
      }

      case 5: {
        if (!(!verificator_->Done())) {
          state_ = 7;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            verificator_->GetMutable()
          )
        );

        error_->path = std::move(
          iteration::MaterializePath(
            *iterator_
          )
        );

        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        verificator_->Next();

        state_ = 5;
        continue;
      }

      case 7: {
        verificator_ = nullptr;

        ++(*iterator_);

        state_ = 4;
        continue;
      }

      case 8: {
        iterator_.reset();
        iterator_end_.reset();
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 9;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion Recursive verificators

// region NonRecursiveVerification

NonRecursiveVerification::NonRecursiveVerification(
  const std::shared_ptr<types::IClass>& instance
) : instance_(instance) {
  // Intentionally empty.
}

Iterator NonRecursiveVerification::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    NewNonRecursiveVerificator(instance_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& NonRecursiveVerification::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion NonRecursiveVerification

// region RecursiveVerification

RecursiveVerification::RecursiveVerification(
  const std::shared_ptr<types::IClass>& instance
) : instance_(instance) {
  // Intentionally empty.
}

Iterator RecursiveVerification::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<RecursiveVerificator>(instance_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& RecursiveVerification::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion RecursiveVerification

// region struct Iterator

Iterator::Iterator(
  const Iterator& other
) :
  verificator_(other.verificator_->Clone()) {
  // Intentionally empty.
}

Iterator::Iterator(
  Iterator&& other
) :
  verificator_(std::move(other.verificator_)) {
  // Intentionally empty.
}

Iterator& Iterator::operator=(const Iterator& other) {
  return *this = Iterator(other);
}

Iterator& Iterator::operator=(Iterator&& other) {
  if (this != &other) {
    verificator_ = std::move(other.verificator_);
  }

  return *this;
}

const Error& Iterator::operator*() const {
  if (verificator_->Done()) {
    throw std::logic_error(
      "You want to de-reference from a completed iterator "
      "over verification errors."
    );
  }

  return verificator_->Get();
}

const Error* Iterator::operator->() const {
  if (verificator_->Done()) {
    throw std::logic_error(
      "You want to de-reference from a completed iterator "
      "over verification errors."
    );
  }

  return &(verificator_->Get());
}

// Prefix increment
Iterator& Iterator::operator++() {
  if (verificator_->Done()) {
    throw std::logic_error(
      "You want to move a completed iterator "
      "over verification errors."
    );
  }

  verificator_->Next();
  return *this;
}

// Postfix increment
Iterator Iterator::operator++(int) {
  Iterator result(*this);
  ++(*this);
  return result;
}

bool operator==(const Iterator& a, const Iterator& b) {
  return a.verificator_->Index() == b.verificator_->Index();
}

bool operator!=(const Iterator& a, const Iterator& b) {
  return a.verificator_->Index() != b.verificator_->Index();
}

// endregion struct Iterator

}  // namespace verification
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
