// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/stringification.hpp"

#pragma warning(push, 0)
#include <unordered_map>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {
namespace stringification {

const std::unordered_map<
  std::string,
  types::ModelType
> kModelTypeFromStringMap = {
  {
    "MyClass",
    types::ModelType::kMyClass
  },
  {
    "ListOfPrimitives",
    types::ModelType::kListOfPrimitives
  }
};

common::optional<types::ModelType> ModelTypeFromString(
  const std::string& text
) {
  const auto it = kModelTypeFromStringMap.find(
    text
  );
  if (it == kModelTypeFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::ModelType MustModelTypeFromString(
  const std::string& text
) {
  const auto it = kModelTypeFromStringMap.find(
    text
  );
  if (it == kModelTypeFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected ModelType literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::ModelType model_type
) {
  switch (model_type) {
    case types::ModelType::kMyClass:
    return "MyClass";
    case types::ModelType::kListOfPrimitives:
    return "ListOfPrimitives";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              model_type
            )
          )
        )
      );
  }
}

// The following encoder has been adapted from Jouni Malinen <j@w1.fi> to work with
// std::string. The original source code is available at:
// https://web.mit.edu/freebsd/head/contrib/wpa/src/utils/base64.c
//
// See also the following StackOverflow question for a benchmark:
// https://stackoverflow.com/questions/342409/how-do-i-base64-encode-decode-in-c/41094722#41094722

constexpr std::size_t kCharBase64TableLen = 65;
static const unsigned char kCharBase64Table[kCharBase64TableLen](
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
);

std::string Base64Encode(
  const std::vector<std::uint8_t>& bytes
) {
  // See: https://cplusplus.com/reference/vector/vector/data/.
  // The data is guaranteed to be a continuous block in memory.
  const unsigned char* const src(
    bytes.data()
  );

  const std::size_t len = bytes.size();

  // 3-byte blocks to 4-byte
  const std::size_t olen = 4 * ((len + 2) / 3);

  // Integer overflow?
  if (olen < len) {
    throw std::invalid_argument(
      common::Concat(
        "The calculation of the output length overflowed. "
        "The length was: ",
        std::to_string(len),
        ", but the output length was calculated as: ",
        std::to_string(olen)
      )
    );
  }

  std::string out_string;
  out_string.resize(olen);

  unsigned char* out(
    reinterpret_cast<unsigned char*>(
      &out_string[0]
    )
  );

  const unsigned char* const end = src + len;

  const unsigned char* in = src;
  unsigned char* pos = out;

  while (end - in >= 3) {
    *pos++ = kCharBase64Table[in[0] >> 2];
    *pos++ = kCharBase64Table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
    *pos++ = kCharBase64Table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
    *pos++ = kCharBase64Table[in[2] & 0x3f];
    in += 3;
  }

  if (end - in) {
    *pos++ = kCharBase64Table[in[0] >> 2];

    if (end - in == 1) {
      *pos++ = kCharBase64Table[(in[0] & 0x03) << 4];
      *pos++ = '=';
    } else {
      *pos++ = kCharBase64Table[
        ((in[0] & 0x03) << 4) | (in[1] >> 4)
      ];
      *pos++ = kCharBase64Table[(in[1] & 0x0f) << 2];
    }
    *pos++ = '=';
  }

  return out_string;
}

// The following decoder is vaguely based on:
// https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js,
// https://github.com/niklasvh/base64-arraybuffer/blob/master/src/index.ts and
// https://github.com/beatgammit/base64-js/blob/master/index.js.

std::vector<std::uint8_t> ConstructBase64Lookup() {
  std::vector<std::uint8_t> lookup(256, 255);
  for (std::uint8_t i = 0; i < kCharBase64TableLen; ++i) {
    lookup.at(kCharBase64Table[i]) = i;
  }
  return lookup;
}
const std::vector<std::uint8_t> kBase64Lookup = ConstructBase64Lookup();

common::expected<
  std::vector<std::uint8_t>,
  std::string
> Base64Decode(
  const std::string& text
) {
  if (text.empty()) {
    return std::vector<std::uint8_t>();
  }

  const std::size_t len = text.size();
  std::size_t len_wo_pad = len;

  // NOTE (mristin):
  // Some implementations forget the padding, so we try to be robust and check
  // for the padding manually.
  std::size_t bytes_length = (len * 3) / 4;
  if (text[len - 1] == '=') {
    bytes_length--;
    len_wo_pad--;

    if (text[len - 2] == '=') {
      bytes_length--;
      len_wo_pad--;
    }
  }

  std::vector<std::uint8_t> bytes(bytes_length);

  const std::size_t base64_lookup_len = kBase64Lookup.size();

  std::size_t pointer = 0;

  for (std::size_t i = 0; i < len; i += 4) {
    // NOTE (mristin):
    // Admittedly, this is very verbose code, but we want to be efficient, so we
    // opted for performance over readability here.

    const unsigned char code0 = text[i];
    if (code0 >= base64_lookup_len) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i),
        ": ",
        std::to_string(code0),
        " (code: ",
        std::to_string(static_cast<int>(code0)),
        ")"
      );

      return common::make_unexpected(message);
    }
    const std::uint8_t encoded0 = kBase64Lookup[code0];
    if (encoded0 == 255) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i),
        ": ",
        std::to_string(code0),
        " (code: ",
        std::to_string(static_cast<int>(code0)),
        ")"
      );

      return common::make_unexpected(message);
    }

    const unsigned char code1 = text[i + 1];
    if (code1 >= base64_lookup_len) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 1),
        ": ",
        std::to_string(code1),
        " (code: ",
        std::to_string(static_cast<int>(code1)),
        ")"
      );

      return common::make_unexpected(message);
    }
    const std::uint8_t encoded1 = kBase64Lookup[code1];
    if (encoded1 == 255) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 1),
        ": ",
        std::to_string(code1),
        " (code: ",
        std::to_string(static_cast<int>(code1)),
        ")"
      );

      return common::make_unexpected(message);
    }

    // We map padding to 65, which is the value of "A".
    const unsigned char code2 = i + 2 < len_wo_pad ? text[i + 2] : 65;
    if (code2 >= base64_lookup_len) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 2),
        ": ",
        std::to_string(code2),
        " (code: ",
        std::to_string(static_cast<int>(code2)),
        ")"
      );

      return common::make_unexpected(message);
    }
    const std::uint8_t encoded2 = kBase64Lookup[code2];
    if (encoded2 == 255) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 2),
        ": ",
        std::to_string(code2),
        " (code: ",
        std::to_string(static_cast<int>(code2)),
        ")"
      );

      return common::make_unexpected(message);
    }

    // We map padding to 65, which is the value of 'A'.
    const unsigned char code3 = i + 3 < len_wo_pad ? text[i + 3] : 65;
    if (code3 >= base64_lookup_len) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 3),
        ": ",
        std::to_string(code3),
        " (code: ",
        std::to_string(static_cast<int>(code3)),
        ")"
      );

      return common::make_unexpected(message);
    }
    const std::uint8_t encoded3 = kBase64Lookup[code3];
    if (encoded3 == 255) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 3),
        ": ",
        std::to_string(code3),
        " (code: ",
        std::to_string(static_cast<int>(code3)),
        ")"
      );

      return common::make_unexpected(message);
    }

    if (pointer >= bytes_length) {
      break;
    }
    bytes[pointer] = (encoded0 << 2) | (encoded1 >> 4);
    pointer++;

    if (pointer >= bytes_length) {
      break;
    }
    bytes[pointer] = ((encoded1 & 15) << 4) | (encoded2 >> 2);
    pointer++;

    if (pointer >= bytes_length) {
      break;
    }
    bytes[pointer] = ((encoded2 & 3) << 6) | (encoded3 & 63);
    pointer++;
  }

  return bytes;
}

}  // namespace stringification
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
