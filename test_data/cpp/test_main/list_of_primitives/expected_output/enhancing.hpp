#ifndef AAS_CORE_AAS_3_0_ENHANCING_GUARD_
#define AAS_CORE_AAS_3_0_ENHANCING_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/stringification.hpp"
#include "aas_core/aas_3_0/types.hpp"

#pragma warning(push, 0)
#include <sstream>
#include <stdexcept>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup enhancing Enhance instances of the model with your custom enhancements.
 * @{
 */
namespace enhancing {

// region Forward declarations

template <typename E>
std::shared_ptr<
  types::IMyClass
> Wrap(
  const std::shared_ptr<
    types::IMyClass
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IListOfPrimitives
> Wrap(
  const std::shared_ptr<
    types::IListOfPrimitives
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

// endregion Forward declarations

/// \cond HIDDEN
namespace impl {

template<typename E>
class IEnhanced {
 public:
  virtual const std::shared_ptr<E>& enhancement() const = 0;

  virtual std::shared_ptr<E>& mutable_enhancement() = 0;

  virtual void set_enhancement(
    std::shared_ptr<E> value
  ) = 0;

  virtual ~IEnhanced() = default;
};

template<class E>
class EnhancedMyClass
    : virtual public types::IMyClass,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kMyClass;
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedMyClass(
    std::shared_ptr<types::IMyClass> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedMyClass() = default;

 private:
  std::shared_ptr<types::IMyClass> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedListOfPrimitives
    : virtual public types::IListOfPrimitives,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kListOfPrimitives;
  }

  const std::vector<std::wstring>& strings() const override {
    return instance_->strings();
  }

  std::vector<std::wstring>& mutable_strings() override {
    return instance_->mutable_strings();
  }

  void set_strings(
    std::vector<std::wstring> value
  ) override {
    instance_->set_strings(value);
  }

  const std::vector<int64_t>& integers() const override {
    return instance_->integers();
  }

  std::vector<int64_t>& mutable_integers() override {
    return instance_->mutable_integers();
  }

  void set_integers(
    std::vector<int64_t> value
  ) override {
    instance_->set_integers(value);
  }

  const std::vector<bool>& booleans() const override {
    return instance_->booleans();
  }

  std::vector<bool>& mutable_booleans() override {
    return instance_->mutable_booleans();
  }

  void set_booleans(
    std::vector<bool> value
  ) override {
    instance_->set_booleans(value);
  }

  const std::vector<
    std::shared_ptr<types::IMyClass>
  >& classes() const override {
    return instance_->classes();
  }

  std::vector<
    std::shared_ptr<types::IMyClass>
  >& mutable_classes() override {
    return instance_->mutable_classes();
  }

  void set_classes(
    std::vector<
      std::shared_ptr<types::IMyClass>
    > value
  ) override {
    instance_->set_classes(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedListOfPrimitives(
    std::shared_ptr<types::IListOfPrimitives> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedListOfPrimitives() = default;

 private:
  std::shared_ptr<types::IListOfPrimitives> instance_;
  std::shared_ptr<E> enhancement_;
};

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IMyClass> WrapMyClass(
  const std::shared_ptr<types::IMyClass>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IMyClass>(
      new EnhancedMyClass<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IListOfPrimitives> WrapListOfPrimitives(
  const std::shared_ptr<types::IListOfPrimitives>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  {
    const std::vector<std::wstring>& value(
      that->strings()
    );
    const std::size_t size = value.size();

    std::vector<std::wstring> wrapped;
    wrapped.reserve(size);

    for (
      const std::wstring& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_strings(
      std::move(wrapped)
    );
  }

  {
    const std::vector<int64_t>& value(
      that->integers()
    );
    const std::size_t size = value.size();

    std::vector<int64_t> wrapped;
    wrapped.reserve(size);

    for (
      int64_t item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_integers(
      std::move(wrapped)
    );
  }

  {
    const std::vector<bool>& value(
      that->booleans()
    );
    const std::size_t size = value.size();

    std::vector<bool> wrapped;
    wrapped.reserve(size);

    for (
      bool item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_booleans(
      std::move(wrapped)
    );
  }

  {
    const std::vector<
      std::shared_ptr<types::IMyClass>
    >& value(
      that->classes()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IMyClass>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IMyClass>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_classes(
      std::move(wrapped)
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IListOfPrimitives>(
      new EnhancedListOfPrimitives<E>(
        that,
        enh
      )
    );
}

/**
 * Assert that the \p that instance has not been already enhanced.
 *
 * \param that instance to be checked
 * \tparam E type of the enhancement
 * \tparam T interface type of \p that instance
 * \throw std::logic_error if \p that already enhanced
 */
template<
  typename E,
  typename T,
  typename std::enable_if<
    std::is_base_of<types::IClass, T>::value
  >::type* = nullptr
>
void AssertNotEnhanced(
  const std::shared_ptr<T>& that
) {
  std::shared_ptr<impl::IEnhanced<E> > enhanced(
    std::dynamic_pointer_cast<
      impl::IEnhanced<E>
    >(that)
  );
  if (enhanced != nullptr) {
    throw std::logic_error(
      common::Concat(
        "An instance of ",
        stringification::to_string(that->model_type()),
        " has been already wrapped."
      )
    );
  }
}

}  // namespace impl
/// \endcond

/**
 * Wrap \p that instance recursively with the enhancement produced by the \p factory.
 *
 * The factory decides itself whether it will produce an enhancement for
 * \p that instance, or not. Even if no enhancement has been produced for \p that
 * instance, we will still continue to enhance the instances referenced
 * by \p that instance recursively.
 *
 * \param that instance to wrap
 * \param factory to selectively produce an enhancement
 * \return enhanced \p that instance
 * \throw std::logic_error if \p that instance has been already wrapped.
 * \tparam E type of the enhancement
 */
///@{

template <typename E>
std::shared_ptr<
  types::IClass
> Wrap(
  const std::shared_ptr<
    types::IClass
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IClass
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kMyClass:
      return impl::WrapMyClass<E>(
        std::dynamic_pointer_cast<
          types::IMyClass
        >(that),
        factory
      );
      break;
    case types::ModelType::kListOfPrimitives:
      return impl::WrapListOfPrimitives<E>(
        std::dynamic_pointer_cast<
          types::IListOfPrimitives
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IMyClass
> Wrap(
  const std::shared_ptr<
    types::IMyClass
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IMyClass
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kMyClass:
      return impl::WrapMyClass<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IListOfPrimitives
> Wrap(
  const std::shared_ptr<
    types::IListOfPrimitives
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IListOfPrimitives
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kListOfPrimitives:
      return impl::WrapListOfPrimitives<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

///@}}

/**
 * Try to unwrap the enhancement from \p that instance.
 *
 * \param that instance possibly wrapped with an enhancement
 * \return the enhancement, or `nullptr` if \p that instance has not been wrapped
 * \tparam E type of the enhancement
 */
template <typename E>
std::shared_ptr<E> Unwrap(
  const std::shared_ptr<types::IClass>& that
) {
  const std::shared_ptr<impl::IEnhanced<E> >& maybe_enhanced(
    std::dynamic_pointer_cast<impl::IEnhanced<E> >(that)
  );

  if (!maybe_enhanced) {
    return nullptr;
  }

  return maybe_enhanced->enhancement();
}

/**
 * Unwrap the enhancement from \p that instance.
 *
 * \remark \p that instance must have been wrapped before.
 *
 * \param that instance expected to be wrapped with an enhancement
 * \return the enhancement
 * \throw std::invalid_argument if \p that instance has not been wrapped
 * \tparam E type of the enhancement
 */
template <typename E>
std::shared_ptr<E> MustUnwrap(
  const std::shared_ptr<types::IClass>& that
) {
  std::shared_ptr<E> enhancement(
    Unwrap<E>(that)
  );
  if (!enhancement) {
    throw std::invalid_argument(
      common::Concat(
        "Expected an instance of ",
        stringification::to_string(that->model_type()),
        " to have been already wrapped with an enhancement, "
        "but it has been not."
      )
    );
  }
  return enhancement;
}

}  // namespace enhancing
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_ENHANCING_GUARD_
