// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/stringification.hpp"
#include "aas_core/aas_3_0/wstringification.hpp"
#include "aas_core/aas_3_0/xmlization.hpp"

#pragma warning(push, 0)
#include <expat.h>

#include <cmath>
#include <cstdint>
#include <deque>
#include <memory>
#include <limits>
#include <unordered_map>
#include <string>
#include <vector>
#pragma warning(pop)

static_assert(
  !std::is_same<XML_Char, wchar_t>::value,
  "Expected Expat to be compiled with UTF-8 support, i.e., that character is "
  "stored as char internally, "
  "but Expat was compiled to store characters internally as UTF-16."
);

static_assert(
  std::is_same<XML_Char, char>::value,
  "Expected Expat to be compiled with UTF-8 support, i.e., that "
  "character is stored as char internally, "
  "but it was not."
);

namespace aas_core {
namespace aas_3_0 {
namespace xmlization {

const std::string kNamespace(  // NOLINT(cert-err58-cpp)
  "https://admin-shell.io/aas/3/0"
);

// region De-serialization

// region struct ElementSegment

ElementSegment::ElementSegment(
  std::wstring a_name
) :
  name(std::move(a_name)) {
  // Intentionally empty.
}

std::wstring ElementSegment::ToWstring() const {
  size_t out_len = 0;
  for (const wchar_t character : name) {
    switch (character) {
      // NOTE (mristin):
      // We use sizeof on *strings* instead of *wide strings* to get
      // the number of *characters*. Otherwise, if we used wide strings,
      // we would obtain the wrong number of characters with `sizeof`
      // as we would count bytes instead of characters, which differ
      // in wide strings due to encoding.

      case L'&': {
        out_len += sizeof("&amp;");
        break;
      }
      case L'/': {
        out_len += sizeof("&#47;");
        break;
      }
      case L'<': {
        out_len += sizeof("&lt;");
        break;
      }
      case L'>': {
        out_len += sizeof("&gt;");
        break;
      }
      case L'"': {
        out_len += sizeof("&quot;");
        break;
      }
      case L'\'': {
        out_len += sizeof("&apos;");
        break;
      }
      default:
        ++out_len;
        break;
    }
  }

  // NOTE (mristin):
  // We assume here that XML encoding is always *longer* than
  // the original text.
  if (out_len == name.size()) {
    return name;
  }

  std::wstring out;
  out.reserve(out_len);

  for (const wchar_t character : name) {
    switch (character) {
      case L'&':
        out.append(L"&amp;");
        break;
      case L'/':
        out.append(L"&#47;");
        break;
      case L'<':
      out.append(L"&lt;");
        break;
      case L'>':
        out.append(L"&gt;");
        break;
      case L'"':
        out.append(L"&quot;");
        break;
      case L'\'':
        out.append(L"&apos;");
        break;
      default:
        out.push_back(character);
        break;
    }
  }

  return out;
}

std::unique_ptr<ISegment> ElementSegment::Clone() const {
  return common::make_unique<ElementSegment>(*this);
}

// endregion struct ElementSegment

// region struct IndexSegment

IndexSegment::IndexSegment(
  size_t an_index
) :
  index(an_index) {
  // Intentionally empty.
}

std::wstring IndexSegment::ToWstring() const {
  return common::Concat(
    L"*[",
    std::to_wstring(index),
    L"]"
  );
}

std::unique_ptr<ISegment> IndexSegment::Clone() const {
  return common::make_unique<IndexSegment>(*this);
}

// endregion struct IndexSegment

// region struct Path

Path::Path() {
  // Intentionally empty.
}

Path::Path(const Path& other) {
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
}

Path::Path(Path&& other) {
  segments = std::move(other.segments);
}

Path& Path::operator=(const Path& other) {
  segments.clear();
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
  return *this;
}

Path& Path::operator=(Path&& other) {
  if (this != &other) {
    segments = std::move(other.segments);
  }
  return *this;
}

std::wstring Path::ToWstring() const {
  if (segments.empty()) {
    return L"";
  }

  std::vector<std::wstring> parts;
  parts.reserve(segments.size() * 2 - 1);

  auto it = segments.begin();

  parts.emplace_back((*it)->ToWstring());
  ++it;

  for (; it != segments.end(); ++it) {
    parts.emplace_back(L"/");
    parts.emplace_back((*it)->ToWstring());
  }

  size_t out_len = 0;
  for (const std::wstring& part : parts) {
    out_len += part.size();
  }

  std::wstring out;
  out.reserve(out_len);
  for (const std::wstring& part : parts) {
    out.append(part);
  }

  return out;
}

// region DeserializationError

DeserializationError::DeserializationError(
  std::wstring a_cause
) :
  cause(a_cause) {
  // Intentionally empty.
}

DeserializationError::DeserializationError(
  std::wstring a_cause,
  Path a_path
) :
  cause(a_cause),
  path(a_path) {
  // Intentionally empty.
}

// endregion DeserializationError

enum class NodeKind : std::uint32_t {
  // Nodes of the kind `Bof` represent the beginning-of-input, before any read.
  Bof = 0,
  Start = 1,
  Stop = 2,
  Text = 3,
  // Nodes of the kind `Eof` represent the end-of-input.
  Eof = 4,
  // Nodes of the kind `Error` represent low-level errors in the XML parsing.
  Error = 5
};  // enum class NodeKind

const std::unordered_map<
  NodeKind,
  std::string
> kNodeKindToHumanReadableString = {
  {NodeKind::Bof, "a beginning-of-input"},
  {NodeKind::Start, "a start element"},
  {NodeKind::Stop, "a stop element"},
  {NodeKind::Text, "a text"},
  {NodeKind::Eof, "an end-of-input"},
  {NodeKind::Error, "an error"},
};

const std::string& NodeKindToHumanReadableString(NodeKind kind) {
  auto it = kNodeKindToHumanReadableString.find(kind);
  if (it == kNodeKindToHumanReadableString.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected node kind: ",
        std::to_string(
          static_cast<std::uint32_t>(kind)
        )
      )
    );
  }

  return it->second;
}

// region Nodes

/**
 * Model a node in an XML document.
 */
class INode {
 public:
  /**
   * @return the kind of the node, used instead of much slower RTTI.
   */
  virtual NodeKind kind() const = 0;
  virtual ~INode() = default;
};  // class INode

/**
 * Model the beginning of the input, before anything was read.
 */
class BofNode : public INode {
 public:
  NodeKind kind() const override { return NodeKind::Bof; }

  ~BofNode() override = default;
}; // class StartNode

/**
 * Model a start of an XML element.
 */
class StartNode : public INode {
 public:
  explicit StartNode(
    std::string a_name
  ) :
    name(std::move(a_name)) {
    // Intentionally empty.
  }

  NodeKind kind() const override { return NodeKind::Start; }

  /**
   * Name of the start element, stripped of the expected XML namespace
   */
  const std::string name;

  ~StartNode() override = default;
};  // class StartNode

/**
 * Model a stop of an XML element.
 */
class StopNode : public INode {
 public:
  explicit StopNode(
    std::string a_name
  ) :
    name(std::move(a_name)) {
    // Intentionally empty.
  }

  NodeKind kind() const override { return NodeKind::Stop; }

  /**
   * Name of the stop element, stripped of the expected XML namespace
   */
  const std::string name;

  ~StopNode() override = default;
};  // class StopNode

/**
 * Model a text node.
 */
class TextNode : public INode {
 public:
  explicit TextNode(
    std::string a_text
  ) :
    text(std::move(a_text)) {
    // Intentionally empty.
  }

  NodeKind kind() const override { return NodeKind::Text; }

  /**
   * UTF-8 encoded XML text somewhere within an XML element
   */
  const std::string text;

  ~TextNode() override = default;
};  // class TextNode

/**
 * Model an end-of-input.
 */
class EofNode : public INode {
 public:
  NodeKind kind() const override { return NodeKind::Eof; }

  ~EofNode() override = default;
};  // class EofNode

/**
 * Model a low-level XML parsing error.
 */
class ErrorNode : public INode {
 public:
  ErrorNode(
    size_t a_line,
    size_t a_column,
    std::string a_cause
  ) :
    line(a_line),
    column(a_column),
    cause(std::move(a_cause)) {
    // Intentionally empty.
  }

  NodeKind kind() const override { return NodeKind::Error; }

  const size_t line;
  const size_t column;

  // Cause of the error as UTF-8 encoded string
  const std::string cause;

  ~ErrorNode() override = default;
};  // class ErrorNode

// endregion Nodes

// region Reading

// region class Reader

/**
 * Structure the data passed over to Expat XML reader.
 */
struct OurData {
  bool additional_attributes;
  size_t buffer_size;
  XML_Parser parser;

  std::deque<std::unique_ptr<INode> >& node_buffer;

  bool stopped = false;

  OurData(
    bool the_additional_attributes,
    size_t a_buffer_size,
    XML_Parser a_parser,
    std::deque<std::unique_ptr<INode> >& a_node_buffer
  ) :
    additional_attributes(the_additional_attributes),
    buffer_size(a_buffer_size), parser(a_parser),
    node_buffer(a_node_buffer) {
    // Intentionally empty.
  }
};  // struct OurData

/**
 * \brief Read XML in form of nodes, whereas text nodes are fragmented.
 *
 * We need a more abstract approach since the Expat library is too low-level
 * to parse complex models.
 *
 * Expat does not read the whole content of a text node in memory, but
 * we need to process the whole text during the XML de-serialization. Hence,
 * we keep on reading until we read the complete text. This has repercussions
 * on memory usage, as the the text will be held in three copies(one copy in
 * the Expat buffer, second copy in our internal buffer in which we
 * incrementally feed in the fragments, and the third copy is the final merged
 * text).
 */
class Reader {
 public:
  Reader(
    std::istream& is,
    const ReadingOptions& options
  );

  /**
   * Set up the reader for the XML parsing and read the first node.
   */
  void Initialize();

  /**
   * Read the next node in the document.
   */
  void Read();

  /**
   * @return the node which has been read last
   */
  const INode& node() const;

  /**
   * @return the node which has been read last moved out of this reader
   */
  std::unique_ptr<INode> moved_node();

  ~Reader();

 private:
  const bool additional_attributes_;
  const size_t buffer_size_;
  std::istream& is_;

  XML_Parser parser_;
  std::unique_ptr<OurData> our_data_;

  // Node buffer does not include the current node.
  std::deque<std::unique_ptr<INode>> node_buffer_;

  // Current node is never null.
  std::unique_ptr<INode> current_;

  // Set if the current node is end-of-input
  bool eof_;

  // Set if the current node is an error
  bool error_;

  void SetCurrentAndEofAndError(std::unique_ptr<INode> node);

  // Re-usable buffer to keep a chunk of the data read from the input
  std::vector<char> chunk_;
};  // class Reader

Reader::Reader(
  std::istream& is,
  const ReadingOptions& options
) :
  additional_attributes_(options.additional_attributes),
  buffer_size_(options.buffer_size),
  is_(is),
  parser_(nullptr),
  current_(common::make_unique<BofNode>()),
  eof_(false),
  error_(false) {
  // Intentionally empty.
}

const char kNamespaceSeparator = '|';

void XMLCALL OnStartElement(
  void* user_data,
  const char* name,
  const char* attributes[]
) {
  auto our_data = static_cast<OurData*>(user_data);

  // NOTE (mristin):
  // Since Expat continues parsing and adding nodes even if the parsing is
  // suspended (see the documentation of `XML_StopParser`), we have to ignore
  // any further events.
  if (our_data->stopped) {
    return;
  }

  const std::string name_str(name);

  size_t separator_i = name_str.find(kNamespaceSeparator);
  if (separator_i == std::string::npos || separator_i == 0) {
    std::string message = common::Concat(
      "The namespace is missing in the start element <",
      name_str,
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  if (name_str.compare(0, separator_i, kNamespace) != 0) {
    std::string message = common::Concat(
      "We expected the XML namespace ",
      kNamespace,
      ", but we got the namespace ",
      name_str.substr(0, separator_i),
      " in the start element <",
      name_str.substr(separator_i + 1),
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  if (
    attributes[0] != nullptr
    && !(our_data->additional_attributes)
  ) {
    std::string message = common::Concat(
      "Additional attributes are not allowed, "
      "but the attribute ",
      attributes[0],
      " was read in the start element <",
      name_str.substr(separator_i + 1),
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  our_data->node_buffer.emplace_back(
    common::make_unique<StartNode>(
      name_str.substr(separator_i + 1)
    )
  );
}

void XMLCALL OnStopElement(
  void* user_data,
  const char* name
) {
  auto* our_data = static_cast<OurData*>(user_data);

  // NOTE (mristin):
  // Since Expat continues parsing and adding nodes even if the parsing is
  // suspended (see the documentation of `XML_StopParser`), we have to ignore
  // any further events.
  if (our_data->stopped) {
    return;
  }

  const std::string name_str(name);

  size_t separator_i = name_str.find(kNamespaceSeparator);
  if (separator_i == std::string::npos || separator_i == 0) {
    std::string message = common::Concat(
      "The namespace is missing in the stop element </",
      name_str,
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  if (name_str.compare(0, separator_i, kNamespace) != 0) {
    std::string message = common::Concat(
      "We expected the XML namespace ",
      kNamespace,
      ", but we got the namespace ",
      name_str.substr(0, separator_i),
      " in the stop element </",
      name_str.substr(separator_i + 1),
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  our_data->node_buffer.emplace_back(
    common::make_unique<StopNode>(
      name_str.substr(separator_i + 1)
    )
  );
}

void XMLCALL OnText(
  void* user_data,
  const char* val,
  int len
) {
  auto our_data = static_cast<OurData*>(user_data);

  // NOTE (mristin):
  // Since Expat continues parsing and adding nodes even if the parsing is
  // suspended (see the documentation of `XML_StopParser`), we have to ignore
  // any further events.
  if (our_data->stopped) {
    return;
  }

  our_data->node_buffer.emplace_back(
    common::make_unique<TextNode>(
      std::string(val, len)
    )
  );
}

void Reader::Initialize() {
  // NOTE (mristin):
  // We set up the underlying parser here instead of the constructor
  // to avoid throwing exceptions in the constructor.

  if (parser_ != nullptr) {
    throw std::logic_error(
      "You are trying to re-initialize an initialized XML reader."
    );
  }

  if (
    buffer_size_
    > static_cast<size_t>(
      (std::numeric_limits<int>::max)()
    )
  ) {
    throw std::invalid_argument(
      common::Concat(
        "Expat library expects the buffer size as int, "
        "but the given buffer size ",
        std::to_string(buffer_size_),
        " does not fit in an int as it is larger than the maximum int ",
        std::to_string(std::numeric_limits<int>::max())
      )
    );
  }

  parser_ = XML_ParserCreateNS(nullptr, kNamespaceSeparator);
  our_data_ = common::make_unique<OurData>(
    additional_attributes_,
    buffer_size_,
    parser_,
    node_buffer_
  );

  XML_SetUserData(parser_, our_data_.get());
  XML_SetElementHandler(
    parser_,
    OnStartElement,
    OnStopElement
  );
  XML_SetCharacterDataHandler(parser_, OnText);

  chunk_.resize(buffer_size_);

  Read();
}

void Reader::Read() {
  if (parser_ == nullptr) {
    throw std::logic_error(
      "You are trying to read from an uninitialized XML reader"
    );
  }

  if (eof_) {
    throw std::logic_error(
      "The XML reader reached the end-of-input, "
      "but you called Read()"
    );
  }

  if (error_) {
    throw std::logic_error(
      "There was an error while reading XML, "
      "but you called Read() again"
    );
  }

  while (node_buffer_.empty()) {
    // NOTE (mristin):
    // We read and parse the next chunk of input, until we parsed a whole node.
    // The text, however, will be fragmented by Expat's design.

    is_.read(&(chunk_[0]), buffer_size_);

    const std::streamsize actual_bytes_read = is_.gcount();

    if (is_.bad()) {
      SetCurrentAndEofAndError(
        common::make_unique<ErrorNode>(
          0,
          0,
          "Failed to read from the input"
        )
      );
      return;
    }

    if (actual_bytes_read == 0) {
      if (is_.eof()) {
        SetCurrentAndEofAndError(common::make_unique<EofNode>());
        return;
      } else {
        SetCurrentAndEofAndError(
          common::make_unique<ErrorNode>(
            0,
            0,
            "Read zero bytes from the input, "
            "but the input is neither eof() nor bad()"
          )
        );
        return;
      }
    } else {
      const bool done = is_.eof();

      if (actual_bytes_read > std::numeric_limits<int>::max()) {
        std::string message = common::Concat(
          "Expat library expects the buffer size as int, ",
          "but the actual number of bytes read ",
          std::to_string(actual_bytes_read),
          " does not fit in an int as it is larger than the maximum int ",
          std::to_string(std::numeric_limits<int>::max())
        );

        throw std::runtime_error(message);
      }

      const auto actual_bytes_read_int = static_cast<int>(actual_bytes_read);

      XML_Status status = XML_Parse(
        parser_,
        &(chunk_[0]),
        actual_bytes_read_int,
        done
      );

      if (status == XML_STATUS_ERROR) {
        XML_Error error_code = XML_GetErrorCode(parser_);

        if (error_code == XML_ERROR_ABORTED) {
          if (node_buffer_.empty()) {
            throw std::logic_error(
              "The XML parsing was aborted, "
              "so we expected an error node on the buffer, "
              "but the buffer was empty"
            );
          }

          if (node_buffer_.back()->kind() != NodeKind::Error) {
            std::string message = common::Concat(
              "The XML parsing was aborted, "
              "so we expected an error node on the buffer, "
              "but we got ",
              NodeKindToHumanReadableString(node_buffer_.back()->kind())
            );

            throw std::logic_error(message);
          }
        } else {
          const XML_LChar* error_str = XML_ErrorString(error_code);

          node_buffer_.emplace_back(
            common::make_unique<ErrorNode>(
              XML_GetCurrentLineNumber(parser_),
              XML_GetCurrentColumnNumber(parser_),
              std::string(error_str)
            )
          );
        }
      } else {
        if (done) {
          node_buffer_.emplace_back(common::make_unique<EofNode>());
        }
      }
    }
  }

  SetCurrentAndEofAndError(std::move(node_buffer_.front()));
  node_buffer_.pop_front();
}

const INode& Reader::node() const {
  return *current_;
}

std::unique_ptr<INode> Reader::moved_node() {
  return std::move(current_);
}

Reader::~Reader() {
  if (parser_ != nullptr) {
    XML_ParserFree(parser_);
  }
}

void Reader::SetCurrentAndEofAndError(
  std::unique_ptr<INode> node
) {
  current_ = std::move(node);

  #ifdef __clang__
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wswitch"
  #endif
  switch (current_->kind()) {
    case NodeKind::Eof:
      eof_ = true;
      break;
    case NodeKind::Error:
      error_ = true;
      break;
  }
  #ifdef __clang__
  #pragma clang diagnostic pop
  #endif
}

// endregion class Reader

// region class ReaderMergingText

/**
 * \brief Read XML in forms of nodes, with text nodes read in whole.
 *
 * This is a reader on top of the \ref Reader which keeps the text fragments
 * in the buffer. We need to process the text in whole during the XML
 * de-serialization, so this buffering is necessary. However, this means that
 * the text is kept in four copies (one partial copy in Expat buffer,
 * another partial copy as fragmented text nodes in the underlying \ref Reader
 * instance, yet another copy in the internal buffer of this instance, and
 * finally the fourth copy as the merged complete text).
 */
class ReaderMergingText {
 public:
  ReaderMergingText(
    std::istream& is,
    const ReadingOptions& options
  );

  /**
   * Set up the reader for the XML parsing and read the first node.
   */
  void Initialize();

  /**
   * Read the next node in the document.
   */
  void Read();

  /**
   * @return the node which has been read last
   */
  const INode& node() const;

  /**
   * @return set if the current node represents an error
   */
  bool error() const;

  /**
   * @return set if the current node represents an end-of-input
   */
  bool eof() const;

 private:
  bool initialized_;
  Reader reader_;

  std::unique_ptr<INode> current_;
  std::unique_ptr<INode> look_ahead_;

  // Assuming that the underlying reader points to a text node,
  // read all the consecutive text nodes and set the look-ahead node
  void ReadAndMergeAllTextAndSetLookahead();

  bool error_;
  bool eof_;
  void SetCurrentAndEofAndError(
    std::unique_ptr<INode> node
  );
};  // class ReaderMergingText

ReaderMergingText::ReaderMergingText(
    std::istream& is,
    const ReadingOptions& options
) :
  initialized_(false),
  reader_(is, options),
  current_(common::make_unique<BofNode>()),
  error_(false),
  eof_(false) {
  // Intentionally empty.
}

void ReaderMergingText::Initialize() {
  if (initialized_) {
    throw std::logic_error(
      "You are trying to initialize "
      "an already initialized ReaderMergingText"
    );
  }

  reader_.Initialize();

  // NOTE (mristin):
  // The `reader_` has already read a node. Hence, we need to parse it here
  // separately from `ReaderMergingText::Read` method.

  if (reader_.node().kind() != NodeKind::Text) {
    SetCurrentAndEofAndError(reader_.moved_node());
  } else {
    ReadAndMergeAllTextAndSetLookahead();
  }

  initialized_ = true;
}

void ReaderMergingText::Read() {
  if (!initialized_) {
    throw std::logic_error(
      "You are reading from an uninitialized ReaderMergingText"
    );
  }

  if (eof()) {
    throw std::logic_error(
      "You are trying to read from a ReaderMergingText, "
      "but it reached the end-of-input"
    );
  }

  if (error()) {
    throw std::logic_error(
      "You are trying to read from a ReaderMergingText, "
      "but an error already occurred"
    );
  }

  if (look_ahead_ != nullptr) {
    SetCurrentAndEofAndError(std::move(look_ahead_));
    return;
  }

  reader_.Read();
  if (reader_.node().kind() != NodeKind::Text) {
    SetCurrentAndEofAndError(reader_.moved_node());
  } else {
    ReadAndMergeAllTextAndSetLookahead();
  }
}

const INode& ReaderMergingText::node() const {
  return *current_;
}

bool ReaderMergingText::error() const {
  return error_;
}

bool ReaderMergingText::eof() const {
  return eof_;
}

void ReaderMergingText::ReadAndMergeAllTextAndSetLookahead() {
  if (reader_.node().kind() != NodeKind::Text) {
    std::string message = common::Concat(
      "Expected the current node in the reader "
      "underlying ReaderMergingText to be a text, "
      "but it was ",
      NodeKindToHumanReadableString(reader_.node().kind())
    );

    throw std::logic_error(message);
  }

  std::deque<std::string> text_buffer;

  while (reader_.node().kind() == NodeKind::Text) {
    const TextNode& fragment_text_node(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const TextNode&
      >(
        reader_.node()
      )
    );

    text_buffer.emplace_back(fragment_text_node.text);

    reader_.Read();
  }
  look_ahead_ = reader_.moved_node();

  size_t size = 0;
  for (const std::string& fragment : text_buffer) {
    size += fragment.size();
  }

  std::string text;
  text.reserve(size);
  while (!text_buffer.empty()) {
    text.append(text_buffer.front());
    text_buffer.pop_front();
  }

  SetCurrentAndEofAndError(common::make_unique<TextNode>(text));
}

void ReaderMergingText::SetCurrentAndEofAndError(std::unique_ptr<INode> node) {
  current_ = std::move(node);

  #ifdef __clang__
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wswitch"
  #endif
  switch (current_->kind()) {
    case NodeKind::Eof:eof_ = true;
      break;
    case NodeKind::Error:error_ = true;
      break;
  }
  #ifdef __clang__
  #pragma clang diagnostic pop
  #endif
}

// endregion class ReaderMergingText

// endregion Reading

// region Forward declarations of de-serialization functions

// NOTE (mristin):
// We make forward declarations of de-serialization functions so that they can be
// called in any order.

std::pair<
  common::optional<
    std::shared_ptr<types::IMyClass>
  >,
  common::optional<DeserializationError>
> MyClassFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IMyClass>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> MyClassFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IListOfPrimitives>
  >,
  common::optional<DeserializationError>
> ListOfPrimitivesFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IListOfPrimitives>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ListOfPrimitivesFromSequence(
  ReaderMergingText& reader
);

// endregion Forward declarations of de-serialization functions

/**
 * Map XML class names to model types.
 */
const std::unordered_map<
  std::string,
  types::ModelType
> kElementNameToModelType = {
  {
    "myClass",
    types::ModelType::kMyClass
  },
  {
    "listOfPrimitives",
    types::ModelType::kListOfPrimitives
  }
};

common::optional<types::ModelType> ModelTypeFromElementName(
  const std::string& element_name
) {
  auto it = kElementNameToModelType.find(element_name);
  if (it == kElementNameToModelType.end()) {
    return common::nullopt;
  }

  return it->second;
}

std::string NodeToHumanReadableString(
  const INode& node
) {
  switch (node.kind()) {
    case NodeKind::Bof:
      return "beginning-of-input";

    case NodeKind::Start: {
      const StartNode& start_node(
        static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
          const StartNode&
        >(node)
      );

      return common::Concat(
        "a start node <",
        start_node.name,
        ">"
      );
    }

    case NodeKind::Stop: {
      const StopNode& stop_node(
        static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
          const StopNode&
        >(node)
      );

      return common::Concat(
        "a stop node </",
        stop_node.name,
        ">"
      );
    }

    case NodeKind::Text:
      return "an XML text";

    case NodeKind::Eof:
      return "end-of-input";

    case NodeKind::Error:
      return "an XML error";

    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected node kind: ",
          std::to_string(
            static_cast<uint32_t>(node.kind())
          )
        )
      );
  }
}

std::wstring NodeToHumanReadableWstring(
  const INode& node
) {
  switch (node.kind()) {
    case NodeKind::Bof:
      return L"beginning-of-input";

    case NodeKind::Start: {
      const StartNode& start_node(
        static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
          const StartNode&
        >(node)
      );

      return common::Concat(
        L"a start node <",
        common::Utf8ToWstring(start_node.name),
        L">"
      );
    }

    case NodeKind::Stop: {
      const StopNode& stop_node(
        static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
          const StopNode&
        >(node)
      );

      return common::Concat(
        L"a stop node </",
        common::Utf8ToWstring(stop_node.name),
        L">"
      );
    }

    case NodeKind::Text:
      return L"an XML text";

    case NodeKind::Eof:
      return L"end-of-input";

    case NodeKind::Error:
      return L"an XML error";

    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected node kind: ",
          std::to_string(
            static_cast<uint32_t>(node.kind())
          )
        )
      );
  }
}

/**
 * Check that the given node is a stop node and that its name corresponds to
 * the expected name.
 */
bool IsStopNodeWithName(
  const INode& node,
  const std::string& expected_name
) {
  if (node.kind() != NodeKind::Stop) {
    return false;
  }

  const std::string& name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(node).name
  );
  if (name != expected_name) {
    return false;
  }

  return true;
}

template <
  typename T
>
std::pair<
  common::optional<T>,
  common::optional<DeserializationError>
> InstanceAndNoDeserializationError(
  T&& instance
) {
  return std::make_pair<
    common::optional<T>,
    common::optional<DeserializationError>
  >(
    std::move(instance),
    common::nullopt
  );
}

template <
  typename T
> std::pair<
  common::optional<T>,
  common::optional<DeserializationError>
> NoInstanceAndDeserializationErrorWithCause(
  std::wstring cause
) {
  return std::make_pair<
    common::optional<T>,
    common::optional<DeserializationError>
  >(
    common::nullopt,
    common::make_optional<DeserializationError>(
      std::move(cause)
    )
  );
}

DeserializationError DeserializationErrorFromReader(
  ReaderMergingText& reader
) {
  if (reader.node().kind() != NodeKind::Error) {
    throw std::logic_error(
      common::Concat(
        "Expected an error node at the reader cursor, but got ",
        NodeToHumanReadableString(reader.node())
      )
    );
  }

  const auto error_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const ErrorNode&
    >(reader.node())
  );

  return DeserializationError(
    common::Utf8ToWstring(
      error_node.cause
    )
  );
}

template <
  typename T
>
std::pair<
  common::optional<T>,
  common::optional<DeserializationError>
> NoInstanceAndDeserializationErrorFromReader(
  ReaderMergingText& reader
) {
  if (reader.node().kind() != NodeKind::Error) {
    throw std::logic_error(
      common::Concat(
        "Expected an error node at the reader cursor, but got ",
        NodeToHumanReadableString(reader.node())
      )
    );
  }

  DeserializationError error = DeserializationErrorFromReader(
    reader
  );

  return std::make_pair(
    common::nullopt,
    common::make_optional<DeserializationError>(
      std::move(error)
    )
  );
}

template <
  typename T
>
std::pair<
  common::optional<T>,
  common::optional<DeserializationError>
> NoInstanceAndDeserializationError(
  DeserializationError error
) {
  return std::make_pair(
    common::nullopt,
    common::make_optional<DeserializationError>(
      std::move(error)
    )
  );
}

void PrependElementSegmentToDeserializationError(
  const std::string& name,
  DeserializationError& deserialization_error
) {
  deserialization_error.path.segments.emplace_front(
    common::make_unique<ElementSegment>(
      common::Utf8ToWstring(name)
    )
  );
}

common::optional<DeserializationError> CheckReaderAtEof(
  const ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in CheckReaderAtEof. "
      "CheckReaderAtEof expects no reader error at entry."
    );
  }
  #endif

  if (reader.node().kind() != NodeKind::Eof) {
    return common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected end-of-input, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  return common::nullopt;
}

/**
 * \brief Skip the beginning-of-file (BoF) and read a node.
 *
 * Do nothing if the cursor points to a non-BoF node.
 *
 * Return an error if the reader produced an error.
 */
common::optional<DeserializationError> SkipBof(
  ReaderMergingText& reader
) {
  if (reader.node().kind() != NodeKind::Bof) {
    return common::nullopt;
  }

  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    return DeserializationErrorFromReader(reader);
  }

  return common::nullopt;
}

/**
 * Return `true` if all characters are whitespace in the UTF-8-encoded text.
 */
bool IsWhitespace(const std::string& utf8_text) {
  for (const char character : utf8_text) {
    switch (character) {
      // NOTE (mristin):
      // The characters are ordered by their ASCII codes so that
      // we allow compilers to optimize.

      // NOTE (mristin):
      // Text nodes contain text in UTF-8 which is compatible with ASCII.
      // In particular, all characters above ASCII (>127) are encoded with
      // all the leading bits set. Hence, it is safe to check for whitespace
      // characters in an UTF-8-encoded string using one-byte characters.
      //
      // See: https://stackoverflow.com/questions/15965811/why-utf8-is-compatible-with-ascii

      case '\t':
      case '\n':
      case '\r':
      case ' ':
        // Pass
        break;
      default:
        return false;
    }
  }

  return true;
}

/**
 * \brief Skip all whitespace text nodes.
 *
 * Do nothing if the cursor points to a non-text node.
 *
 * The whitespace includes space, tab, carriage return and newline.
 *
 * Return an error if the reader produced an error.
 */
common::optional<DeserializationError> SkipWhitespace(
  ReaderMergingText& reader
) {
  while (reader.node().kind() == NodeKind::Text) {
    const TextNode& text_node(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const TextNode&
      >(
        reader.node()
      )
    );

    if (!IsWhitespace(text_node.text)) {
      break;
    }

    reader.Read();
  }

  if (reader.node().kind() == NodeKind::Error) {
    return DeserializationErrorFromReader(reader);
  }

  return common::nullopt;
}

std::pair<
  common::optional<
    std::shared_ptr<types::IClass>
  >,
  common::optional<DeserializationError>
> ClassFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ClassFromElement. "
      "ClassFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IClass>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IClass>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IClass>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IClass>
  > instance;

  switch (*model_type) {
    case types::ModelType::kMyClass:
      std::tie(instance, error) = MyClassFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kListOfPrimitives:
      std::tie(instance, error) = ListOfPrimitivesFromSequence<
        types::IClass
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IClass>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IClass from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IMyClass>
  >,
  common::optional<DeserializationError>
> MyClassFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in MyClassFromElement. "
      "MyClassFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMyClass>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMyClass>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IMyClass>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IMyClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IMyClass>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IMyClass>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IMyClass>
  > instance;

  switch (*model_type) {
    case types::ModelType::kMyClass:
      std::tie(instance, error) = MyClassFromSequence<
        types::IMyClass
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IMyClass>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IMyClass from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMyClass>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMyClass>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IMyClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMyClass>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IMyClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMyClass>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMyClass>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IListOfPrimitives>
  >,
  common::optional<DeserializationError>
> ListOfPrimitivesFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ListOfPrimitivesFromElement. "
      "ListOfPrimitivesFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IListOfPrimitives>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IListOfPrimitives>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IListOfPrimitives>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IListOfPrimitives, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IListOfPrimitives>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IListOfPrimitives>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IListOfPrimitives>
  > instance;

  switch (*model_type) {
    case types::ModelType::kListOfPrimitives:
      std::tie(instance, error) = ListOfPrimitivesFromSequence<
        types::IListOfPrimitives
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IListOfPrimitives>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IListOfPrimitives from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IListOfPrimitives>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IListOfPrimitives>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IListOfPrimitives, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IListOfPrimitives>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IListOfPrimitives, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IListOfPrimitives>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IListOfPrimitives>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

// region De-serialize primitives

const std::unordered_map<
  std::string,
  bool
> kTextToBool = {
  {"true", true},
  {"false", false},
  {"1", true},
  {"0", false}
};

std::pair<
  common::optional<bool>,
  common::optional<DeserializationError>
> DeserializeBool(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeBool. "
      "DeserializeBool expects no error node."
    );
  }
  #endif

  if (reader.node().kind() != NodeKind::Text) {
    return NoInstanceAndDeserializationErrorWithCause<bool>(
      common::Concat(
        L"Expected to parse an xs:boolean from XML text, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  auto it = kTextToBool.find(text);
  if (it == kTextToBool.end()) {
    return NoInstanceAndDeserializationErrorWithCause<bool>(
      common::Concat(
        L"Expected to parse an xs:boolean from text, "
        L"but got an invalid value: ",
        common::Utf8ToWstring(text)
      )
    );
  }

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<bool>(reader);
  }

  return std::make_pair(
    it->second,
    common::nullopt
  );
}

std::pair<
  common::optional<int64_t>,
  common::optional<DeserializationError>
> DeserializeInt64(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeInt64. "
      "DeserializeInt64 expects no error node."
    );
  }
  #endif

  if (reader.node().kind() != NodeKind::Text) {
    return NoInstanceAndDeserializationErrorWithCause<int64_t>(
      common::Concat(
        L"Expected to parse an xs:long from XML text, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  common::optional<int64_t> deserialized;

  static_assert(
    sizeof(int) == 8
    || sizeof(long) == 8
    || sizeof(long long) == 8,
    "Neither int nor long nor long long are 8 bytes long, "
    "so we do not know how to parse an xs:long."
  );

  try {
    // NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
    const bool sizeof_int_is_8 = sizeof(int) == 8;
    const bool sizeof_long_is_8 = sizeof(long) == 8;
    const bool sizeof_long_long_is_8 = sizeof(long long) == 8;

    if (sizeof_int_is_8) {
      deserialized = std::stoi(text);
    } else if (sizeof_long_is_8) {
      deserialized = std::stol(text);
    } else if (sizeof_long_long_is_8) {
      deserialized = std::stoll(text);
    }
  } catch (std::invalid_argument&) {
    return NoInstanceAndDeserializationErrorWithCause<int64_t>(
      common::Concat(
        L"Expected to parse an xs:long from text, "
        L"but got an invalid value: ",
        common::Utf8ToWstring(text)
      )
    );
  } catch (std::out_of_range&) {
    return NoInstanceAndDeserializationErrorWithCause<int64_t>(
      common::Concat(
        L"Expected to parse an xs:long from text, "
        L"but got a value out of the xs:long range: ",
        common::Utf8ToWstring(text)
      )
    );
  }

  if (!deserialized.has_value()) {
    throw std::logic_error(
      "Neither int nor long nor long long are 8 bytes long, "
      "but this should have been caught earlier in the static assert"
    );
  }

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<int64_t>(reader);
  }

  return std::make_pair(
    deserialized,
    common::nullopt
  );
}

std::pair<
  common::optional<double>,
  common::optional<DeserializationError>
> DeserializeDouble(
  ReaderMergingText& reader
) {
  static_assert(
    sizeof(double) == 8,
    "DeserializeDouble expects double to be 8 bytes, "
    "but the size of the double is not 8 bytes"
  );

  #ifdef DEBUG
  if (node.kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeDouble. "
      "DeserializeDouble expects no error node."
    );
  }
  #endif

  if (reader.node().kind() != NodeKind::Text) {
    return NoInstanceAndDeserializationErrorWithCause<double>(
      common::Concat(
        L"Expected to parse an xs:double from XML text, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  double deserialized;

  try {
    deserialized = std::stod(text);
  } catch (std::invalid_argument&) {
    return NoInstanceAndDeserializationErrorWithCause<double>(
      common::Concat(
        L"Expected to parse an xs:double from text, "
        L"but got an invalid value: ",
        common::Utf8ToWstring(text)
      )
    );
  } catch (std::out_of_range&) {
    return NoInstanceAndDeserializationErrorWithCause<double>(
      common::Concat(
        L"Expected to parse an xs:double from text, "
        L"but got a value out of the xs:double range: ",
        common::Utf8ToWstring(text)
      )
    );
  }

  // NOTE (mristin):
  // XSD basic types are not case insensitive and quite strict.
  // We follow this strictness in the parsing as well.
  //
  // See: https://www.w3.org/TR/xmlschema11-2/#double

  const bool invalid_xml(
    (
      deserialized == std::numeric_limits<double>::infinity()
      && text != "INF"
    ) || (
      deserialized == -std::numeric_limits<double>::infinity()
      && text != "-INF"
    ) || (
      std::isnan(deserialized)
      && text != "NaN"
    )
  );

  if (invalid_xml) {
    return NoInstanceAndDeserializationErrorWithCause<double>(
      common::Concat(
        L"Expected to parse an xs:double from text, "
        L"but got an invalid value: ",
        common::Utf8ToWstring(text)
      )
    );
  }

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<double>(reader);
  }

  return std::make_pair(
    deserialized,
    common::nullopt
  );
}

std::pair<
  common::optional<std::wstring>,
  common::optional<DeserializationError>
> DeserializeWstring(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeWstring. "
      "DeserializeWstring expects no error node."
    );
  }
  #endif

  switch (reader.node().kind()) {
    case NodeKind::Stop:
      // Encountering a stop node means that the string is empty.
      return std::make_pair(std::wstring(), common::nullopt);
    case NodeKind::Text:
      // We pass and continue decoding the text.
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<std::wstring>(
        common::Concat(
          L"Expected to parse an xs:string from XML text, but got ",
            NodeToHumanReadableWstring(reader.node())
          )
        );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  std::wstring deserialized = common::Utf8ToWstring(text);

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<std::wstring>(reader);
  }

  return std::make_pair(std::move(deserialized), common::nullopt);
}

std::pair<
  common::optional<std::vector<std::uint8_t> >,
  common::optional<DeserializationError>
> DeserializeByteArray(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeByteArray. "
      "DeserializeByteArray expects no error node."
    );
  }
  #endif

  switch (reader.node().kind()) {
    case NodeKind::Stop:
      // Encountering a stop node means empty byte array.
      return std::make_pair(
        std::vector<std::uint8_t>(),
        common::nullopt
      );
    case NodeKind::Text:
      // We pass and continue decoding the byte array.
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::vector<std::uint8_t>
      >(
        common::Concat(
          L"Expected to parse an xs:base64Binary from XML text, but got ",
            NodeToHumanReadableWstring(reader.node())
          )
        );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  common::expected<
    std::vector<std::uint8_t>,
    std::string
  > deserialized = stringification::Base64Decode(text);

  if (!deserialized.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::vector<std::uint8_t>
    >(
      common::Concat(
        L"Expected to parse an xs:base64Binary from text, "
        L"but the value was invalid: ",
        common::Utf8ToWstring(deserialized.error())
      )
    );
  }

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<
      std::vector<std::uint8_t>
    >(reader);
  }

  return std::make_pair(
    std::move(*deserialized),
    common::nullopt
  );
}

// endregion De-serialize primitives

namespace properties {

enum class OfMyClass : std::uint32_t {
  
};  // enum class OfMyClass

enum class OfListOfPrimitives : std::uint32_t {
  kStrings = 0,
  kIntegers = 1,
  kBooleans = 2,
  kClasses = 3
};  // enum class OfListOfPrimitives

const std::unordered_map<
  std::string,
  OfMyClass
> kMapOfMyClass = {
  
};

const std::unordered_map<
  std::string,
  OfListOfPrimitives
> kMapOfListOfPrimitives = {
  {
    "strings",
    OfListOfPrimitives::kStrings
  },
  {
    "integers",
    OfListOfPrimitives::kIntegers
  },
  {
    "booleans",
    OfListOfPrimitives::kBooleans
  },
  {
    "classes",
    OfListOfPrimitives::kClasses
  }
};

}  // namespace properties

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IMyClass>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> MyClassFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in MyClassFromSequence. "
      "MyClassFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IMyClass, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfMyClass.find(
      name
    );
    if (it == properties::kMapOfMyClass.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IMyClass, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfMyClass property(
      it->second
    );

    switch (property) {
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfMyClass: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IMyClass, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::MyClass()
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IListOfPrimitives>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ListOfPrimitivesFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ListOfPrimitivesFromSequence. "
      "ListOfPrimitivesFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::vector<std::wstring> > the_strings;

  common::optional<std::vector<int64_t> > the_integers;

  common::optional<std::vector<bool> > the_booleans;

  common::optional<
    std::vector<
      std::shared_ptr<types::IMyClass>
    >
  > the_classes;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IListOfPrimitives, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfListOfPrimitives.find(
      name
    );
    if (it == properties::kMapOfListOfPrimitives.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IListOfPrimitives, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfListOfPrimitives property(
      it->second
    );

    switch (property) {
      case properties::OfListOfPrimitives::kStrings: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_strings = std::vector<
            std::wstring
          >();
        } else {
          std::deque<
            std::wstring
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::wstring
            > item;
          
            std::tie(
              item,
              error
            ) = DeserializeWstring(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_strings = std::vector<
              std::wstring
            >();
            the_strings->reserve(items.size());
            
            for (auto& item : items) {
              the_strings->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfListOfPrimitives::kIntegers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_integers = std::vector<
            int64_t
          >();
        } else {
          std::deque<
            int64_t
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              int64_t
            > item;
          
            std::tie(
              item,
              error
            ) = DeserializeInt64(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_integers = std::vector<
              int64_t
            >();
            the_integers->reserve(items.size());
            
            for (auto& item : items) {
              the_integers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfListOfPrimitives::kBooleans: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_booleans = std::vector<
            bool
          >();
        } else {
          std::deque<
            bool
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              bool
            > item;
          
            std::tie(
              item,
              error
            ) = DeserializeBool(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_booleans = std::vector<
              bool
            >();
            the_booleans->reserve(items.size());
            
            for (auto& item : items) {
              the_booleans->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfListOfPrimitives::kClasses: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_classes = std::vector<
            std::shared_ptr<types::IMyClass>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IMyClass>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IMyClass>
            > item;
          
            std::tie(
              item,
              error
            ) = MyClassFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_classes = std::vector<
              std::shared_ptr<types::IMyClass>
            >();
            the_classes->reserve(items.size());
            
            for (auto& item : items) {
              the_classes->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfListOfPrimitives: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IListOfPrimitives, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_strings.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property strings is missing"
    );
  }

  if (!the_integers.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property integers is missing"
    );
  }

  if (!the_booleans.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property booleans is missing"
    );
  }

  if (!the_classes.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property classes is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ListOfPrimitives(
        std::move(*the_strings),
        std::move(*the_integers),
        std::move(*the_booleans),
        std::move(*the_classes)
      )
    ),
    common::nullopt
  );
}

common::expected<
  std::shared_ptr<types::IClass>,
  DeserializationError
> From(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IClass>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ClassFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IMyClass>,
  DeserializationError
> MyClassFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IMyClass>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = MyClassFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IListOfPrimitives>,
  DeserializationError
> ListOfPrimitivesFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IListOfPrimitives>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ListOfPrimitivesFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

// endregion De-serialization

// region Serialization

/**
 * Represent a serialization error.
 *
 * We use this error internally to avoid unnecessary stack unwinding,
 * but throw the \ref SerializationException at the final site of
 * the serialization for the user.
 */
struct SerializationError {
  /**
   * Human-readable description of the error
   */
  std::wstring cause;

  /**
   * Path to the value that caused the error
   */
  iteration::Path path;

  explicit SerializationError(
    std::wstring a_cause
  ) :
    cause(std::move(a_cause)) {
    // Intentionally empty.
  }
};  // struct SerializationError

const std::wstring kTheOutputStreamIsInABadState(
  L"The output stream is in a bad state."
    );

/**
 * Check that the output stream is not in a bad state. If so, create an error.
 */
common::optional<SerializationError> CheckOstreamState(
  const std::ostream& os
) {
  if (os.bad()) {
    return common::make_optional<SerializationError>(
      kTheOutputStreamIsInABadState
    );
  }

  return common::nullopt;
}

// region SerializationException

std::string RenderSerializationErrorMessage(
  const std::wstring& cause,
  const iteration::Path& path
) {
  return common::WstringToUtf8(
    common::Concat(
      L"Serialization failed at ",
      path.ToWstring(),
      L": ",
      cause
    )
  );
}

SerializationException::SerializationException(
  std::wstring cause
) :
  cause_(std::move(cause)),
  path_(),
  msg_(RenderSerializationErrorMessage(cause, path_)) {
  // Intentionally empty.
}

SerializationException::SerializationException(
  std::wstring cause,
  iteration::Path path
) :
  cause_(std::move(cause)),
  path_(std::move(path)),
  msg_(RenderSerializationErrorMessage(cause, path)) {
  // Intentionally empty.
}

const char* SerializationException::what() const noexcept {
  return msg_.c_str();
}

const std::wstring& SerializationException::cause() const noexcept {
  return cause_;
}

const iteration::Path& SerializationException::path() const noexcept {
  return path_;
}

// endregion SerializationException

// region SelfClosingWriter

/**
 * \brief Write XML nodes to the UTF-8-encoded output stream.
 *
 * The start elements are put on hold until we observe a text, a stop element or
 * end-of-input. This allows us to continuously shorten the XML elements to self-closing
 * tags.
 *
 * The prefix is appended to each element name. If you do not need the prefix,
 * specify it as empty string. In most cases, you put a colon, `:` at the end of
 * the prefix.
 *
 * Each writing method captures any errors and obvious exceptions as
 * serialization errors.
 *
 * Use \ref error() to check if there is any error.
 */
class SelfClosingWriter {
 public:
  SelfClosingWriter(
    std::ostream& os,
    std::string prefix
  );

  /**
   * Queue a start element for an eventual write.
   */
  void StartElement(
    std::string name
  );

  /**
   * Write a stop element.
   *
   * If there is a pending start element with no content, shorten it to
   * a self-closing XML element.
   */
  void StopElement(
    const std::string& name
  );

  /**
   * \brief Serialize the given boolean to an xs:bool value.
   *
   * We explicitly write longer text, `true` and `false`, to make the values explicit,
   * and not potentially confusing with numbers, in the XML.
   */
  void SerializeBool(
    bool value
  );

  /**
   * \brief Serialize the given number to an xs:long value.
   *
   * We do not check that the number is within a range representable as 64-bit
   * floats, as the value can be de-serialized correctly from XML. However, this
   * means that XML and JSON serializations are not interoperable. If you need
   * interoperability, you have to ensure that range yourself (<i>e.g.</i>, through
   * \ref validation, see also
   * https://github.com/aas-core-works/aas-core-meta/issues/298).
   */
  void SerializeInt64(
    int64_t value
  );

  /**
   * \brief Serialize the given number to an xs:double value.
   */
  void SerializeDouble(
    double value
  );

  /**
   * \brief Write the text while escaping special characters for XML.
   */
  void SerializeWstring(
    const std::wstring& text
  );

  /**
   * \brief Write the text while escaping special characters for XML.
   */
  void SerializeString(
    const std::string& text
  );

  /**
   * \brief Encode bytes to Base64 and write them.
   */
  void SerializeByteArray(
  const std::vector<std::uint8_t>& byte_array
  );

  /**
   * Finish and flush any pending start nodes.
   */
  void Finish();

  /**
   * Get an error, if any, caught during the serialization.
   */
  const common::optional<SerializationError>& error() const;

  /**
   * Transfer the ownership of the error.
   */
  common::optional<SerializationError>&& move_error();

 private:
  std::ostream& os_;
  std::string prefix_;
  common::optional<SerializationError> error_;
  common::optional<std::string> pending_start_wo_text_;

  /**
   * \brief Escape the given text to XML.
   *
   * Return nothing if no escaping was needed.
   */
  static common::optional<std::wstring> EscapeForXml(
    const std::wstring& text
  );

  /**
   * \brief Escape the given text to XML.
   *
   * Return nothing if no escaping was needed.
   */
  static common::optional<std::string> EscapeForXml(
    const std::string& text
  );

  void WritePendingStartElementIfAvailable();

  /**
   * Write the text without any XML escaping or flushing of pending start elements.
   */
  void WriteStringWithoutEscapingNorFlushing(
    const std::string& text
  );
};  // class SelfClosingWriter

SelfClosingWriter::SelfClosingWriter(
  std::ostream& os,
  std::string prefix
) :
  os_(os),
  prefix_(std::move(prefix)) {
  // Intentionally empty.
}

void SelfClosingWriter::StartElement(
  std::string name
) {
  #ifdef DEBUG
  if (error_.has_value()) {
    throw std::logic_error(
      "You are trying to queue a start element with a SelfClosingWriter "
      "which caught an error."
    );
  #endif

  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
  return;
  }

  pending_start_wo_text_ = std::move(name);
}

void SelfClosingWriter::StopElement(
  const std::string& name
) {
  #ifdef DEBUG
  if (error_.has_value()) {
    throw std::logic_error(
      "You are trying to write a stop element with a SelfClosingWriter "
      "which caught an error before."
    );
  #endif

  if (pending_start_wo_text_.has_value()) {
    #ifdef DEBUG
    if (*pending_start_wo_text_ != name) {
      throw std::logic_error(
        common::Concat(
          "The start element <",
          *pending_start_wo_text_,
          "> is pending for writing, "
          "but you are trying to write a stop element </",
          name
          ">"
        )
      );
    }
    #endif

    pending_start_wo_text_ = common::nullopt;

    WriteStringWithoutEscapingNorFlushing(
      common::Concat(
        "<",
        prefix_,
        name,
        " />"
      )
    );
  } else {
    WritePendingStartElementIfAvailable();
    if (error_.has_value()) {
      return;
    }

    WriteStringWithoutEscapingNorFlushing(
      common::Concat(
        "</",
        prefix_,
        name,
        ">"
      )
    );
  }
}

void SelfClosingWriter::SerializeBool(
  bool value
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  WriteStringWithoutEscapingNorFlushing(
    value ? "true" : "false"
  );
}

void SelfClosingWriter::SerializeInt64(
  int64_t value
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  WriteStringWithoutEscapingNorFlushing(
    std::to_string(value)
  );
}

void SelfClosingWriter::SerializeDouble(
  double value
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  // NOTE (mristin):
  // We handle edge values infinity and not-a-number explicitly here
  // as some C/C++ implementations might not convert them to XML-conformant
  // strings.

  if (std::isinf(value)) {
    if (value < 0) {
      WriteStringWithoutEscapingNorFlushing("-INF");
    } else {
      WriteStringWithoutEscapingNorFlushing("INF");
    }
  } else if(std::isnan(value)) {
    WriteStringWithoutEscapingNorFlushing("NaN");
  } else {
    WriteStringWithoutEscapingNorFlushing(
      std::to_string(value)
    );
  }
}

void SelfClosingWriter::SerializeString(
  const std::string& text
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  // NOTE (mristin):
  // We optimize here for short and long texts, respectively.
  // The main assumption is that the short texts can be escaped and converted
  // in one go, while the longer texts need to be converted in chunks.

  if (text.size() < 1024) {
    common::optional<std::string> escaped = EscapeForXml(text);

    if (escaped.has_value()) {
      WriteStringWithoutEscapingNorFlushing(
        *escaped
      );
      return;
    } else {
      WriteStringWithoutEscapingNorFlushing(
        text
      );
      return;
    }
  }

  size_t start = 0;
  while (start < text.size()) {
    const size_t end = std::min(start + 1024, text.size());
    const size_t chunk_size = end - start;

    // NOTE (mristin):
    // We assume that making short copies of text substrings does not hurt
    // the performance here, but makes the code more readable.

    const std::string chunk = text.substr(start, chunk_size);

    common::optional<std::string> escaped = EscapeForXml(chunk);

    if (escaped.has_value()) {
      WriteStringWithoutEscapingNorFlushing(
        *escaped
      );
    } else {
      WriteStringWithoutEscapingNorFlushing(
        chunk
      );
    }

    if (error_.has_value()) {
      return;
    }

    start += chunk_size;
  }
}

void SelfClosingWriter::SerializeWstring(
  const std::wstring& text
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  // NOTE (mristin):
  // We optimize here for short and long texts, respectively.
  // The main assumption is that the short texts can be escaped and converted
  // in one go, while the longer texts need to be converted in chunks.

  if (text.size() < 1024) {
    common::optional<std::wstring> escaped = EscapeForXml(text);

    if (escaped.has_value()) {
      WriteStringWithoutEscapingNorFlushing(
        common::WstringToUtf8(*escaped)
      );
      return;
    } else {
      WriteStringWithoutEscapingNorFlushing(
        common::WstringToUtf8(text)
      );
      return;
    }
  }

  size_t start = 0;
  while (start < text.size()) {
    const size_t end = std::min(start + 1024, text.size());
    const size_t chunk_size = end - start;

    // NOTE (mristin):
    // We assume that making short copies of text substrings does not hurt
    // the performance here, but makes the code more readable.

    const std::wstring chunk = text.substr(start, chunk_size);

    common::optional<std::wstring> escaped = EscapeForXml(chunk);

    if (escaped.has_value()) {
      WriteStringWithoutEscapingNorFlushing(
        common::WstringToUtf8(*escaped)
      );
    } else {
      WriteStringWithoutEscapingNorFlushing(
        common::WstringToUtf8(chunk)
      );
    }

    if (error_.has_value()) {
      return;
    }

    start += chunk_size;
  }
}

void SelfClosingWriter::SerializeByteArray(
  const std::vector<std::uint8_t>& byte_array
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  // NOTE (mristin):
  // We optimize here for short and long byte arrays, respectively.
  // The main assumption is that the short texts can be escaped and converted
  // in one go, while the longer texts need to be converted in chunks.
  //
  // Optimally, we would write an encoding function such that it encodes directly
  // to the output stream. As we lack the time resources for that at the moment,
  // we go for the compromise with one pass and chunking, respectively.

  if (byte_array.size() <= 1536) {
    WriteStringWithoutEscapingNorFlushing(
      stringification::Base64Encode(byte_array)
    );
    return;
  }

  // NOTE (mristin):
  // We assume here that making copies of small sub-arrays does not hurt
  // the performance, but makes the code substantially more readable.

  size_t start = 0;
  while (start < byte_array.size()) {
    // NOTE (mristin):
    // We pick a multiple of 3 for the chunk size in order to make the encoding
    // of chunking identical to the output as we encoded all bytes at the same time.
    //
    // See: https://stackoverflow.com/questions/7920780/is-it-possible-to-base64-encode-a-file-in-chunks

    const size_t end = std::min(start + 1536, byte_array.size());

    const std::vector<std::uint8_t> chunk(
      byte_array.begin() + start,
      byte_array.begin() + end
    );

    WriteStringWithoutEscapingNorFlushing(
      stringification::Base64Encode(chunk)
    );
    if (error_.has_value()) {
      return;
    }
  }
}

void SelfClosingWriter::Finish() {
  WritePendingStartElementIfAvailable();
}

const common::optional<SerializationError>& SelfClosingWriter::error() const {
  return error_;
}

common::optional<SerializationError>&& SelfClosingWriter::move_error() {
  return std::move(error_);
}

common::optional<std::wstring> SelfClosingWriter::EscapeForXml(
  const std::wstring& text
) {
  size_t out_len = 0;

  // NOTE (mristin):
  // We use sizeof on *strings* instead of *wide strings* to get
  // the number of *characters*. Otherwise, if we used wide strings,
  // we would obtain the wrong number of characters as we would count
  // bytes instead of characters with `sizeof`, which differ in wide strings
  // due to encoding.

  for (wchar_t character : text ) {
    switch (character) {
      case L'&': {
        out_len += sizeof("&amp;");
        break;
      }
      case L'<': {
        out_len += sizeof("&lt;");
        break;
      }
      case L'>': {
        out_len += sizeof("&gt;");
        break;
      }
      case L'"': {
        out_len += sizeof("&quot;");
        break;
      }
      case L'\'': {
        out_len += sizeof("&apos;");
        break;
      }
      default:
        ++out_len;
        break;
    }
  }

  // NOTE (mristin):
  // We assume here that XML encoding is always *longer* than
  // the original text.

  if (out_len == text.size()) {
    return common::nullopt;
  }

  std::wstring out;
  out.reserve(out_len);

  for (wchar_t character : text ) {
    switch (character) {
      case L'&':
        out.append(L"&amp;");
        break;
      case L'<':
        out.append(L"&lt;");
        break;
      case L'>':
        out.append(L"&gt;");
        break;
      case L'"':
        out.append(L"&quot;");
        break;
      case L'\'':
        out.append(L"&apos;");
        break;
      default:
        out.push_back(character);
        break;
    }
  }

  return common::make_optional<std::wstring>(
    std::move(out)
  );
}

common::optional<std::string> SelfClosingWriter::EscapeForXml(
  const std::string& text
) {
  size_t out_len = 0;

  for (char character : text ) {
    switch (character) {
      case '&': {
        out_len += sizeof("&amp;");
        break;
      }
      case '<': {
        out_len += sizeof("&lt;");
        break;
      }
      case '>': {
        out_len += sizeof("&gt;");
        break;
      }
      case '"': {
        out_len += sizeof("&quot;");
        break;
      }
      case '\'': {
        out_len += sizeof("&apos;");
        break;
      }
      default:
        ++out_len;
        break;
    }
  }

  // NOTE (mristin):
  // We assume here that XML encoding is always *longer* than
  // the original text.

  if (out_len == text.size()) {
    return common::nullopt;
  }

  std::string out;
  out.reserve(out_len);

  for (char character : text ) {
    switch (character) {
      case '&':
        out.append("&amp;");
        break;
      case '<':
        out.append("&lt;");
        break;
      case '>':
        out.append("&gt;");
        break;
      case '"':
        out.append("&quot;");
        break;
      case '\'':
        out.append("&apos;");
        break;
      default:
        out.push_back(character);
        break;
    }
  }

  return common::make_optional<std::string>(
    std::move(out)
  );
}

void SelfClosingWriter::WritePendingStartElementIfAvailable() {
  if (!pending_start_wo_text_.has_value()) {
    return;
  }

  WriteStringWithoutEscapingNorFlushing(
    common::Concat(
      "<",
      prefix_,
      *pending_start_wo_text_,
      ">"
    )
  );

  pending_start_wo_text_ = common::nullopt;
}

void SelfClosingWriter::WriteStringWithoutEscapingNorFlushing(
  const std::string& text
) {
  #ifdef DEBUG
  if (error_.has_value()) {
    throw std::logic_error(
      "You are trying to write to a SelfClosingWriter which "
      "caught an error"
    );
  }
  #endif

  if (os_.bad()) {
    error_ = common::make_optional<SerializationError>(
      kTheOutputStreamIsInABadState
    );
    return;
  }

  os_ << text;

  if (os_.bad()) {
    error_ = common::make_optional<SerializationError>(
      kTheOutputStreamIsInABadState
    );
    return;
  }
}

// endregion SelfClosingWriter

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeMyClassAsSequence(
  const types::IMyClass& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<myClass>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeMyClassAsElement(
  const types::IMyClass& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeListOfPrimitivesAsSequence(
  const types::IListOfPrimitives& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<listOfPrimitives>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeListOfPrimitivesAsElement(
  const types::IListOfPrimitives& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeMyClassAsSequence(
  const types::IMyClass& that,
  SelfClosingWriter& writer
) {
  return common::nullopt;
}

common::optional<SerializationError> SerializeMyClassAsElement(
  const types::IMyClass& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "myClass"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeMyClassAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "myClass"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeListOfPrimitivesAsSequence(
  const types::IListOfPrimitives& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::vector<std::wstring>& the_strings(
    that.strings()
  );
  writer.StartElement(
    "strings"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  for (size_t i = 0; i < the_strings.size(); ++i) {
    std::wstring item(
      the_strings[i]
    );

    error = DeserializeWstring(
      *item,
      writer
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          i
        )
      );

      break;
    }
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kStrings
      )
    );

    return error;
  }
  writer.StopElement(
    "strings"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kStrings
      )
    );

    return error;
  }

  const std::vector<int64_t>& the_integers(
    that.integers()
  );
  writer.StartElement(
    "integers"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  for (size_t i = 0; i < the_integers.size(); ++i) {
    int64_t item(
      the_integers[i]
    );

    error = DeserializeInt64(
      *item,
      writer
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          i
        )
      );

      break;
    }
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kIntegers
      )
    );

    return error;
  }
  writer.StopElement(
    "integers"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kIntegers
      )
    );

    return error;
  }

  const std::vector<bool>& the_booleans(
    that.booleans()
  );
  writer.StartElement(
    "booleans"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  for (size_t i = 0; i < the_booleans.size(); ++i) {
    bool item(
      the_booleans[i]
    );

    error = DeserializeBool(
      *item,
      writer
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          i
        )
      );

      break;
    }
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kBooleans
      )
    );

    return error;
  }
  writer.StopElement(
    "booleans"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kBooleans
      )
    );

    return error;
  }

  const std::vector<
    std::shared_ptr<types::IMyClass>
  >& the_classes(
    that.classes()
  );
  writer.StartElement(
    "classes"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  for (size_t i = 0; i < the_classes.size(); ++i) {
    const std::shared_ptr<types::IMyClass>& item(
      the_classes[i]
    );

    error = SerializeMyClassAsElement(
      *item,
      writer
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          i
        )
      );

      break;
    }
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kClasses
      )
    );

    return error;
  }
  writer.StopElement(
    "classes"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kClasses
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeListOfPrimitivesAsElement(
  const types::IListOfPrimitives& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "listOfPrimitives"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeListOfPrimitivesAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "listOfPrimitives"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

void Serialize(
  const types::IClass& that,
  const WritingOptions& options,
  std::ostream& os
) {
  if (options.write_declaration) {
    os << "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
    if (os.bad()) {
      throw SerializationException(
        kTheOutputStreamIsInABadState
      );
    }
  }

  SelfClosingWriter writer(
    os,
    options.prefix
  );

  common::optional<SerializationError> error;

  // NOTE (mristin):
  // Instead of using `Serialize*AsElement`, we write the root XML element
  // in this functions so that we check for the XML namespace only once, namely
  // here. Otherwise, we would have a condition check in <em>every</em> nested
  // `Serialize*AsElement` which could cause a significant efficiency hit.

  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kMyClass:
      if (options.write_namespace) {
        os << (
          "<myClass "
          "xmlns=\"https://dummy.com\">"
        );
      } else {
        os << "<myClass>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeMyClassAsSequence(
        dynamic_cast<
          const types::IMyClass&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</myClass>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kListOfPrimitives:
      if (options.write_namespace) {
        os << (
          "<listOfPrimitives "
          "xmlns=\"https://dummy.com\">"
        );
      } else {
        os << "<listOfPrimitives>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeListOfPrimitivesAsSequence(
        dynamic_cast<
          const types::IListOfPrimitives&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</listOfPrimitives>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  }

  if (error.has_value()) {
    throw SerializationException(
      std::move(error->cause),
      std::move(error->path)
    );
  }
}

// endregion Serialization

}  // namespace xmlization
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
