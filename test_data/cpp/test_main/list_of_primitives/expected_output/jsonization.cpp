// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/jsonization.hpp"
#include "aas_core/aas_3_0/stringification.hpp"
#include "aas_core/aas_3_0/wstringification.hpp"

#pragma warning(push, 0)
#include <functional>
#include <map>
#include <set>
#include <sstream>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {
namespace jsonization {

// region PropertySegment

PropertySegment::PropertySegment(
  std::wstring a_name
) :
  name(std::move(a_name)) {
  // Intentionally empty.
}

std::wstring PropertySegment::ToWstring() const {
  return common::Concat(
    L".",
    name
  );
}

std::unique_ptr<ISegment> PropertySegment::Clone() const {
  return common::make_unique<PropertySegment>(*this);
}

// endregion PropertySegment

// region IndexSegment

IndexSegment::IndexSegment(
  size_t an_index
) :
  index(an_index) {
  // Intentionally empty.
}

std::wstring IndexSegment::ToWstring() const {
  return common::Concat(
    L"[",
    std::to_wstring(index),
    L"]"
  );
}

std::unique_ptr<ISegment> IndexSegment::Clone() const {
  return common::make_unique<IndexSegment>(*this);
}

// endregion IndexSegment

// region struct Path

Path::Path() {
  // Intentionally empty.
}

Path::Path(const Path& other) {
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
}

Path::Path(Path&& other) {
  segments = std::move(other.segments);
}

Path& Path::operator=(const Path& other) {
  segments.clear();
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
  return *this;
}

Path& Path::operator=(Path&& other) {
  if (this != &other) {
    segments = std::move(other.segments);
  }
  return *this;
}

std::wstring Path::ToWstring() const {
  if (segments.empty()) {
    return L"";
  }

  std::deque<std::wstring> parts;
  for (const std::unique_ptr<ISegment>& segment : segments ) {
    parts.emplace_back(segment->ToWstring());
  }

  size_t out_len = 0;
  for (const std::wstring& part : parts) {
    out_len += part.size();
  }

  std::wstring out;
  out.reserve(out_len);
  for (const std::wstring& part : parts) {
    out.append(part);
  }

  return out;
}

// endregion struct Path

// region De-serialization

// region class DeserializationError

DeserializationError::DeserializationError(
  std::wstring a_cause
) :
  cause(a_cause) {
  // Intentionally empty.
}

DeserializationError::DeserializationError(
  std::wstring a_cause,
  Path a_path
) :
  cause(a_cause),
  path(a_path) {
  // Intentionally empty.
}

// endregion class DeserializationError

std::pair<
  common::optional<bool>,
  common::optional<DeserializationError>
> DeserializeBool(
  const nlohmann::json& json
) {
  if (!json.is_boolean()) {
    std::wstring message = common::Concat(
      L"Expected a boolean, but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<bool>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return std::make_pair<
    common::optional<bool>,
    common::optional<DeserializationError>
  >(
    json.get<bool>(),
    common::nullopt
  );
}

std::pair<
  common::optional<int64_t>,
  common::optional<DeserializationError>
> DeserializeInt64(
  const nlohmann::json& json
) {
  if (!json.is_number()) {
    std::wstring message = common::Concat(
      L"Expected an integer number, but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  static_assert(
    std::is_same<nlohmann::json::number_integer_t, int64_t>::value,
    "Expected nlohmann::json::number_integer_t to equal int64_t, "
    "but it does not."
  );

  if (json.is_number_integer()) {
    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      json.get<int64_t>(),
      common::nullopt
    );
  }

  if (json.is_number_unsigned()) {
    std::wstring message = common::Concat(
      L"Expected a 64-bit integer number, "
      L"but got an unsigned integer number which does not fit in that range: ",
      std::to_wstring(json.get<nlohmann::json::number_unsigned_t>())
    );

    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  // NOTE (mristin):
  // We have to check that the number is an integer even though it can
  // not be stored in int64_t in order to give an informative message.

  const nlohmann::json::number_float_t number(
    json.get<nlohmann::json::number_float_t>()
  );

  nlohmann::json::number_float_t integer_part;
  const bool is_integer(
    std::modf(number, &integer_part) == 0
  );
  if (is_integer) {
    std::wstring message = common::Concat(
      L"Expected a 64-bit integer number, "
      L"but got an integer number which does not fit in that range: ",
      std::to_wstring(number)
    );

    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  } else {
    std::wstring message = common::Concat(
      L"Expected a 64-bit integer number, "
      L"but got a non-integer number: ",
      std::to_wstring(number)
    );

    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }
}

std::pair<
  common::optional<double>,
  common::optional<DeserializationError>
> DeserializeDouble(
  const nlohmann::json& json
) {
  if (!json.is_number()) {
    std::wstring message = common::Concat(
      L"Expected a number, but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<double>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  static_assert(
    std::is_same<nlohmann::json::number_float_t, double>::value,
    "Expected nlohmann::json::number_float_t to equal double, "
    "but it does not."
  );

  return std::make_pair<
    common::optional<double>,
    common::optional<DeserializationError>
  >(
    json.get<double>(),
    common::nullopt
  );
}

std::pair<
  common::optional<std::wstring>,
  common::optional<DeserializationError>
> DeserializeWstring(
  const nlohmann::json& json
) {
  if (!json.is_string()) {
    std::wstring message = common::Concat(
      L"Expected a string, but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::wstring>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return std::make_pair<
    common::optional<std::wstring>,
    common::optional<DeserializationError>
  >(
    common::Utf8ToWstring(*(json.get_ptr<const std::string*>())),
    common::nullopt
  );
}

std::pair<
  common::optional<std::vector<std::uint8_t> >,
  common::optional<DeserializationError>
> DeserializeByteArray(
  const nlohmann::json& json
) {
  if (!json.is_string()) {
    std::wstring message = common::Concat(
      L"Expected a base64-encoded byte array as a string, "
      L"but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );;

    return std::make_pair<
      common::optional<std::vector<std::uint8_t> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  common::expected<
    std::vector<std::uint8_t>,
    std::string
  > bytes = stringification::Base64Decode(
    *(json.get_ptr<const std::string*>())
  );

  if (!bytes.has_value()) {
    std::wstring message = common::Concat(
      L"Failed to base64-decode the bytes from a string: ",
      common::Utf8ToWstring(bytes.error())
    );

    return std::make_pair<
      common::optional<std::vector<std::uint8_t> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return std::make_pair<
    common::optional<std::vector<std::uint8_t> >,
    common::optional<DeserializationError>
  >(
    std::move(*bytes),
    common::nullopt
  );
}

/**
 * Get the property `modelType` from the JSON value expected as a JSON object.
 */
std::pair<
  const std::string*,
  common::optional<DeserializationError>
> GetModelTypeFrom(
  const nlohmann::json& json
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      const std::string*,
      common::optional<DeserializationError>
    >(
      nullptr,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      const std::string*,
      common::optional<DeserializationError>
    >(
      nullptr,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  const nlohmann::json& model_type_prop = json["modelType"];
  if (!model_type_prop.is_string()) {
    std::wstring message = common::Concat(
      L"Expected modelType to be a string, but got: ",
      common::Utf8ToWstring(model_type_prop.type_name())
    );

    common::optional<DeserializationError> error(
      common::make_optional<DeserializationError>(
        message
      )
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    // NOTE (mristin):
    // We have to explicitly use the constructor instead of std::make_pair
    // as `const std::string*` can not be automatically converted to a rvalue.
    return std::pair<
      const std::string*,
      common::optional<DeserializationError>
    >(
      nullptr,
      error
    );
  }

  static_assert(
    std::is_same<nlohmann::json::string_t, std::string>::value,
    "Expected nlohmann::json::string_t to equal std::string, but it does not."
  );

  const std::string* model_type(
    model_type_prop.get_ptr<const std::string*>()
  );

  // NOTE (mristin):
  // We have to explicitly use the constructor instead of std::make_pair
  // as `const std::string*` can not be automatically converted to a rvalue.
  return std::pair<
    const std::string*,
    common::optional<DeserializationError>
  >(
    model_type,
    common::nullopt
  );
}

/**
 * \brief Deserialize concretely an instance
 * of types::IMyClass.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IMyClass>
  >,
  common::optional<DeserializationError>
> DeserializeMyClass(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IListOfPrimitives.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IListOfPrimitives>
  >,
  common::optional<DeserializationError>
> DeserializeListOfPrimitives(
  const nlohmann::json& json,
  bool additional_properties
);

std::set<std::string> kPropertiesInMyClass = {
  
};

std::pair<
  common::optional<
    std::shared_ptr<types::IMyClass>
  >,
  common::optional<DeserializationError>
> DeserializeMyClass(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IMyClass> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInMyClass.find(key_val.key())
      );
      if (it == kPropertiesInMyClass.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IMyClass> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IMyClass>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::MyClass()
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInListOfPrimitives = {
  "strings",
  "integers",
  "booleans",
  "classes"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IListOfPrimitives>
  >,
  common::optional<DeserializationError>
> DeserializeListOfPrimitives(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInListOfPrimitives.find(key_val.key())
      );
      if (it == kPropertiesInListOfPrimitives.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IListOfPrimitives> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("strings")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property strings is missing"
      )
    );
  }

  if (!json.contains("integers")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property integers is missing"
      )
    );
  }

  if (!json.contains("booleans")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property booleans is missing"
      )
    );
  }

  if (!json.contains("classes")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property classes is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::vector<std::wstring> > the_strings;

  common::optional<std::vector<int64_t> > the_integers;

  common::optional<std::vector<bool> > the_booleans;

  common::optional<
    std::vector<
      std::shared_ptr<types::IMyClass>
    >
  > the_classes;

  // endregion Initialization

  // region De-serialize strings

  const nlohmann::json& json_strings(
    json["strings"]
  );
  if (!json_strings.is_array()) {
    error = common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected an array, but got: ",
        common::Utf8ToWstring(
          json_strings.type_name()
        )
      )
    );

    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"strings"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_strings = common::make_optional<
    std::vector<
      std::shared_ptr<std::wstring>
    >
  >();

  the_strings->reserve(json_strings.size());

  size_t index_strings = 0;

  for (
    const nlohmann::json& item
    : json_strings
  ) {
    common::optional<
      std::shared_ptr<std::wstring>
    > deserialized;

    std::tie(
      deserialized,
      error
    ) = DeserializeWstring(
      item,
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<IndexSegment>(
          index_strings
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"strings"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IListOfPrimitives> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_strings->emplace_back(
      std::move(*deserialized)
    );

    ++index_strings;
  }

  // endregion De-serialize strings

  // region De-serialize integers

  const nlohmann::json& json_integers(
    json["integers"]
  );
  if (!json_integers.is_array()) {
    error = common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected an array, but got: ",
        common::Utf8ToWstring(
          json_integers.type_name()
        )
      )
    );

    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"integers"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_integers = common::make_optional<
    std::vector<
      std::shared_ptr<int64_t>
    >
  >();

  the_integers->reserve(json_integers.size());

  size_t index_integers = 0;

  for (
    const nlohmann::json& item
    : json_integers
  ) {
    common::optional<
      std::shared_ptr<int64_t>
    > deserialized;

    std::tie(
      deserialized,
      error
    ) = DeserializeInt64(
      item,
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<IndexSegment>(
          index_integers
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"integers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IListOfPrimitives> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_integers->emplace_back(
      std::move(*deserialized)
    );

    ++index_integers;
  }

  // endregion De-serialize integers

  // region De-serialize booleans

  const nlohmann::json& json_booleans(
    json["booleans"]
  );
  if (!json_booleans.is_array()) {
    error = common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected an array, but got: ",
        common::Utf8ToWstring(
          json_booleans.type_name()
        )
      )
    );

    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"booleans"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_booleans = common::make_optional<
    std::vector<
      std::shared_ptr<bool>
    >
  >();

  the_booleans->reserve(json_booleans.size());

  size_t index_booleans = 0;

  for (
    const nlohmann::json& item
    : json_booleans
  ) {
    common::optional<
      std::shared_ptr<bool>
    > deserialized;

    std::tie(
      deserialized,
      error
    ) = DeserializeBool(
      item,
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<IndexSegment>(
          index_booleans
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"booleans"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IListOfPrimitives> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_booleans->emplace_back(
      std::move(*deserialized)
    );

    ++index_booleans;
  }

  // endregion De-serialize booleans

  // region De-serialize classes

  const nlohmann::json& json_classes(
    json["classes"]
  );
  if (!json_classes.is_array()) {
    error = common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected an array, but got: ",
        common::Utf8ToWstring(
          json_classes.type_name()
        )
      )
    );

    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"classes"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IListOfPrimitives> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_classes = common::make_optional<
    std::vector<
      std::shared_ptr<types::IMyClass>
    >
  >();

  the_classes->reserve(json_classes.size());

  size_t index_classes = 0;

  for (
    const nlohmann::json& item
    : json_classes
  ) {
    common::optional<
      std::shared_ptr<types::IMyClass>
    > deserialized;

    std::tie(
      deserialized,
      error
    ) = DeserializeMyClass(
      item,
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<IndexSegment>(
          index_classes
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"classes"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IListOfPrimitives> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_classes->emplace_back(
      std::move(*deserialized)
    );

    ++index_classes;
  }

  // endregion De-serialize classes

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IListOfPrimitives>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ListOfPrimitives(
        std::move(*the_strings),
        std::move(*the_integers),
        std::move(*the_booleans),
        std::move(*the_classes)
      )
    ),
    common::nullopt
  );
}

common::expected<
  std::shared_ptr<types::IMyClass>,
  DeserializationError
> MyClassFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IMyClass>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeMyClass(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IListOfPrimitives>,
  DeserializationError
> ListOfPrimitivesFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IListOfPrimitives>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeListOfPrimitives(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

// endregion De-serialization

// region Serialization

/**
 * \brief Represent a serialization error.
 *
 * We use this error internally to avoid unnecessary stack unwinding,
 * but throw the \ref SerializationException at the final site of
 * the serialization for the user.
 */
struct SerializationError {
  /**
   * Human-readable description of the error
   */
  std::wstring cause;

  /**
   * Path to the value that caused the error
   */
  iteration::Path path;

  explicit SerializationError(
    std::wstring a_cause
  ) : cause(std::move(a_cause)) {
    // Intentionally empty.
  }
};  // struct SerializationError

// region SerializationException

std::string RenderSerializationErrorMessage(
  const std::wstring& cause,
  const iteration::Path& path
) {
  return common::WstringToUtf8(
    common::Concat(
      L"Serialization failed at ",
      path.ToWstring(),
      L": ",
      cause
    )
  );
}

SerializationException::SerializationException(
  std::wstring cause,
  iteration::Path path
) :
  cause_(std::move(cause)),
  path_(std::move(path)),
  msg_(RenderSerializationErrorMessage(cause, path)) {
  // Intentionally empty.
}

const char* SerializationException::what() const noexcept {
  return msg_.c_str();
}

const std::wstring& SerializationException::cause() const noexcept {
  return cause_;
}

const iteration::Path& SerializationException::path() const noexcept {
  return path_;
}

// endregion SerializationException

/**
 * \brief Serialize the given number to a JSON value.
 *
 * We verify that the integer is within the range representable by 64-bit floats
 * for interoperability with other de-serializers.
 */
std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeInt64(int64_t value) {
  if (
    value < -9007199254740991L
    || value > 9007199254740991L
  ) {
    const std::wstring message = common::Concat(
      L"The integer ",
      std::to_wstring(value),
      L" can not be serialized to JSON "
      L"as it is outside the range [-2^53 + 1, 2^53 - 1] and can not "
      L"be exactly represented as a 64-bit floating point number."
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      common::make_optional<SerializationError>(
        message
      )
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(value),
    common::nullopt
  );
}

/**
 * Serialize the given text to a JSON value.
 */
nlohmann::json SerializeWstring(
  const std::wstring& text
) {
  return nlohmann::json(
    common::WstringToUtf8(text)
  );
}

/**
 * Serialize the given bytes to a JSON value.
 */
nlohmann::json SerializeByteArray(
  const std::vector<std::uint8_t>& bytes
) {
  return nlohmann::json(
    std::move(
      stringification::Base64Encode(bytes)
    )
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeIClass(
  const types::IClass& that
);

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeMyClass(
  const types::IMyClass& that
) {
  nlohmann::json result = nlohmann::json::object();

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeListOfPrimitives(
  const types::IListOfPrimitives& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  nlohmann::json json_strings = nlohmann::json::array();
  json_strings.get_ptr<nlohmann::json::array_t*>()->reserve(
    that.strings().size()
  );
  size_t index_strings = 0;
  for (
    const std::wstring& item
    : that.strings()
  ) {
    common::optional<nlohmann::json> json_item;
    std::tie(
      json_item,
      error
    ) = SerializeIClass(*item);

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          index_strings
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kStrings
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    json_strings.emplace_back(
      std::move(*json_item)
    );

    ++index_strings;
  }
  result["strings"] = std::move(
    json_strings
  );

  nlohmann::json json_integers = nlohmann::json::array();
  json_integers.get_ptr<nlohmann::json::array_t*>()->reserve(
    that.integers().size()
  );
  size_t index_integers = 0;
  for (
    int64_t item
    : that.integers()
  ) {
    common::optional<nlohmann::json> json_item;
    std::tie(
      json_item,
      error
    ) = SerializeIClass(*item);

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          index_integers
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIntegers
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    json_integers.emplace_back(
      std::move(*json_item)
    );

    ++index_integers;
  }
  result["integers"] = std::move(
    json_integers
  );

  nlohmann::json json_booleans = nlohmann::json::array();
  json_booleans.get_ptr<nlohmann::json::array_t*>()->reserve(
    that.booleans().size()
  );
  size_t index_booleans = 0;
  for (
    bool item
    : that.booleans()
  ) {
    common::optional<nlohmann::json> json_item;
    std::tie(
      json_item,
      error
    ) = SerializeIClass(*item);

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          index_booleans
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kBooleans
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    json_booleans.emplace_back(
      std::move(*json_item)
    );

    ++index_booleans;
  }
  result["booleans"] = std::move(
    json_booleans
  );

  nlohmann::json json_classes = nlohmann::json::array();
  json_classes.get_ptr<nlohmann::json::array_t*>()->reserve(
    that.classes().size()
  );
  size_t index_classes = 0;
  for (
    const std::shared_ptr<types::IMyClass>& item
    : that.classes()
  ) {
    common::optional<nlohmann::json> json_item;
    std::tie(
      json_item,
      error
    ) = SerializeIClass(*item);

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          index_classes
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kClasses
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    json_classes.emplace_back(
      std::move(*json_item)
    );

    ++index_classes;
  }
  result["classes"] = std::move(
    json_classes
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeIClass(
  const types::IClass& that
) {
  switch (that.model_type()) {
    case types::ModelType::kMyClass:
      return SerializeMyClass(
        dynamic_cast<const types::IMyClass&>(that)
      );
    case types::ModelType::kListOfPrimitives:
      return SerializeListOfPrimitives(
        dynamic_cast<const types::IListOfPrimitives&>(that)
      );
    default: {
      std::string message = common::Concat(
        "Unexpected model type: ",
        std::to_string(
          static_cast<std::uint32_t>(
            that.model_type()
          )
        )
      );

      throw std::invalid_argument(message);
    }
  };
}

nlohmann::json Serialize(
  const types::IClass& that
) {
  common::optional<nlohmann::json> result;
  common::optional<SerializationError> error;

  std::tie(
    result,
    error
  ) = SerializeIClass(that);

  if (error.has_value()) {
    throw SerializationException(
      std::move(error->cause),
      std::move(error->path)
    );
  }

  return std::move(*result);
}

// endregion Serialization

}  // namespace jsonization
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
