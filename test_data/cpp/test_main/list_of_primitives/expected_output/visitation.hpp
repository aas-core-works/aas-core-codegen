#ifndef AAS_CORE_AAS_3_0_VISITATION_GUARD_
#define AAS_CORE_AAS_3_0_VISITATION_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/types.hpp"

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup visitation Iterate and modify instances through visitors.
 * @{
 */
namespace visitation {

/**
 * Provide an interface for a recursive mutating visitor on an instance.
 */
class IVisitor {
 public:
  /**
   * Visit \p that instance and recursively visit all the instances
   * referenced from \p that instance.
   *
   * We use const references to shared pointers here for efficiency in case you want,
   * say, to share ownership over instances in your own external containers. Since
   * we do not make copies of the shared pointers, it is very important that
   * the given shared pointers outlive the visitor, lest cause undefined behavior.
   * See these StackOverflow questions:
   * * https://stackoverflow.com/questions/12002480/passing-stdshared-ptr-to-constructors/12002668#12002668
   * * https://stackoverflow.com/questions/3310737/should-we-pass-a-shared-ptr-by-reference-or-by-value
   * * https://stackoverflow.com/questions/37610494/passing-const-shared-ptrt-versus-just-shared-ptrt-as-parameter
   *
   * Changing the references during the visitation results in undefined
   * behavior. This follows how STL deals with modifications to containers, see:
   * https://stackoverflow.com/questions/6438086/iterator-invalidation-rules-for-c-containers
   *
   * \param that instance to be visited recursively
   */
  virtual void Visit(const std::shared_ptr<types::IClass>& that) = 0;
  virtual ~IVisitor() = default;

 protected:
  virtual void VisitMyClass(
    const std::shared_ptr<types::IMyClass>& that
  ) = 0;
  virtual void VisitListOfPrimitives(
    const std::shared_ptr<types::IListOfPrimitives>& that
  ) = 0;
};  // class IVisitor

/**
 * Provide an abstract recursive mutating visitor on an instance.
 */
class AbstractVisitor
    : public IVisitor {
 public:
  void Visit(const std::shared_ptr<types::IClass>& that) override;
  ~AbstractVisitor() override = default;
};  // class AbstractVisitor

/**
 * \brief Provide a mutating, recursive and no-op visitor on an instance.
 *
 * Usually, you want to inherit from this visitor and override one or more of its
 * visitation methods.
 */
class PassThroughVisitor
    : public AbstractVisitor {
 public:
  ~PassThroughVisitor() override = default;

 protected:
  void VisitMyClass(
    const std::shared_ptr<types::IMyClass>& that
  ) override;
  void VisitListOfPrimitives(
    const std::shared_ptr<types::IListOfPrimitives>& that
  ) override;
};  // class PassThroughVisitor

}  // namespace visitation
/**@*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_VISITATION_GUARD_
