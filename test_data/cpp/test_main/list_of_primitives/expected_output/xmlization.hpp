#ifndef AAS_CORE_AAS_3_0_XMLIZATION_GUARD_
#define AAS_CORE_AAS_3_0_XMLIZATION_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/iteration.hpp"
#include "aas_core/aas_3_0/types.hpp"

#pragma warning(push, 0)
#include <deque>
#include <memory>
#include <string>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup xmlization De/serialize instances from and to XML.
 * @{
 */
namespace xmlization {

/**
 * Specify the expected XML namespace of all the XML elements.
 */
extern const std::string kNamespace;

/**
 * Represent a segment of an XPath to an erroneous value.
 */
class ISegment {
 public:
  /**
   * \brief Convert the segment to a string in an XPath.
   *
   * The result is escaped such that it can be directly inserted
   * into an XPath.
   */
  virtual std::wstring ToWstring() const = 0;

  virtual std::unique_ptr<ISegment> Clone() const = 0;

  virtual ~ISegment() = default;
};  // class ISegment

/**
 * Represent an element on an XPath to the erroneous value.
 */
struct ElementSegment : public ISegment {
  /**
   * \brief Name of the XML element, without the namespace
   *
   * We deliberately omit the namespace in the tag names. If you want to actually
   * query with the resulting XPath, you have to insert the namespaces manually.
   * We did not know how to include the namespace in a meaningful way, as XPath
   * assumes namespace prefixes to be defined <em>outside</em> of the document.
   * At least the path thus rendered is informative, and you should be able to
   * descend it manually.
   */
  std::wstring name;

  ElementSegment(
    std::wstring a_name
  );

  std::wstring ToWstring() const override;

  std::unique_ptr<ISegment> Clone() const override;

  ~ElementSegment() override = default;
};  // struct ElementSegment

/**
 * Represent an element in a sequence on an XPath to the erroneous value.
 */
struct IndexSegment : public ISegment {
  /**
   * Index of the element in the sequence
   */
  size_t index;

  explicit IndexSegment(
    size_t an_index
  );

  std::wstring ToWstring() const override;

  std::unique_ptr<ISegment> Clone() const override;

  ~IndexSegment() override = default;
};  // struct IndexSegment

/**
 * Represent the relative XPath to the erroneous element.
 */
struct Path {
  std::deque<std::unique_ptr<ISegment> > segments;

  Path();
  Path(const Path& other);
  Path(Path&& other);
  Path& operator=(const Path& other);
  Path& operator=(Path&& other);

  std::wstring ToWstring() const;
};  // struct Path

// region De-serialization

/**
 * Represent a de-serialization error.
 */
struct DeserializationError {
  /**
   * Human-readable description of the error
   */
  std::wstring cause;

  /**
   * Path to the erroneous value
   */
  Path path;

  explicit DeserializationError(std::wstring a_cause);
  DeserializationError(std::wstring a_cause, Path a_path);
};  // struct DeserializationError

struct ReadingOptions {
  /**
   * No XML attributes are expected in XML elements.
   * Usually, attributes are considered errors and reported as such. However,
   * some implementations add their own custom attributes, and we sometimes
   * still want to parse such XML. If `additional_attributes` is set,
   * the unexpected XML attributes will be ignored during parsing, and not
   * reported.
   */
  bool additional_attributes = false;

  /**
   * Size of the chunk to be read from the input stream and passed to
   * the XML parser.
   */
  size_t buffer_size = 1024;
};  // struct ReadingOptions

/**
 * Deserialize the instance from an XML read from the stream \p is.
 *
 * \param is stream of ASCII, ISO-8859-1 or UTF-8-encoded characters to read XML from
 * \param options reading options to be tweaked for special cases. The defaults should
 * work in most cases.
 * \return the parsed instance, or an error if any
 */
common::expected<
  std::shared_ptr<types::IClass>,
  DeserializationError
> From(
  std::istream& is,
  const ReadingOptions& options = {}
);

/**
 * Deserialize an instance of types::IMyClass from an XML
 * read from the stream \p is.
 *
 * \param is stream to read XML from
 * \param options reading options to be tweaked for special cases. The defaults should
 * work in most cases.
 * \return the parsed types::IMyClass, or an error if any
 */
common::expected<
  std::shared_ptr<types::IMyClass>,
  DeserializationError
> MyClassFrom(
  std::istream& is,
  const ReadingOptions& options = {}
);

/**
 * Deserialize an instance of types::IListOfPrimitives from an XML
 * read from the stream \p is.
 *
 * \param is stream to read XML from
 * \param options reading options to be tweaked for special cases. The defaults should
 * work in most cases.
 * \return the parsed types::IListOfPrimitives, or an error if any
 */
common::expected<
  std::shared_ptr<types::IListOfPrimitives>,
  DeserializationError
> ListOfPrimitivesFrom(
  std::istream& is,
  const ReadingOptions& options = {}
);

// endregion Deserialization

// region Serialization

/**
 * Represent an error in the serialization of an instance to XML.
 */
class SerializationException : public std::exception {
 public:
  SerializationException(
    std::wstring cause
  );

  SerializationException(
    std::wstring cause,
    iteration::Path path
  );

  const char* what() const noexcept override;

  const std::wstring& cause() const noexcept;
  const iteration::Path& path() const noexcept;

  ~SerializationException() noexcept override = default;

 private:
  const std::wstring cause_;
  const iteration::Path path_;
  const std::string msg_;
};  // class SerializationException

/**
 * \brief Customize how instances should be serialized to XML.
 *
 * We selected the defaults so that they can be used when you serialize to
 * a file.
 *
 * Usually, you want to write the namespace at the root element, and no
 * prefixes are written in the XML names. However, if you are embedding
 * the XML in a larger XML structure, you specify the namespace
 * aliases and then use them as XML name prefixes. The prefix usually ends
 * with a full colon (`:`).
 *
 * We can not imagine in what situation you would want to write both
 * the namespace <em>and</em> the prefix. Nevertheless, we allow for that
 * possibility and do not throw any exception if you specify the both.
 */
struct WritingOptions {
  /**
   * If set, the XML declaration is written at the beginning.
   */
  bool write_declaration = true;

  /**
   * If set, the root XML element is written with the XML namespace
   * set as the XML attribute `xmlns`.
   */
  bool write_namespace = true;

  /**
   * The prefix is prepended to the name of each XML element.
   */
   std::string prefix = "";
};  // struct WritingOptions

/**
 * \brief Serialize \p that instance to XML.
 *
 * \param that instance to be serialized
 * \param options  to be tweaked for special cases. The defaults should
 * work in most cases.
 * \param os The UTF8-encoded output stream where XML will be written
 * \throw \ref SerializationException if \p that instance could not be serialized
 */
void Serialize(
  const types::IClass& that,
  const WritingOptions& options,
  std::ostream& os
);

// endregion Serialization

}  // namespace xmlization
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_XMLIZATION_GUARD_
