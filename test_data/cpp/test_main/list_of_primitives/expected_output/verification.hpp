#ifndef AAS_CORE_AAS_3_0_VERIFICATION_GUARD_
#define AAS_CORE_AAS_3_0_VERIFICATION_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/iteration.hpp"
#include "aas_core/aas_3_0/pattern.hpp"
#include "aas_core/aas_3_0/types.hpp"

#pragma warning(push, 0)
#include <set>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup verification Verify that instances conform to the meta-model constraints.
 * @{
 */
namespace verification {

// region Forward declarations
class Iterator;
class IVerification;

namespace impl {
class IVerificator;
}  // namespace impl
// endregion Forward declarations

/**
 * Represent a verification error in an instance.
 */
struct Error {
  /**
   * Human-readable description of the error
   */
  std::wstring cause;

  /**
   * Path to the erroneous value
   */
  iteration::Path path;

  explicit Error(std::wstring a_cause);
  Error(std::wstring a_cause, iteration::Path a_path);
};  // struct Error

/**
 * \brief Iterate over the verification errors.
 *
 * The user is expected to take ownership of the errors if they need to be further
 * processed.
 *
 * Unlike STL, this is <em>not</em> a light-weight iterator. We implement
 * a "yielding" iterator by leveraging code generation so that we always keep
 * the model stack as well as the properties verified thus far.
 *
 * This means that copy-construction and equality comparisons are much more heavy-weight
 * than you'd usually expect from an STL iterator. For example, if you want to sort
 * the errors by some criterion, you are most probably faster if you populate a vector,
 * and then sort the vector.
 *
 * Also, given that this iterator is not light-weight, you should in almost all cases
 * avoid the postfix increment (it++) and prefer the prefix one (++it) as the postfix
 * increment would create an iterator copy every time.
 *
 * We follow the C++ standard, and assume that comparison between the two iterators
 * over two different collections results in undefined behavior. See
 * http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2948.html and
 * https://stackoverflow.com/questions/4657513/comparing-iterators-from-different-containers.
 */
class Iterator {
  using iterator_category = std::forward_iterator_tag;
  /// The difference is meaningless, but has to be defined.
  using difference_type = std::ptrdiff_t;
  using value_type = Error;
  using pointer = const Error*;
  using reference = const Error&;

 public:
  explicit Iterator(
    std::unique_ptr<impl::IVerificator> verificator
  ) :
  verificator_(std::move(verificator)) {
      // Intentionally empty.
  }

  Iterator(const Iterator& other);
  Iterator(Iterator&& other);

  Iterator& operator=(const Iterator& other);
  Iterator& operator=(Iterator&& other);

  reference operator*() const;
  pointer operator->() const;

  // Prefix increment
  Iterator& operator++();

  // Postfix increment
  Iterator operator++(int);

  friend bool operator==(const Iterator& a, const Iterator& b);
  friend bool operator!=(const Iterator& a, const Iterator& b);

 private:
  std::unique_ptr<impl::IVerificator> verificator_;
};

bool operator==(const Iterator& a, const Iterator& b);

bool operator!=(const Iterator& a, const Iterator& b);

/// \cond HIDDEN
namespace impl {
class IVerificator {
 public:
  virtual void Start() = 0;
  virtual void Next() = 0;
  virtual bool Done() const = 0;

  virtual const Error& Get() const = 0;
  virtual Error& GetMutable() = 0;
  virtual long Index() const = 0;

  virtual std::unique_ptr<IVerificator> Clone() const = 0;

  virtual ~IVerificator() = default;
};  // class IVerificator
}  // namespace impl
/// \endcond

class IVerification {
 public:
  virtual Iterator begin() const = 0;
  virtual const Iterator& end() const = 0;
  virtual ~IVerification() = default;
};  // class IVerification

/**
 * \brief Verify that the instance conforms to the meta-model constraints.
 *
 * Do not proceed to verify the instances referenced from
 * the given instance.
 *
 * Range-based loops should fit the vast majority of the use cases:
 * \code
 * std::shared_ptr<types::Environment> env = ...;
 * for (const Error& error : NonRecursiveVerification(env)) {
 *   report_somehow(error);
 * }
 * \endcode
 *
 * We use const references to shared pointers here for efficiency. Since
 * we do not make a copy of \p that shared pointer, it is very important that
 * the given shared pointer outlives the verification, lest cause undefined behavior.
 * See these StackOverflow questions:
 * * https://stackoverflow.com/questions/12002480/passing-stdshared-ptr-to-constructors/12002668#12002668
 * * https://stackoverflow.com/questions/3310737/should-we-pass-a-shared-ptr-by-reference-or-by-value
 * * https://stackoverflow.com/questions/37610494/passing-const-shared-ptrt-versus-just-shared-ptrt-as-parameter
 */
class NonRecursiveVerification : public IVerification {
 public:
  NonRecursiveVerification(
    const std::shared_ptr<types::IClass>& instance
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~NonRecursiveVerification() override = default;
 private:
  const std::shared_ptr<types::IClass>& instance_;
};  // class NonRecursiveVerification

/**
 * \brief Verify that the instance conforms to the meta-model constraints.
 *
 * Also verify recursively all the instances referenced from
 * the given instance.
 *
 * Range-based loops should fit the vast majority of the use cases:
 * \code
 * std::shared_ptr<types::Environment> env = ...;
 * for (const Error& error : RecursiveVerification(env)) {
 *   report_somehow(error);
 * }
 * \endcode
 *
 * We use const references to shared pointers here for efficiency. Since
 * we do not make a copy of \p that shared pointer, it is very important that
 * the given shared pointer outlives the verification, lest cause undefined behavior.
 * See these StackOverflow questions:
 * * https://stackoverflow.com/questions/12002480/passing-stdshared-ptr-to-constructors/12002668#12002668
 * * https://stackoverflow.com/questions/3310737/should-we-pass-a-shared-ptr-by-reference-or-by-value
 * * https://stackoverflow.com/questions/37610494/passing-const-shared-ptrt-versus-just-shared-ptrt-as-parameter
 */
class RecursiveVerification : public IVerification {
 public:
  RecursiveVerification(
    const std::shared_ptr<types::IClass>& instance
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~RecursiveVerification() override = default;
 private:
  const std::shared_ptr<types::IClass>& instance_;
};  // class RecursiveVerification

}  // namespace verification
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_VERIFICATION_GUARD_
