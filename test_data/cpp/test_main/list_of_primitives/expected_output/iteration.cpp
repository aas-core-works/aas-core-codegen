// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/iteration.hpp"

namespace aas_core {
namespace aas_3_0 {
namespace iteration {

// region Pathing

/**
 * Translate the enumeration literal \p property to text.
 *
 * \param property to be converted into text
 * \return text representation of \p property
 * \throw std::invalid_argument if \p property invalid
 */
std::wstring PropertyToWstring(
  Property property
) {
  switch (property) {
    case Property::kBooleans:
      return L"booleans";
    case Property::kClasses:
      return L"classes";
    case Property::kIntegers:
      return L"integers";
    case Property::kStrings:
      return L"strings";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected property literal: ",
          std::to_string(
            static_cast<std::uint32_t>(property)
          )
        )
      );
  }
}  // function to_wstring

// region struct PropertySegment

PropertySegment::PropertySegment(Property a_property) {
  property = a_property;
}

std::wstring PropertySegment::ToWstring() const {
  return common::Concat(
    L".",
    PropertyToWstring(property)
  );
}

std::unique_ptr<ISegment> PropertySegment::Clone() const {
  return common::make_unique<PropertySegment>(*this);
}

// endregion struct PropertySegment

// region struct IndexSegment

IndexSegment::IndexSegment(size_t an_index) {
  index = an_index;
}

std::wstring IndexSegment::ToWstring() const {
  return common::Concat(
    L"[",
    std::to_wstring(index),
    L"]"
  );
}

std::unique_ptr<ISegment> IndexSegment::Clone() const {
  return common::make_unique<IndexSegment>(*this);
}

// endregion struct IndexSegment

// region struct Path

Path::Path() {
  // Intentionally empty.
}

Path::Path(const Path& other) {
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
}

Path::Path(Path&& other) {
  segments = std::move(other.segments);
}

Path& Path::operator=(const Path& other) {
  segments.clear();
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
  return *this;
}

Path& Path::operator=(Path&& other) {
  if (this != &other) {
    segments = std::move(other.segments);
  }
  return *this;
}

std::wstring Path::ToWstring() const {
  std::vector<std::wstring> parts;
  parts.reserve(segments.size());

  for (const std::unique_ptr<ISegment>& segment : segments ) {
    parts.emplace_back(segment->ToWstring());
  }

  size_t size = 0;
  for (const std::wstring& part : parts) {
    size += part.size();
  }

  std::wstring result;
  result.reserve(size);
  for (const std::wstring& part : parts) {
    result.append(part);
  }

  return result;
}

// endregion struct Path

// endregion Pathing

// region Non-recursive iteration

/**
 * This iterator is always done as IMyClass
 * references no other instances.
 */
class IteratorOverMyClass : public impl::IIterator {
 public:
  IteratorOverMyClass(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverMyClass, "
      "but the iterator is always done as "
      "IMyClass "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverMyClass, "
      "but the iterator is always done as "
      "IMyClass references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverMyClass>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverMyClass, "
      "but the iterator is always done as "
      "IMyClass references "
      "no other instances."
    );
  }

  ~IteratorOverMyClass() override = default;
};  // class IteratorOverMyClass

// region Non-recursive iteration over IListOfPrimitives

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverListOfPrimitives : public impl::IIterator {
 public:
  IteratorOverListOfPrimitives(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverListOfPrimitives() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IListOfPrimitives* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverListOfPrimitives

IteratorOverListOfPrimitives::IteratorOverListOfPrimitives(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IListOfPrimitives*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverListOfPrimitives::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverListOfPrimitives::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverListOfPrimitives, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverListOfPrimitives::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverListOfPrimitives::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverListOfPrimitives, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverListOfPrimitives::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverListOfPrimitives, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverListOfPrimitives::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverListOfPrimitives, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverListOfPrimitives, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverListOfPrimitives::Clone() const {
  return common::make_unique<IteratorOverListOfPrimitives>(*this);
}

void IteratorOverListOfPrimitives::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        property_ = Property::kStrings;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->strings().size())) {
          state_ = 3;
          continue;
        }

        const std::vector<std::wstring>& the_strings(
          casted_->strings()
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_strings[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();

        property_ = Property::kIntegers;

        cursor_ = 0;
      }

      case 4: {
        if (!(*cursor_ < casted_->integers().size())) {
          state_ = 6;
          continue;
        }

        const std::vector<int64_t>& the_integers(
          casted_->integers()
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_integers[*cursor_]
          )
        );
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        ++(*cursor_);

        state_ = 4;
        continue;
      }

      case 6: {
        cursor_.reset();

        property_ = Property::kBooleans;

        cursor_ = 0;
      }

      case 7: {
        if (!(*cursor_ < casted_->booleans().size())) {
          state_ = 9;
          continue;
        }

        const std::vector<bool>& the_booleans(
          casted_->booleans()
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_booleans[*cursor_]
          )
        );
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        ++(*cursor_);

        state_ = 7;
        continue;
      }

      case 9: {
        cursor_.reset();

        property_ = Property::kClasses;

        cursor_ = 0;
      }

      case 10: {
        if (!(*cursor_ < casted_->classes().size())) {
          state_ = 12;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IMyClass>
        >& the_classes(
          casted_->classes()
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_classes[*cursor_]
          )
        );
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        ++(*cursor_);

        state_ = 10;
        continue;
      }

      case 12: {
        cursor_.reset();

        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 13;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

/**
 * This iterator is always done.
 *
 * It is used for efficient comparisons against end-of-descent.
 */
class AlwaysDoneIterator : public impl::IIterator {
 public:
  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move an AlwaysDoneIterator, "
      "but the iterator is always done, as its name suggests."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an AlwaysDoneIterator, "
      "but the iterator is always done, as its name suggests."
    );
  }

  std::unique_ptr<IIterator> Clone() const override {
    return common::make_unique<AlwaysDoneIterator>(*this);
  };

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an AlwaysDoneIterator, "
      "but the iterator is always done, as its name suggests."
    );
  }

  long Index() const override {
    return -1;
  }

  ~AlwaysDoneIterator() override = default;
};  // class AlwaysDoneIterator

/**
 * Produce a non-recursive iterator over the instance given its runtime model type.
 */
std::unique_ptr<impl::IIterator> NewNonRecursiveIterator(
  const std::shared_ptr<types::IClass>& instance
) {
  switch (instance->model_type()) {
    case types::ModelType::kMyClass:
      return common::make_unique<IteratorOverMyClass>(
        instance
      );
    case types::ModelType::kListOfPrimitives:
      return common::make_unique<IteratorOverListOfPrimitives>(
        instance
      );
    default:
      throw std::logic_error(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(instance->model_type())
          )
        )
      );
  }
}

// endregion Non-recursive iteration

// region Recursive iteration

/**
 * Iterate recursively over the instance, including the instance in the iteration.
 *
 * This is a realisation of the following pseudo-code:
 * \code
 * stack = new Stack();
 * stack.push(instance);
 * while not stack.empty():
 *     instance = stack.pop()
 *     yield instance
 *
 *     it = new_non_recursive_iterator(instance)
 *     while not it.done():
 *         yield recursively from it.get()
 *         it.next()
 * \endcode
 */
class RecursiveInclusiveIterator : public impl::IIterator {
 public:
  RecursiveInclusiveIterator(
    const std::shared_ptr<types::IClass>& instance
  );

  RecursiveInclusiveIterator(
    const RecursiveInclusiveIterator& other
  );
  RecursiveInclusiveIterator(
    RecursiveInclusiveIterator&& other
  );
  RecursiveInclusiveIterator& operator=(
    const RecursiveInclusiveIterator& other
  );
  RecursiveInclusiveIterator& operator=(
    RecursiveInclusiveIterator&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~RecursiveInclusiveIterator() override = default;

 private:
  // The instance_ needs to be a pointer so that we can re-assign it in
  // the constructors and assignment operations.
  const std::shared_ptr<types::IClass>* instance_;

  // Iterator over the instances referenced from this instance
  // in the outer loop
  std::unique_ptr<impl::IIterator> non_recursive_iterator_;

  // Iterator for recursion into the reference referenced from this instance
  // in the inner loop
  std::unique_ptr<impl::IIterator> recursive_iterator_;

  const std::shared_ptr<types::IClass>* item_;

  bool done_;
  long index_;
  size_t state_;

  void Execute();
};  // class RecursiveInclusiveIterator

/**
 * Iterate recursively over the instance, excluding the instance in the iteration.
 *
 * This is a realisation of the following pseudo-code:
 * \code
 * stack = new Stack();
 * stack.push(instance);
 * while not stack.empty():
 *     some_instance = stack.pop()
 *     if some_instance is not instance:
 *         yield some_instance
 *
 *     it = new_non_recursive_iterator(some_instance)
 *     while not it.done():
 *         yield recursively from it.get()
 *         it.next()
 * \endcode
 */
class RecursiveExclusiveIterator : public impl::IIterator {
 public:
  RecursiveExclusiveIterator(
    const std::shared_ptr<types::IClass>& instance
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~RecursiveExclusiveIterator() override = default;

 private:
  RecursiveInclusiveIterator inclusive_iterator_;
};  // class RecursiveExclusiveIterator

// region RecursiveInclusiveIterator implementation

RecursiveInclusiveIterator::RecursiveInclusiveIterator(
  const std::shared_ptr<types::IClass>& instance
) : instance_(&instance), item_(nullptr), index_(-1) {
  // Intentionally empty.
}

RecursiveInclusiveIterator::RecursiveInclusiveIterator(
  const RecursiveInclusiveIterator& other
) {
  instance_ = other.instance_;
  non_recursive_iterator_ = (other.non_recursive_iterator_ == nullptr)
    ? nullptr
    : other.non_recursive_iterator_->Clone();
  recursive_iterator_ = (other.recursive_iterator_ == nullptr)
    ? nullptr
    : other.recursive_iterator_->Clone();
  item_ = other.item_;
  done_ = other.done_;
  index_ = other.index_;
  state_ = other.state_;
}

RecursiveInclusiveIterator::RecursiveInclusiveIterator(
  RecursiveInclusiveIterator&& other
) {
  instance_ = other.instance_;
  non_recursive_iterator_ = std::move(other.non_recursive_iterator_);
  recursive_iterator_ = std::move(other.recursive_iterator_);
  item_ = other.item_;
  done_ = other.done_;
  index_ = other.index_;
  state_ = other.state_;
}

RecursiveInclusiveIterator& RecursiveInclusiveIterator::operator=(
  const RecursiveInclusiveIterator& other
) {
  return *this = RecursiveInclusiveIterator(other);
}

RecursiveInclusiveIterator& RecursiveInclusiveIterator::operator=(
  RecursiveInclusiveIterator&& other
) {
  if (this != &other) {
    instance_ = other.instance_;
    non_recursive_iterator_ = std::move(other.non_recursive_iterator_);
    recursive_iterator_ = std::move(other.recursive_iterator_);
    item_ = other.item_;
    done_ = other.done_;
    index_ = other.index_;
    state_ = other.state_;
  }

  return *this;
}

void RecursiveInclusiveIterator::Start() {
  state_ = 0;
  Execute();

  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "Expected RecursiveInclusiveIterator not to be done at start, but it was."
    );
  }

  if (Index() !== 0) {
    throw std::logic_error(
      common::Concat(
        "Expected RecursiveInclusiveIterator::Index() to be 0 on Start()"
        ", but got ",
        std::to_string(Index())
      )
    );
  }

  const std::shared_ptr<IClass>& current_item(Get());
  if (current_item == nullptr) {
    throw std::logic_error(
      "Unexpected null pointer from Get() at the end of "
      "RecursiveInclusiveIterator::Start"
    );
  }

  if (current_item.get() != instance_.get()) {
    throw std::logic_error(
      common::Concat(
        "Expected the current item to point to the instance "
        "at the end of RecursiveInclusiveIterator::Start, "
        "but got ",
        std::to_string(current_item.get()),
        " from Get() instead of ",
        std::to_string(instance_.get())
      )
    );
  }
  #endif
}

void RecursiveInclusiveIterator::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a RecursiveInclusiveIterator, but it was done."
    );
  }
  #endif

  Execute();
}

bool RecursiveInclusiveIterator::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& RecursiveInclusiveIterator::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from RecursiveInclusiveIterator, but it was done."
    );
  }

  if (item_ == nullptr) {
    throw std::logic_error(
      "You want to get from a RecursiveInclusiveIterator, "
      "but item_ has not been set."
    );
  }
  #endif

  return *item_;
}

long RecursiveInclusiveIterator::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 on a done RecursiveInclusiveIterator, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void RecursiveInclusiveIterator::PrependToPath(Path* path) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from RecursiveInclusiveIterator, "
      "but the iterator was done."
    );
  }
  #endif

  if (Index() == 0) {
    // Index set to 0 indicates that the iterator points to the instance itself.
    // Therefore, there is nothing to prepend to the path.
    return;
  }

  if (recursive_iterator_ != nullptr) {
    recursive_iterator_->PrependToPath(path);
  }

  if (non_recursive_iterator_ != nullptr) {
    non_recursive_iterator_->PrependToPath(path);
  }
}

std::unique_ptr<impl::IIterator> RecursiveInclusiveIterator::Clone() const {
  return common::make_unique<RecursiveInclusiveIterator>(*this);
}

void RecursiveInclusiveIterator::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        item_ = instance_;
        index_ = 0;
        done_ = false;
        non_recursive_iterator_.reset(nullptr);
        recursive_iterator_.reset(nullptr);

        state_ = 1;
        return;
      }

      case 1: {
        non_recursive_iterator_ = NewNonRecursiveIterator(
          *instance_
        );

        non_recursive_iterator_->Start();
      }

      case 2: {
        if (!(!non_recursive_iterator_->Done())) {
          state_ = 7;
          continue;
        }

        item_ = &(non_recursive_iterator_->Get());
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        recursive_iterator_ = std::move(
          common::make_unique<RecursiveExclusiveIterator>(
            *item_
          )
        );

        recursive_iterator_->Start();
      }

      case 4: {
        if (!(!recursive_iterator_->Done())) {
          state_ = 6;
          continue;
        }

        item_ = &(recursive_iterator_->Get());
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        recursive_iterator_->Next();

        state_ = 4;
        continue;
      }

      case 6: {
        recursive_iterator_.reset(nullptr);

        non_recursive_iterator_->Next();

        state_ = 2;
        continue;
      }

      case 7: {
        non_recursive_iterator_.reset(nullptr);
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 8;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion RecursiveInclusiveIterator implementation

// region RecursiveExclusiveIterator implementation

RecursiveExclusiveIterator::RecursiveExclusiveIterator(
  const std::shared_ptr<types::IClass>& instance
) : inclusive_iterator_(instance) {
  // Intentionally empty.
}

void RecursiveExclusiveIterator::Start() {
  inclusive_iterator_.Start();

  #ifdef DEBUG
  if (inclusive_iterator_.Done()) {
    throw std::logic_error(
      "Expected the inclusive iterator to be not-done immediately after start, "
      "as the first item is expected to point to the instance itself, "
      "but the inclusive iterator was done."
    );
  }
  #endif

  // Simply skip the instance in the very first yield.
  inclusive_iterator_.Next();
}

void RecursiveExclusiveIterator::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a RecursiveExclusiveIterator, but it was done."
    );
  }
  #endif

  inclusive_iterator_.Next();
}

bool RecursiveExclusiveIterator::Done() const {
  return inclusive_iterator_.Done();
}

const std::shared_ptr<types::IClass>& RecursiveExclusiveIterator::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from RecursiveExclusiveIterator, but it was done."
    );
  }
  #endif

  return inclusive_iterator_.Get();
}

long RecursiveExclusiveIterator::Index() const {
  if (inclusive_iterator_.Done()) {
    return -1;
  }

  return inclusive_iterator_.Index() - 1;
}

void RecursiveExclusiveIterator::PrependToPath(Path* path) const {
  inclusive_iterator_.PrependToPath(path);
}

std::unique_ptr<impl::IIterator> RecursiveExclusiveIterator::Clone() const {
  return common::make_unique<RecursiveExclusiveIterator>(*this);
}

// endregion RecursiveExclusiveIterator implementation

// endregion Recursive iteration

// region Iterator facade

Iterator::Iterator(
  const Iterator& other
) : implementation_(other.implementation_->Clone()) {
  // Intentionally empty.
}

Iterator::Iterator(
  Iterator&& other
) : implementation_(std::move(other.implementation_)) {
  // Intentionally empty.
}

Iterator& Iterator::operator=(const Iterator& other) {
  return *this = Iterator(other);
}

Iterator& Iterator::operator=(Iterator&& other) {
  if (this != &other) {
    this->implementation_ = std::move(other.implementation_);
  }

  return *this;
}

const std::shared_ptr<types::IClass>& Iterator::operator*() const {
  if (implementation_->Done()) {
    throw std::logic_error(
      "You want to dereference a completed iterator."
    );
  }

  return implementation_->Get();
}

const std::shared_ptr<types::IClass>* Iterator::operator->() {
  if (implementation_->Done()) {
    throw std::logic_error(
      "You want to dereference a completed iterator."
    );
  }

  return &(implementation_->Get());
}

// Prefix increment
Iterator& Iterator::operator++() {
  if (implementation_->Done()) {
    throw std::logic_error(
      "You want to move a completed iterator."
    );
  }

  implementation_->Next();
  return *this;
}

// Postfix increment
Iterator Iterator::operator++(int) {
  Iterator result(*this);
  ++(*this);
  return result;
}

bool operator==(const Iterator& a, const Iterator& b) {
  return a.implementation_->Index() == b.implementation_->Index();
}

bool operator!=(const Iterator& a, const Iterator& b) {
  return a.implementation_->Index() != b.implementation_->Index();
}

Path MaterializePath(const Iterator& iterator) {
  if (iterator.implementation_->Done()) {
    throw std::logic_error(
      "You want to materialize path of a completed iterator."
    );
  }

  Path path;
  iterator.implementation_->PrependToPath(&path);
  return path;
}

void PrependToPath(const Iterator& iterator, Path* path) {
  if (iterator.implementation_->Done()) {
    throw std::logic_error(
      "You want to prepend a path of a completed iterator."
    );
  }

  iterator.implementation_->PrependToPath(path);
}

// endregion Iterator facade

// region Descents

// region Descent

// NOTE (mristin):
// We have to make a copy of the pointer since we would lose otherwise
// in range-based `for` loops,
// see: https://stackoverflow.com/questions/29990045/temporary-lifetime-in-range-for-expression
Descent::Descent(
  std::shared_ptr<types::IClass> instance
) : instance_(std::move(instance)) {
  // Intentionally empty.
}

Iterator Descent::begin() const {
  std::unique_ptr<impl::IIterator> it_impl(
    std::move(
      common::make_unique<RecursiveExclusiveIterator>(instance_)
    )
  );

  it_impl->Start();

  // NOTE(mristin):
  // We short-circuit here for memory frugality,
  // as we can immediately dispose it_impl.
  if (it_impl->Done()) {
    return end();
  }

  return Iterator(std::move(it_impl));
}

const Iterator& Descent::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneIterator>());
  return iterator;
}

// endregion Descent

// region DescentOnce

// NOTE (mristin):
// We have to make a copy of the pointer since we would lose otherwise
// in range-based `for` loops,
// see: https://stackoverflow.com/questions/29990045/temporary-lifetime-in-range-for-expression
DescentOnce::DescentOnce(
  std::shared_ptr<types::IClass> instance
) : instance_(std::move(instance)) {
  // Intentionally empty.
}

Iterator DescentOnce::begin() const {
  std::unique_ptr<impl::IIterator> it_impl(
    NewNonRecursiveIterator(instance_)
  );

  it_impl->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose it_impl.
  if (it_impl->Done()) {
    return Iterator(std::move(common::make_unique<AlwaysDoneIterator>()));
  }

  return Iterator(std::move(it_impl));
}

const Iterator& DescentOnce::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneIterator>());
  return iterator;
}

// endregion DescentOnce

// endregion Descents

}  // namespace iteration
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
