// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/stringification.hpp"
#include "aas_core/aas_3_0/wstringification.hpp"
#include "aas_core/aas_3_0/xmlization.hpp"

#pragma warning(push, 0)
#include <expat.h>

#include <cmath>
#include <cstdint>
#include <deque>
#include <memory>
#include <limits>
#include <unordered_map>
#include <string>
#include <vector>
#pragma warning(pop)

static_assert(
  !std::is_same<XML_Char, wchar_t>::value,
  "Expected Expat to be compiled with UTF-8 support, i.e., that character is "
  "stored as char internally, "
  "but Expat was compiled to store characters internally as UTF-16."
);

static_assert(
  std::is_same<XML_Char, char>::value,
  "Expected Expat to be compiled with UTF-8 support, i.e., that "
  "character is stored as char internally, "
  "but it was not."
);

namespace aas_core {
namespace aas_3_0 {
namespace xmlization {

const std::string kNamespace(  // NOLINT(cert-err58-cpp)
  "https://admin-shell.io/aas/3/0"
);

// region De-serialization

// region struct ElementSegment

ElementSegment::ElementSegment(
  std::wstring a_name
) :
  name(std::move(a_name)) {
  // Intentionally empty.
}

std::wstring ElementSegment::ToWstring() const {
  size_t out_len = 0;
  for (const wchar_t character : name) {
    switch (character) {
      // NOTE (mristin):
      // We use sizeof on *strings* instead of *wide strings* to get
      // the number of *characters*. Otherwise, if we used wide strings,
      // we would obtain the wrong number of characters with `sizeof`
      // as we would count bytes instead of characters, which differ
      // in wide strings due to encoding.

      case L'&': {
        out_len += sizeof("&amp;");
        break;
      }
      case L'/': {
        out_len += sizeof("&#47;");
        break;
      }
      case L'<': {
        out_len += sizeof("&lt;");
        break;
      }
      case L'>': {
        out_len += sizeof("&gt;");
        break;
      }
      case L'"': {
        out_len += sizeof("&quot;");
        break;
      }
      case L'\'': {
        out_len += sizeof("&apos;");
        break;
      }
      default:
        ++out_len;
        break;
    }
  }

  // NOTE (mristin):
  // We assume here that XML encoding is always *longer* than
  // the original text.
  if (out_len == name.size()) {
    return name;
  }

  std::wstring out;
  out.reserve(out_len);

  for (const wchar_t character : name) {
    switch (character) {
      case L'&':
        out.append(L"&amp;");
        break;
      case L'/':
        out.append(L"&#47;");
        break;
      case L'<':
      out.append(L"&lt;");
        break;
      case L'>':
        out.append(L"&gt;");
        break;
      case L'"':
        out.append(L"&quot;");
        break;
      case L'\'':
        out.append(L"&apos;");
        break;
      default:
        out.push_back(character);
        break;
    }
  }

  return out;
}

std::unique_ptr<ISegment> ElementSegment::Clone() const {
  return common::make_unique<ElementSegment>(*this);
}

// endregion struct ElementSegment

// region struct IndexSegment

IndexSegment::IndexSegment(
  size_t an_index
) :
  index(an_index) {
  // Intentionally empty.
}

std::wstring IndexSegment::ToWstring() const {
  return common::Concat(
    L"*[",
    std::to_wstring(index),
    L"]"
  );
}

std::unique_ptr<ISegment> IndexSegment::Clone() const {
  return common::make_unique<IndexSegment>(*this);
}

// endregion struct IndexSegment

// region struct Path

Path::Path() {
  // Intentionally empty.
}

Path::Path(const Path& other) {
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
}

Path::Path(Path&& other) {
  segments = std::move(other.segments);
}

Path& Path::operator=(const Path& other) {
  segments.clear();
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
  return *this;
}

Path& Path::operator=(Path&& other) {
  if (this != &other) {
    segments = std::move(other.segments);
  }
  return *this;
}

std::wstring Path::ToWstring() const {
  if (segments.empty()) {
    return L"";
  }

  std::vector<std::wstring> parts;
  parts.reserve(segments.size() * 2 - 1);

  auto it = segments.begin();

  parts.emplace_back((*it)->ToWstring());
  ++it;

  for (; it != segments.end(); ++it) {
    parts.emplace_back(L"/");
    parts.emplace_back((*it)->ToWstring());
  }

  size_t out_len = 0;
  for (const std::wstring& part : parts) {
    out_len += part.size();
  }

  std::wstring out;
  out.reserve(out_len);
  for (const std::wstring& part : parts) {
    out.append(part);
  }

  return out;
}

// region DeserializationError

DeserializationError::DeserializationError(
  std::wstring a_cause
) :
  cause(a_cause) {
  // Intentionally empty.
}

DeserializationError::DeserializationError(
  std::wstring a_cause,
  Path a_path
) :
  cause(a_cause),
  path(a_path) {
  // Intentionally empty.
}

// endregion DeserializationError

enum class NodeKind : std::uint32_t {
  // Nodes of the kind `Bof` represent the beginning-of-input, before any read.
  Bof = 0,
  Start = 1,
  Stop = 2,
  Text = 3,
  // Nodes of the kind `Eof` represent the end-of-input.
  Eof = 4,
  // Nodes of the kind `Error` represent low-level errors in the XML parsing.
  Error = 5
};  // enum class NodeKind

const std::unordered_map<
  NodeKind,
  std::string
> kNodeKindToHumanReadableString = {
  {NodeKind::Bof, "a beginning-of-input"},
  {NodeKind::Start, "a start element"},
  {NodeKind::Stop, "a stop element"},
  {NodeKind::Text, "a text"},
  {NodeKind::Eof, "an end-of-input"},
  {NodeKind::Error, "an error"},
};

const std::string& NodeKindToHumanReadableString(NodeKind kind) {
  auto it = kNodeKindToHumanReadableString.find(kind);
  if (it == kNodeKindToHumanReadableString.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected node kind: ",
        std::to_string(
          static_cast<std::uint32_t>(kind)
        )
      )
    );
  }

  return it->second;
}

// region Nodes

/**
 * Model a node in an XML document.
 */
class INode {
 public:
  /**
   * @return the kind of the node, used instead of much slower RTTI.
   */
  virtual NodeKind kind() const = 0;
  virtual ~INode() = default;
};  // class INode

/**
 * Model the beginning of the input, before anything was read.
 */
class BofNode : public INode {
 public:
  NodeKind kind() const override { return NodeKind::Bof; }

  ~BofNode() override = default;
}; // class StartNode

/**
 * Model a start of an XML element.
 */
class StartNode : public INode {
 public:
  explicit StartNode(
    std::string a_name
  ) :
    name(std::move(a_name)) {
    // Intentionally empty.
  }

  NodeKind kind() const override { return NodeKind::Start; }

  /**
   * Name of the start element, stripped of the expected XML namespace
   */
  const std::string name;

  ~StartNode() override = default;
};  // class StartNode

/**
 * Model a stop of an XML element.
 */
class StopNode : public INode {
 public:
  explicit StopNode(
    std::string a_name
  ) :
    name(std::move(a_name)) {
    // Intentionally empty.
  }

  NodeKind kind() const override { return NodeKind::Stop; }

  /**
   * Name of the stop element, stripped of the expected XML namespace
   */
  const std::string name;

  ~StopNode() override = default;
};  // class StopNode

/**
 * Model a text node.
 */
class TextNode : public INode {
 public:
  explicit TextNode(
    std::string a_text
  ) :
    text(std::move(a_text)) {
    // Intentionally empty.
  }

  NodeKind kind() const override { return NodeKind::Text; }

  /**
   * UTF-8 encoded XML text somewhere within an XML element
   */
  const std::string text;

  ~TextNode() override = default;
};  // class TextNode

/**
 * Model an end-of-input.
 */
class EofNode : public INode {
 public:
  NodeKind kind() const override { return NodeKind::Eof; }

  ~EofNode() override = default;
};  // class EofNode

/**
 * Model a low-level XML parsing error.
 */
class ErrorNode : public INode {
 public:
  ErrorNode(
    size_t a_line,
    size_t a_column,
    std::string a_cause
  ) :
    line(a_line),
    column(a_column),
    cause(std::move(a_cause)) {
    // Intentionally empty.
  }

  NodeKind kind() const override { return NodeKind::Error; }

  const size_t line;
  const size_t column;

  // Cause of the error as UTF-8 encoded string
  const std::string cause;

  ~ErrorNode() override = default;
};  // class ErrorNode

// endregion Nodes

// region Reading

// region class Reader

/**
 * Structure the data passed over to Expat XML reader.
 */
struct OurData {
  bool additional_attributes;
  size_t buffer_size;
  XML_Parser parser;

  std::deque<std::unique_ptr<INode> >& node_buffer;

  bool stopped = false;

  OurData(
    bool the_additional_attributes,
    size_t a_buffer_size,
    XML_Parser a_parser,
    std::deque<std::unique_ptr<INode> >& a_node_buffer
  ) :
    additional_attributes(the_additional_attributes),
    buffer_size(a_buffer_size), parser(a_parser),
    node_buffer(a_node_buffer) {
    // Intentionally empty.
  }
};  // struct OurData

/**
 * \brief Read XML in form of nodes, whereas text nodes are fragmented.
 *
 * We need a more abstract approach since the Expat library is too low-level
 * to parse complex models.
 *
 * Expat does not read the whole content of a text node in memory, but
 * we need to process the whole text during the XML de-serialization. Hence,
 * we keep on reading until we read the complete text. This has repercussions
 * on memory usage, as the the text will be held in three copies(one copy in
 * the Expat buffer, second copy in our internal buffer in which we
 * incrementally feed in the fragments, and the third copy is the final merged
 * text).
 */
class Reader {
 public:
  Reader(
    std::istream& is,
    const ReadingOptions& options
  );

  /**
   * Set up the reader for the XML parsing and read the first node.
   */
  void Initialize();

  /**
   * Read the next node in the document.
   */
  void Read();

  /**
   * @return the node which has been read last
   */
  const INode& node() const;

  /**
   * @return the node which has been read last moved out of this reader
   */
  std::unique_ptr<INode> moved_node();

  ~Reader();

 private:
  const bool additional_attributes_;
  const size_t buffer_size_;
  std::istream& is_;

  XML_Parser parser_;
  std::unique_ptr<OurData> our_data_;

  // Node buffer does not include the current node.
  std::deque<std::unique_ptr<INode>> node_buffer_;

  // Current node is never null.
  std::unique_ptr<INode> current_;

  // Set if the current node is end-of-input
  bool eof_;

  // Set if the current node is an error
  bool error_;

  void SetCurrentAndEofAndError(std::unique_ptr<INode> node);

  // Re-usable buffer to keep a chunk of the data read from the input
  std::vector<char> chunk_;
};  // class Reader

Reader::Reader(
  std::istream& is,
  const ReadingOptions& options
) :
  additional_attributes_(options.additional_attributes),
  buffer_size_(options.buffer_size),
  is_(is),
  parser_(nullptr),
  current_(common::make_unique<BofNode>()),
  eof_(false),
  error_(false) {
  // Intentionally empty.
}

const char kNamespaceSeparator = '|';

void XMLCALL OnStartElement(
  void* user_data,
  const char* name,
  const char* attributes[]
) {
  auto our_data = static_cast<OurData*>(user_data);

  // NOTE (mristin):
  // Since Expat continues parsing and adding nodes even if the parsing is
  // suspended (see the documentation of `XML_StopParser`), we have to ignore
  // any further events.
  if (our_data->stopped) {
    return;
  }

  const std::string name_str(name);

  size_t separator_i = name_str.find(kNamespaceSeparator);
  if (separator_i == std::string::npos || separator_i == 0) {
    std::string message = common::Concat(
      "The namespace is missing in the start element <",
      name_str,
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  if (name_str.compare(0, separator_i, kNamespace) != 0) {
    std::string message = common::Concat(
      "We expected the XML namespace ",
      kNamespace,
      ", but we got the namespace ",
      name_str.substr(0, separator_i),
      " in the start element <",
      name_str.substr(separator_i + 1),
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  if (
    attributes[0] != nullptr
    && !(our_data->additional_attributes)
  ) {
    std::string message = common::Concat(
      "Additional attributes are not allowed, "
      "but the attribute ",
      attributes[0],
      " was read in the start element <",
      name_str.substr(separator_i + 1),
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  our_data->node_buffer.emplace_back(
    common::make_unique<StartNode>(
      name_str.substr(separator_i + 1)
    )
  );
}

void XMLCALL OnStopElement(
  void* user_data,
  const char* name
) {
  auto* our_data = static_cast<OurData*>(user_data);

  // NOTE (mristin):
  // Since Expat continues parsing and adding nodes even if the parsing is
  // suspended (see the documentation of `XML_StopParser`), we have to ignore
  // any further events.
  if (our_data->stopped) {
    return;
  }

  const std::string name_str(name);

  size_t separator_i = name_str.find(kNamespaceSeparator);
  if (separator_i == std::string::npos || separator_i == 0) {
    std::string message = common::Concat(
      "The namespace is missing in the stop element </",
      name_str,
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  if (name_str.compare(0, separator_i, kNamespace) != 0) {
    std::string message = common::Concat(
      "We expected the XML namespace ",
      kNamespace,
      ", but we got the namespace ",
      name_str.substr(0, separator_i),
      " in the stop element </",
      name_str.substr(separator_i + 1),
      ">"
    );

    our_data->node_buffer.emplace_back(
      common::make_unique<ErrorNode>(
        XML_GetCurrentLineNumber(our_data->parser),
        XML_GetCurrentColumnNumber(our_data->parser),
        message
      )
    );

    XML_StopParser(our_data->parser, false);
    our_data->stopped = true;
    return;
  }

  our_data->node_buffer.emplace_back(
    common::make_unique<StopNode>(
      name_str.substr(separator_i + 1)
    )
  );
}

void XMLCALL OnText(
  void* user_data,
  const char* val,
  int len
) {
  auto our_data = static_cast<OurData*>(user_data);

  // NOTE (mristin):
  // Since Expat continues parsing and adding nodes even if the parsing is
  // suspended (see the documentation of `XML_StopParser`), we have to ignore
  // any further events.
  if (our_data->stopped) {
    return;
  }

  our_data->node_buffer.emplace_back(
    common::make_unique<TextNode>(
      std::string(val, len)
    )
  );
}

void Reader::Initialize() {
  // NOTE (mristin):
  // We set up the underlying parser here instead of the constructor
  // to avoid throwing exceptions in the constructor.

  if (parser_ != nullptr) {
    throw std::logic_error(
      "You are trying to re-initialize an initialized XML reader."
    );
  }

  if (
    buffer_size_
    > static_cast<size_t>(
      (std::numeric_limits<int>::max)()
    )
  ) {
    throw std::invalid_argument(
      common::Concat(
        "Expat library expects the buffer size as int, "
        "but the given buffer size ",
        std::to_string(buffer_size_),
        " does not fit in an int as it is larger than the maximum int ",
        std::to_string(std::numeric_limits<int>::max())
      )
    );
  }

  parser_ = XML_ParserCreateNS(nullptr, kNamespaceSeparator);
  our_data_ = common::make_unique<OurData>(
    additional_attributes_,
    buffer_size_,
    parser_,
    node_buffer_
  );

  XML_SetUserData(parser_, our_data_.get());
  XML_SetElementHandler(
    parser_,
    OnStartElement,
    OnStopElement
  );
  XML_SetCharacterDataHandler(parser_, OnText);

  chunk_.resize(buffer_size_);

  Read();
}

void Reader::Read() {
  if (parser_ == nullptr) {
    throw std::logic_error(
      "You are trying to read from an uninitialized XML reader"
    );
  }

  if (eof_) {
    throw std::logic_error(
      "The XML reader reached the end-of-input, "
      "but you called Read()"
    );
  }

  if (error_) {
    throw std::logic_error(
      "There was an error while reading XML, "
      "but you called Read() again"
    );
  }

  while (node_buffer_.empty()) {
    // NOTE (mristin):
    // We read and parse the next chunk of input, until we parsed a whole node.
    // The text, however, will be fragmented by Expat's design.

    is_.read(&(chunk_[0]), buffer_size_);

    const std::streamsize actual_bytes_read = is_.gcount();

    if (is_.bad()) {
      SetCurrentAndEofAndError(
        common::make_unique<ErrorNode>(
          0,
          0,
          "Failed to read from the input"
        )
      );
      return;
    }

    if (actual_bytes_read == 0) {
      if (is_.eof()) {
        SetCurrentAndEofAndError(common::make_unique<EofNode>());
        return;
      } else {
        SetCurrentAndEofAndError(
          common::make_unique<ErrorNode>(
            0,
            0,
            "Read zero bytes from the input, "
            "but the input is neither eof() nor bad()"
          )
        );
        return;
      }
    } else {
      const bool done = is_.eof();

      if (actual_bytes_read > std::numeric_limits<int>::max()) {
        std::string message = common::Concat(
          "Expat library expects the buffer size as int, ",
          "but the actual number of bytes read ",
          std::to_string(actual_bytes_read),
          " does not fit in an int as it is larger than the maximum int ",
          std::to_string(std::numeric_limits<int>::max())
        );

        throw std::runtime_error(message);
      }

      const auto actual_bytes_read_int = static_cast<int>(actual_bytes_read);

      XML_Status status = XML_Parse(
        parser_,
        &(chunk_[0]),
        actual_bytes_read_int,
        done
      );

      if (status == XML_STATUS_ERROR) {
        XML_Error error_code = XML_GetErrorCode(parser_);

        if (error_code == XML_ERROR_ABORTED) {
          if (node_buffer_.empty()) {
            throw std::logic_error(
              "The XML parsing was aborted, "
              "so we expected an error node on the buffer, "
              "but the buffer was empty"
            );
          }

          if (node_buffer_.back()->kind() != NodeKind::Error) {
            std::string message = common::Concat(
              "The XML parsing was aborted, "
              "so we expected an error node on the buffer, "
              "but we got ",
              NodeKindToHumanReadableString(node_buffer_.back()->kind())
            );

            throw std::logic_error(message);
          }
        } else {
          const XML_LChar* error_str = XML_ErrorString(error_code);

          node_buffer_.emplace_back(
            common::make_unique<ErrorNode>(
              XML_GetCurrentLineNumber(parser_),
              XML_GetCurrentColumnNumber(parser_),
              std::string(error_str)
            )
          );
        }
      } else {
        if (done) {
          node_buffer_.emplace_back(common::make_unique<EofNode>());
        }
      }
    }
  }

  SetCurrentAndEofAndError(std::move(node_buffer_.front()));
  node_buffer_.pop_front();
}

const INode& Reader::node() const {
  return *current_;
}

std::unique_ptr<INode> Reader::moved_node() {
  return std::move(current_);
}

Reader::~Reader() {
  if (parser_ != nullptr) {
    XML_ParserFree(parser_);
  }
}

void Reader::SetCurrentAndEofAndError(
  std::unique_ptr<INode> node
) {
  current_ = std::move(node);

  #ifdef __clang__
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wswitch"
  #endif
  switch (current_->kind()) {
    case NodeKind::Eof:
      eof_ = true;
      break;
    case NodeKind::Error:
      error_ = true;
      break;
  }
  #ifdef __clang__
  #pragma clang diagnostic pop
  #endif
}

// endregion class Reader

// region class ReaderMergingText

/**
 * \brief Read XML in forms of nodes, with text nodes read in whole.
 *
 * This is a reader on top of the \ref Reader which keeps the text fragments
 * in the buffer. We need to process the text in whole during the XML
 * de-serialization, so this buffering is necessary. However, this means that
 * the text is kept in four copies (one partial copy in Expat buffer,
 * another partial copy as fragmented text nodes in the underlying \ref Reader
 * instance, yet another copy in the internal buffer of this instance, and
 * finally the fourth copy as the merged complete text).
 */
class ReaderMergingText {
 public:
  ReaderMergingText(
    std::istream& is,
    const ReadingOptions& options
  );

  /**
   * Set up the reader for the XML parsing and read the first node.
   */
  void Initialize();

  /**
   * Read the next node in the document.
   */
  void Read();

  /**
   * @return the node which has been read last
   */
  const INode& node() const;

  /**
   * @return set if the current node represents an error
   */
  bool error() const;

  /**
   * @return set if the current node represents an end-of-input
   */
  bool eof() const;

 private:
  bool initialized_;
  Reader reader_;

  std::unique_ptr<INode> current_;
  std::unique_ptr<INode> look_ahead_;

  // Assuming that the underlying reader points to a text node,
  // read all the consecutive text nodes and set the look-ahead node
  void ReadAndMergeAllTextAndSetLookahead();

  bool error_;
  bool eof_;
  void SetCurrentAndEofAndError(
    std::unique_ptr<INode> node
  );
};  // class ReaderMergingText

ReaderMergingText::ReaderMergingText(
    std::istream& is,
    const ReadingOptions& options
) :
  initialized_(false),
  reader_(is, options),
  current_(common::make_unique<BofNode>()),
  error_(false),
  eof_(false) {
  // Intentionally empty.
}

void ReaderMergingText::Initialize() {
  if (initialized_) {
    throw std::logic_error(
      "You are trying to initialize "
      "an already initialized ReaderMergingText"
    );
  }

  reader_.Initialize();

  // NOTE (mristin):
  // The `reader_` has already read a node. Hence, we need to parse it here
  // separately from `ReaderMergingText::Read` method.

  if (reader_.node().kind() != NodeKind::Text) {
    SetCurrentAndEofAndError(reader_.moved_node());
  } else {
    ReadAndMergeAllTextAndSetLookahead();
  }

  initialized_ = true;
}

void ReaderMergingText::Read() {
  if (!initialized_) {
    throw std::logic_error(
      "You are reading from an uninitialized ReaderMergingText"
    );
  }

  if (eof()) {
    throw std::logic_error(
      "You are trying to read from a ReaderMergingText, "
      "but it reached the end-of-input"
    );
  }

  if (error()) {
    throw std::logic_error(
      "You are trying to read from a ReaderMergingText, "
      "but an error already occurred"
    );
  }

  if (look_ahead_ != nullptr) {
    SetCurrentAndEofAndError(std::move(look_ahead_));
    return;
  }

  reader_.Read();
  if (reader_.node().kind() != NodeKind::Text) {
    SetCurrentAndEofAndError(reader_.moved_node());
  } else {
    ReadAndMergeAllTextAndSetLookahead();
  }
}

const INode& ReaderMergingText::node() const {
  return *current_;
}

bool ReaderMergingText::error() const {
  return error_;
}

bool ReaderMergingText::eof() const {
  return eof_;
}

void ReaderMergingText::ReadAndMergeAllTextAndSetLookahead() {
  if (reader_.node().kind() != NodeKind::Text) {
    std::string message = common::Concat(
      "Expected the current node in the reader "
      "underlying ReaderMergingText to be a text, "
      "but it was ",
      NodeKindToHumanReadableString(reader_.node().kind())
    );

    throw std::logic_error(message);
  }

  std::deque<std::string> text_buffer;

  while (reader_.node().kind() == NodeKind::Text) {
    const TextNode& fragment_text_node(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const TextNode&
      >(
        reader_.node()
      )
    );

    text_buffer.emplace_back(fragment_text_node.text);

    reader_.Read();
  }
  look_ahead_ = reader_.moved_node();

  size_t size = 0;
  for (const std::string& fragment : text_buffer) {
    size += fragment.size();
  }

  std::string text;
  text.reserve(size);
  while (!text_buffer.empty()) {
    text.append(text_buffer.front());
    text_buffer.pop_front();
  }

  SetCurrentAndEofAndError(common::make_unique<TextNode>(text));
}

void ReaderMergingText::SetCurrentAndEofAndError(std::unique_ptr<INode> node) {
  current_ = std::move(node);

  #ifdef __clang__
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wswitch"
  #endif
  switch (current_->kind()) {
    case NodeKind::Eof:eof_ = true;
      break;
    case NodeKind::Error:error_ = true;
      break;
  }
  #ifdef __clang__
  #pragma clang diagnostic pop
  #endif
}

// endregion class ReaderMergingText

// endregion Reading

// region Forward declarations of de-serialization functions

// NOTE (mristin):
// We make forward declarations of de-serialization functions so that they can be
// called in any order.

std::pair<
  common::optional<
    std::shared_ptr<types::IHasSemantics>
  >,
  common::optional<DeserializationError>
> HasSemanticsFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IExtension>
  >,
  common::optional<DeserializationError>
> ExtensionFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IExtension>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ExtensionFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IHasExtensions>
  >,
  common::optional<DeserializationError>
> HasExtensionsFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IReferable>
  >,
  common::optional<DeserializationError>
> ReferableFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IIdentifiable>
  >,
  common::optional<DeserializationError>
> IdentifiableFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IHasKind>
  >,
  common::optional<DeserializationError>
> HasKindFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IHasDataSpecification>
  >,
  common::optional<DeserializationError>
> HasDataSpecificationFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >,
  common::optional<DeserializationError>
> AdministrativeInformationFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAdministrativeInformation>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> AdministrativeInformationFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IQualifiable>
  >,
  common::optional<DeserializationError>
> QualifiableFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IQualifier>
  >,
  common::optional<DeserializationError>
> QualifierFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IQualifier>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> QualifierFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IAssetAdministrationShell>
  >,
  common::optional<DeserializationError>
> AssetAdministrationShellFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAssetAdministrationShell>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> AssetAdministrationShellFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IAssetInformation>
  >,
  common::optional<DeserializationError>
> AssetInformationFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAssetInformation>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> AssetInformationFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IResource>
  >,
  common::optional<DeserializationError>
> ResourceFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IResource>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ResourceFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ISpecificAssetId>
  >,
  common::optional<DeserializationError>
> SpecificAssetIdFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISpecificAssetId>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> SpecificAssetIdFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodel>
  >,
  common::optional<DeserializationError>
> SubmodelFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodel>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> SubmodelFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodelElement>
  >,
  common::optional<DeserializationError>
> SubmodelElementFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IRelationshipElement>
  >,
  common::optional<DeserializationError>
> RelationshipElementFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IRelationshipElement>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> RelationshipElementFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodelElementList>
  >,
  common::optional<DeserializationError>
> SubmodelElementListFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodelElementList>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> SubmodelElementListFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodelElementCollection>
  >,
  common::optional<DeserializationError>
> SubmodelElementCollectionFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodelElementCollection>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> SubmodelElementCollectionFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IDataElement>
  >,
  common::optional<DeserializationError>
> DataElementFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IProperty>
  >,
  common::optional<DeserializationError>
> PropertyFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IProperty>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> PropertyFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IMultiLanguageProperty>
  >,
  common::optional<DeserializationError>
> MultiLanguagePropertyFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IMultiLanguageProperty>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> MultiLanguagePropertyFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IRange>
  >,
  common::optional<DeserializationError>
> RangeFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IRange>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> RangeFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IReferenceElement>
  >,
  common::optional<DeserializationError>
> ReferenceElementFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IReferenceElement>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ReferenceElementFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IBlob>
  >,
  common::optional<DeserializationError>
> BlobFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IBlob>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> BlobFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IFile>
  >,
  common::optional<DeserializationError>
> FileFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IFile>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> FileFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IAnnotatedRelationshipElement>
  >,
  common::optional<DeserializationError>
> AnnotatedRelationshipElementFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAnnotatedRelationshipElement>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> AnnotatedRelationshipElementFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IEntity>
  >,
  common::optional<DeserializationError>
> EntityFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEntity>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> EntityFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IEventPayload>
  >,
  common::optional<DeserializationError>
> EventPayloadFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEventPayload>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> EventPayloadFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IEventElement>
  >,
  common::optional<DeserializationError>
> EventElementFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IBasicEventElement>
  >,
  common::optional<DeserializationError>
> BasicEventElementFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IBasicEventElement>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> BasicEventElementFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IOperation>
  >,
  common::optional<DeserializationError>
> OperationFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IOperation>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> OperationFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IOperationVariable>
  >,
  common::optional<DeserializationError>
> OperationVariableFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IOperationVariable>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> OperationVariableFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ICapability>
  >,
  common::optional<DeserializationError>
> CapabilityFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ICapability>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> CapabilityFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IConceptDescription>
  >,
  common::optional<DeserializationError>
> ConceptDescriptionFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IConceptDescription>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ConceptDescriptionFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IReference>
  >,
  common::optional<DeserializationError>
> ReferenceFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IReference>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ReferenceFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IKey>
  >,
  common::optional<DeserializationError>
> KeyFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IKey>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> KeyFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IAbstractLangString>
  >,
  common::optional<DeserializationError>
> AbstractLangStringFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringNameType>
  >,
  common::optional<DeserializationError>
> LangStringNameTypeFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringNameType>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringNameTypeFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringTextType>
  >,
  common::optional<DeserializationError>
> LangStringTextTypeFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringTextType>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringTextTypeFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IEnvironment>
  >,
  common::optional<DeserializationError>
> EnvironmentFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEnvironment>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> EnvironmentFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IDataSpecificationContent>
  >,
  common::optional<DeserializationError>
> DataSpecificationContentFromElement(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >,
  common::optional<DeserializationError>
> EmbeddedDataSpecificationFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEmbeddedDataSpecification>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> EmbeddedDataSpecificationFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ILevelType>
  >,
  common::optional<DeserializationError>
> LevelTypeFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILevelType>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LevelTypeFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IValueReferencePair>
  >,
  common::optional<DeserializationError>
> ValueReferencePairFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IValueReferencePair>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ValueReferencePairFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IValueList>
  >,
  common::optional<DeserializationError>
> ValueListFromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IValueList>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ValueListFromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
  >,
  common::optional<DeserializationError>
> LangStringPreferredNameTypeIec61360FromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringPreferredNameTypeIec61360>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringPreferredNameTypeIec61360FromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringShortNameTypeIec61360>
  >,
  common::optional<DeserializationError>
> LangStringShortNameTypeIec61360FromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringShortNameTypeIec61360>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringShortNameTypeIec61360FromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
  >,
  common::optional<DeserializationError>
> LangStringDefinitionTypeIec61360FromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringDefinitionTypeIec61360>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringDefinitionTypeIec61360FromSequence(
  ReaderMergingText& reader
);

std::pair<
  common::optional<
    std::shared_ptr<types::IDataSpecificationIec61360>
  >,
  common::optional<DeserializationError>
> DataSpecificationIec61360FromElement(
  ReaderMergingText& reader
);

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IDataSpecificationIec61360>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DataSpecificationIec61360FromSequence(
  ReaderMergingText& reader
);

// endregion Forward declarations of de-serialization functions

/**
 * Map XML class names to model types.
 */
const std::unordered_map<
  std::string,
  types::ModelType
> kElementNameToModelType = {
  {
    "extension",
    types::ModelType::kExtension
  },
  {
    "administrativeInformation",
    types::ModelType::kAdministrativeInformation
  },
  {
    "qualifier",
    types::ModelType::kQualifier
  },
  {
    "assetAdministrationShell",
    types::ModelType::kAssetAdministrationShell
  },
  {
    "assetInformation",
    types::ModelType::kAssetInformation
  },
  {
    "resource",
    types::ModelType::kResource
  },
  {
    "specificAssetId",
    types::ModelType::kSpecificAssetId
  },
  {
    "submodel",
    types::ModelType::kSubmodel
  },
  {
    "relationshipElement",
    types::ModelType::kRelationshipElement
  },
  {
    "submodelElementList",
    types::ModelType::kSubmodelElementList
  },
  {
    "submodelElementCollection",
    types::ModelType::kSubmodelElementCollection
  },
  {
    "property",
    types::ModelType::kProperty
  },
  {
    "multiLanguageProperty",
    types::ModelType::kMultiLanguageProperty
  },
  {
    "range",
    types::ModelType::kRange
  },
  {
    "referenceElement",
    types::ModelType::kReferenceElement
  },
  {
    "blob",
    types::ModelType::kBlob
  },
  {
    "file",
    types::ModelType::kFile
  },
  {
    "annotatedRelationshipElement",
    types::ModelType::kAnnotatedRelationshipElement
  },
  {
    "entity",
    types::ModelType::kEntity
  },
  {
    "eventPayload",
    types::ModelType::kEventPayload
  },
  {
    "basicEventElement",
    types::ModelType::kBasicEventElement
  },
  {
    "operation",
    types::ModelType::kOperation
  },
  {
    "operationVariable",
    types::ModelType::kOperationVariable
  },
  {
    "capability",
    types::ModelType::kCapability
  },
  {
    "conceptDescription",
    types::ModelType::kConceptDescription
  },
  {
    "reference",
    types::ModelType::kReference
  },
  {
    "key",
    types::ModelType::kKey
  },
  {
    "langStringNameType",
    types::ModelType::kLangStringNameType
  },
  {
    "langStringTextType",
    types::ModelType::kLangStringTextType
  },
  {
    "environment",
    types::ModelType::kEnvironment
  },
  {
    "embeddedDataSpecification",
    types::ModelType::kEmbeddedDataSpecification
  },
  {
    "levelType",
    types::ModelType::kLevelType
  },
  {
    "valueReferencePair",
    types::ModelType::kValueReferencePair
  },
  {
    "valueList",
    types::ModelType::kValueList
  },
  {
    "langStringPreferredNameTypeIec61360",
    types::ModelType::kLangStringPreferredNameTypeIec61360
  },
  {
    "langStringShortNameTypeIec61360",
    types::ModelType::kLangStringShortNameTypeIec61360
  },
  {
    "langStringDefinitionTypeIec61360",
    types::ModelType::kLangStringDefinitionTypeIec61360
  },
  {
    "dataSpecificationIec61360",
    types::ModelType::kDataSpecificationIec61360
  }
};

common::optional<types::ModelType> ModelTypeFromElementName(
  const std::string& element_name
) {
  auto it = kElementNameToModelType.find(element_name);
  if (it == kElementNameToModelType.end()) {
    return common::nullopt;
  }

  return it->second;
}

std::string NodeToHumanReadableString(
  const INode& node
) {
  switch (node.kind()) {
    case NodeKind::Bof:
      return "beginning-of-input";

    case NodeKind::Start: {
      const StartNode& start_node(
        static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
          const StartNode&
        >(node)
      );

      return common::Concat(
        "a start node <",
        start_node.name,
        ">"
      );
    }

    case NodeKind::Stop: {
      const StopNode& stop_node(
        static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
          const StopNode&
        >(node)
      );

      return common::Concat(
        "a stop node </",
        stop_node.name,
        ">"
      );
    }

    case NodeKind::Text:
      return "an XML text";

    case NodeKind::Eof:
      return "end-of-input";

    case NodeKind::Error:
      return "an XML error";

    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected node kind: ",
          std::to_string(
            static_cast<uint32_t>(node.kind())
          )
        )
      );
  }
}

std::wstring NodeToHumanReadableWstring(
  const INode& node
) {
  switch (node.kind()) {
    case NodeKind::Bof:
      return L"beginning-of-input";

    case NodeKind::Start: {
      const StartNode& start_node(
        static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
          const StartNode&
        >(node)
      );

      return common::Concat(
        L"a start node <",
        common::Utf8ToWstring(start_node.name),
        L">"
      );
    }

    case NodeKind::Stop: {
      const StopNode& stop_node(
        static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
          const StopNode&
        >(node)
      );

      return common::Concat(
        L"a stop node </",
        common::Utf8ToWstring(stop_node.name),
        L">"
      );
    }

    case NodeKind::Text:
      return L"an XML text";

    case NodeKind::Eof:
      return L"end-of-input";

    case NodeKind::Error:
      return L"an XML error";

    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected node kind: ",
          std::to_string(
            static_cast<uint32_t>(node.kind())
          )
        )
      );
  }
}

/**
 * Check that the given node is a stop node and that its name corresponds to
 * the expected name.
 */
bool IsStopNodeWithName(
  const INode& node,
  const std::string& expected_name
) {
  if (node.kind() != NodeKind::Stop) {
    return false;
  }

  const std::string& name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(node).name
  );
  if (name != expected_name) {
    return false;
  }

  return true;
}

template <
  typename T
>
std::pair<
  common::optional<T>,
  common::optional<DeserializationError>
> InstanceAndNoDeserializationError(
  T&& instance
) {
  return std::make_pair<
    common::optional<T>,
    common::optional<DeserializationError>
  >(
    std::move(instance),
    common::nullopt
  );
}

template <
  typename T
> std::pair<
  common::optional<T>,
  common::optional<DeserializationError>
> NoInstanceAndDeserializationErrorWithCause(
  std::wstring cause
) {
  return std::make_pair<
    common::optional<T>,
    common::optional<DeserializationError>
  >(
    common::nullopt,
    common::make_optional<DeserializationError>(
      std::move(cause)
    )
  );
}

DeserializationError DeserializationErrorFromReader(
  ReaderMergingText& reader
) {
  if (reader.node().kind() != NodeKind::Error) {
    throw std::logic_error(
      common::Concat(
        "Expected an error node at the reader cursor, but got ",
        NodeToHumanReadableString(reader.node())
      )
    );
  }

  const auto error_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const ErrorNode&
    >(reader.node())
  );

  return DeserializationError(
    common::Utf8ToWstring(
      error_node.cause
    )
  );
}

template <
  typename T
>
std::pair<
  common::optional<T>,
  common::optional<DeserializationError>
> NoInstanceAndDeserializationErrorFromReader(
  ReaderMergingText& reader
) {
  if (reader.node().kind() != NodeKind::Error) {
    throw std::logic_error(
      common::Concat(
        "Expected an error node at the reader cursor, but got ",
        NodeToHumanReadableString(reader.node())
      )
    );
  }

  DeserializationError error = DeserializationErrorFromReader(
    reader
  );

  return std::make_pair(
    common::nullopt,
    common::make_optional<DeserializationError>(
      std::move(error)
    )
  );
}

template <
  typename T
>
std::pair<
  common::optional<T>,
  common::optional<DeserializationError>
> NoInstanceAndDeserializationError(
  DeserializationError error
) {
  return std::make_pair(
    common::nullopt,
    common::make_optional<DeserializationError>(
      std::move(error)
    )
  );
}

void PrependElementSegmentToDeserializationError(
  const std::string& name,
  DeserializationError& deserialization_error
) {
  deserialization_error.path.segments.emplace_front(
    common::make_unique<ElementSegment>(
      common::Utf8ToWstring(name)
    )
  );
}

common::optional<DeserializationError> CheckReaderAtEof(
  const ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in CheckReaderAtEof. "
      "CheckReaderAtEof expects no reader error at entry."
    );
  }
  #endif

  if (reader.node().kind() != NodeKind::Eof) {
    return common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected end-of-input, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  return common::nullopt;
}

/**
 * \brief Skip the beginning-of-file (BoF) and read a node.
 *
 * Do nothing if the cursor points to a non-BoF node.
 *
 * Return an error if the reader produced an error.
 */
common::optional<DeserializationError> SkipBof(
  ReaderMergingText& reader
) {
  if (reader.node().kind() != NodeKind::Bof) {
    return common::nullopt;
  }

  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    return DeserializationErrorFromReader(reader);
  }

  return common::nullopt;
}

/**
 * Return `true` if all characters are whitespace in the UTF-8-encoded text.
 */
bool IsWhitespace(const std::string& utf8_text) {
  for (const char character : utf8_text) {
    switch (character) {
      // NOTE (mristin):
      // The characters are ordered by their ASCII codes so that
      // we allow compilers to optimize.

      // NOTE (mristin):
      // Text nodes contain text in UTF-8 which is compatible with ASCII.
      // In particular, all characters above ASCII (>127) are encoded with
      // all the leading bits set. Hence, it is safe to check for whitespace
      // characters in an UTF-8-encoded string using one-byte characters.
      //
      // See: https://stackoverflow.com/questions/15965811/why-utf8-is-compatible-with-ascii

      case '\t':
      case '\n':
      case '\r':
      case ' ':
        // Pass
        break;
      default:
        return false;
    }
  }

  return true;
}

/**
 * \brief Skip all whitespace text nodes.
 *
 * Do nothing if the cursor points to a non-text node.
 *
 * The whitespace includes space, tab, carriage return and newline.
 *
 * Return an error if the reader produced an error.
 */
common::optional<DeserializationError> SkipWhitespace(
  ReaderMergingText& reader
) {
  while (reader.node().kind() == NodeKind::Text) {
    const TextNode& text_node(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const TextNode&
      >(
        reader.node()
      )
    );

    if (!IsWhitespace(text_node.text)) {
      break;
    }

    reader.Read();
  }

  if (reader.node().kind() == NodeKind::Error) {
    return DeserializationErrorFromReader(reader);
  }

  return common::nullopt;
}

std::pair<
  common::optional<
    std::shared_ptr<types::IClass>
  >,
  common::optional<DeserializationError>
> ClassFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ClassFromElement. "
      "ClassFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IClass>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IClass>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IClass>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IClass>
  > instance;

  switch (*model_type) {
    case types::ModelType::kExtension:
      std::tie(instance, error) = ExtensionFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kAdministrativeInformation:
      std::tie(instance, error) = AdministrativeInformationFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kQualifier:
      std::tie(instance, error) = QualifierFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kAssetAdministrationShell:
      std::tie(instance, error) = AssetAdministrationShellFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kAssetInformation:
      std::tie(instance, error) = AssetInformationFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kResource:
      std::tie(instance, error) = ResourceFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kSpecificAssetId:
      std::tie(instance, error) = SpecificAssetIdFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kRelationshipElement:
      std::tie(instance, error) = RelationshipElementFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kSubmodelElementList:
      std::tie(instance, error) = SubmodelElementListFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kSubmodelElementCollection:
      std::tie(instance, error) = SubmodelElementCollectionFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kEntity:
      std::tie(instance, error) = EntityFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kEventPayload:
      std::tie(instance, error) = EventPayloadFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kOperation:
      std::tie(instance, error) = OperationFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kOperationVariable:
      std::tie(instance, error) = OperationVariableFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kCapability:
      std::tie(instance, error) = CapabilityFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kConceptDescription:
      std::tie(instance, error) = ConceptDescriptionFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kReference:
      std::tie(instance, error) = ReferenceFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kKey:
      std::tie(instance, error) = KeyFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kLangStringNameType:
      std::tie(instance, error) = LangStringNameTypeFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kLangStringTextType:
      std::tie(instance, error) = LangStringTextTypeFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kEnvironment:
      std::tie(instance, error) = EnvironmentFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kEmbeddedDataSpecification:
      std::tie(instance, error) = EmbeddedDataSpecificationFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kLevelType:
      std::tie(instance, error) = LevelTypeFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kValueReferencePair:
      std::tie(instance, error) = ValueReferencePairFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kValueList:
      std::tie(instance, error) = ValueListFromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      std::tie(instance, error) = LangStringPreferredNameTypeIec61360FromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kLangStringShortNameTypeIec61360:
      std::tie(instance, error) = LangStringShortNameTypeIec61360FromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      std::tie(instance, error) = LangStringDefinitionTypeIec61360FromSequence<
        types::IClass
      >(reader);
      break;
    case types::ModelType::kDataSpecificationIec61360:
      std::tie(instance, error) = DataSpecificationIec61360FromSequence<
        types::IClass
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IClass>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IClass from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IClass, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IClass>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IHasSemantics>
  >,
  common::optional<DeserializationError>
> HasSemanticsFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in HasSemanticsFromElement. "
      "HasSemanticsFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasSemantics>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasSemantics>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IHasSemantics>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IHasSemantics, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IHasSemantics>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IHasSemantics>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IHasSemantics>
  > instance;

  switch (*model_type) {
    case types::ModelType::kRelationshipElement:
      std::tie(instance, error) = RelationshipElementFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kCapability:
      std::tie(instance, error) = CapabilityFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kEntity:
      std::tie(instance, error) = EntityFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kExtension:
      std::tie(instance, error) = ExtensionFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kOperation:
      std::tie(instance, error) = OperationFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kQualifier:
      std::tie(instance, error) = QualifierFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kSpecificAssetId:
      std::tie(instance, error) = SpecificAssetIdFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kSubmodelElementCollection:
      std::tie(instance, error) = SubmodelElementCollectionFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    case types::ModelType::kSubmodelElementList:
      std::tie(instance, error) = SubmodelElementListFromSequence<
        types::IHasSemantics
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IHasSemantics>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IHasSemantics from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasSemantics>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasSemantics>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IHasSemantics, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasSemantics>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IHasSemantics, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasSemantics>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasSemantics>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IExtension>
  >,
  common::optional<DeserializationError>
> ExtensionFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ExtensionFromElement. "
      "ExtensionFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IExtension>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IExtension>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IExtension>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IExtension, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IExtension>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IExtension>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IExtension>
  > instance;

  switch (*model_type) {
    case types::ModelType::kExtension:
      std::tie(instance, error) = ExtensionFromSequence<
        types::IExtension
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IExtension>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IExtension from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IExtension>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IExtension>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IExtension, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IExtension>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IExtension, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IExtension>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IExtension>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IHasExtensions>
  >,
  common::optional<DeserializationError>
> HasExtensionsFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in HasExtensionsFromElement. "
      "HasExtensionsFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasExtensions>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasExtensions>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IHasExtensions>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IHasExtensions, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IHasExtensions>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IHasExtensions>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IHasExtensions>
  > instance;

  switch (*model_type) {
    case types::ModelType::kRelationshipElement:
      std::tie(instance, error) = RelationshipElementFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kAssetAdministrationShell:
      std::tie(instance, error) = AssetAdministrationShellFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kCapability:
      std::tie(instance, error) = CapabilityFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kConceptDescription:
      std::tie(instance, error) = ConceptDescriptionFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kEntity:
      std::tie(instance, error) = EntityFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kOperation:
      std::tie(instance, error) = OperationFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kSubmodelElementCollection:
      std::tie(instance, error) = SubmodelElementCollectionFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    case types::ModelType::kSubmodelElementList:
      std::tie(instance, error) = SubmodelElementListFromSequence<
        types::IHasExtensions
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IHasExtensions>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IHasExtensions from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasExtensions>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasExtensions>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IHasExtensions, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasExtensions>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IHasExtensions, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasExtensions>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasExtensions>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IReferable>
  >,
  common::optional<DeserializationError>
> ReferableFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ReferableFromElement. "
      "ReferableFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferable>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferable>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IReferable>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IReferable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IReferable>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IReferable>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IReferable>
  > instance;

  switch (*model_type) {
    case types::ModelType::kRelationshipElement:
      std::tie(instance, error) = RelationshipElementFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kAssetAdministrationShell:
      std::tie(instance, error) = AssetAdministrationShellFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kCapability:
      std::tie(instance, error) = CapabilityFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kConceptDescription:
      std::tie(instance, error) = ConceptDescriptionFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kEntity:
      std::tie(instance, error) = EntityFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kOperation:
      std::tie(instance, error) = OperationFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kSubmodelElementCollection:
      std::tie(instance, error) = SubmodelElementCollectionFromSequence<
        types::IReferable
      >(reader);
      break;
    case types::ModelType::kSubmodelElementList:
      std::tie(instance, error) = SubmodelElementListFromSequence<
        types::IReferable
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IReferable>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IReferable from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferable>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferable>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IReferable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferable>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IReferable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferable>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferable>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IIdentifiable>
  >,
  common::optional<DeserializationError>
> IdentifiableFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in IdentifiableFromElement. "
      "IdentifiableFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IIdentifiable>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IIdentifiable>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IIdentifiable>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IIdentifiable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IIdentifiable>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IIdentifiable>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IIdentifiable>
  > instance;

  switch (*model_type) {
    case types::ModelType::kAssetAdministrationShell:
      std::tie(instance, error) = AssetAdministrationShellFromSequence<
        types::IIdentifiable
      >(reader);
      break;
    case types::ModelType::kConceptDescription:
      std::tie(instance, error) = ConceptDescriptionFromSequence<
        types::IIdentifiable
      >(reader);
      break;
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::IIdentifiable
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IIdentifiable>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IIdentifiable from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IIdentifiable>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IIdentifiable>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IIdentifiable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IIdentifiable>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IIdentifiable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IIdentifiable>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IIdentifiable>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IHasKind>
  >,
  common::optional<DeserializationError>
> HasKindFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in HasKindFromElement. "
      "HasKindFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasKind>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasKind>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IHasKind>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IHasKind, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IHasKind>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IHasKind>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IHasKind>
  > instance;

  switch (*model_type) {
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::IHasKind
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IHasKind>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IHasKind from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasKind>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasKind>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IHasKind, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasKind>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IHasKind, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasKind>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasKind>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IHasDataSpecification>
  >,
  common::optional<DeserializationError>
> HasDataSpecificationFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in HasDataSpecificationFromElement. "
      "HasDataSpecificationFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasDataSpecification>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasDataSpecification>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IHasDataSpecification>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IHasDataSpecification, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IHasDataSpecification>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IHasDataSpecification>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IHasDataSpecification>
  > instance;

  switch (*model_type) {
    case types::ModelType::kAdministrativeInformation:
      std::tie(instance, error) = AdministrativeInformationFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kRelationshipElement:
      std::tie(instance, error) = RelationshipElementFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kAssetAdministrationShell:
      std::tie(instance, error) = AssetAdministrationShellFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kCapability:
      std::tie(instance, error) = CapabilityFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kConceptDescription:
      std::tie(instance, error) = ConceptDescriptionFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kEntity:
      std::tie(instance, error) = EntityFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kOperation:
      std::tie(instance, error) = OperationFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kSubmodelElementCollection:
      std::tie(instance, error) = SubmodelElementCollectionFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    case types::ModelType::kSubmodelElementList:
      std::tie(instance, error) = SubmodelElementListFromSequence<
        types::IHasDataSpecification
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IHasDataSpecification>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IHasDataSpecification from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasDataSpecification>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasDataSpecification>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IHasDataSpecification, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasDataSpecification>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IHasDataSpecification, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasDataSpecification>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IHasDataSpecification>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >,
  common::optional<DeserializationError>
> AdministrativeInformationFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AdministrativeInformationFromElement. "
      "AdministrativeInformationFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAdministrativeInformation>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAdministrativeInformation>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAdministrativeInformation>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IAdministrativeInformation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAdministrativeInformation>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IAdministrativeInformation>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > instance;

  switch (*model_type) {
    case types::ModelType::kAdministrativeInformation:
      std::tie(instance, error) = AdministrativeInformationFromSequence<
        types::IAdministrativeInformation
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IAdministrativeInformation>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IAdministrativeInformation from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAdministrativeInformation>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAdministrativeInformation>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAdministrativeInformation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAdministrativeInformation>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAdministrativeInformation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAdministrativeInformation>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAdministrativeInformation>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IQualifiable>
  >,
  common::optional<DeserializationError>
> QualifiableFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in QualifiableFromElement. "
      "QualifiableFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifiable>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifiable>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IQualifiable>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IQualifiable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IQualifiable>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IQualifiable>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IQualifiable>
  > instance;

  switch (*model_type) {
    case types::ModelType::kRelationshipElement:
      std::tie(instance, error) = RelationshipElementFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kCapability:
      std::tie(instance, error) = CapabilityFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kEntity:
      std::tie(instance, error) = EntityFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kOperation:
      std::tie(instance, error) = OperationFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kSubmodelElementCollection:
      std::tie(instance, error) = SubmodelElementCollectionFromSequence<
        types::IQualifiable
      >(reader);
      break;
    case types::ModelType::kSubmodelElementList:
      std::tie(instance, error) = SubmodelElementListFromSequence<
        types::IQualifiable
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IQualifiable>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IQualifiable from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifiable>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifiable>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IQualifiable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifiable>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IQualifiable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifiable>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifiable>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IQualifier>
  >,
  common::optional<DeserializationError>
> QualifierFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in QualifierFromElement. "
      "QualifierFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifier>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifier>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IQualifier>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IQualifier, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IQualifier>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IQualifier>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IQualifier>
  > instance;

  switch (*model_type) {
    case types::ModelType::kQualifier:
      std::tie(instance, error) = QualifierFromSequence<
        types::IQualifier
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IQualifier>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IQualifier from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifier>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifier>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IQualifier, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifier>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IQualifier, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifier>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IQualifier>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IAssetAdministrationShell>
  >,
  common::optional<DeserializationError>
> AssetAdministrationShellFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AssetAdministrationShellFromElement. "
      "AssetAdministrationShellFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IAssetAdministrationShell, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IAssetAdministrationShell>
  > instance;

  switch (*model_type) {
    case types::ModelType::kAssetAdministrationShell:
      std::tie(instance, error) = AssetAdministrationShellFromSequence<
        types::IAssetAdministrationShell
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IAssetAdministrationShell>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IAssetAdministrationShell from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAssetAdministrationShell, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAssetAdministrationShell, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetAdministrationShell>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IAssetInformation>
  >,
  common::optional<DeserializationError>
> AssetInformationFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AssetInformationFromElement. "
      "AssetInformationFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetInformation>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetInformation>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAssetInformation>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IAssetInformation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAssetInformation>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IAssetInformation>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IAssetInformation>
  > instance;

  switch (*model_type) {
    case types::ModelType::kAssetInformation:
      std::tie(instance, error) = AssetInformationFromSequence<
        types::IAssetInformation
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IAssetInformation>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IAssetInformation from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetInformation>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetInformation>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAssetInformation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetInformation>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAssetInformation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetInformation>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAssetInformation>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IResource>
  >,
  common::optional<DeserializationError>
> ResourceFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ResourceFromElement. "
      "ResourceFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IResource>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IResource>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IResource>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IResource, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IResource>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IResource>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IResource>
  > instance;

  switch (*model_type) {
    case types::ModelType::kResource:
      std::tie(instance, error) = ResourceFromSequence<
        types::IResource
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IResource>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IResource from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IResource>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IResource>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IResource, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IResource>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IResource, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IResource>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IResource>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ISpecificAssetId>
  >,
  common::optional<DeserializationError>
> SpecificAssetIdFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SpecificAssetIdFromElement. "
      "SpecificAssetIdFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISpecificAssetId>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISpecificAssetId>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISpecificAssetId>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ISpecificAssetId, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISpecificAssetId>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ISpecificAssetId>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ISpecificAssetId>
  > instance;

  switch (*model_type) {
    case types::ModelType::kSpecificAssetId:
      std::tie(instance, error) = SpecificAssetIdFromSequence<
        types::ISpecificAssetId
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ISpecificAssetId>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ISpecificAssetId from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISpecificAssetId>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISpecificAssetId>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISpecificAssetId, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISpecificAssetId>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISpecificAssetId, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISpecificAssetId>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISpecificAssetId>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodel>
  >,
  common::optional<DeserializationError>
> SubmodelFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SubmodelFromElement. "
      "SubmodelFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodel>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodel>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISubmodel>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ISubmodel, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISubmodel>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ISubmodel>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ISubmodel>
  > instance;

  switch (*model_type) {
    case types::ModelType::kSubmodel:
      std::tie(instance, error) = SubmodelFromSequence<
        types::ISubmodel
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ISubmodel>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ISubmodel from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodel>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodel>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISubmodel, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodel>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISubmodel, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodel>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodel>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodelElement>
  >,
  common::optional<DeserializationError>
> SubmodelElementFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SubmodelElementFromElement. "
      "SubmodelElementFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElement>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISubmodelElement>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ISubmodelElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISubmodelElement>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ISubmodelElement>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ISubmodelElement>
  > instance;

  switch (*model_type) {
    case types::ModelType::kRelationshipElement:
      std::tie(instance, error) = RelationshipElementFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kCapability:
      std::tie(instance, error) = CapabilityFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kEntity:
      std::tie(instance, error) = EntityFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kOperation:
      std::tie(instance, error) = OperationFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kSubmodelElementCollection:
      std::tie(instance, error) = SubmodelElementCollectionFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    case types::ModelType::kSubmodelElementList:
      std::tie(instance, error) = SubmodelElementListFromSequence<
        types::ISubmodelElement
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ISubmodelElement>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ISubmodelElement from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElement>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISubmodelElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElement>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISubmodelElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElement>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElement>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IRelationshipElement>
  >,
  common::optional<DeserializationError>
> RelationshipElementFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in RelationshipElementFromElement. "
      "RelationshipElementFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRelationshipElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRelationshipElement>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IRelationshipElement>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IRelationshipElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IRelationshipElement>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IRelationshipElement>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IRelationshipElement>
  > instance;

  switch (*model_type) {
    case types::ModelType::kRelationshipElement:
      std::tie(instance, error) = RelationshipElementFromSequence<
        types::IRelationshipElement
      >(reader);
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::IRelationshipElement
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IRelationshipElement>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IRelationshipElement from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRelationshipElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRelationshipElement>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IRelationshipElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRelationshipElement>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IRelationshipElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRelationshipElement>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRelationshipElement>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodelElementList>
  >,
  common::optional<DeserializationError>
> SubmodelElementListFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SubmodelElementListFromElement. "
      "SubmodelElementListFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementList>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementList>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISubmodelElementList>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ISubmodelElementList, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISubmodelElementList>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ISubmodelElementList>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ISubmodelElementList>
  > instance;

  switch (*model_type) {
    case types::ModelType::kSubmodelElementList:
      std::tie(instance, error) = SubmodelElementListFromSequence<
        types::ISubmodelElementList
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ISubmodelElementList>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ISubmodelElementList from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementList>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementList>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISubmodelElementList, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementList>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISubmodelElementList, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementList>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementList>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodelElementCollection>
  >,
  common::optional<DeserializationError>
> SubmodelElementCollectionFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SubmodelElementCollectionFromElement. "
      "SubmodelElementCollectionFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ISubmodelElementCollection, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ISubmodelElementCollection>
  > instance;

  switch (*model_type) {
    case types::ModelType::kSubmodelElementCollection:
      std::tie(instance, error) = SubmodelElementCollectionFromSequence<
        types::ISubmodelElementCollection
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ISubmodelElementCollection>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ISubmodelElementCollection from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISubmodelElementCollection, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ISubmodelElementCollection, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ISubmodelElementCollection>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IDataElement>
  >,
  common::optional<DeserializationError>
> DataElementFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DataElementFromElement. "
      "DataElementFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataElement>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IDataElement>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IDataElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IDataElement>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IDataElement>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IDataElement>
  > instance;

  switch (*model_type) {
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::IDataElement
      >(reader);
      break;
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::IDataElement
      >(reader);
      break;
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::IDataElement
      >(reader);
      break;
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::IDataElement
      >(reader);
      break;
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::IDataElement
      >(reader);
      break;
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::IDataElement
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IDataElement>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IDataElement from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataElement>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IDataElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataElement>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IDataElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataElement>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataElement>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IProperty>
  >,
  common::optional<DeserializationError>
> PropertyFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in PropertyFromElement. "
      "PropertyFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IProperty>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IProperty>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IProperty>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IProperty, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IProperty>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IProperty>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IProperty>
  > instance;

  switch (*model_type) {
    case types::ModelType::kProperty:
      std::tie(instance, error) = PropertyFromSequence<
        types::IProperty
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IProperty>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IProperty from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IProperty>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IProperty>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IProperty, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IProperty>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IProperty, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IProperty>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IProperty>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IMultiLanguageProperty>
  >,
  common::optional<DeserializationError>
> MultiLanguagePropertyFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in MultiLanguagePropertyFromElement. "
      "MultiLanguagePropertyFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IMultiLanguageProperty, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IMultiLanguageProperty>
  > instance;

  switch (*model_type) {
    case types::ModelType::kMultiLanguageProperty:
      std::tie(instance, error) = MultiLanguagePropertyFromSequence<
        types::IMultiLanguageProperty
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IMultiLanguageProperty>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IMultiLanguageProperty from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IMultiLanguageProperty, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IMultiLanguageProperty, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IMultiLanguageProperty>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IRange>
  >,
  common::optional<DeserializationError>
> RangeFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in RangeFromElement. "
      "RangeFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRange>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRange>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IRange>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IRange, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IRange>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IRange>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IRange>
  > instance;

  switch (*model_type) {
    case types::ModelType::kRange:
      std::tie(instance, error) = RangeFromSequence<
        types::IRange
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IRange>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IRange from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRange>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRange>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IRange, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRange>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IRange, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRange>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IRange>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IReferenceElement>
  >,
  common::optional<DeserializationError>
> ReferenceElementFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ReferenceElementFromElement. "
      "ReferenceElementFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferenceElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferenceElement>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IReferenceElement>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IReferenceElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IReferenceElement>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IReferenceElement>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IReferenceElement>
  > instance;

  switch (*model_type) {
    case types::ModelType::kReferenceElement:
      std::tie(instance, error) = ReferenceElementFromSequence<
        types::IReferenceElement
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IReferenceElement>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IReferenceElement from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferenceElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferenceElement>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IReferenceElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferenceElement>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IReferenceElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferenceElement>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReferenceElement>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IBlob>
  >,
  common::optional<DeserializationError>
> BlobFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in BlobFromElement. "
      "BlobFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBlob>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBlob>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IBlob>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IBlob, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IBlob>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IBlob>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IBlob>
  > instance;

  switch (*model_type) {
    case types::ModelType::kBlob:
      std::tie(instance, error) = BlobFromSequence<
        types::IBlob
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IBlob>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IBlob from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBlob>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBlob>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IBlob, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBlob>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IBlob, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBlob>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBlob>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IFile>
  >,
  common::optional<DeserializationError>
> FileFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in FileFromElement. "
      "FileFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IFile>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IFile>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IFile>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IFile, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IFile>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IFile>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IFile>
  > instance;

  switch (*model_type) {
    case types::ModelType::kFile:
      std::tie(instance, error) = FileFromSequence<
        types::IFile
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IFile>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IFile from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IFile>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IFile>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IFile, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IFile>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IFile, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IFile>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IFile>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IAnnotatedRelationshipElement>
  >,
  common::optional<DeserializationError>
> AnnotatedRelationshipElementFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AnnotatedRelationshipElementFromElement. "
      "AnnotatedRelationshipElementFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IAnnotatedRelationshipElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IAnnotatedRelationshipElement>
  > instance;

  switch (*model_type) {
    case types::ModelType::kAnnotatedRelationshipElement:
      std::tie(instance, error) = AnnotatedRelationshipElementFromSequence<
        types::IAnnotatedRelationshipElement
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IAnnotatedRelationshipElement>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IAnnotatedRelationshipElement from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAnnotatedRelationshipElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAnnotatedRelationshipElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAnnotatedRelationshipElement>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IEntity>
  >,
  common::optional<DeserializationError>
> EntityFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EntityFromElement. "
      "EntityFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEntity>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEntity>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEntity>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IEntity, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEntity>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IEntity>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IEntity>
  > instance;

  switch (*model_type) {
    case types::ModelType::kEntity:
      std::tie(instance, error) = EntityFromSequence<
        types::IEntity
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IEntity>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IEntity from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEntity>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEntity>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEntity, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEntity>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEntity, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEntity>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEntity>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IEventPayload>
  >,
  common::optional<DeserializationError>
> EventPayloadFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EventPayloadFromElement. "
      "EventPayloadFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventPayload>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventPayload>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEventPayload>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IEventPayload, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEventPayload>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IEventPayload>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IEventPayload>
  > instance;

  switch (*model_type) {
    case types::ModelType::kEventPayload:
      std::tie(instance, error) = EventPayloadFromSequence<
        types::IEventPayload
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IEventPayload>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IEventPayload from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventPayload>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventPayload>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEventPayload, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventPayload>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEventPayload, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventPayload>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventPayload>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IEventElement>
  >,
  common::optional<DeserializationError>
> EventElementFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EventElementFromElement. "
      "EventElementFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventElement>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEventElement>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IEventElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEventElement>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IEventElement>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IEventElement>
  > instance;

  switch (*model_type) {
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::IEventElement
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IEventElement>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IEventElement from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventElement>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEventElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventElement>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEventElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventElement>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEventElement>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IBasicEventElement>
  >,
  common::optional<DeserializationError>
> BasicEventElementFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in BasicEventElementFromElement. "
      "BasicEventElementFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBasicEventElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBasicEventElement>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IBasicEventElement>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IBasicEventElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IBasicEventElement>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IBasicEventElement>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IBasicEventElement>
  > instance;

  switch (*model_type) {
    case types::ModelType::kBasicEventElement:
      std::tie(instance, error) = BasicEventElementFromSequence<
        types::IBasicEventElement
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IBasicEventElement>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IBasicEventElement from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBasicEventElement>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBasicEventElement>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IBasicEventElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBasicEventElement>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IBasicEventElement, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBasicEventElement>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IBasicEventElement>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IOperation>
  >,
  common::optional<DeserializationError>
> OperationFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in OperationFromElement. "
      "OperationFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperation>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperation>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IOperation>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IOperation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IOperation>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IOperation>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IOperation>
  > instance;

  switch (*model_type) {
    case types::ModelType::kOperation:
      std::tie(instance, error) = OperationFromSequence<
        types::IOperation
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IOperation>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IOperation from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperation>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperation>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IOperation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperation>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IOperation, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperation>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperation>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IOperationVariable>
  >,
  common::optional<DeserializationError>
> OperationVariableFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in OperationVariableFromElement. "
      "OperationVariableFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperationVariable>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperationVariable>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IOperationVariable>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IOperationVariable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IOperationVariable>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IOperationVariable>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IOperationVariable>
  > instance;

  switch (*model_type) {
    case types::ModelType::kOperationVariable:
      std::tie(instance, error) = OperationVariableFromSequence<
        types::IOperationVariable
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IOperationVariable>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IOperationVariable from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperationVariable>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperationVariable>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IOperationVariable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperationVariable>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IOperationVariable, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperationVariable>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IOperationVariable>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ICapability>
  >,
  common::optional<DeserializationError>
> CapabilityFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in CapabilityFromElement. "
      "CapabilityFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ICapability>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ICapability>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ICapability>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ICapability, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ICapability>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ICapability>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ICapability>
  > instance;

  switch (*model_type) {
    case types::ModelType::kCapability:
      std::tie(instance, error) = CapabilityFromSequence<
        types::ICapability
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ICapability>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ICapability from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ICapability>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ICapability>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ICapability, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ICapability>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ICapability, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ICapability>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ICapability>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IConceptDescription>
  >,
  common::optional<DeserializationError>
> ConceptDescriptionFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ConceptDescriptionFromElement. "
      "ConceptDescriptionFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IConceptDescription>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IConceptDescription>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IConceptDescription>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IConceptDescription, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IConceptDescription>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IConceptDescription>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IConceptDescription>
  > instance;

  switch (*model_type) {
    case types::ModelType::kConceptDescription:
      std::tie(instance, error) = ConceptDescriptionFromSequence<
        types::IConceptDescription
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IConceptDescription>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IConceptDescription from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IConceptDescription>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IConceptDescription>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IConceptDescription, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IConceptDescription>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IConceptDescription, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IConceptDescription>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IConceptDescription>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IReference>
  >,
  common::optional<DeserializationError>
> ReferenceFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ReferenceFromElement. "
      "ReferenceFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReference>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReference>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IReference>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IReference, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IReference>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IReference>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IReference>
  > instance;

  switch (*model_type) {
    case types::ModelType::kReference:
      std::tie(instance, error) = ReferenceFromSequence<
        types::IReference
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IReference>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IReference from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReference>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReference>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IReference, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReference>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IReference, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReference>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IReference>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IKey>
  >,
  common::optional<DeserializationError>
> KeyFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in KeyFromElement. "
      "KeyFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IKey>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IKey>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IKey>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IKey, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IKey>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IKey>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IKey>
  > instance;

  switch (*model_type) {
    case types::ModelType::kKey:
      std::tie(instance, error) = KeyFromSequence<
        types::IKey
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IKey>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IKey from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IKey>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IKey>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IKey, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IKey>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IKey, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IKey>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IKey>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IAbstractLangString>
  >,
  common::optional<DeserializationError>
> AbstractLangStringFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AbstractLangStringFromElement. "
      "AbstractLangStringFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAbstractLangString>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAbstractLangString>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAbstractLangString>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IAbstractLangString, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IAbstractLangString>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IAbstractLangString>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IAbstractLangString>
  > instance;

  switch (*model_type) {
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      std::tie(instance, error) = LangStringDefinitionTypeIec61360FromSequence<
        types::IAbstractLangString
      >(reader);
      break;
    case types::ModelType::kLangStringNameType:
      std::tie(instance, error) = LangStringNameTypeFromSequence<
        types::IAbstractLangString
      >(reader);
      break;
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      std::tie(instance, error) = LangStringPreferredNameTypeIec61360FromSequence<
        types::IAbstractLangString
      >(reader);
      break;
    case types::ModelType::kLangStringShortNameTypeIec61360:
      std::tie(instance, error) = LangStringShortNameTypeIec61360FromSequence<
        types::IAbstractLangString
      >(reader);
      break;
    case types::ModelType::kLangStringTextType:
      std::tie(instance, error) = LangStringTextTypeFromSequence<
        types::IAbstractLangString
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IAbstractLangString>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IAbstractLangString from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAbstractLangString>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAbstractLangString>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAbstractLangString, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAbstractLangString>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IAbstractLangString, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAbstractLangString>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IAbstractLangString>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringNameType>
  >,
  common::optional<DeserializationError>
> LangStringNameTypeFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringNameTypeFromElement. "
      "LangStringNameTypeFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringNameType>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringNameType>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringNameType>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ILangStringNameType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringNameType>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ILangStringNameType>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ILangStringNameType>
  > instance;

  switch (*model_type) {
    case types::ModelType::kLangStringNameType:
      std::tie(instance, error) = LangStringNameTypeFromSequence<
        types::ILangStringNameType
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ILangStringNameType>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ILangStringNameType from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringNameType>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringNameType>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringNameType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringNameType>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringNameType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringNameType>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringNameType>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringTextType>
  >,
  common::optional<DeserializationError>
> LangStringTextTypeFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringTextTypeFromElement. "
      "LangStringTextTypeFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringTextType>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringTextType>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringTextType>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ILangStringTextType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringTextType>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ILangStringTextType>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ILangStringTextType>
  > instance;

  switch (*model_type) {
    case types::ModelType::kLangStringTextType:
      std::tie(instance, error) = LangStringTextTypeFromSequence<
        types::ILangStringTextType
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ILangStringTextType>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ILangStringTextType from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringTextType>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringTextType>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringTextType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringTextType>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringTextType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringTextType>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringTextType>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IEnvironment>
  >,
  common::optional<DeserializationError>
> EnvironmentFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EnvironmentFromElement. "
      "EnvironmentFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEnvironment>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEnvironment>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEnvironment>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IEnvironment, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEnvironment>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IEnvironment>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IEnvironment>
  > instance;

  switch (*model_type) {
    case types::ModelType::kEnvironment:
      std::tie(instance, error) = EnvironmentFromSequence<
        types::IEnvironment
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IEnvironment>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IEnvironment from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEnvironment>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEnvironment>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEnvironment, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEnvironment>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEnvironment, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEnvironment>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEnvironment>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IDataSpecificationContent>
  >,
  common::optional<DeserializationError>
> DataSpecificationContentFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DataSpecificationContentFromElement. "
      "DataSpecificationContentFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationContent>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationContent>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IDataSpecificationContent>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IDataSpecificationContent, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IDataSpecificationContent>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IDataSpecificationContent>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IDataSpecificationContent>
  > instance;

  switch (*model_type) {
    case types::ModelType::kDataSpecificationIec61360:
      std::tie(instance, error) = DataSpecificationIec61360FromSequence<
        types::IDataSpecificationContent
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IDataSpecificationContent>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IDataSpecificationContent from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationContent>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationContent>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IDataSpecificationContent, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationContent>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IDataSpecificationContent, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationContent>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationContent>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >,
  common::optional<DeserializationError>
> EmbeddedDataSpecificationFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EmbeddedDataSpecificationFromElement. "
      "EmbeddedDataSpecificationFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IEmbeddedDataSpecification, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  > instance;

  switch (*model_type) {
    case types::ModelType::kEmbeddedDataSpecification:
      std::tie(instance, error) = EmbeddedDataSpecificationFromSequence<
        types::IEmbeddedDataSpecification
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IEmbeddedDataSpecification from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEmbeddedDataSpecification, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IEmbeddedDataSpecification, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ILevelType>
  >,
  common::optional<DeserializationError>
> LevelTypeFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LevelTypeFromElement. "
      "LevelTypeFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILevelType>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILevelType>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILevelType>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ILevelType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILevelType>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ILevelType>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ILevelType>
  > instance;

  switch (*model_type) {
    case types::ModelType::kLevelType:
      std::tie(instance, error) = LevelTypeFromSequence<
        types::ILevelType
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ILevelType>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ILevelType from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILevelType>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILevelType>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILevelType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILevelType>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILevelType, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILevelType>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILevelType>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IValueReferencePair>
  >,
  common::optional<DeserializationError>
> ValueReferencePairFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ValueReferencePairFromElement. "
      "ValueReferencePairFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueReferencePair>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueReferencePair>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IValueReferencePair>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IValueReferencePair, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IValueReferencePair>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IValueReferencePair>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IValueReferencePair>
  > instance;

  switch (*model_type) {
    case types::ModelType::kValueReferencePair:
      std::tie(instance, error) = ValueReferencePairFromSequence<
        types::IValueReferencePair
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IValueReferencePair>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IValueReferencePair from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueReferencePair>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueReferencePair>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IValueReferencePair, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueReferencePair>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IValueReferencePair, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueReferencePair>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueReferencePair>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IValueList>
  >,
  common::optional<DeserializationError>
> ValueListFromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ValueListFromElement. "
      "ValueListFromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueList>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueList>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IValueList>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IValueList, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IValueList>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IValueList>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IValueList>
  > instance;

  switch (*model_type) {
    case types::ModelType::kValueList:
      std::tie(instance, error) = ValueListFromSequence<
        types::IValueList
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IValueList>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IValueList from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueList>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueList>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IValueList, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueList>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IValueList, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueList>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IValueList>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
  >,
  common::optional<DeserializationError>
> LangStringPreferredNameTypeIec61360FromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringPreferredNameTypeIec61360FromElement. "
      "LangStringPreferredNameTypeIec61360FromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ILangStringPreferredNameTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
  > instance;

  switch (*model_type) {
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      std::tie(instance, error) = LangStringPreferredNameTypeIec61360FromSequence<
        types::ILangStringPreferredNameTypeIec61360
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ILangStringPreferredNameTypeIec61360 from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringPreferredNameTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringPreferredNameTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringShortNameTypeIec61360>
  >,
  common::optional<DeserializationError>
> LangStringShortNameTypeIec61360FromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringShortNameTypeIec61360FromElement. "
      "LangStringShortNameTypeIec61360FromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ILangStringShortNameTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ILangStringShortNameTypeIec61360>
  > instance;

  switch (*model_type) {
    case types::ModelType::kLangStringShortNameTypeIec61360:
      std::tie(instance, error) = LangStringShortNameTypeIec61360FromSequence<
        types::ILangStringShortNameTypeIec61360
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ILangStringShortNameTypeIec61360>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ILangStringShortNameTypeIec61360 from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringShortNameTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringShortNameTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
  >,
  common::optional<DeserializationError>
> LangStringDefinitionTypeIec61360FromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringDefinitionTypeIec61360FromElement. "
      "LangStringDefinitionTypeIec61360FromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of ILangStringDefinitionTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
  > instance;

  switch (*model_type) {
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      std::tie(instance, error) = LangStringDefinitionTypeIec61360FromSequence<
        types::ILangStringDefinitionTypeIec61360
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of ILangStringDefinitionTypeIec61360 from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringDefinitionTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of ILangStringDefinitionTypeIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

std::pair<
  common::optional<
    std::shared_ptr<types::IDataSpecificationIec61360>
  >,
  common::optional<DeserializationError>
> DataSpecificationIec61360FromElement(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DataSpecificationIec61360FromElement. "
      "DataSpecificationIec61360FromElement expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(std::move(*error));
  }

  if (reader.node().kind() != NodeKind::Start) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(
      common::Concat(
        L"Expected a start element opening an instance "
        L"of IDataSpecificationIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string name(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StartNode&
    >(reader.node()).name
  );

  common::optional<types::ModelType> model_type(
    ModelTypeFromElementName(name)
  );
  if (!model_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(
      common::Concat(
      L"Unexpected start element as its name does not correspond "
      L"to any model type: ",
      common::Utf8ToWstring(name)
      )
    );
  }

  // NOTE (mristin):
  // We consume the start element.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    auto noInstanceAndError = NoInstanceAndDeserializationErrorFromReader<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(
      reader
    );

    PrependElementSegmentToDeserializationError(
      name,
      *(noInstanceAndError.second)
    );

    return noInstanceAndError;
  }

  common::optional<
    std::shared_ptr<types::IDataSpecificationIec61360>
  > instance;

  switch (*model_type) {
    case types::ModelType::kDataSpecificationIec61360:
      std::tie(instance, error) = DataSpecificationIec61360FromSequence<
        types::IDataSpecificationIec61360
      >(reader);
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<types::IDataSpecificationIec61360>
      >(
        common::Concat(
          L"Impossible to de-serialize an instance "
          L"of IDataSpecificationIec61360 from <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
  }

  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(std::move(*error));
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(std::move(*error));
  }

  if (!IsStopNodeWithName(reader.node(), name)) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IDataSpecificationIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(std::move(*error));
  }

  const StopNode& stop_node(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const StopNode&
    >(reader.node())
  );
  if (stop_node.name != name) {
    error = DeserializationError(
      common::Concat(
        L"Expected a stop element </",
        common::Utf8ToWstring(name),
        L"> closing an instance "
        L"of IDataSpecificationIec61360, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(std::move(*error));
  }

  // NOTE (mristin):
  // We consume the stop element.
  reader.Read();
  if (reader.node().kind() == NodeKind::Error) {
    error = DeserializationErrorFromReader(reader);

    PrependElementSegmentToDeserializationError(
      name,
      *error
    );

    return NoInstanceAndDeserializationError<
      std::shared_ptr<types::IDataSpecificationIec61360>
    >(std::move(*error));
  }

  return InstanceAndNoDeserializationError(
    std::move(*instance)
  );
}

// region De-serialize primitives

const std::unordered_map<
  std::string,
  bool
> kTextToBool = {
  {"true", true},
  {"false", false},
  {"1", true},
  {"0", false}
};

std::pair<
  common::optional<bool>,
  common::optional<DeserializationError>
> DeserializeBool(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeBool. "
      "DeserializeBool expects no error node."
    );
  }
  #endif

  if (reader.node().kind() != NodeKind::Text) {
    return NoInstanceAndDeserializationErrorWithCause<bool>(
      common::Concat(
        L"Expected to parse an xs:boolean from XML text, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  auto it = kTextToBool.find(text);
  if (it == kTextToBool.end()) {
    return NoInstanceAndDeserializationErrorWithCause<bool>(
      common::Concat(
        L"Expected to parse an xs:boolean from text, "
        L"but got an invalid value: ",
        common::Utf8ToWstring(text)
      )
    );
  }

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<bool>(reader);
  }

  return std::make_pair(
    it->second,
    common::nullopt
  );
}

std::pair<
  common::optional<int64_t>,
  common::optional<DeserializationError>
> DeserializeInt64(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeInt64. "
      "DeserializeInt64 expects no error node."
    );
  }
  #endif

  if (reader.node().kind() != NodeKind::Text) {
    return NoInstanceAndDeserializationErrorWithCause<int64_t>(
      common::Concat(
        L"Expected to parse an xs:long from XML text, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  common::optional<int64_t> deserialized;

  static_assert(
    sizeof(int) == 8
    || sizeof(long) == 8
    || sizeof(long long) == 8,
    "Neither int nor long nor long long are 8 bytes long, "
    "so we do not know how to parse an xs:long."
  );

  try {
    // NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
    const bool sizeof_int_is_8 = sizeof(int) == 8;
    const bool sizeof_long_is_8 = sizeof(long) == 8;
    const bool sizeof_long_long_is_8 = sizeof(long long) == 8;

    if (sizeof_int_is_8) {
      deserialized = std::stoi(text);
    } else if (sizeof_long_is_8) {
      deserialized = std::stol(text);
    } else if (sizeof_long_long_is_8) {
      deserialized = std::stoll(text);
    }
  } catch (std::invalid_argument&) {
    return NoInstanceAndDeserializationErrorWithCause<int64_t>(
      common::Concat(
        L"Expected to parse an xs:long from text, "
        L"but got an invalid value: ",
        common::Utf8ToWstring(text)
      )
    );
  } catch (std::out_of_range&) {
    return NoInstanceAndDeserializationErrorWithCause<int64_t>(
      common::Concat(
        L"Expected to parse an xs:long from text, "
        L"but got a value out of the xs:long range: ",
        common::Utf8ToWstring(text)
      )
    );
  }

  if (!deserialized.has_value()) {
    throw std::logic_error(
      "Neither int nor long nor long long are 8 bytes long, "
      "but this should have been caught earlier in the static assert"
    );
  }

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<int64_t>(reader);
  }

  return std::make_pair(
    deserialized,
    common::nullopt
  );
}

std::pair<
  common::optional<double>,
  common::optional<DeserializationError>
> DeserializeDouble(
  ReaderMergingText& reader
) {
  static_assert(
    sizeof(double) == 8,
    "DeserializeDouble expects double to be 8 bytes, "
    "but the size of the double is not 8 bytes"
  );

  #ifdef DEBUG
  if (node.kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeDouble. "
      "DeserializeDouble expects no error node."
    );
  }
  #endif

  if (reader.node().kind() != NodeKind::Text) {
    return NoInstanceAndDeserializationErrorWithCause<double>(
      common::Concat(
        L"Expected to parse an xs:double from XML text, but got ",
        NodeToHumanReadableWstring(reader.node())
      )
    );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  double deserialized;

  try {
    deserialized = std::stod(text);
  } catch (std::invalid_argument&) {
    return NoInstanceAndDeserializationErrorWithCause<double>(
      common::Concat(
        L"Expected to parse an xs:double from text, "
        L"but got an invalid value: ",
        common::Utf8ToWstring(text)
      )
    );
  } catch (std::out_of_range&) {
    return NoInstanceAndDeserializationErrorWithCause<double>(
      common::Concat(
        L"Expected to parse an xs:double from text, "
        L"but got a value out of the xs:double range: ",
        common::Utf8ToWstring(text)
      )
    );
  }

  // NOTE (mristin):
  // XSD basic types are not case insensitive and quite strict.
  // We follow this strictness in the parsing as well.
  //
  // See: https://www.w3.org/TR/xmlschema11-2/#double

  const bool invalid_xml(
    (
      deserialized == std::numeric_limits<double>::infinity()
      && text != "INF"
    ) || (
      deserialized == -std::numeric_limits<double>::infinity()
      && text != "-INF"
    ) || (
      std::isnan(deserialized)
      && text != "NaN"
    )
  );

  if (invalid_xml) {
    return NoInstanceAndDeserializationErrorWithCause<double>(
      common::Concat(
        L"Expected to parse an xs:double from text, "
        L"but got an invalid value: ",
        common::Utf8ToWstring(text)
      )
    );
  }

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<double>(reader);
  }

  return std::make_pair(
    deserialized,
    common::nullopt
  );
}

std::pair<
  common::optional<std::wstring>,
  common::optional<DeserializationError>
> DeserializeWstring(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeWstring. "
      "DeserializeWstring expects no error node."
    );
  }
  #endif

  switch (reader.node().kind()) {
    case NodeKind::Stop:
      // Encountering a stop node means that the string is empty.
      return std::make_pair(std::wstring(), common::nullopt);
    case NodeKind::Text:
      // We pass and continue decoding the text.
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<std::wstring>(
        common::Concat(
          L"Expected to parse an xs:string from XML text, but got ",
            NodeToHumanReadableWstring(reader.node())
          )
        );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  std::wstring deserialized = common::Utf8ToWstring(text);

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<std::wstring>(reader);
  }

  return std::make_pair(std::move(deserialized), common::nullopt);
}

std::pair<
  common::optional<std::vector<std::uint8_t> >,
  common::optional<DeserializationError>
> DeserializeByteArray(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DeserializeByteArray. "
      "DeserializeByteArray expects no error node."
    );
  }
  #endif

  switch (reader.node().kind()) {
    case NodeKind::Stop:
      // Encountering a stop node means empty byte array.
      return std::make_pair(
        std::vector<std::uint8_t>(),
        common::nullopt
      );
    case NodeKind::Text:
      // We pass and continue decoding the byte array.
      break;
    default:
      return NoInstanceAndDeserializationErrorWithCause<
        std::vector<std::uint8_t>
      >(
        common::Concat(
          L"Expected to parse an xs:base64Binary from XML text, but got ",
            NodeToHumanReadableWstring(reader.node())
          )
        );
  }

  const std::string& text(
    static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
      const TextNode&
    >(reader.node()).text
  );

  common::expected<
    std::vector<std::uint8_t>,
    std::string
  > deserialized = stringification::Base64Decode(text);

  if (!deserialized.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::vector<std::uint8_t>
    >(
      common::Concat(
        L"Expected to parse an xs:base64Binary from text, "
        L"but the value was invalid: ",
        common::Utf8ToWstring(deserialized.error())
      )
    );
  }

  // NOTE (mristin):
  // We consume the text node.
  reader.Read();

  if (reader.node().kind() == NodeKind::Error) {
    return NoInstanceAndDeserializationErrorFromReader<
      std::vector<std::uint8_t>
    >(reader);
  }

  return std::make_pair(
    std::move(*deserialized),
    common::nullopt
  );
}

// endregion De-serialize primitives

namespace properties {

enum class OfExtension : std::uint32_t {
  kSemanticId = 0,
  kSupplementalSemanticIds = 1,
  kName = 2,
  kValueType = 3,
  kValue = 4,
  kRefersTo = 5
};  // enum class OfExtension

enum class OfAdministrativeInformation : std::uint32_t {
  kEmbeddedDataSpecifications = 0,
  kVersion = 1,
  kRevision = 2,
  kCreator = 3,
  kTemplateId = 4
};  // enum class OfAdministrativeInformation

enum class OfQualifier : std::uint32_t {
  kSemanticId = 0,
  kSupplementalSemanticIds = 1,
  kKind = 2,
  kType = 3,
  kValueType = 4,
  kValue = 5,
  kValueId = 6
};  // enum class OfQualifier

enum class OfAssetAdministrationShell : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kAdministration = 5,
  kId = 6,
  kEmbeddedDataSpecifications = 7,
  kDerivedFrom = 8,
  kAssetInformation = 9,
  kSubmodels = 10
};  // enum class OfAssetAdministrationShell

enum class OfAssetInformation : std::uint32_t {
  kAssetKind = 0,
  kGlobalAssetId = 1,
  kSpecificAssetIds = 2,
  kAssetType = 3,
  kDefaultThumbnail = 4
};  // enum class OfAssetInformation

enum class OfResource : std::uint32_t {
  kPath = 0,
  kContentType = 1
};  // enum class OfResource

enum class OfSpecificAssetId : std::uint32_t {
  kSemanticId = 0,
  kSupplementalSemanticIds = 1,
  kName = 2,
  kValue = 3,
  kExternalSubjectId = 4
};  // enum class OfSpecificAssetId

enum class OfSubmodel : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kAdministration = 5,
  kId = 6,
  kKind = 7,
  kSemanticId = 8,
  kSupplementalSemanticIds = 9,
  kQualifiers = 10,
  kEmbeddedDataSpecifications = 11,
  kSubmodelElements = 12
};  // enum class OfSubmodel

enum class OfRelationshipElement : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kFirst = 9,
  kSecond = 10
};  // enum class OfRelationshipElement

enum class OfSubmodelElementList : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kOrderRelevant = 9,
  kSemanticIdListElement = 10,
  kTypeValueListElement = 11,
  kValueTypeListElement = 12,
  kValue = 13
};  // enum class OfSubmodelElementList

enum class OfSubmodelElementCollection : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kValue = 9
};  // enum class OfSubmodelElementCollection

enum class OfProperty : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kValueType = 9,
  kValue = 10,
  kValueId = 11
};  // enum class OfProperty

enum class OfMultiLanguageProperty : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kValue = 9,
  kValueId = 10
};  // enum class OfMultiLanguageProperty

enum class OfRange : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kValueType = 9,
  kMin = 10,
  kMax = 11
};  // enum class OfRange

enum class OfReferenceElement : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kValue = 9
};  // enum class OfReferenceElement

enum class OfBlob : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kValue = 9,
  kContentType = 10
};  // enum class OfBlob

enum class OfFile : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kValue = 9,
  kContentType = 10
};  // enum class OfFile

enum class OfAnnotatedRelationshipElement : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kFirst = 9,
  kSecond = 10,
  kAnnotations = 11
};  // enum class OfAnnotatedRelationshipElement

enum class OfEntity : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kStatements = 9,
  kEntityType = 10,
  kGlobalAssetId = 11,
  kSpecificAssetIds = 12
};  // enum class OfEntity

enum class OfEventPayload : std::uint32_t {
  kSource = 0,
  kSourceSemanticId = 1,
  kObservableReference = 2,
  kObservableSemanticId = 3,
  kTopic = 4,
  kSubjectId = 5,
  kTimeStamp = 6,
  kPayload = 7
};  // enum class OfEventPayload

enum class OfBasicEventElement : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kObserved = 9,
  kDirection = 10,
  kState = 11,
  kMessageTopic = 12,
  kMessageBroker = 13,
  kLastUpdate = 14,
  kMinInterval = 15,
  kMaxInterval = 16
};  // enum class OfBasicEventElement

enum class OfOperation : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8,
  kInputVariables = 9,
  kOutputVariables = 10,
  kInoutputVariables = 11
};  // enum class OfOperation

enum class OfOperationVariable : std::uint32_t {
  kValue = 0
};  // enum class OfOperationVariable

enum class OfCapability : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kSemanticId = 5,
  kSupplementalSemanticIds = 6,
  kQualifiers = 7,
  kEmbeddedDataSpecifications = 8
};  // enum class OfCapability

enum class OfConceptDescription : std::uint32_t {
  kExtensions = 0,
  kCategory = 1,
  kIdShort = 2,
  kDisplayName = 3,
  kDescription = 4,
  kAdministration = 5,
  kId = 6,
  kEmbeddedDataSpecifications = 7,
  kIsCaseOf = 8
};  // enum class OfConceptDescription

enum class OfReference : std::uint32_t {
  kType = 0,
  kReferredSemanticId = 1,
  kKeys = 2
};  // enum class OfReference

enum class OfKey : std::uint32_t {
  kType = 0,
  kValue = 1
};  // enum class OfKey

enum class OfLangStringNameType : std::uint32_t {
  kLanguage = 0,
  kText = 1
};  // enum class OfLangStringNameType

enum class OfLangStringTextType : std::uint32_t {
  kLanguage = 0,
  kText = 1
};  // enum class OfLangStringTextType

enum class OfEnvironment : std::uint32_t {
  kAssetAdministrationShells = 0,
  kSubmodels = 1,
  kConceptDescriptions = 2
};  // enum class OfEnvironment

enum class OfEmbeddedDataSpecification : std::uint32_t {
  kDataSpecificationContent = 0,
  kDataSpecification = 1
};  // enum class OfEmbeddedDataSpecification

enum class OfLevelType : std::uint32_t {
  kMin = 0,
  kNom = 1,
  kTyp = 2,
  kMax = 3
};  // enum class OfLevelType

enum class OfValueReferencePair : std::uint32_t {
  kValue = 0,
  kValueId = 1
};  // enum class OfValueReferencePair

enum class OfValueList : std::uint32_t {
  kValueReferencePairs = 0
};  // enum class OfValueList

enum class OfLangStringPreferredNameTypeIec61360 : std::uint32_t {
  kLanguage = 0,
  kText = 1
};  // enum class OfLangStringPreferredNameTypeIec61360

enum class OfLangStringShortNameTypeIec61360 : std::uint32_t {
  kLanguage = 0,
  kText = 1
};  // enum class OfLangStringShortNameTypeIec61360

enum class OfLangStringDefinitionTypeIec61360 : std::uint32_t {
  kLanguage = 0,
  kText = 1
};  // enum class OfLangStringDefinitionTypeIec61360

enum class OfDataSpecificationIec61360 : std::uint32_t {
  kPreferredName = 0,
  kShortName = 1,
  kUnit = 2,
  kUnitId = 3,
  kSourceOfDefinition = 4,
  kSymbol = 5,
  kDataType = 6,
  kDefinition = 7,
  kValueFormat = 8,
  kValueList = 9,
  kValue = 10,
  kLevelType = 11
};  // enum class OfDataSpecificationIec61360

const std::unordered_map<
  std::string,
  OfExtension
> kMapOfExtension = {
  {
    "semanticId",
    OfExtension::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfExtension::kSupplementalSemanticIds
  },
  {
    "name",
    OfExtension::kName
  },
  {
    "valueType",
    OfExtension::kValueType
  },
  {
    "value",
    OfExtension::kValue
  },
  {
    "refersTo",
    OfExtension::kRefersTo
  }
};

const std::unordered_map<
  std::string,
  OfAdministrativeInformation
> kMapOfAdministrativeInformation = {
  {
    "embeddedDataSpecifications",
    OfAdministrativeInformation::kEmbeddedDataSpecifications
  },
  {
    "version",
    OfAdministrativeInformation::kVersion
  },
  {
    "revision",
    OfAdministrativeInformation::kRevision
  },
  {
    "creator",
    OfAdministrativeInformation::kCreator
  },
  {
    "templateId",
    OfAdministrativeInformation::kTemplateId
  }
};

const std::unordered_map<
  std::string,
  OfQualifier
> kMapOfQualifier = {
  {
    "semanticId",
    OfQualifier::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfQualifier::kSupplementalSemanticIds
  },
  {
    "kind",
    OfQualifier::kKind
  },
  {
    "type",
    OfQualifier::kType
  },
  {
    "valueType",
    OfQualifier::kValueType
  },
  {
    "value",
    OfQualifier::kValue
  },
  {
    "valueId",
    OfQualifier::kValueId
  }
};

const std::unordered_map<
  std::string,
  OfAssetAdministrationShell
> kMapOfAssetAdministrationShell = {
  {
    "extensions",
    OfAssetAdministrationShell::kExtensions
  },
  {
    "category",
    OfAssetAdministrationShell::kCategory
  },
  {
    "idShort",
    OfAssetAdministrationShell::kIdShort
  },
  {
    "displayName",
    OfAssetAdministrationShell::kDisplayName
  },
  {
    "description",
    OfAssetAdministrationShell::kDescription
  },
  {
    "administration",
    OfAssetAdministrationShell::kAdministration
  },
  {
    "id",
    OfAssetAdministrationShell::kId
  },
  {
    "embeddedDataSpecifications",
    OfAssetAdministrationShell::kEmbeddedDataSpecifications
  },
  {
    "derivedFrom",
    OfAssetAdministrationShell::kDerivedFrom
  },
  {
    "assetInformation",
    OfAssetAdministrationShell::kAssetInformation
  },
  {
    "submodels",
    OfAssetAdministrationShell::kSubmodels
  }
};

const std::unordered_map<
  std::string,
  OfAssetInformation
> kMapOfAssetInformation = {
  {
    "assetKind",
    OfAssetInformation::kAssetKind
  },
  {
    "globalAssetId",
    OfAssetInformation::kGlobalAssetId
  },
  {
    "specificAssetIds",
    OfAssetInformation::kSpecificAssetIds
  },
  {
    "assetType",
    OfAssetInformation::kAssetType
  },
  {
    "defaultThumbnail",
    OfAssetInformation::kDefaultThumbnail
  }
};

const std::unordered_map<
  std::string,
  OfResource
> kMapOfResource = {
  {
    "path",
    OfResource::kPath
  },
  {
    "contentType",
    OfResource::kContentType
  }
};

const std::unordered_map<
  std::string,
  OfSpecificAssetId
> kMapOfSpecificAssetId = {
  {
    "semanticId",
    OfSpecificAssetId::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfSpecificAssetId::kSupplementalSemanticIds
  },
  {
    "name",
    OfSpecificAssetId::kName
  },
  {
    "value",
    OfSpecificAssetId::kValue
  },
  {
    "externalSubjectId",
    OfSpecificAssetId::kExternalSubjectId
  }
};

const std::unordered_map<
  std::string,
  OfSubmodel
> kMapOfSubmodel = {
  {
    "extensions",
    OfSubmodel::kExtensions
  },
  {
    "category",
    OfSubmodel::kCategory
  },
  {
    "idShort",
    OfSubmodel::kIdShort
  },
  {
    "displayName",
    OfSubmodel::kDisplayName
  },
  {
    "description",
    OfSubmodel::kDescription
  },
  {
    "administration",
    OfSubmodel::kAdministration
  },
  {
    "id",
    OfSubmodel::kId
  },
  {
    "kind",
    OfSubmodel::kKind
  },
  {
    "semanticId",
    OfSubmodel::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfSubmodel::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfSubmodel::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfSubmodel::kEmbeddedDataSpecifications
  },
  {
    "submodelElements",
    OfSubmodel::kSubmodelElements
  }
};

const std::unordered_map<
  std::string,
  OfRelationshipElement
> kMapOfRelationshipElement = {
  {
    "extensions",
    OfRelationshipElement::kExtensions
  },
  {
    "category",
    OfRelationshipElement::kCategory
  },
  {
    "idShort",
    OfRelationshipElement::kIdShort
  },
  {
    "displayName",
    OfRelationshipElement::kDisplayName
  },
  {
    "description",
    OfRelationshipElement::kDescription
  },
  {
    "semanticId",
    OfRelationshipElement::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfRelationshipElement::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfRelationshipElement::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfRelationshipElement::kEmbeddedDataSpecifications
  },
  {
    "first",
    OfRelationshipElement::kFirst
  },
  {
    "second",
    OfRelationshipElement::kSecond
  }
};

const std::unordered_map<
  std::string,
  OfSubmodelElementList
> kMapOfSubmodelElementList = {
  {
    "extensions",
    OfSubmodelElementList::kExtensions
  },
  {
    "category",
    OfSubmodelElementList::kCategory
  },
  {
    "idShort",
    OfSubmodelElementList::kIdShort
  },
  {
    "displayName",
    OfSubmodelElementList::kDisplayName
  },
  {
    "description",
    OfSubmodelElementList::kDescription
  },
  {
    "semanticId",
    OfSubmodelElementList::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfSubmodelElementList::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfSubmodelElementList::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfSubmodelElementList::kEmbeddedDataSpecifications
  },
  {
    "orderRelevant",
    OfSubmodelElementList::kOrderRelevant
  },
  {
    "semanticIdListElement",
    OfSubmodelElementList::kSemanticIdListElement
  },
  {
    "typeValueListElement",
    OfSubmodelElementList::kTypeValueListElement
  },
  {
    "valueTypeListElement",
    OfSubmodelElementList::kValueTypeListElement
  },
  {
    "value",
    OfSubmodelElementList::kValue
  }
};

const std::unordered_map<
  std::string,
  OfSubmodelElementCollection
> kMapOfSubmodelElementCollection = {
  {
    "extensions",
    OfSubmodelElementCollection::kExtensions
  },
  {
    "category",
    OfSubmodelElementCollection::kCategory
  },
  {
    "idShort",
    OfSubmodelElementCollection::kIdShort
  },
  {
    "displayName",
    OfSubmodelElementCollection::kDisplayName
  },
  {
    "description",
    OfSubmodelElementCollection::kDescription
  },
  {
    "semanticId",
    OfSubmodelElementCollection::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfSubmodelElementCollection::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfSubmodelElementCollection::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfSubmodelElementCollection::kEmbeddedDataSpecifications
  },
  {
    "value",
    OfSubmodelElementCollection::kValue
  }
};

const std::unordered_map<
  std::string,
  OfProperty
> kMapOfProperty = {
  {
    "extensions",
    OfProperty::kExtensions
  },
  {
    "category",
    OfProperty::kCategory
  },
  {
    "idShort",
    OfProperty::kIdShort
  },
  {
    "displayName",
    OfProperty::kDisplayName
  },
  {
    "description",
    OfProperty::kDescription
  },
  {
    "semanticId",
    OfProperty::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfProperty::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfProperty::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfProperty::kEmbeddedDataSpecifications
  },
  {
    "valueType",
    OfProperty::kValueType
  },
  {
    "value",
    OfProperty::kValue
  },
  {
    "valueId",
    OfProperty::kValueId
  }
};

const std::unordered_map<
  std::string,
  OfMultiLanguageProperty
> kMapOfMultiLanguageProperty = {
  {
    "extensions",
    OfMultiLanguageProperty::kExtensions
  },
  {
    "category",
    OfMultiLanguageProperty::kCategory
  },
  {
    "idShort",
    OfMultiLanguageProperty::kIdShort
  },
  {
    "displayName",
    OfMultiLanguageProperty::kDisplayName
  },
  {
    "description",
    OfMultiLanguageProperty::kDescription
  },
  {
    "semanticId",
    OfMultiLanguageProperty::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfMultiLanguageProperty::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfMultiLanguageProperty::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfMultiLanguageProperty::kEmbeddedDataSpecifications
  },
  {
    "value",
    OfMultiLanguageProperty::kValue
  },
  {
    "valueId",
    OfMultiLanguageProperty::kValueId
  }
};

const std::unordered_map<
  std::string,
  OfRange
> kMapOfRange = {
  {
    "extensions",
    OfRange::kExtensions
  },
  {
    "category",
    OfRange::kCategory
  },
  {
    "idShort",
    OfRange::kIdShort
  },
  {
    "displayName",
    OfRange::kDisplayName
  },
  {
    "description",
    OfRange::kDescription
  },
  {
    "semanticId",
    OfRange::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfRange::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfRange::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfRange::kEmbeddedDataSpecifications
  },
  {
    "valueType",
    OfRange::kValueType
  },
  {
    "min",
    OfRange::kMin
  },
  {
    "max",
    OfRange::kMax
  }
};

const std::unordered_map<
  std::string,
  OfReferenceElement
> kMapOfReferenceElement = {
  {
    "extensions",
    OfReferenceElement::kExtensions
  },
  {
    "category",
    OfReferenceElement::kCategory
  },
  {
    "idShort",
    OfReferenceElement::kIdShort
  },
  {
    "displayName",
    OfReferenceElement::kDisplayName
  },
  {
    "description",
    OfReferenceElement::kDescription
  },
  {
    "semanticId",
    OfReferenceElement::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfReferenceElement::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfReferenceElement::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfReferenceElement::kEmbeddedDataSpecifications
  },
  {
    "value",
    OfReferenceElement::kValue
  }
};

const std::unordered_map<
  std::string,
  OfBlob
> kMapOfBlob = {
  {
    "extensions",
    OfBlob::kExtensions
  },
  {
    "category",
    OfBlob::kCategory
  },
  {
    "idShort",
    OfBlob::kIdShort
  },
  {
    "displayName",
    OfBlob::kDisplayName
  },
  {
    "description",
    OfBlob::kDescription
  },
  {
    "semanticId",
    OfBlob::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfBlob::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfBlob::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfBlob::kEmbeddedDataSpecifications
  },
  {
    "value",
    OfBlob::kValue
  },
  {
    "contentType",
    OfBlob::kContentType
  }
};

const std::unordered_map<
  std::string,
  OfFile
> kMapOfFile = {
  {
    "extensions",
    OfFile::kExtensions
  },
  {
    "category",
    OfFile::kCategory
  },
  {
    "idShort",
    OfFile::kIdShort
  },
  {
    "displayName",
    OfFile::kDisplayName
  },
  {
    "description",
    OfFile::kDescription
  },
  {
    "semanticId",
    OfFile::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfFile::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfFile::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfFile::kEmbeddedDataSpecifications
  },
  {
    "value",
    OfFile::kValue
  },
  {
    "contentType",
    OfFile::kContentType
  }
};

const std::unordered_map<
  std::string,
  OfAnnotatedRelationshipElement
> kMapOfAnnotatedRelationshipElement = {
  {
    "extensions",
    OfAnnotatedRelationshipElement::kExtensions
  },
  {
    "category",
    OfAnnotatedRelationshipElement::kCategory
  },
  {
    "idShort",
    OfAnnotatedRelationshipElement::kIdShort
  },
  {
    "displayName",
    OfAnnotatedRelationshipElement::kDisplayName
  },
  {
    "description",
    OfAnnotatedRelationshipElement::kDescription
  },
  {
    "semanticId",
    OfAnnotatedRelationshipElement::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfAnnotatedRelationshipElement::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfAnnotatedRelationshipElement::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfAnnotatedRelationshipElement::kEmbeddedDataSpecifications
  },
  {
    "first",
    OfAnnotatedRelationshipElement::kFirst
  },
  {
    "second",
    OfAnnotatedRelationshipElement::kSecond
  },
  {
    "annotations",
    OfAnnotatedRelationshipElement::kAnnotations
  }
};

const std::unordered_map<
  std::string,
  OfEntity
> kMapOfEntity = {
  {
    "extensions",
    OfEntity::kExtensions
  },
  {
    "category",
    OfEntity::kCategory
  },
  {
    "idShort",
    OfEntity::kIdShort
  },
  {
    "displayName",
    OfEntity::kDisplayName
  },
  {
    "description",
    OfEntity::kDescription
  },
  {
    "semanticId",
    OfEntity::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfEntity::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfEntity::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfEntity::kEmbeddedDataSpecifications
  },
  {
    "statements",
    OfEntity::kStatements
  },
  {
    "entityType",
    OfEntity::kEntityType
  },
  {
    "globalAssetId",
    OfEntity::kGlobalAssetId
  },
  {
    "specificAssetIds",
    OfEntity::kSpecificAssetIds
  }
};

const std::unordered_map<
  std::string,
  OfEventPayload
> kMapOfEventPayload = {
  {
    "source",
    OfEventPayload::kSource
  },
  {
    "sourceSemanticId",
    OfEventPayload::kSourceSemanticId
  },
  {
    "observableReference",
    OfEventPayload::kObservableReference
  },
  {
    "observableSemanticId",
    OfEventPayload::kObservableSemanticId
  },
  {
    "topic",
    OfEventPayload::kTopic
  },
  {
    "subjectId",
    OfEventPayload::kSubjectId
  },
  {
    "timeStamp",
    OfEventPayload::kTimeStamp
  },
  {
    "payload",
    OfEventPayload::kPayload
  }
};

const std::unordered_map<
  std::string,
  OfBasicEventElement
> kMapOfBasicEventElement = {
  {
    "extensions",
    OfBasicEventElement::kExtensions
  },
  {
    "category",
    OfBasicEventElement::kCategory
  },
  {
    "idShort",
    OfBasicEventElement::kIdShort
  },
  {
    "displayName",
    OfBasicEventElement::kDisplayName
  },
  {
    "description",
    OfBasicEventElement::kDescription
  },
  {
    "semanticId",
    OfBasicEventElement::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfBasicEventElement::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfBasicEventElement::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfBasicEventElement::kEmbeddedDataSpecifications
  },
  {
    "observed",
    OfBasicEventElement::kObserved
  },
  {
    "direction",
    OfBasicEventElement::kDirection
  },
  {
    "state",
    OfBasicEventElement::kState
  },
  {
    "messageTopic",
    OfBasicEventElement::kMessageTopic
  },
  {
    "messageBroker",
    OfBasicEventElement::kMessageBroker
  },
  {
    "lastUpdate",
    OfBasicEventElement::kLastUpdate
  },
  {
    "minInterval",
    OfBasicEventElement::kMinInterval
  },
  {
    "maxInterval",
    OfBasicEventElement::kMaxInterval
  }
};

const std::unordered_map<
  std::string,
  OfOperation
> kMapOfOperation = {
  {
    "extensions",
    OfOperation::kExtensions
  },
  {
    "category",
    OfOperation::kCategory
  },
  {
    "idShort",
    OfOperation::kIdShort
  },
  {
    "displayName",
    OfOperation::kDisplayName
  },
  {
    "description",
    OfOperation::kDescription
  },
  {
    "semanticId",
    OfOperation::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfOperation::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfOperation::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfOperation::kEmbeddedDataSpecifications
  },
  {
    "inputVariables",
    OfOperation::kInputVariables
  },
  {
    "outputVariables",
    OfOperation::kOutputVariables
  },
  {
    "inoutputVariables",
    OfOperation::kInoutputVariables
  }
};

const std::unordered_map<
  std::string,
  OfOperationVariable
> kMapOfOperationVariable = {
  {
    "value",
    OfOperationVariable::kValue
  }
};

const std::unordered_map<
  std::string,
  OfCapability
> kMapOfCapability = {
  {
    "extensions",
    OfCapability::kExtensions
  },
  {
    "category",
    OfCapability::kCategory
  },
  {
    "idShort",
    OfCapability::kIdShort
  },
  {
    "displayName",
    OfCapability::kDisplayName
  },
  {
    "description",
    OfCapability::kDescription
  },
  {
    "semanticId",
    OfCapability::kSemanticId
  },
  {
    "supplementalSemanticIds",
    OfCapability::kSupplementalSemanticIds
  },
  {
    "qualifiers",
    OfCapability::kQualifiers
  },
  {
    "embeddedDataSpecifications",
    OfCapability::kEmbeddedDataSpecifications
  }
};

const std::unordered_map<
  std::string,
  OfConceptDescription
> kMapOfConceptDescription = {
  {
    "extensions",
    OfConceptDescription::kExtensions
  },
  {
    "category",
    OfConceptDescription::kCategory
  },
  {
    "idShort",
    OfConceptDescription::kIdShort
  },
  {
    "displayName",
    OfConceptDescription::kDisplayName
  },
  {
    "description",
    OfConceptDescription::kDescription
  },
  {
    "administration",
    OfConceptDescription::kAdministration
  },
  {
    "id",
    OfConceptDescription::kId
  },
  {
    "embeddedDataSpecifications",
    OfConceptDescription::kEmbeddedDataSpecifications
  },
  {
    "isCaseOf",
    OfConceptDescription::kIsCaseOf
  }
};

const std::unordered_map<
  std::string,
  OfReference
> kMapOfReference = {
  {
    "type",
    OfReference::kType
  },
  {
    "referredSemanticId",
    OfReference::kReferredSemanticId
  },
  {
    "keys",
    OfReference::kKeys
  }
};

const std::unordered_map<
  std::string,
  OfKey
> kMapOfKey = {
  {
    "type",
    OfKey::kType
  },
  {
    "value",
    OfKey::kValue
  }
};

const std::unordered_map<
  std::string,
  OfLangStringNameType
> kMapOfLangStringNameType = {
  {
    "language",
    OfLangStringNameType::kLanguage
  },
  {
    "text",
    OfLangStringNameType::kText
  }
};

const std::unordered_map<
  std::string,
  OfLangStringTextType
> kMapOfLangStringTextType = {
  {
    "language",
    OfLangStringTextType::kLanguage
  },
  {
    "text",
    OfLangStringTextType::kText
  }
};

const std::unordered_map<
  std::string,
  OfEnvironment
> kMapOfEnvironment = {
  {
    "assetAdministrationShells",
    OfEnvironment::kAssetAdministrationShells
  },
  {
    "submodels",
    OfEnvironment::kSubmodels
  },
  {
    "conceptDescriptions",
    OfEnvironment::kConceptDescriptions
  }
};

const std::unordered_map<
  std::string,
  OfEmbeddedDataSpecification
> kMapOfEmbeddedDataSpecification = {
  {
    "dataSpecificationContent",
    OfEmbeddedDataSpecification::kDataSpecificationContent
  },
  {
    "dataSpecification",
    OfEmbeddedDataSpecification::kDataSpecification
  }
};

const std::unordered_map<
  std::string,
  OfLevelType
> kMapOfLevelType = {
  {
    "min",
    OfLevelType::kMin
  },
  {
    "nom",
    OfLevelType::kNom
  },
  {
    "typ",
    OfLevelType::kTyp
  },
  {
    "max",
    OfLevelType::kMax
  }
};

const std::unordered_map<
  std::string,
  OfValueReferencePair
> kMapOfValueReferencePair = {
  {
    "value",
    OfValueReferencePair::kValue
  },
  {
    "valueId",
    OfValueReferencePair::kValueId
  }
};

const std::unordered_map<
  std::string,
  OfValueList
> kMapOfValueList = {
  {
    "valueReferencePairs",
    OfValueList::kValueReferencePairs
  }
};

const std::unordered_map<
  std::string,
  OfLangStringPreferredNameTypeIec61360
> kMapOfLangStringPreferredNameTypeIec61360 = {
  {
    "language",
    OfLangStringPreferredNameTypeIec61360::kLanguage
  },
  {
    "text",
    OfLangStringPreferredNameTypeIec61360::kText
  }
};

const std::unordered_map<
  std::string,
  OfLangStringShortNameTypeIec61360
> kMapOfLangStringShortNameTypeIec61360 = {
  {
    "language",
    OfLangStringShortNameTypeIec61360::kLanguage
  },
  {
    "text",
    OfLangStringShortNameTypeIec61360::kText
  }
};

const std::unordered_map<
  std::string,
  OfLangStringDefinitionTypeIec61360
> kMapOfLangStringDefinitionTypeIec61360 = {
  {
    "language",
    OfLangStringDefinitionTypeIec61360::kLanguage
  },
  {
    "text",
    OfLangStringDefinitionTypeIec61360::kText
  }
};

const std::unordered_map<
  std::string,
  OfDataSpecificationIec61360
> kMapOfDataSpecificationIec61360 = {
  {
    "preferredName",
    OfDataSpecificationIec61360::kPreferredName
  },
  {
    "shortName",
    OfDataSpecificationIec61360::kShortName
  },
  {
    "unit",
    OfDataSpecificationIec61360::kUnit
  },
  {
    "unitId",
    OfDataSpecificationIec61360::kUnitId
  },
  {
    "sourceOfDefinition",
    OfDataSpecificationIec61360::kSourceOfDefinition
  },
  {
    "symbol",
    OfDataSpecificationIec61360::kSymbol
  },
  {
    "dataType",
    OfDataSpecificationIec61360::kDataType
  },
  {
    "definition",
    OfDataSpecificationIec61360::kDefinition
  },
  {
    "valueFormat",
    OfDataSpecificationIec61360::kValueFormat
  },
  {
    "valueList",
    OfDataSpecificationIec61360::kValueList
  },
  {
    "value",
    OfDataSpecificationIec61360::kValue
  },
  {
    "levelType",
    OfDataSpecificationIec61360::kLevelType
  }
};

}  // namespace properties

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IExtension>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ExtensionFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ExtensionFromSequence. "
      "ExtensionFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<std::wstring> the_name;

  common::optional<types::DataTypeDefXsd> the_value_type;

  common::optional<std::wstring> the_value;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_refers_to;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IExtension, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfExtension.find(
      name
    );
    if (it == properties::kMapOfExtension.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IExtension, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfExtension property(
      it->second
    );

    switch (property) {
      case properties::OfExtension::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfExtension::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfExtension::kName:
        std::tie(
          the_name,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfExtension::kValueType: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_value_type = wstringification::DataTypeDefXsdFromWstring(
          *text
        );

        if (!the_value_type.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of DataTypeDefXsd, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfExtension::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfExtension::kRefersTo: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_refers_to = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_refers_to = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_refers_to->reserve(items.size());
            
            for (auto& item : items) {
              the_refers_to->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfExtension: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IExtension, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_name.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property name is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Extension(
        std::move(*the_name),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_value_type),
        std::move(the_value),
        std::move(the_refers_to)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAdministrativeInformation>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> AdministrativeInformationFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AdministrativeInformationFromSequence. "
      "AdministrativeInformationFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::wstring> the_version;

  common::optional<std::wstring> the_revision;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_creator;

  common::optional<std::wstring> the_template_id;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IAdministrativeInformation, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfAdministrativeInformation.find(
      name
    );
    if (it == properties::kMapOfAdministrativeInformation.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IAdministrativeInformation, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfAdministrativeInformation property(
      it->second
    );

    switch (property) {
      case properties::OfAdministrativeInformation::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAdministrativeInformation::kVersion:
        std::tie(
          the_version,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAdministrativeInformation::kRevision:
        std::tie(
          the_revision,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAdministrativeInformation::kCreator:
        std::tie(
          the_creator,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfAdministrativeInformation::kTemplateId:
        std::tie(
          the_template_id,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfAdministrativeInformation: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IAdministrativeInformation, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::AdministrativeInformation(
        std::move(the_embedded_data_specifications),
        std::move(the_version),
        std::move(the_revision),
        std::move(the_creator),
        std::move(the_template_id)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IQualifier>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> QualifierFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in QualifierFromSequence. "
      "QualifierFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<types::QualifierKind> the_kind;

  common::optional<std::wstring> the_type;

  common::optional<types::DataTypeDefXsd> the_value_type;

  common::optional<std::wstring> the_value;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_value_id;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IQualifier, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfQualifier.find(
      name
    );
    if (it == properties::kMapOfQualifier.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IQualifier, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfQualifier property(
      it->second
    );

    switch (property) {
      case properties::OfQualifier::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfQualifier::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfQualifier::kKind: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_kind = wstringification::QualifierKindFromWstring(
          *text
        );

        if (!the_kind.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of QualifierKind, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfQualifier::kType:
        std::tie(
          the_type,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfQualifier::kValueType: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_value_type = wstringification::DataTypeDefXsdFromWstring(
          *text
        );

        if (!the_value_type.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of DataTypeDefXsd, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfQualifier::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfQualifier::kValueId:
        std::tie(
          the_value_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfQualifier: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IQualifier, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property type is missing"
    );
  }

  if (!the_value_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property valueType is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Qualifier(
        std::move(*the_type),
        std::move(*the_value_type),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_kind),
        std::move(the_value),
        std::move(the_value_id)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAssetAdministrationShell>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> AssetAdministrationShellFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AssetAdministrationShellFromSequence. "
      "AssetAdministrationShellFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > the_administration;

  common::optional<std::wstring> the_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_derived_from;

  common::optional<std::shared_ptr<types::IAssetInformation> > the_asset_information;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_submodels;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IAssetAdministrationShell, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfAssetAdministrationShell.find(
      name
    );
    if (it == properties::kMapOfAssetAdministrationShell.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IAssetAdministrationShell, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfAssetAdministrationShell property(
      it->second
    );

    switch (property) {
      case properties::OfAssetAdministrationShell::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAssetAdministrationShell::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAssetAdministrationShell::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAssetAdministrationShell::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAssetAdministrationShell::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAssetAdministrationShell::kAdministration:
        std::tie(
          the_administration,
          error
        ) = AdministrativeInformationFromSequence<
          types::IAdministrativeInformation
        >(reader);
        break;
      case properties::OfAssetAdministrationShell::kId:
        std::tie(
          the_id,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAssetAdministrationShell::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAssetAdministrationShell::kDerivedFrom:
        std::tie(
          the_derived_from,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfAssetAdministrationShell::kAssetInformation:
        std::tie(
          the_asset_information,
          error
        ) = AssetInformationFromSequence<
          types::IAssetInformation
        >(reader);
        break;
      case properties::OfAssetAdministrationShell::kSubmodels: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_submodels = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_submodels = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_submodels->reserve(items.size());
            
            for (auto& item : items) {
              the_submodels->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfAssetAdministrationShell: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IAssetAdministrationShell, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_id.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property id is missing"
    );
  }

  if (!the_asset_information.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property assetInformation is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::AssetAdministrationShell(
        std::move(*the_id),
        std::move(*the_asset_information),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_administration),
        std::move(the_embedded_data_specifications),
        std::move(the_derived_from),
        std::move(the_submodels)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAssetInformation>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> AssetInformationFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AssetInformationFromSequence. "
      "AssetInformationFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<types::AssetKind> the_asset_kind;

  common::optional<std::wstring> the_global_asset_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  > the_specific_asset_ids;

  common::optional<std::wstring> the_asset_type;

  common::optional<
    std::shared_ptr<types::IResource>
  > the_default_thumbnail;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IAssetInformation, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfAssetInformation.find(
      name
    );
    if (it == properties::kMapOfAssetInformation.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IAssetInformation, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfAssetInformation property(
      it->second
    );

    switch (property) {
      case properties::OfAssetInformation::kAssetKind: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_asset_kind = wstringification::AssetKindFromWstring(
          *text
        );

        if (!the_asset_kind.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of AssetKind, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfAssetInformation::kGlobalAssetId:
        std::tie(
          the_global_asset_id,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAssetInformation::kSpecificAssetIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_specific_asset_ids = std::vector<
            std::shared_ptr<types::ISpecificAssetId>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ISpecificAssetId>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ISpecificAssetId>
            > item;
          
            std::tie(
              item,
              error
            ) = SpecificAssetIdFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_specific_asset_ids = std::vector<
              std::shared_ptr<types::ISpecificAssetId>
            >();
            the_specific_asset_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_specific_asset_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAssetInformation::kAssetType:
        std::tie(
          the_asset_type,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAssetInformation::kDefaultThumbnail:
        std::tie(
          the_default_thumbnail,
          error
        ) = ResourceFromSequence<
          types::IResource
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfAssetInformation: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IAssetInformation, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_asset_kind.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property assetKind is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::AssetInformation(
        std::move(*the_asset_kind),
        std::move(the_global_asset_id),
        std::move(the_specific_asset_ids),
        std::move(the_asset_type),
        std::move(the_default_thumbnail)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IResource>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ResourceFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ResourceFromSequence. "
      "ResourceFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::wstring> the_path;

  common::optional<std::wstring> the_content_type;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IResource, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfResource.find(
      name
    );
    if (it == properties::kMapOfResource.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IResource, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfResource property(
      it->second
    );

    switch (property) {
      case properties::OfResource::kPath:
        std::tie(
          the_path,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfResource::kContentType:
        std::tie(
          the_content_type,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfResource: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IResource, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_path.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property path is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Resource(
        std::move(*the_path),
        std::move(the_content_type)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISpecificAssetId>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> SpecificAssetIdFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SpecificAssetIdFromSequence. "
      "SpecificAssetIdFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<std::wstring> the_name;

  common::optional<std::wstring> the_value;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_external_subject_id;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ISpecificAssetId, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfSpecificAssetId.find(
      name
    );
    if (it == properties::kMapOfSpecificAssetId.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ISpecificAssetId, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfSpecificAssetId property(
      it->second
    );

    switch (property) {
      case properties::OfSpecificAssetId::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfSpecificAssetId::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSpecificAssetId::kName:
        std::tie(
          the_name,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSpecificAssetId::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSpecificAssetId::kExternalSubjectId:
        std::tie(
          the_external_subject_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfSpecificAssetId: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ISpecificAssetId, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_name.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property name is missing"
    );
  }

  if (!the_value.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property value is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::SpecificAssetId(
        std::move(*the_name),
        std::move(*the_value),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_external_subject_id)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodel>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> SubmodelFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SubmodelFromSequence. "
      "SubmodelFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > the_administration;

  common::optional<std::wstring> the_id;

  common::optional<types::ModellingKind> the_kind;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  > the_submodel_elements;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ISubmodel, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfSubmodel.find(
      name
    );
    if (it == properties::kMapOfSubmodel.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ISubmodel, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfSubmodel property(
      it->second
    );

    switch (property) {
      case properties::OfSubmodel::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodel::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSubmodel::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSubmodel::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodel::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodel::kAdministration:
        std::tie(
          the_administration,
          error
        ) = AdministrativeInformationFromSequence<
          types::IAdministrativeInformation
        >(reader);
        break;
      case properties::OfSubmodel::kId:
        std::tie(
          the_id,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSubmodel::kKind: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_kind = wstringification::ModellingKindFromWstring(
          *text
        );

        if (!the_kind.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of ModellingKind, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfSubmodel::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfSubmodel::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodel::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodel::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodel::kSubmodelElements: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_submodel_elements = std::vector<
            std::shared_ptr<types::ISubmodelElement>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ISubmodelElement>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ISubmodelElement>
            > item;
          
            std::tie(
              item,
              error
            ) = SubmodelElementFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_submodel_elements = std::vector<
              std::shared_ptr<types::ISubmodelElement>
            >();
            the_submodel_elements->reserve(items.size());
            
            for (auto& item : items) {
              the_submodel_elements->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfSubmodel: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ISubmodel, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_id.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property id is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Submodel(
        std::move(*the_id),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_administration),
        std::move(the_kind),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_submodel_elements)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IRelationshipElement>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> RelationshipElementFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in RelationshipElementFromSequence. "
      "RelationshipElementFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::shared_ptr<types::IReference> > the_first;

  common::optional<std::shared_ptr<types::IReference> > the_second;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IRelationshipElement, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfRelationshipElement.find(
      name
    );
    if (it == properties::kMapOfRelationshipElement.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IRelationshipElement, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfRelationshipElement property(
      it->second
    );

    switch (property) {
      case properties::OfRelationshipElement::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRelationshipElement::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfRelationshipElement::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfRelationshipElement::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRelationshipElement::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRelationshipElement::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfRelationshipElement::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRelationshipElement::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRelationshipElement::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRelationshipElement::kFirst:
        std::tie(
          the_first,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfRelationshipElement::kSecond:
        std::tie(
          the_second,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfRelationshipElement: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IRelationshipElement, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_first.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property first is missing"
    );
  }

  if (!the_second.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property second is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::RelationshipElement(
        std::move(*the_first),
        std::move(*the_second),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodelElementList>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> SubmodelElementListFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SubmodelElementListFromSequence. "
      "SubmodelElementListFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<bool> the_order_relevant;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id_list_element;

  common::optional<types::AasSubmodelElements> the_type_value_list_element;

  common::optional<types::DataTypeDefXsd> the_value_type_list_element;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  > the_value;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ISubmodelElementList, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfSubmodelElementList.find(
      name
    );
    if (it == properties::kMapOfSubmodelElementList.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ISubmodelElementList, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfSubmodelElementList property(
      it->second
    );

    switch (property) {
      case properties::OfSubmodelElementList::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementList::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSubmodelElementList::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSubmodelElementList::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementList::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementList::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfSubmodelElementList::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementList::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementList::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementList::kOrderRelevant:
        std::tie(
          the_order_relevant,
          error
        ) = DeserializeBool(reader);
        break;
      case properties::OfSubmodelElementList::kSemanticIdListElement:
        std::tie(
          the_semantic_id_list_element,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfSubmodelElementList::kTypeValueListElement: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_type_value_list_element = wstringification::AasSubmodelElementsFromWstring(
          *text
        );

        if (!the_type_value_list_element.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of AasSubmodelElements, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfSubmodelElementList::kValueTypeListElement: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_value_type_list_element = wstringification::DataTypeDefXsdFromWstring(
          *text
        );

        if (!the_value_type_list_element.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of DataTypeDefXsd, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfSubmodelElementList::kValue: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_value = std::vector<
            std::shared_ptr<types::ISubmodelElement>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ISubmodelElement>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ISubmodelElement>
            > item;
          
            std::tie(
              item,
              error
            ) = SubmodelElementFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_value = std::vector<
              std::shared_ptr<types::ISubmodelElement>
            >();
            the_value->reserve(items.size());
            
            for (auto& item : items) {
              the_value->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfSubmodelElementList: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ISubmodelElementList, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_type_value_list_element.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property typeValueListElement is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::SubmodelElementList(
        std::move(*the_type_value_list_element),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_order_relevant),
        std::move(the_semantic_id_list_element),
        std::move(the_value_type_list_element),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodelElementCollection>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> SubmodelElementCollectionFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in SubmodelElementCollectionFromSequence. "
      "SubmodelElementCollectionFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  > the_value;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ISubmodelElementCollection, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfSubmodelElementCollection.find(
      name
    );
    if (it == properties::kMapOfSubmodelElementCollection.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ISubmodelElementCollection, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfSubmodelElementCollection property(
      it->second
    );

    switch (property) {
      case properties::OfSubmodelElementCollection::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementCollection::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSubmodelElementCollection::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfSubmodelElementCollection::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementCollection::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementCollection::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfSubmodelElementCollection::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementCollection::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementCollection::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfSubmodelElementCollection::kValue: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_value = std::vector<
            std::shared_ptr<types::ISubmodelElement>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ISubmodelElement>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ISubmodelElement>
            > item;
          
            std::tie(
              item,
              error
            ) = SubmodelElementFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_value = std::vector<
              std::shared_ptr<types::ISubmodelElement>
            >();
            the_value->reserve(items.size());
            
            for (auto& item : items) {
              the_value->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfSubmodelElementCollection: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ISubmodelElementCollection, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::SubmodelElementCollection(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IProperty>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> PropertyFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in PropertyFromSequence. "
      "PropertyFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<types::DataTypeDefXsd> the_value_type;

  common::optional<std::wstring> the_value;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_value_id;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IProperty, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfProperty.find(
      name
    );
    if (it == properties::kMapOfProperty.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IProperty, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfProperty property(
      it->second
    );

    switch (property) {
      case properties::OfProperty::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfProperty::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfProperty::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfProperty::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfProperty::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfProperty::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfProperty::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfProperty::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfProperty::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfProperty::kValueType: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_value_type = wstringification::DataTypeDefXsdFromWstring(
          *text
        );

        if (!the_value_type.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of DataTypeDefXsd, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfProperty::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfProperty::kValueId:
        std::tie(
          the_value_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfProperty: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IProperty, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_value_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property valueType is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Property(
        std::move(*the_value_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value),
        std::move(the_value_id)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IMultiLanguageProperty>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> MultiLanguagePropertyFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in MultiLanguagePropertyFromSequence. "
      "MultiLanguagePropertyFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_value;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_value_id;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IMultiLanguageProperty, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfMultiLanguageProperty.find(
      name
    );
    if (it == properties::kMapOfMultiLanguageProperty.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IMultiLanguageProperty, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfMultiLanguageProperty property(
      it->second
    );

    switch (property) {
      case properties::OfMultiLanguageProperty::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfMultiLanguageProperty::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfMultiLanguageProperty::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfMultiLanguageProperty::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfMultiLanguageProperty::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfMultiLanguageProperty::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfMultiLanguageProperty::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfMultiLanguageProperty::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfMultiLanguageProperty::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfMultiLanguageProperty::kValue: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_value = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_value = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_value->reserve(items.size());
            
            for (auto& item : items) {
              the_value->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfMultiLanguageProperty::kValueId:
        std::tie(
          the_value_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfMultiLanguageProperty: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IMultiLanguageProperty, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::MultiLanguageProperty(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value),
        std::move(the_value_id)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IRange>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> RangeFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in RangeFromSequence. "
      "RangeFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<types::DataTypeDefXsd> the_value_type;

  common::optional<std::wstring> the_min;

  common::optional<std::wstring> the_max;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IRange, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfRange.find(
      name
    );
    if (it == properties::kMapOfRange.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IRange, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfRange property(
      it->second
    );

    switch (property) {
      case properties::OfRange::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRange::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfRange::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfRange::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRange::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRange::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfRange::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRange::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRange::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfRange::kValueType: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_value_type = wstringification::DataTypeDefXsdFromWstring(
          *text
        );

        if (!the_value_type.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of DataTypeDefXsd, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfRange::kMin:
        std::tie(
          the_min,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfRange::kMax:
        std::tie(
          the_max,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfRange: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IRange, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_value_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property valueType is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Range(
        std::move(*the_value_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_min),
        std::move(the_max)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IReferenceElement>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ReferenceElementFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ReferenceElementFromSequence. "
      "ReferenceElementFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_value;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IReferenceElement, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfReferenceElement.find(
      name
    );
    if (it == properties::kMapOfReferenceElement.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IReferenceElement, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfReferenceElement property(
      it->second
    );

    switch (property) {
      case properties::OfReferenceElement::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfReferenceElement::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfReferenceElement::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfReferenceElement::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfReferenceElement::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfReferenceElement::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfReferenceElement::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfReferenceElement::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfReferenceElement::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfReferenceElement::kValue:
        std::tie(
          the_value,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfReferenceElement: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IReferenceElement, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ReferenceElement(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IBlob>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> BlobFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in BlobFromSequence. "
      "BlobFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<std::uint8_t>
  > the_value;

  common::optional<std::wstring> the_content_type;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IBlob, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfBlob.find(
      name
    );
    if (it == properties::kMapOfBlob.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IBlob, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfBlob property(
      it->second
    );

    switch (property) {
      case properties::OfBlob::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBlob::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfBlob::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfBlob::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBlob::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBlob::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfBlob::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBlob::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBlob::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBlob::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeByteArray(reader);
        break;
      case properties::OfBlob::kContentType:
        std::tie(
          the_content_type,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfBlob: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IBlob, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_content_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property contentType is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Blob(
        std::move(*the_content_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IFile>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> FileFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in FileFromSequence. "
      "FileFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::wstring> the_value;

  common::optional<std::wstring> the_content_type;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IFile, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfFile.find(
      name
    );
    if (it == properties::kMapOfFile.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IFile, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfFile property(
      it->second
    );

    switch (property) {
      case properties::OfFile::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfFile::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfFile::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfFile::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfFile::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfFile::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfFile::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfFile::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfFile::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfFile::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfFile::kContentType:
        std::tie(
          the_content_type,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfFile: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IFile, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_content_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property contentType is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::File(
        std::move(*the_content_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAnnotatedRelationshipElement>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> AnnotatedRelationshipElementFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in AnnotatedRelationshipElementFromSequence. "
      "AnnotatedRelationshipElementFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::shared_ptr<types::IReference> > the_first;

  common::optional<std::shared_ptr<types::IReference> > the_second;

  common::optional<
    std::vector<
      std::shared_ptr<types::IDataElement>
    >
  > the_annotations;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IAnnotatedRelationshipElement, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfAnnotatedRelationshipElement.find(
      name
    );
    if (it == properties::kMapOfAnnotatedRelationshipElement.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IAnnotatedRelationshipElement, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfAnnotatedRelationshipElement property(
      it->second
    );

    switch (property) {
      case properties::OfAnnotatedRelationshipElement::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAnnotatedRelationshipElement::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAnnotatedRelationshipElement::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfAnnotatedRelationshipElement::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAnnotatedRelationshipElement::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAnnotatedRelationshipElement::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfAnnotatedRelationshipElement::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAnnotatedRelationshipElement::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAnnotatedRelationshipElement::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfAnnotatedRelationshipElement::kFirst:
        std::tie(
          the_first,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfAnnotatedRelationshipElement::kSecond:
        std::tie(
          the_second,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfAnnotatedRelationshipElement::kAnnotations: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_annotations = std::vector<
            std::shared_ptr<types::IDataElement>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IDataElement>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IDataElement>
            > item;
          
            std::tie(
              item,
              error
            ) = DataElementFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_annotations = std::vector<
              std::shared_ptr<types::IDataElement>
            >();
            the_annotations->reserve(items.size());
            
            for (auto& item : items) {
              the_annotations->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfAnnotatedRelationshipElement: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IAnnotatedRelationshipElement, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_first.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property first is missing"
    );
  }

  if (!the_second.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property second is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::AnnotatedRelationshipElement(
        std::move(*the_first),
        std::move(*the_second),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_annotations)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEntity>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> EntityFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EntityFromSequence. "
      "EntityFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  > the_statements;

  common::optional<types::EntityType> the_entity_type;

  common::optional<std::wstring> the_global_asset_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  > the_specific_asset_ids;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IEntity, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfEntity.find(
      name
    );
    if (it == properties::kMapOfEntity.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IEntity, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfEntity property(
      it->second
    );

    switch (property) {
      case properties::OfEntity::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEntity::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfEntity::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfEntity::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEntity::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEntity::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfEntity::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEntity::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEntity::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEntity::kStatements: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_statements = std::vector<
            std::shared_ptr<types::ISubmodelElement>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ISubmodelElement>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ISubmodelElement>
            > item;
          
            std::tie(
              item,
              error
            ) = SubmodelElementFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_statements = std::vector<
              std::shared_ptr<types::ISubmodelElement>
            >();
            the_statements->reserve(items.size());
            
            for (auto& item : items) {
              the_statements->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEntity::kEntityType: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_entity_type = wstringification::EntityTypeFromWstring(
          *text
        );

        if (!the_entity_type.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of EntityType, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfEntity::kGlobalAssetId:
        std::tie(
          the_global_asset_id,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfEntity::kSpecificAssetIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_specific_asset_ids = std::vector<
            std::shared_ptr<types::ISpecificAssetId>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ISpecificAssetId>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ISpecificAssetId>
            > item;
          
            std::tie(
              item,
              error
            ) = SpecificAssetIdFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_specific_asset_ids = std::vector<
              std::shared_ptr<types::ISpecificAssetId>
            >();
            the_specific_asset_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_specific_asset_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfEntity: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IEntity, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_entity_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property entityType is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Entity(
        std::move(*the_entity_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_statements),
        std::move(the_global_asset_id),
        std::move(the_specific_asset_ids)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEventPayload>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> EventPayloadFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EventPayloadFromSequence. "
      "EventPayloadFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::shared_ptr<types::IReference> > the_source;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_source_semantic_id;

  common::optional<std::shared_ptr<types::IReference> > the_observable_reference;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_observable_semantic_id;

  common::optional<std::wstring> the_topic;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_subject_id;

  common::optional<std::wstring> the_time_stamp;

  common::optional<
    std::vector<std::uint8_t>
  > the_payload;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IEventPayload, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfEventPayload.find(
      name
    );
    if (it == properties::kMapOfEventPayload.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IEventPayload, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfEventPayload property(
      it->second
    );

    switch (property) {
      case properties::OfEventPayload::kSource:
        std::tie(
          the_source,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfEventPayload::kSourceSemanticId:
        std::tie(
          the_source_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfEventPayload::kObservableReference:
        std::tie(
          the_observable_reference,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfEventPayload::kObservableSemanticId:
        std::tie(
          the_observable_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfEventPayload::kTopic:
        std::tie(
          the_topic,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfEventPayload::kSubjectId:
        std::tie(
          the_subject_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfEventPayload::kTimeStamp:
        std::tie(
          the_time_stamp,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfEventPayload::kPayload:
        std::tie(
          the_payload,
          error
        ) = DeserializeByteArray(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfEventPayload: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IEventPayload, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_source.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property source is missing"
    );
  }

  if (!the_observable_reference.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property observableReference is missing"
    );
  }

  if (!the_time_stamp.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property timeStamp is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::EventPayload(
        std::move(*the_source),
        std::move(*the_observable_reference),
        std::move(*the_time_stamp),
        std::move(the_source_semantic_id),
        std::move(the_observable_semantic_id),
        std::move(the_topic),
        std::move(the_subject_id),
        std::move(the_payload)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IBasicEventElement>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> BasicEventElementFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in BasicEventElementFromSequence. "
      "BasicEventElementFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::shared_ptr<types::IReference> > the_observed;

  common::optional<types::Direction> the_direction;

  common::optional<types::StateOfEvent> the_state;

  common::optional<std::wstring> the_message_topic;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_message_broker;

  common::optional<std::wstring> the_last_update;

  common::optional<std::wstring> the_min_interval;

  common::optional<std::wstring> the_max_interval;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IBasicEventElement, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfBasicEventElement.find(
      name
    );
    if (it == properties::kMapOfBasicEventElement.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IBasicEventElement, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfBasicEventElement property(
      it->second
    );

    switch (property) {
      case properties::OfBasicEventElement::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBasicEventElement::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfBasicEventElement::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfBasicEventElement::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBasicEventElement::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBasicEventElement::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfBasicEventElement::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBasicEventElement::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBasicEventElement::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfBasicEventElement::kObserved:
        std::tie(
          the_observed,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfBasicEventElement::kDirection: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_direction = wstringification::DirectionFromWstring(
          *text
        );

        if (!the_direction.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of Direction, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfBasicEventElement::kState: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_state = wstringification::StateOfEventFromWstring(
          *text
        );

        if (!the_state.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of StateOfEvent, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfBasicEventElement::kMessageTopic:
        std::tie(
          the_message_topic,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfBasicEventElement::kMessageBroker:
        std::tie(
          the_message_broker,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfBasicEventElement::kLastUpdate:
        std::tie(
          the_last_update,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfBasicEventElement::kMinInterval:
        std::tie(
          the_min_interval,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfBasicEventElement::kMaxInterval:
        std::tie(
          the_max_interval,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfBasicEventElement: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IBasicEventElement, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_observed.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property observed is missing"
    );
  }

  if (!the_direction.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property direction is missing"
    );
  }

  if (!the_state.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property state is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::BasicEventElement(
        std::move(*the_observed),
        std::move(*the_direction),
        std::move(*the_state),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_message_topic),
        std::move(the_message_broker),
        std::move(the_last_update),
        std::move(the_min_interval),
        std::move(the_max_interval)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IOperation>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> OperationFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in OperationFromSequence. "
      "OperationFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  > the_input_variables;

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  > the_output_variables;

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  > the_inoutput_variables;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IOperation, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfOperation.find(
      name
    );
    if (it == properties::kMapOfOperation.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IOperation, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfOperation property(
      it->second
    );

    switch (property) {
      case properties::OfOperation::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfOperation::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfOperation::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfOperation::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfOperation::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfOperation::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfOperation::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfOperation::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfOperation::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfOperation::kInputVariables: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_input_variables = std::vector<
            std::shared_ptr<types::IOperationVariable>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IOperationVariable>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IOperationVariable>
            > item;
          
            std::tie(
              item,
              error
            ) = OperationVariableFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_input_variables = std::vector<
              std::shared_ptr<types::IOperationVariable>
            >();
            the_input_variables->reserve(items.size());
            
            for (auto& item : items) {
              the_input_variables->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfOperation::kOutputVariables: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_output_variables = std::vector<
            std::shared_ptr<types::IOperationVariable>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IOperationVariable>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IOperationVariable>
            > item;
          
            std::tie(
              item,
              error
            ) = OperationVariableFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_output_variables = std::vector<
              std::shared_ptr<types::IOperationVariable>
            >();
            the_output_variables->reserve(items.size());
            
            for (auto& item : items) {
              the_output_variables->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfOperation::kInoutputVariables: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_inoutput_variables = std::vector<
            std::shared_ptr<types::IOperationVariable>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IOperationVariable>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IOperationVariable>
            > item;
          
            std::tie(
              item,
              error
            ) = OperationVariableFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_inoutput_variables = std::vector<
              std::shared_ptr<types::IOperationVariable>
            >();
            the_inoutput_variables->reserve(items.size());
            
            for (auto& item : items) {
              the_inoutput_variables->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfOperation: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IOperation, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Operation(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_input_variables),
        std::move(the_output_variables),
        std::move(the_inoutput_variables)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IOperationVariable>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> OperationVariableFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in OperationVariableFromSequence. "
      "OperationVariableFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::shared_ptr<types::ISubmodelElement> > the_value;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IOperationVariable, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfOperationVariable.find(
      name
    );
    if (it == properties::kMapOfOperationVariable.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IOperationVariable, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfOperationVariable property(
      it->second
    );

    switch (property) {
      case properties::OfOperationVariable::kValue:
        std::tie(
          the_value,
          error
        ) = SubmodelElementFromElement(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfOperationVariable: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IOperationVariable, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_value.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property value is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::OperationVariable(
        std::move(*the_value)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ICapability>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> CapabilityFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in CapabilityFromSequence. "
      "CapabilityFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ICapability, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfCapability.find(
      name
    );
    if (it == properties::kMapOfCapability.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ICapability, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfCapability property(
      it->second
    );

    switch (property) {
      case properties::OfCapability::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfCapability::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfCapability::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfCapability::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfCapability::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfCapability::kSemanticId:
        std::tie(
          the_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfCapability::kSupplementalSemanticIds: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_supplemental_semantic_ids = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_supplemental_semantic_ids = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_supplemental_semantic_ids->reserve(items.size());
            
            for (auto& item : items) {
              the_supplemental_semantic_ids->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfCapability::kQualifiers: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_qualifiers = std::vector<
            std::shared_ptr<types::IQualifier>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IQualifier>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IQualifier>
            > item;
          
            std::tie(
              item,
              error
            ) = QualifierFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_qualifiers = std::vector<
              std::shared_ptr<types::IQualifier>
            >();
            the_qualifiers->reserve(items.size());
            
            for (auto& item : items) {
              the_qualifiers->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfCapability::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfCapability: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ICapability, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Capability(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IConceptDescription>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ConceptDescriptionFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ConceptDescriptionFromSequence. "
      "ConceptDescriptionFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > the_administration;

  common::optional<std::wstring> the_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_is_case_of;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IConceptDescription, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfConceptDescription.find(
      name
    );
    if (it == properties::kMapOfConceptDescription.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IConceptDescription, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfConceptDescription property(
      it->second
    );

    switch (property) {
      case properties::OfConceptDescription::kExtensions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_extensions = std::vector<
            std::shared_ptr<types::IExtension>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IExtension>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IExtension>
            > item;
          
            std::tie(
              item,
              error
            ) = ExtensionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_extensions = std::vector<
              std::shared_ptr<types::IExtension>
            >();
            the_extensions->reserve(items.size());
            
            for (auto& item : items) {
              the_extensions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfConceptDescription::kCategory:
        std::tie(
          the_category,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfConceptDescription::kIdShort:
        std::tie(
          the_id_short,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfConceptDescription::kDisplayName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_display_name = std::vector<
            std::shared_ptr<types::ILangStringNameType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringNameType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringNameType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringNameTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_display_name = std::vector<
              std::shared_ptr<types::ILangStringNameType>
            >();
            the_display_name->reserve(items.size());
            
            for (auto& item : items) {
              the_display_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfConceptDescription::kDescription: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_description = std::vector<
            std::shared_ptr<types::ILangStringTextType>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringTextType>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringTextType>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringTextTypeFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_description = std::vector<
              std::shared_ptr<types::ILangStringTextType>
            >();
            the_description->reserve(items.size());
            
            for (auto& item : items) {
              the_description->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfConceptDescription::kAdministration:
        std::tie(
          the_administration,
          error
        ) = AdministrativeInformationFromSequence<
          types::IAdministrativeInformation
        >(reader);
        break;
      case properties::OfConceptDescription::kId:
        std::tie(
          the_id,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfConceptDescription::kEmbeddedDataSpecifications: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_embedded_data_specifications = std::vector<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IEmbeddedDataSpecification>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            > item;
          
            std::tie(
              item,
              error
            ) = EmbeddedDataSpecificationFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_embedded_data_specifications = std::vector<
              std::shared_ptr<types::IEmbeddedDataSpecification>
            >();
            the_embedded_data_specifications->reserve(items.size());
            
            for (auto& item : items) {
              the_embedded_data_specifications->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfConceptDescription::kIsCaseOf: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_is_case_of = std::vector<
            std::shared_ptr<types::IReference>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IReference>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IReference>
            > item;
          
            std::tie(
              item,
              error
            ) = ReferenceFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_is_case_of = std::vector<
              std::shared_ptr<types::IReference>
            >();
            the_is_case_of->reserve(items.size());
            
            for (auto& item : items) {
              the_is_case_of->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfConceptDescription: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IConceptDescription, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_id.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property id is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ConceptDescription(
        std::move(*the_id),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_administration),
        std::move(the_embedded_data_specifications),
        std::move(the_is_case_of)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IReference>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ReferenceFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ReferenceFromSequence. "
      "ReferenceFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<types::ReferenceTypes> the_type;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_referred_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IKey>
    >
  > the_keys;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IReference, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfReference.find(
      name
    );
    if (it == properties::kMapOfReference.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IReference, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfReference property(
      it->second
    );

    switch (property) {
      case properties::OfReference::kType: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_type = wstringification::ReferenceTypesFromWstring(
          *text
        );

        if (!the_type.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of ReferenceTypes, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfReference::kReferredSemanticId:
        std::tie(
          the_referred_semantic_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfReference::kKeys: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_keys = std::vector<
            std::shared_ptr<types::IKey>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IKey>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IKey>
            > item;
          
            std::tie(
              item,
              error
            ) = KeyFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_keys = std::vector<
              std::shared_ptr<types::IKey>
            >();
            the_keys->reserve(items.size());
            
            for (auto& item : items) {
              the_keys->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfReference: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IReference, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property type is missing"
    );
  }

  if (!the_keys.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property keys is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Reference(
        std::move(*the_type),
        std::move(*the_keys),
        std::move(the_referred_semantic_id)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IKey>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> KeyFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in KeyFromSequence. "
      "KeyFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<types::KeyTypes> the_type;

  common::optional<std::wstring> the_value;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IKey, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfKey.find(
      name
    );
    if (it == properties::kMapOfKey.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IKey, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfKey property(
      it->second
    );

    switch (property) {
      case properties::OfKey::kType: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_type = wstringification::KeyTypesFromWstring(
          *text
        );

        if (!the_type.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of KeyTypes, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfKey::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfKey: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IKey, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_type.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property type is missing"
    );
  }

  if (!the_value.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property value is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Key(
        std::move(*the_type),
        std::move(*the_value)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringNameType>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringNameTypeFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringNameTypeFromSequence. "
      "LangStringNameTypeFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringNameType, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfLangStringNameType.find(
      name
    );
    if (it == properties::kMapOfLangStringNameType.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringNameType, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfLangStringNameType property(
      it->second
    );

    switch (property) {
      case properties::OfLangStringNameType::kLanguage:
        std::tie(
          the_language,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfLangStringNameType::kText:
        std::tie(
          the_text,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfLangStringNameType: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ILangStringNameType, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_language.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property language is missing"
    );
  }

  if (!the_text.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property text is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringNameType(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringTextType>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringTextTypeFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringTextTypeFromSequence. "
      "LangStringTextTypeFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringTextType, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfLangStringTextType.find(
      name
    );
    if (it == properties::kMapOfLangStringTextType.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringTextType, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfLangStringTextType property(
      it->second
    );

    switch (property) {
      case properties::OfLangStringTextType::kLanguage:
        std::tie(
          the_language,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfLangStringTextType::kText:
        std::tie(
          the_text,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfLangStringTextType: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ILangStringTextType, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_language.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property language is missing"
    );
  }

  if (!the_text.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property text is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringTextType(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEnvironment>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> EnvironmentFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EnvironmentFromSequence. "
      "EnvironmentFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IAssetAdministrationShell>
    >
  > the_asset_administration_shells;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodel>
    >
  > the_submodels;

  common::optional<
    std::vector<
      std::shared_ptr<types::IConceptDescription>
    >
  > the_concept_descriptions;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IEnvironment, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfEnvironment.find(
      name
    );
    if (it == properties::kMapOfEnvironment.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IEnvironment, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfEnvironment property(
      it->second
    );

    switch (property) {
      case properties::OfEnvironment::kAssetAdministrationShells: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_asset_administration_shells = std::vector<
            std::shared_ptr<types::IAssetAdministrationShell>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IAssetAdministrationShell>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IAssetAdministrationShell>
            > item;
          
            std::tie(
              item,
              error
            ) = AssetAdministrationShellFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_asset_administration_shells = std::vector<
              std::shared_ptr<types::IAssetAdministrationShell>
            >();
            the_asset_administration_shells->reserve(items.size());
            
            for (auto& item : items) {
              the_asset_administration_shells->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEnvironment::kSubmodels: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_submodels = std::vector<
            std::shared_ptr<types::ISubmodel>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ISubmodel>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ISubmodel>
            > item;
          
            std::tie(
              item,
              error
            ) = SubmodelFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_submodels = std::vector<
              std::shared_ptr<types::ISubmodel>
            >();
            the_submodels->reserve(items.size());
            
            for (auto& item : items) {
              the_submodels->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfEnvironment::kConceptDescriptions: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_concept_descriptions = std::vector<
            std::shared_ptr<types::IConceptDescription>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IConceptDescription>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IConceptDescription>
            > item;
          
            std::tie(
              item,
              error
            ) = ConceptDescriptionFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_concept_descriptions = std::vector<
              std::shared_ptr<types::IConceptDescription>
            >();
            the_concept_descriptions->reserve(items.size());
            
            for (auto& item : items) {
              the_concept_descriptions->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfEnvironment: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IEnvironment, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Environment(
        std::move(the_asset_administration_shells),
        std::move(the_submodels),
        std::move(the_concept_descriptions)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEmbeddedDataSpecification>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> EmbeddedDataSpecificationFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in EmbeddedDataSpecificationFromSequence. "
      "EmbeddedDataSpecificationFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::shared_ptr<types::IDataSpecificationContent> > the_data_specification_content;

  common::optional<std::shared_ptr<types::IReference> > the_data_specification;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IEmbeddedDataSpecification, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfEmbeddedDataSpecification.find(
      name
    );
    if (it == properties::kMapOfEmbeddedDataSpecification.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IEmbeddedDataSpecification, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfEmbeddedDataSpecification property(
      it->second
    );

    switch (property) {
      case properties::OfEmbeddedDataSpecification::kDataSpecificationContent:
        std::tie(
          the_data_specification_content,
          error
        ) = DataSpecificationContentFromElement(reader);
        break;
      case properties::OfEmbeddedDataSpecification::kDataSpecification:
        std::tie(
          the_data_specification,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfEmbeddedDataSpecification: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IEmbeddedDataSpecification, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_data_specification_content.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property dataSpecificationContent is missing"
    );
  }

  if (!the_data_specification.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property dataSpecification is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::EmbeddedDataSpecification(
        std::move(*the_data_specification_content),
        std::move(*the_data_specification)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILevelType>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LevelTypeFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LevelTypeFromSequence. "
      "LevelTypeFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<bool> the_min;

  common::optional<bool> the_nom;

  common::optional<bool> the_typ;

  common::optional<bool> the_max;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILevelType, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfLevelType.find(
      name
    );
    if (it == properties::kMapOfLevelType.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILevelType, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfLevelType property(
      it->second
    );

    switch (property) {
      case properties::OfLevelType::kMin:
        std::tie(
          the_min,
          error
        ) = DeserializeBool(reader);
        break;
      case properties::OfLevelType::kNom:
        std::tie(
          the_nom,
          error
        ) = DeserializeBool(reader);
        break;
      case properties::OfLevelType::kTyp:
        std::tie(
          the_typ,
          error
        ) = DeserializeBool(reader);
        break;
      case properties::OfLevelType::kMax:
        std::tie(
          the_max,
          error
        ) = DeserializeBool(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfLevelType: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ILevelType, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_min.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property min is missing"
    );
  }

  if (!the_nom.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property nom is missing"
    );
  }

  if (!the_typ.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property typ is missing"
    );
  }

  if (!the_max.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property max is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LevelType(
        std::move(*the_min),
        std::move(*the_nom),
        std::move(*the_typ),
        std::move(*the_max)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IValueReferencePair>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ValueReferencePairFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ValueReferencePairFromSequence. "
      "ValueReferencePairFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::wstring> the_value;

  common::optional<std::shared_ptr<types::IReference> > the_value_id;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IValueReferencePair, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfValueReferencePair.find(
      name
    );
    if (it == properties::kMapOfValueReferencePair.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IValueReferencePair, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfValueReferencePair property(
      it->second
    );

    switch (property) {
      case properties::OfValueReferencePair::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfValueReferencePair::kValueId:
        std::tie(
          the_value_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfValueReferencePair: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IValueReferencePair, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_value.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property value is missing"
    );
  }

  if (!the_value_id.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property valueId is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ValueReferencePair(
        std::move(*the_value),
        std::move(*the_value_id)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IValueList>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ValueListFromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in ValueListFromSequence. "
      "ValueListFromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::IValueReferencePair>
    >
  > the_value_reference_pairs;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IValueList, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfValueList.find(
      name
    );
    if (it == properties::kMapOfValueList.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IValueList, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfValueList property(
      it->second
    );

    switch (property) {
      case properties::OfValueList::kValueReferencePairs: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_value_reference_pairs = std::vector<
            std::shared_ptr<types::IValueReferencePair>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::IValueReferencePair>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::IValueReferencePair>
            > item;
          
            std::tie(
              item,
              error
            ) = ValueReferencePairFromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_value_reference_pairs = std::vector<
              std::shared_ptr<types::IValueReferencePair>
            >();
            the_value_reference_pairs->reserve(items.size());
            
            for (auto& item : items) {
              the_value_reference_pairs->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfValueList: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IValueList, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_value_reference_pairs.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property valueReferencePairs is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ValueList(
        std::move(*the_value_reference_pairs)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringPreferredNameTypeIec61360>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringPreferredNameTypeIec61360FromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringPreferredNameTypeIec61360FromSequence. "
      "LangStringPreferredNameTypeIec61360FromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringPreferredNameTypeIec61360, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfLangStringPreferredNameTypeIec61360.find(
      name
    );
    if (it == properties::kMapOfLangStringPreferredNameTypeIec61360.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringPreferredNameTypeIec61360, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfLangStringPreferredNameTypeIec61360 property(
      it->second
    );

    switch (property) {
      case properties::OfLangStringPreferredNameTypeIec61360::kLanguage:
        std::tie(
          the_language,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfLangStringPreferredNameTypeIec61360::kText:
        std::tie(
          the_text,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfLangStringPreferredNameTypeIec61360: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ILangStringPreferredNameTypeIec61360, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_language.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property language is missing"
    );
  }

  if (!the_text.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property text is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringPreferredNameTypeIec61360(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringShortNameTypeIec61360>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringShortNameTypeIec61360FromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringShortNameTypeIec61360FromSequence. "
      "LangStringShortNameTypeIec61360FromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringShortNameTypeIec61360, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfLangStringShortNameTypeIec61360.find(
      name
    );
    if (it == properties::kMapOfLangStringShortNameTypeIec61360.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringShortNameTypeIec61360, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfLangStringShortNameTypeIec61360 property(
      it->second
    );

    switch (property) {
      case properties::OfLangStringShortNameTypeIec61360::kLanguage:
        std::tie(
          the_language,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfLangStringShortNameTypeIec61360::kText:
        std::tie(
          the_text,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfLangStringShortNameTypeIec61360: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ILangStringShortNameTypeIec61360, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_language.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property language is missing"
    );
  }

  if (!the_text.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property text is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringShortNameTypeIec61360(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringDefinitionTypeIec61360>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> LangStringDefinitionTypeIec61360FromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in LangStringDefinitionTypeIec61360FromSequence. "
      "LangStringDefinitionTypeIec61360FromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringDefinitionTypeIec61360, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfLangStringDefinitionTypeIec61360.find(
      name
    );
    if (it == properties::kMapOfLangStringDefinitionTypeIec61360.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of ILangStringDefinitionTypeIec61360, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfLangStringDefinitionTypeIec61360 property(
      it->second
    );

    switch (property) {
      case properties::OfLangStringDefinitionTypeIec61360::kLanguage:
        std::tie(
          the_language,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfLangStringDefinitionTypeIec61360::kText:
        std::tie(
          the_text,
          error
        ) = DeserializeWstring(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfLangStringDefinitionTypeIec61360: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of ILangStringDefinitionTypeIec61360, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_language.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property language is missing"
    );
  }

  if (!the_text.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property text is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringDefinitionTypeIec61360(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IDataSpecificationIec61360>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DataSpecificationIec61360FromSequence(
  ReaderMergingText& reader
) {
  #ifdef DEBUG
  if (reader.node().kind() == NodeKind::Error) {
    throw std::logic_error(
      "Unexpected unhandled XML error in DataSpecificationIec61360FromSequence. "
      "DataSpecificationIec61360FromSequence expects no reader error at entry."
    );
  }
  #endif

  common::optional<DeserializationError> error;

  error = SkipBof(reader);
  if (error.has_value()) {
    return NoInstanceAndDeserializationError<
      std::shared_ptr<T>
    >(
      std::move(*error)
    );
  }

  // region Initialization

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >
  > the_preferred_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >
  > the_short_name;

  common::optional<std::wstring> the_unit;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_unit_id;

  common::optional<std::wstring> the_source_of_definition;

  common::optional<std::wstring> the_symbol;

  common::optional<types::DataTypeIec61360> the_data_type;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >
  > the_definition;

  common::optional<std::wstring> the_value_format;

  common::optional<
    std::shared_ptr<types::IValueList>
  > the_value_list;

  common::optional<std::wstring> the_value;

  common::optional<
    std::shared_ptr<types::ILevelType>
  > the_level_type;

  // endregion Initialization

  while (true) {
    error = SkipWhitespace(reader);
    if (error.has_value()) {
      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (reader.node().kind() == NodeKind::Stop) {
      // NOTE (mristin):
      // We reached a closing element of an instance, so we know that
      // the sequence ended.
      break;
    } else if (reader.node().kind() != NodeKind::Start) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IDataSpecificationIec61360, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );
    }

    const std::string name(
      static_cast<  // NOLINT(cppcoreguidelines-pro-type-static-cast-downcast)
        const StartNode&
      >(reader.node()).name
    );

    // NOTE (mristin):
    // We consume the start element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    auto it = properties::kMapOfDataSpecificationIec61360.find(
      name
    );
    if (it == properties::kMapOfDataSpecificationIec61360.end()) {
      return NoInstanceAndDeserializationErrorWithCause<
        std::shared_ptr<T>
      >(
        common::Concat(
          L"Expected a start element opening a property "
          L"of IDataSpecificationIec61360, "
          L"but got a start element "
          L"which does not correspond to any of its properties: <",
          common::Utf8ToWstring(name),
          L">"
        )
      );
    }

    const properties::OfDataSpecificationIec61360 property(
      it->second
    );

    switch (property) {
      case properties::OfDataSpecificationIec61360::kPreferredName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_preferred_name = std::vector<
            std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringPreferredNameTypeIec61360FromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_preferred_name = std::vector<
              std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
            >();
            the_preferred_name->reserve(items.size());
            
            for (auto& item : items) {
              the_preferred_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfDataSpecificationIec61360::kShortName: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_short_name = std::vector<
            std::shared_ptr<types::ILangStringShortNameTypeIec61360>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringShortNameTypeIec61360>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringShortNameTypeIec61360>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringShortNameTypeIec61360FromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_short_name = std::vector<
              std::shared_ptr<types::ILangStringShortNameTypeIec61360>
            >();
            the_short_name->reserve(items.size());
            
            for (auto& item : items) {
              the_short_name->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfDataSpecificationIec61360::kUnit:
        std::tie(
          the_unit,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfDataSpecificationIec61360::kUnitId:
        std::tie(
          the_unit_id,
          error
        ) = ReferenceFromSequence<
          types::IReference
        >(reader);
        break;
      case properties::OfDataSpecificationIec61360::kSourceOfDefinition:
        std::tie(
          the_source_of_definition,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfDataSpecificationIec61360::kSymbol:
        std::tie(
          the_symbol,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfDataSpecificationIec61360::kDataType: {
        common::optional<std::wstring> text;
        std::tie(
          text,
          error
        ) = DeserializeWstring(reader);

        if (error.has_value()) {
          break;
        }

        the_data_type = wstringification::DataTypeIec61360FromWstring(
          *text
        );

        if (!the_data_type.has_value()) {
          error = common::make_optional<DeserializationError>(
            common::Concat(
              L"Expected to parse a literal of DataTypeIec61360, "
              L"but got: ",
              *text
            )
          );
        }
        break;
      }
      case properties::OfDataSpecificationIec61360::kDefinition: {
        if (reader.node().kind() == NodeKind::Stop) {
          the_definition = std::vector<
            std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
          >();
        } else {
          std::deque<
            std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
          > items;
          size_t i = 0;
          
          while (true) {
            common::optional<
              std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
            > item;
          
            std::tie(
              item,
              error
            ) = LangStringDefinitionTypeIec61360FromElement(reader);
          
            if (error.has_value()) {
              error->path.segments.emplace_front(
                common::make_unique<IndexSegment>(i)
              );
              break;
            }
          
            error = SkipWhitespace(reader);
            if (error.has_value()) {
              break;
            }
          
            items.emplace_back(*item);
          
            if (reader.node().kind() == NodeKind::Stop) {
              break;
            }
          
            ++i;
          }
          
          if (!error.has_value()) {
            the_definition = std::vector<
              std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
            >();
            the_definition->reserve(items.size());
            
            for (auto& item : items) {
              the_definition->emplace_back(
                std::move(item)
              );
            }
          }
        }
        break;
      }
      case properties::OfDataSpecificationIec61360::kValueFormat:
        std::tie(
          the_value_format,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfDataSpecificationIec61360::kValueList:
        std::tie(
          the_value_list,
          error
        ) = ValueListFromSequence<
          types::IValueList
        >(reader);
        break;
      case properties::OfDataSpecificationIec61360::kValue:
        std::tie(
          the_value,
          error
        ) = DeserializeWstring(reader);
        break;
      case properties::OfDataSpecificationIec61360::kLevelType:
        std::tie(
          the_level_type,
          error
        ) = LevelTypeFromSequence<
          types::ILevelType
        >(reader);
        break;
      default:
        throw std::logic_error(
          common::Concat(
            "Unexpected properties literal of "
            "properties::OfDataSpecificationIec61360: ",
            std::to_string(
              static_cast<uint32_t>(property)
            )
          )
        );
    }

    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    error = SkipWhitespace(reader);
    if (error.has_value()) {
      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    if (!IsStopNodeWithName(reader.node(), name)) {
      error = DeserializationError(
        common::Concat(
          L"Expected a stop element </",
          common::Utf8ToWstring(name),
          L"> closing the property "
          L"of IDataSpecificationIec61360, but got ",
          NodeToHumanReadableWstring(reader.node())
        )
      );

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }

    // NOTE (mristin):
    // We consume the stop element.
    reader.Read();

    if (reader.node().kind() == NodeKind::Error) {
      error = DeserializationErrorFromReader(reader);

      PrependElementSegmentToDeserializationError(
        name,
        *error
      );

      return NoInstanceAndDeserializationError<
        std::shared_ptr<T>
      >(
        std::move(*error)
      );
    }
  }

  // region Check required properties

  if (!the_preferred_name.has_value()) {
    return NoInstanceAndDeserializationErrorWithCause<
      std::shared_ptr<T>
    >(
      L"The required property preferredName is missing"
    );
  }

  // endregion Check required properties

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::DataSpecificationIec61360(
        std::move(*the_preferred_name),
        std::move(the_short_name),
        std::move(the_unit),
        std::move(the_unit_id),
        std::move(the_source_of_definition),
        std::move(the_symbol),
        std::move(the_data_type),
        std::move(the_definition),
        std::move(the_value_format),
        std::move(the_value_list),
        std::move(the_value),
        std::move(the_level_type)
      )
    ),
    common::nullopt
  );
}

common::expected<
  std::shared_ptr<types::IClass>,
  DeserializationError
> From(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IClass>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ClassFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IHasSemantics>,
  DeserializationError
> HasSemanticsFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IHasSemantics>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = HasSemanticsFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IExtension>,
  DeserializationError
> ExtensionFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IExtension>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ExtensionFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IHasExtensions>,
  DeserializationError
> HasExtensionsFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IHasExtensions>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = HasExtensionsFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IReferable>,
  DeserializationError
> ReferableFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IReferable>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ReferableFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IIdentifiable>,
  DeserializationError
> IdentifiableFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IIdentifiable>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = IdentifiableFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IHasKind>,
  DeserializationError
> HasKindFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IHasKind>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = HasKindFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IHasDataSpecification>,
  DeserializationError
> HasDataSpecificationFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IHasDataSpecification>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = HasDataSpecificationFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IAdministrativeInformation>,
  DeserializationError
> AdministrativeInformationFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = AdministrativeInformationFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IQualifiable>,
  DeserializationError
> QualifiableFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IQualifiable>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = QualifiableFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IQualifier>,
  DeserializationError
> QualifierFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IQualifier>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = QualifierFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IAssetAdministrationShell>,
  DeserializationError
> AssetAdministrationShellFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IAssetAdministrationShell>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = AssetAdministrationShellFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IAssetInformation>,
  DeserializationError
> AssetInformationFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IAssetInformation>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = AssetInformationFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IResource>,
  DeserializationError
> ResourceFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IResource>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ResourceFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ISpecificAssetId>,
  DeserializationError
> SpecificAssetIdFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ISpecificAssetId>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = SpecificAssetIdFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ISubmodel>,
  DeserializationError
> SubmodelFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ISubmodel>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = SubmodelFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ISubmodelElement>,
  DeserializationError
> SubmodelElementFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ISubmodelElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = SubmodelElementFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IRelationshipElement>,
  DeserializationError
> RelationshipElementFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IRelationshipElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = RelationshipElementFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ISubmodelElementList>,
  DeserializationError
> SubmodelElementListFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ISubmodelElementList>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = SubmodelElementListFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ISubmodelElementCollection>,
  DeserializationError
> SubmodelElementCollectionFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ISubmodelElementCollection>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = SubmodelElementCollectionFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IDataElement>,
  DeserializationError
> DataElementFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IDataElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DataElementFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IProperty>,
  DeserializationError
> PropertyFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IProperty>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = PropertyFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IMultiLanguageProperty>,
  DeserializationError
> MultiLanguagePropertyFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IMultiLanguageProperty>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = MultiLanguagePropertyFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IRange>,
  DeserializationError
> RangeFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IRange>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = RangeFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IReferenceElement>,
  DeserializationError
> ReferenceElementFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IReferenceElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ReferenceElementFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IBlob>,
  DeserializationError
> BlobFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IBlob>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = BlobFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IFile>,
  DeserializationError
> FileFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IFile>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = FileFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IAnnotatedRelationshipElement>,
  DeserializationError
> AnnotatedRelationshipElementFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IAnnotatedRelationshipElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = AnnotatedRelationshipElementFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IEntity>,
  DeserializationError
> EntityFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IEntity>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = EntityFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IEventPayload>,
  DeserializationError
> EventPayloadFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IEventPayload>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = EventPayloadFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IEventElement>,
  DeserializationError
> EventElementFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IEventElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = EventElementFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IBasicEventElement>,
  DeserializationError
> BasicEventElementFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IBasicEventElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = BasicEventElementFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IOperation>,
  DeserializationError
> OperationFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IOperation>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = OperationFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IOperationVariable>,
  DeserializationError
> OperationVariableFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IOperationVariable>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = OperationVariableFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ICapability>,
  DeserializationError
> CapabilityFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ICapability>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = CapabilityFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IConceptDescription>,
  DeserializationError
> ConceptDescriptionFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IConceptDescription>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ConceptDescriptionFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IReference>,
  DeserializationError
> ReferenceFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IReference>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ReferenceFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IKey>,
  DeserializationError
> KeyFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IKey>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = KeyFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IAbstractLangString>,
  DeserializationError
> AbstractLangStringFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IAbstractLangString>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = AbstractLangStringFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ILangStringNameType>,
  DeserializationError
> LangStringNameTypeFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ILangStringNameType>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = LangStringNameTypeFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ILangStringTextType>,
  DeserializationError
> LangStringTextTypeFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ILangStringTextType>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = LangStringTextTypeFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IEnvironment>,
  DeserializationError
> EnvironmentFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IEnvironment>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = EnvironmentFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IDataSpecificationContent>,
  DeserializationError
> DataSpecificationContentFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IDataSpecificationContent>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DataSpecificationContentFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IEmbeddedDataSpecification>,
  DeserializationError
> EmbeddedDataSpecificationFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = EmbeddedDataSpecificationFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ILevelType>,
  DeserializationError
> LevelTypeFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ILevelType>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = LevelTypeFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IValueReferencePair>,
  DeserializationError
> ValueReferencePairFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IValueReferencePair>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ValueReferencePairFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IValueList>,
  DeserializationError
> ValueListFrom(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IValueList>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = ValueListFromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>,
  DeserializationError
> LangStringPreferredNameTypeIec61360From(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = LangStringPreferredNameTypeIec61360FromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ILangStringShortNameTypeIec61360>,
  DeserializationError
> LangStringShortNameTypeIec61360From(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ILangStringShortNameTypeIec61360>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = LangStringShortNameTypeIec61360FromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::ILangStringDefinitionTypeIec61360>,
  DeserializationError
> LangStringDefinitionTypeIec61360From(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = LangStringDefinitionTypeIec61360FromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

common::expected<
  std::shared_ptr<types::IDataSpecificationIec61360>,
  DeserializationError
> DataSpecificationIec61360From(
  std::istream& is,
  const ReadingOptions& options
) {
  ReaderMergingText reader(is, options);

  reader.Initialize();
  if (reader.node().kind() == NodeKind::Error) {
    return common::make_unexpected(
      DeserializationErrorFromReader(reader)
    );
  }

  common::optional<
    std::shared_ptr<types::IDataSpecificationIec61360>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DataSpecificationIec61360FromElement(reader);

  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = SkipWhitespace(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  error = CheckReaderAtEof(reader);
  if (error.has_value()) {
    return common::make_unexpected(
      std::move(*error)
    );
  }

  return std::move(*instance);
}

// endregion De-serialization

// region Serialization

/**
 * Represent a serialization error.
 *
 * We use this error internally to avoid unnecessary stack unwinding,
 * but throw the \ref SerializationException at the final site of
 * the serialization for the user.
 */
struct SerializationError {
  /**
   * Human-readable description of the error
   */
  std::wstring cause;

  /**
   * Path to the value that caused the error
   */
  iteration::Path path;

  explicit SerializationError(
    std::wstring a_cause
  ) :
    cause(std::move(a_cause)) {
    // Intentionally empty.
  }
};  // struct SerializationError

const std::wstring kTheOutputStreamIsInABadState(
  L"The output stream is in a bad state."
    );

/**
 * Check that the output stream is not in a bad state. If so, create an error.
 */
common::optional<SerializationError> CheckOstreamState(
  const std::ostream& os
) {
  if (os.bad()) {
    return common::make_optional<SerializationError>(
      kTheOutputStreamIsInABadState
    );
  }

  return common::nullopt;
}

// region SerializationException

std::string RenderSerializationErrorMessage(
  const std::wstring& cause,
  const iteration::Path& path
) {
  return common::WstringToUtf8(
    common::Concat(
      L"Serialization failed at ",
      path.ToWstring(),
      L": ",
      cause
    )
  );
}

SerializationException::SerializationException(
  std::wstring cause
) :
  cause_(std::move(cause)),
  path_(),
  msg_(RenderSerializationErrorMessage(cause, path_)) {
  // Intentionally empty.
}

SerializationException::SerializationException(
  std::wstring cause,
  iteration::Path path
) :
  cause_(std::move(cause)),
  path_(std::move(path)),
  msg_(RenderSerializationErrorMessage(cause, path)) {
  // Intentionally empty.
}

const char* SerializationException::what() const noexcept {
  return msg_.c_str();
}

const std::wstring& SerializationException::cause() const noexcept {
  return cause_;
}

const iteration::Path& SerializationException::path() const noexcept {
  return path_;
}

// endregion SerializationException

// region SelfClosingWriter

/**
 * \brief Write XML nodes to the UTF-8-encoded output stream.
 *
 * The start elements are put on hold until we observe a text, a stop element or
 * end-of-input. This allows us to continuously shorten the XML elements to self-closing
 * tags.
 *
 * The prefix is appended to each element name. If you do not need the prefix,
 * specify it as empty string. In most cases, you put a colon, `:` at the end of
 * the prefix.
 *
 * Each writing method captures any errors and obvious exceptions as
 * serialization errors.
 *
 * Use \ref error() to check if there is any error.
 */
class SelfClosingWriter {
 public:
  SelfClosingWriter(
    std::ostream& os,
    std::string prefix
  );

  /**
   * Queue a start element for an eventual write.
   */
  void StartElement(
    std::string name
  );

  /**
   * Write a stop element.
   *
   * If there is a pending start element with no content, shorten it to
   * a self-closing XML element.
   */
  void StopElement(
    const std::string& name
  );

  /**
   * \brief Serialize the given boolean to an xs:bool value.
   *
   * We explicitly write longer text, `true` and `false`, to make the values explicit,
   * and not potentially confusing with numbers, in the XML.
   */
  void SerializeBool(
    bool value
  );

  /**
   * \brief Serialize the given number to an xs:long value.
   *
   * We do not check that the number is within a range representable as 64-bit
   * floats, as the value can be de-serialized correctly from XML. However, this
   * means that XML and JSON serializations are not interoperable. If you need
   * interoperability, you have to ensure that range yourself (<i>e.g.</i>, through
   * \ref validation, see also
   * https://github.com/aas-core-works/aas-core-meta/issues/298).
   */
  void SerializeInt64(
    int64_t value
  );

  /**
   * \brief Serialize the given number to an xs:double value.
   */
  void SerializeDouble(
    double value
  );

  /**
   * \brief Write the text while escaping special characters for XML.
   */
  void SerializeWstring(
    const std::wstring& text
  );

  /**
   * \brief Write the text while escaping special characters for XML.
   */
  void SerializeString(
    const std::string& text
  );

  /**
   * \brief Encode bytes to Base64 and write them.
   */
  void SerializeByteArray(
  const std::vector<std::uint8_t>& byte_array
  );

  /**
   * Finish and flush any pending start nodes.
   */
  void Finish();

  /**
   * Get an error, if any, caught during the serialization.
   */
  const common::optional<SerializationError>& error() const;

  /**
   * Transfer the ownership of the error.
   */
  common::optional<SerializationError>&& move_error();

 private:
  std::ostream& os_;
  std::string prefix_;
  common::optional<SerializationError> error_;
  common::optional<std::string> pending_start_wo_text_;

  /**
   * \brief Escape the given text to XML.
   *
   * Return nothing if no escaping was needed.
   */
  static common::optional<std::wstring> EscapeForXml(
    const std::wstring& text
  );

  /**
   * \brief Escape the given text to XML.
   *
   * Return nothing if no escaping was needed.
   */
  static common::optional<std::string> EscapeForXml(
    const std::string& text
  );

  void WritePendingStartElementIfAvailable();

  /**
   * Write the text without any XML escaping or flushing of pending start elements.
   */
  void WriteStringWithoutEscapingNorFlushing(
    const std::string& text
  );
};  // class SelfClosingWriter

SelfClosingWriter::SelfClosingWriter(
  std::ostream& os,
  std::string prefix
) :
  os_(os),
  prefix_(std::move(prefix)) {
  // Intentionally empty.
}

void SelfClosingWriter::StartElement(
  std::string name
) {
  #ifdef DEBUG
  if (error_.has_value()) {
    throw std::logic_error(
      "You are trying to queue a start element with a SelfClosingWriter "
      "which caught an error."
    );
  #endif

  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
  return;
  }

  pending_start_wo_text_ = std::move(name);
}

void SelfClosingWriter::StopElement(
  const std::string& name
) {
  #ifdef DEBUG
  if (error_.has_value()) {
    throw std::logic_error(
      "You are trying to write a stop element with a SelfClosingWriter "
      "which caught an error before."
    );
  #endif

  if (pending_start_wo_text_.has_value()) {
    #ifdef DEBUG
    if (*pending_start_wo_text_ != name) {
      throw std::logic_error(
        common::Concat(
          "The start element <",
          *pending_start_wo_text_,
          "> is pending for writing, "
          "but you are trying to write a stop element </",
          name
          ">"
        )
      );
    }
    #endif

    pending_start_wo_text_ = common::nullopt;

    WriteStringWithoutEscapingNorFlushing(
      common::Concat(
        "<",
        prefix_,
        name,
        " />"
      )
    );
  } else {
    WritePendingStartElementIfAvailable();
    if (error_.has_value()) {
      return;
    }

    WriteStringWithoutEscapingNorFlushing(
      common::Concat(
        "</",
        prefix_,
        name,
        ">"
      )
    );
  }
}

void SelfClosingWriter::SerializeBool(
  bool value
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  WriteStringWithoutEscapingNorFlushing(
    value ? "true" : "false"
  );
}

void SelfClosingWriter::SerializeInt64(
  int64_t value
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  WriteStringWithoutEscapingNorFlushing(
    std::to_string(value)
  );
}

void SelfClosingWriter::SerializeDouble(
  double value
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  // NOTE (mristin):
  // We handle edge values infinity and not-a-number explicitly here
  // as some C/C++ implementations might not convert them to XML-conformant
  // strings.

  if (std::isinf(value)) {
    if (value < 0) {
      WriteStringWithoutEscapingNorFlushing("-INF");
    } else {
      WriteStringWithoutEscapingNorFlushing("INF");
    }
  } else if(std::isnan(value)) {
    WriteStringWithoutEscapingNorFlushing("NaN");
  } else {
    WriteStringWithoutEscapingNorFlushing(
      std::to_string(value)
    );
  }
}

void SelfClosingWriter::SerializeString(
  const std::string& text
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  // NOTE (mristin):
  // We optimize here for short and long texts, respectively.
  // The main assumption is that the short texts can be escaped and converted
  // in one go, while the longer texts need to be converted in chunks.

  if (text.size() < 1024) {
    common::optional<std::string> escaped = EscapeForXml(text);

    if (escaped.has_value()) {
      WriteStringWithoutEscapingNorFlushing(
        *escaped
      );
      return;
    } else {
      WriteStringWithoutEscapingNorFlushing(
        text
      );
      return;
    }
  }

  size_t start = 0;
  while (start < text.size()) {
    const size_t end = std::min(start + 1024, text.size());
    const size_t chunk_size = end - start;

    // NOTE (mristin):
    // We assume that making short copies of text substrings does not hurt
    // the performance here, but makes the code more readable.

    const std::string chunk = text.substr(start, chunk_size);

    common::optional<std::string> escaped = EscapeForXml(chunk);

    if (escaped.has_value()) {
      WriteStringWithoutEscapingNorFlushing(
        *escaped
      );
    } else {
      WriteStringWithoutEscapingNorFlushing(
        chunk
      );
    }

    if (error_.has_value()) {
      return;
    }

    start += chunk_size;
  }
}

void SelfClosingWriter::SerializeWstring(
  const std::wstring& text
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  // NOTE (mristin):
  // We optimize here for short and long texts, respectively.
  // The main assumption is that the short texts can be escaped and converted
  // in one go, while the longer texts need to be converted in chunks.

  if (text.size() < 1024) {
    common::optional<std::wstring> escaped = EscapeForXml(text);

    if (escaped.has_value()) {
      WriteStringWithoutEscapingNorFlushing(
        common::WstringToUtf8(*escaped)
      );
      return;
    } else {
      WriteStringWithoutEscapingNorFlushing(
        common::WstringToUtf8(text)
      );
      return;
    }
  }

  size_t start = 0;
  while (start < text.size()) {
    const size_t end = std::min(start + 1024, text.size());
    const size_t chunk_size = end - start;

    // NOTE (mristin):
    // We assume that making short copies of text substrings does not hurt
    // the performance here, but makes the code more readable.

    const std::wstring chunk = text.substr(start, chunk_size);

    common::optional<std::wstring> escaped = EscapeForXml(chunk);

    if (escaped.has_value()) {
      WriteStringWithoutEscapingNorFlushing(
        common::WstringToUtf8(*escaped)
      );
    } else {
      WriteStringWithoutEscapingNorFlushing(
        common::WstringToUtf8(chunk)
      );
    }

    if (error_.has_value()) {
      return;
    }

    start += chunk_size;
  }
}

void SelfClosingWriter::SerializeByteArray(
  const std::vector<std::uint8_t>& byte_array
) {
  WritePendingStartElementIfAvailable();
  if (error_.has_value()) {
    return;
  }

  // NOTE (mristin):
  // We optimize here for short and long byte arrays, respectively.
  // The main assumption is that the short texts can be escaped and converted
  // in one go, while the longer texts need to be converted in chunks.
  //
  // Optimally, we would write an encoding function such that it encodes directly
  // to the output stream. As we lack the time resources for that at the moment,
  // we go for the compromise with one pass and chunking, respectively.

  if (byte_array.size() <= 1536) {
    WriteStringWithoutEscapingNorFlushing(
      stringification::Base64Encode(byte_array)
    );
    return;
  }

  // NOTE (mristin):
  // We assume here that making copies of small sub-arrays does not hurt
  // the performance, but makes the code substantially more readable.

  size_t start = 0;
  while (start < byte_array.size()) {
    // NOTE (mristin):
    // We pick a multiple of 3 for the chunk size in order to make the encoding
    // of chunking identical to the output as we encoded all bytes at the same time.
    //
    // See: https://stackoverflow.com/questions/7920780/is-it-possible-to-base64-encode-a-file-in-chunks

    const size_t end = std::min(start + 1536, byte_array.size());

    const std::vector<std::uint8_t> chunk(
      byte_array.begin() + start,
      byte_array.begin() + end
    );

    WriteStringWithoutEscapingNorFlushing(
      stringification::Base64Encode(chunk)
    );
    if (error_.has_value()) {
      return;
    }
  }
}

void SelfClosingWriter::Finish() {
  WritePendingStartElementIfAvailable();
}

const common::optional<SerializationError>& SelfClosingWriter::error() const {
  return error_;
}

common::optional<SerializationError>&& SelfClosingWriter::move_error() {
  return std::move(error_);
}

common::optional<std::wstring> SelfClosingWriter::EscapeForXml(
  const std::wstring& text
) {
  size_t out_len = 0;

  // NOTE (mristin):
  // We use sizeof on *strings* instead of *wide strings* to get
  // the number of *characters*. Otherwise, if we used wide strings,
  // we would obtain the wrong number of characters as we would count
  // bytes instead of characters with `sizeof`, which differ in wide strings
  // due to encoding.

  for (wchar_t character : text ) {
    switch (character) {
      case L'&': {
        out_len += sizeof("&amp;");
        break;
      }
      case L'<': {
        out_len += sizeof("&lt;");
        break;
      }
      case L'>': {
        out_len += sizeof("&gt;");
        break;
      }
      case L'"': {
        out_len += sizeof("&quot;");
        break;
      }
      case L'\'': {
        out_len += sizeof("&apos;");
        break;
      }
      default:
        ++out_len;
        break;
    }
  }

  // NOTE (mristin):
  // We assume here that XML encoding is always *longer* than
  // the original text.

  if (out_len == text.size()) {
    return common::nullopt;
  }

  std::wstring out;
  out.reserve(out_len);

  for (wchar_t character : text ) {
    switch (character) {
      case L'&':
        out.append(L"&amp;");
        break;
      case L'<':
        out.append(L"&lt;");
        break;
      case L'>':
        out.append(L"&gt;");
        break;
      case L'"':
        out.append(L"&quot;");
        break;
      case L'\'':
        out.append(L"&apos;");
        break;
      default:
        out.push_back(character);
        break;
    }
  }

  return common::make_optional<std::wstring>(
    std::move(out)
  );
}

common::optional<std::string> SelfClosingWriter::EscapeForXml(
  const std::string& text
) {
  size_t out_len = 0;

  for (char character : text ) {
    switch (character) {
      case '&': {
        out_len += sizeof("&amp;");
        break;
      }
      case '<': {
        out_len += sizeof("&lt;");
        break;
      }
      case '>': {
        out_len += sizeof("&gt;");
        break;
      }
      case '"': {
        out_len += sizeof("&quot;");
        break;
      }
      case '\'': {
        out_len += sizeof("&apos;");
        break;
      }
      default:
        ++out_len;
        break;
    }
  }

  // NOTE (mristin):
  // We assume here that XML encoding is always *longer* than
  // the original text.

  if (out_len == text.size()) {
    return common::nullopt;
  }

  std::string out;
  out.reserve(out_len);

  for (char character : text ) {
    switch (character) {
      case '&':
        out.append("&amp;");
        break;
      case '<':
        out.append("&lt;");
        break;
      case '>':
        out.append("&gt;");
        break;
      case '"':
        out.append("&quot;");
        break;
      case '\'':
        out.append("&apos;");
        break;
      default:
        out.push_back(character);
        break;
    }
  }

  return common::make_optional<std::string>(
    std::move(out)
  );
}

void SelfClosingWriter::WritePendingStartElementIfAvailable() {
  if (!pending_start_wo_text_.has_value()) {
    return;
  }

  WriteStringWithoutEscapingNorFlushing(
    common::Concat(
      "<",
      prefix_,
      *pending_start_wo_text_,
      ">"
    )
  );

  pending_start_wo_text_ = common::nullopt;
}

void SelfClosingWriter::WriteStringWithoutEscapingNorFlushing(
  const std::string& text
) {
  #ifdef DEBUG
  if (error_.has_value()) {
    throw std::logic_error(
      "You are trying to write to a SelfClosingWriter which "
      "caught an error"
    );
  }
  #endif

  if (os_.bad()) {
    error_ = common::make_optional<SerializationError>(
      kTheOutputStreamIsInABadState
    );
    return;
  }

  os_ << text;

  if (os_.bad()) {
    error_ = common::make_optional<SerializationError>(
      kTheOutputStreamIsInABadState
    );
    return;
  }
}

// endregion SelfClosingWriter

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeHasSemanticsAsElement(
  const types::IHasSemantics& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeExtensionAsSequence(
  const types::IExtension& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<extension>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeExtensionAsElement(
  const types::IExtension& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeHasExtensionsAsElement(
  const types::IHasExtensions& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeReferableAsElement(
  const types::IReferable& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeIdentifiableAsElement(
  const types::IIdentifiable& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeHasKindAsElement(
  const types::IHasKind& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeHasDataSpecificationAsElement(
  const types::IHasDataSpecification& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAdministrativeInformationAsSequence(
  const types::IAdministrativeInformation& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<administrativeInformation>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeAdministrativeInformationAsElement(
  const types::IAdministrativeInformation& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeQualifiableAsElement(
  const types::IQualifiable& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeQualifierAsSequence(
  const types::IQualifier& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<qualifier>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeQualifierAsElement(
  const types::IQualifier& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAssetAdministrationShellAsSequence(
  const types::IAssetAdministrationShell& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<assetAdministrationShell>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeAssetAdministrationShellAsElement(
  const types::IAssetAdministrationShell& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAssetInformationAsSequence(
  const types::IAssetInformation& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<assetInformation>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeAssetInformationAsElement(
  const types::IAssetInformation& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeResourceAsSequence(
  const types::IResource& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<resource>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeResourceAsElement(
  const types::IResource& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSpecificAssetIdAsSequence(
  const types::ISpecificAssetId& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<specificAssetId>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeSpecificAssetIdAsElement(
  const types::ISpecificAssetId& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSubmodelAsSequence(
  const types::ISubmodel& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<submodel>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeSubmodelAsElement(
  const types::ISubmodel& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSubmodelElementAsElement(
  const types::ISubmodelElement& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeRelationshipElementAsSequence(
  const types::IRelationshipElement& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeRelationshipElementAsElement(
  const types::IRelationshipElement& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSubmodelElementListAsSequence(
  const types::ISubmodelElementList& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<submodelElementList>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeSubmodelElementListAsElement(
  const types::ISubmodelElementList& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSubmodelElementCollectionAsSequence(
  const types::ISubmodelElementCollection& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<submodelElementCollection>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeSubmodelElementCollectionAsElement(
  const types::ISubmodelElementCollection& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeDataElementAsElement(
  const types::IDataElement& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializePropertyAsSequence(
  const types::IProperty& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<property>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializePropertyAsElement(
  const types::IProperty& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeMultiLanguagePropertyAsSequence(
  const types::IMultiLanguageProperty& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<multiLanguageProperty>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeMultiLanguagePropertyAsElement(
  const types::IMultiLanguageProperty& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeRangeAsSequence(
  const types::IRange& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<range>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeRangeAsElement(
  const types::IRange& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeReferenceElementAsSequence(
  const types::IReferenceElement& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<referenceElement>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeReferenceElementAsElement(
  const types::IReferenceElement& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeBlobAsSequence(
  const types::IBlob& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<blob>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeBlobAsElement(
  const types::IBlob& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeFileAsSequence(
  const types::IFile& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<file>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeFileAsElement(
  const types::IFile& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAnnotatedRelationshipElementAsSequence(
  const types::IAnnotatedRelationshipElement& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<annotatedRelationshipElement>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeAnnotatedRelationshipElementAsElement(
  const types::IAnnotatedRelationshipElement& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEntityAsSequence(
  const types::IEntity& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<entity>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeEntityAsElement(
  const types::IEntity& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEventPayloadAsSequence(
  const types::IEventPayload& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<eventPayload>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeEventPayloadAsElement(
  const types::IEventPayload& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEventElementAsElement(
  const types::IEventElement& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeBasicEventElementAsSequence(
  const types::IBasicEventElement& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<basicEventElement>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeBasicEventElementAsElement(
  const types::IBasicEventElement& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeOperationAsSequence(
  const types::IOperation& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<operation>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeOperationAsElement(
  const types::IOperation& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeOperationVariableAsSequence(
  const types::IOperationVariable& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<operationVariable>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeOperationVariableAsElement(
  const types::IOperationVariable& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeCapabilityAsSequence(
  const types::ICapability& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<capability>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeCapabilityAsElement(
  const types::ICapability& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeConceptDescriptionAsSequence(
  const types::IConceptDescription& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<conceptDescription>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeConceptDescriptionAsElement(
  const types::IConceptDescription& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeReferenceAsSequence(
  const types::IReference& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<reference>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeReferenceAsElement(
  const types::IReference& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeKeyAsSequence(
  const types::IKey& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<key>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeKeyAsElement(
  const types::IKey& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAbstractLangStringAsElement(
  const types::IAbstractLangString& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringNameTypeAsSequence(
  const types::ILangStringNameType& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<langStringNameType>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeLangStringNameTypeAsElement(
  const types::ILangStringNameType& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringTextTypeAsSequence(
  const types::ILangStringTextType& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<langStringTextType>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeLangStringTextTypeAsElement(
  const types::ILangStringTextType& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEnvironmentAsSequence(
  const types::IEnvironment& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<environment>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeEnvironmentAsElement(
  const types::IEnvironment& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance by dispatching to the appropriate concrete
 * serialization function.
 *
 * \param that instance to be serialized
 * \param writer to be write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeDataSpecificationContentAsElement(
  const types::IDataSpecificationContent& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEmbeddedDataSpecificationAsSequence(
  const types::IEmbeddedDataSpecification& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<embeddedDataSpecification>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeEmbeddedDataSpecificationAsElement(
  const types::IEmbeddedDataSpecification& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLevelTypeAsSequence(
  const types::ILevelType& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<levelType>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeLevelTypeAsElement(
  const types::ILevelType& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeValueReferencePairAsSequence(
  const types::IValueReferencePair& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<valueReferencePair>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeValueReferencePairAsElement(
  const types::IValueReferencePair& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeValueListAsSequence(
  const types::IValueList& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<valueList>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeValueListAsElement(
  const types::IValueList& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringPreferredNameTypeIec61360AsSequence(
  const types::ILangStringPreferredNameTypeIec61360& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<langStringPreferredNameTypeIec61360>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeLangStringPreferredNameTypeIec61360AsElement(
  const types::ILangStringPreferredNameTypeIec61360& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringShortNameTypeIec61360AsSequence(
  const types::ILangStringShortNameTypeIec61360& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<langStringShortNameTypeIec61360>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeLangStringShortNameTypeIec61360AsElement(
  const types::ILangStringShortNameTypeIec61360& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringDefinitionTypeIec61360AsSequence(
  const types::ILangStringDefinitionTypeIec61360& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<langStringDefinitionTypeIec61360>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeLangStringDefinitionTypeIec61360AsElement(
  const types::ILangStringDefinitionTypeIec61360& that,
  SelfClosingWriter& writer
);

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeDataSpecificationIec61360AsSequence(
  const types::IDataSpecificationIec61360& that,
  SelfClosingWriter& writer
);

/**
 * Serialize \p that instance to an XML element
 * `<dataSpecificationIec61360>`.
 *
 * \param that instance to be serialized
 * \return an error, if any
 */
common::optional<SerializationError> SerializeDataSpecificationIec61360AsElement(
  const types::IDataSpecificationIec61360& that,
  SelfClosingWriter& writer
);

common::optional<SerializationError> SerializeHasSemanticsAsElement(
  const types::IHasSemantics& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kRelationshipElement:
      return SerializeRelationshipElementAsElement(
        dynamic_cast<
          const types::IRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return SerializeAnnotatedRelationshipElementAsElement(
        dynamic_cast<
          const types::IAnnotatedRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kBasicEventElement:
      return SerializeBasicEventElementAsElement(
        dynamic_cast<
          const types::IBasicEventElement&
        >(that),
        writer
      );
    case types::ModelType::kBlob:
      return SerializeBlobAsElement(
        dynamic_cast<
          const types::IBlob&
        >(that),
        writer
      );
    case types::ModelType::kCapability:
      return SerializeCapabilityAsElement(
        dynamic_cast<
          const types::ICapability&
        >(that),
        writer
      );
    case types::ModelType::kEntity:
      return SerializeEntityAsElement(
        dynamic_cast<
          const types::IEntity&
        >(that),
        writer
      );
    case types::ModelType::kExtension:
      return SerializeExtensionAsElement(
        dynamic_cast<
          const types::IExtension&
        >(that),
        writer
      );
    case types::ModelType::kFile:
      return SerializeFileAsElement(
        dynamic_cast<
          const types::IFile&
        >(that),
        writer
      );
    case types::ModelType::kMultiLanguageProperty:
      return SerializeMultiLanguagePropertyAsElement(
        dynamic_cast<
          const types::IMultiLanguageProperty&
        >(that),
        writer
      );
    case types::ModelType::kOperation:
      return SerializeOperationAsElement(
        dynamic_cast<
          const types::IOperation&
        >(that),
        writer
      );
    case types::ModelType::kProperty:
      return SerializePropertyAsElement(
        dynamic_cast<
          const types::IProperty&
        >(that),
        writer
      );
    case types::ModelType::kQualifier:
      return SerializeQualifierAsElement(
        dynamic_cast<
          const types::IQualifier&
        >(that),
        writer
      );
    case types::ModelType::kRange:
      return SerializeRangeAsElement(
        dynamic_cast<
          const types::IRange&
        >(that),
        writer
      );
    case types::ModelType::kReferenceElement:
      return SerializeReferenceElementAsElement(
        dynamic_cast<
          const types::IReferenceElement&
        >(that),
        writer
      );
    case types::ModelType::kSpecificAssetId:
      return SerializeSpecificAssetIdAsElement(
        dynamic_cast<
          const types::ISpecificAssetId&
        >(that),
        writer
      );
    case types::ModelType::kSubmodel:
      return SerializeSubmodelAsElement(
        dynamic_cast<
          const types::ISubmodel&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementCollection:
      return SerializeSubmodelElementCollectionAsElement(
        dynamic_cast<
          const types::ISubmodelElementCollection&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementList:
      return SerializeSubmodelElementListAsElement(
        dynamic_cast<
          const types::ISubmodelElementList&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeExtensionAsSequence(
  const types::IExtension& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const std::wstring& the_name(
    that.name()
  );
  writer.StartElement(
    "name"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_name
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kName
      )
    );

    return error;
  }
  writer.StopElement(
    "name"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kName
      )
    );

    return error;
  }

  const auto& maybe_value_type(
    that.value_type()
  );
  if (maybe_value_type.has_value()) {
    types::DataTypeDefXsd the_value_type(
      *maybe_value_type
    );
    writer.StartElement(
      "valueType"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeString(
      stringification::to_string(
        the_value_type
      )
    );
    if (writer.error()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueType
        )
      );

      return error;
    }
    writer.StopElement(
      "valueType"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueType
        )
      );

      return error;
    }
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::wstring& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_value
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  const auto& maybe_refers_to(
    that.refers_to()
  );
  if (maybe_refers_to.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_refers_to(
      *maybe_refers_to
    );
    writer.StartElement(
      "refersTo"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_refers_to.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_refers_to[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kRefersTo
        )
      );

      return error;
    }
    writer.StopElement(
      "refersTo"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kRefersTo
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeExtensionAsElement(
  const types::IExtension& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "extension"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeExtensionAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "extension"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeHasExtensionsAsElement(
  const types::IHasExtensions& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kRelationshipElement:
      return SerializeRelationshipElementAsElement(
        dynamic_cast<
          const types::IRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return SerializeAnnotatedRelationshipElementAsElement(
        dynamic_cast<
          const types::IAnnotatedRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAssetAdministrationShell:
      return SerializeAssetAdministrationShellAsElement(
        dynamic_cast<
          const types::IAssetAdministrationShell&
        >(that),
        writer
      );
    case types::ModelType::kBasicEventElement:
      return SerializeBasicEventElementAsElement(
        dynamic_cast<
          const types::IBasicEventElement&
        >(that),
        writer
      );
    case types::ModelType::kBlob:
      return SerializeBlobAsElement(
        dynamic_cast<
          const types::IBlob&
        >(that),
        writer
      );
    case types::ModelType::kCapability:
      return SerializeCapabilityAsElement(
        dynamic_cast<
          const types::ICapability&
        >(that),
        writer
      );
    case types::ModelType::kConceptDescription:
      return SerializeConceptDescriptionAsElement(
        dynamic_cast<
          const types::IConceptDescription&
        >(that),
        writer
      );
    case types::ModelType::kEntity:
      return SerializeEntityAsElement(
        dynamic_cast<
          const types::IEntity&
        >(that),
        writer
      );
    case types::ModelType::kFile:
      return SerializeFileAsElement(
        dynamic_cast<
          const types::IFile&
        >(that),
        writer
      );
    case types::ModelType::kMultiLanguageProperty:
      return SerializeMultiLanguagePropertyAsElement(
        dynamic_cast<
          const types::IMultiLanguageProperty&
        >(that),
        writer
      );
    case types::ModelType::kOperation:
      return SerializeOperationAsElement(
        dynamic_cast<
          const types::IOperation&
        >(that),
        writer
      );
    case types::ModelType::kProperty:
      return SerializePropertyAsElement(
        dynamic_cast<
          const types::IProperty&
        >(that),
        writer
      );
    case types::ModelType::kRange:
      return SerializeRangeAsElement(
        dynamic_cast<
          const types::IRange&
        >(that),
        writer
      );
    case types::ModelType::kReferenceElement:
      return SerializeReferenceElementAsElement(
        dynamic_cast<
          const types::IReferenceElement&
        >(that),
        writer
      );
    case types::ModelType::kSubmodel:
      return SerializeSubmodelAsElement(
        dynamic_cast<
          const types::ISubmodel&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementCollection:
      return SerializeSubmodelElementCollectionAsElement(
        dynamic_cast<
          const types::ISubmodelElementCollection&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementList:
      return SerializeSubmodelElementListAsElement(
        dynamic_cast<
          const types::ISubmodelElementList&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

common::optional<SerializationError> SerializeReferableAsElement(
  const types::IReferable& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kRelationshipElement:
      return SerializeRelationshipElementAsElement(
        dynamic_cast<
          const types::IRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return SerializeAnnotatedRelationshipElementAsElement(
        dynamic_cast<
          const types::IAnnotatedRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAssetAdministrationShell:
      return SerializeAssetAdministrationShellAsElement(
        dynamic_cast<
          const types::IAssetAdministrationShell&
        >(that),
        writer
      );
    case types::ModelType::kBasicEventElement:
      return SerializeBasicEventElementAsElement(
        dynamic_cast<
          const types::IBasicEventElement&
        >(that),
        writer
      );
    case types::ModelType::kBlob:
      return SerializeBlobAsElement(
        dynamic_cast<
          const types::IBlob&
        >(that),
        writer
      );
    case types::ModelType::kCapability:
      return SerializeCapabilityAsElement(
        dynamic_cast<
          const types::ICapability&
        >(that),
        writer
      );
    case types::ModelType::kConceptDescription:
      return SerializeConceptDescriptionAsElement(
        dynamic_cast<
          const types::IConceptDescription&
        >(that),
        writer
      );
    case types::ModelType::kEntity:
      return SerializeEntityAsElement(
        dynamic_cast<
          const types::IEntity&
        >(that),
        writer
      );
    case types::ModelType::kFile:
      return SerializeFileAsElement(
        dynamic_cast<
          const types::IFile&
        >(that),
        writer
      );
    case types::ModelType::kMultiLanguageProperty:
      return SerializeMultiLanguagePropertyAsElement(
        dynamic_cast<
          const types::IMultiLanguageProperty&
        >(that),
        writer
      );
    case types::ModelType::kOperation:
      return SerializeOperationAsElement(
        dynamic_cast<
          const types::IOperation&
        >(that),
        writer
      );
    case types::ModelType::kProperty:
      return SerializePropertyAsElement(
        dynamic_cast<
          const types::IProperty&
        >(that),
        writer
      );
    case types::ModelType::kRange:
      return SerializeRangeAsElement(
        dynamic_cast<
          const types::IRange&
        >(that),
        writer
      );
    case types::ModelType::kReferenceElement:
      return SerializeReferenceElementAsElement(
        dynamic_cast<
          const types::IReferenceElement&
        >(that),
        writer
      );
    case types::ModelType::kSubmodel:
      return SerializeSubmodelAsElement(
        dynamic_cast<
          const types::ISubmodel&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementCollection:
      return SerializeSubmodelElementCollectionAsElement(
        dynamic_cast<
          const types::ISubmodelElementCollection&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementList:
      return SerializeSubmodelElementListAsElement(
        dynamic_cast<
          const types::ISubmodelElementList&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

common::optional<SerializationError> SerializeIdentifiableAsElement(
  const types::IIdentifiable& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kAssetAdministrationShell:
      return SerializeAssetAdministrationShellAsElement(
        dynamic_cast<
          const types::IAssetAdministrationShell&
        >(that),
        writer
      );
    case types::ModelType::kConceptDescription:
      return SerializeConceptDescriptionAsElement(
        dynamic_cast<
          const types::IConceptDescription&
        >(that),
        writer
      );
    case types::ModelType::kSubmodel:
      return SerializeSubmodelAsElement(
        dynamic_cast<
          const types::ISubmodel&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

common::optional<SerializationError> SerializeHasKindAsElement(
  const types::IHasKind& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kSubmodel:
      return SerializeSubmodelAsElement(
        dynamic_cast<
          const types::ISubmodel&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

common::optional<SerializationError> SerializeHasDataSpecificationAsElement(
  const types::IHasDataSpecification& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kAdministrativeInformation:
      return SerializeAdministrativeInformationAsElement(
        dynamic_cast<
          const types::IAdministrativeInformation&
        >(that),
        writer
      );
    case types::ModelType::kRelationshipElement:
      return SerializeRelationshipElementAsElement(
        dynamic_cast<
          const types::IRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return SerializeAnnotatedRelationshipElementAsElement(
        dynamic_cast<
          const types::IAnnotatedRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAssetAdministrationShell:
      return SerializeAssetAdministrationShellAsElement(
        dynamic_cast<
          const types::IAssetAdministrationShell&
        >(that),
        writer
      );
    case types::ModelType::kBasicEventElement:
      return SerializeBasicEventElementAsElement(
        dynamic_cast<
          const types::IBasicEventElement&
        >(that),
        writer
      );
    case types::ModelType::kBlob:
      return SerializeBlobAsElement(
        dynamic_cast<
          const types::IBlob&
        >(that),
        writer
      );
    case types::ModelType::kCapability:
      return SerializeCapabilityAsElement(
        dynamic_cast<
          const types::ICapability&
        >(that),
        writer
      );
    case types::ModelType::kConceptDescription:
      return SerializeConceptDescriptionAsElement(
        dynamic_cast<
          const types::IConceptDescription&
        >(that),
        writer
      );
    case types::ModelType::kEntity:
      return SerializeEntityAsElement(
        dynamic_cast<
          const types::IEntity&
        >(that),
        writer
      );
    case types::ModelType::kFile:
      return SerializeFileAsElement(
        dynamic_cast<
          const types::IFile&
        >(that),
        writer
      );
    case types::ModelType::kMultiLanguageProperty:
      return SerializeMultiLanguagePropertyAsElement(
        dynamic_cast<
          const types::IMultiLanguageProperty&
        >(that),
        writer
      );
    case types::ModelType::kOperation:
      return SerializeOperationAsElement(
        dynamic_cast<
          const types::IOperation&
        >(that),
        writer
      );
    case types::ModelType::kProperty:
      return SerializePropertyAsElement(
        dynamic_cast<
          const types::IProperty&
        >(that),
        writer
      );
    case types::ModelType::kRange:
      return SerializeRangeAsElement(
        dynamic_cast<
          const types::IRange&
        >(that),
        writer
      );
    case types::ModelType::kReferenceElement:
      return SerializeReferenceElementAsElement(
        dynamic_cast<
          const types::IReferenceElement&
        >(that),
        writer
      );
    case types::ModelType::kSubmodel:
      return SerializeSubmodelAsElement(
        dynamic_cast<
          const types::ISubmodel&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementCollection:
      return SerializeSubmodelElementCollectionAsElement(
        dynamic_cast<
          const types::ISubmodelElementCollection&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementList:
      return SerializeSubmodelElementListAsElement(
        dynamic_cast<
          const types::ISubmodelElementList&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAdministrativeInformationAsSequence(
  const types::IAdministrativeInformation& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_version(
    that.version()
  );
  if (maybe_version.has_value()) {
    const std::wstring& the_version(
      *maybe_version
    );
    writer.StartElement(
      "version"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_version
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kVersion
        )
      );

      return error;
    }
    writer.StopElement(
      "version"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kVersion
        )
      );

      return error;
    }
  }

  const auto& maybe_revision(
    that.revision()
  );
  if (maybe_revision.has_value()) {
    const std::wstring& the_revision(
      *maybe_revision
    );
    writer.StartElement(
      "revision"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_revision
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kRevision
        )
      );

      return error;
    }
    writer.StopElement(
      "revision"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kRevision
        )
      );

      return error;
    }
  }

  const auto& maybe_creator(
    that.creator()
  );
  if (maybe_creator.has_value()) {
    const std::shared_ptr<types::IReference>& the_creator(
      *maybe_creator
    );
    writer.StartElement(
      "creator"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_creator,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCreator
        )
      );

      return error;
    }
    writer.StopElement(
      "creator"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCreator
        )
      );

      return error;
    }
  }

  const auto& maybe_template_id(
    that.template_id()
  );
  if (maybe_template_id.has_value()) {
    const std::wstring& the_template_id(
      *maybe_template_id
    );
    writer.StartElement(
      "templateId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_template_id
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kTemplateId
        )
      );

      return error;
    }
    writer.StopElement(
      "templateId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kTemplateId
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeAdministrativeInformationAsElement(
  const types::IAdministrativeInformation& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "administrativeInformation"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeAdministrativeInformationAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "administrativeInformation"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeQualifiableAsElement(
  const types::IQualifiable& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kRelationshipElement:
      return SerializeRelationshipElementAsElement(
        dynamic_cast<
          const types::IRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return SerializeAnnotatedRelationshipElementAsElement(
        dynamic_cast<
          const types::IAnnotatedRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kBasicEventElement:
      return SerializeBasicEventElementAsElement(
        dynamic_cast<
          const types::IBasicEventElement&
        >(that),
        writer
      );
    case types::ModelType::kBlob:
      return SerializeBlobAsElement(
        dynamic_cast<
          const types::IBlob&
        >(that),
        writer
      );
    case types::ModelType::kCapability:
      return SerializeCapabilityAsElement(
        dynamic_cast<
          const types::ICapability&
        >(that),
        writer
      );
    case types::ModelType::kEntity:
      return SerializeEntityAsElement(
        dynamic_cast<
          const types::IEntity&
        >(that),
        writer
      );
    case types::ModelType::kFile:
      return SerializeFileAsElement(
        dynamic_cast<
          const types::IFile&
        >(that),
        writer
      );
    case types::ModelType::kMultiLanguageProperty:
      return SerializeMultiLanguagePropertyAsElement(
        dynamic_cast<
          const types::IMultiLanguageProperty&
        >(that),
        writer
      );
    case types::ModelType::kOperation:
      return SerializeOperationAsElement(
        dynamic_cast<
          const types::IOperation&
        >(that),
        writer
      );
    case types::ModelType::kProperty:
      return SerializePropertyAsElement(
        dynamic_cast<
          const types::IProperty&
        >(that),
        writer
      );
    case types::ModelType::kRange:
      return SerializeRangeAsElement(
        dynamic_cast<
          const types::IRange&
        >(that),
        writer
      );
    case types::ModelType::kReferenceElement:
      return SerializeReferenceElementAsElement(
        dynamic_cast<
          const types::IReferenceElement&
        >(that),
        writer
      );
    case types::ModelType::kSubmodel:
      return SerializeSubmodelAsElement(
        dynamic_cast<
          const types::ISubmodel&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementCollection:
      return SerializeSubmodelElementCollectionAsElement(
        dynamic_cast<
          const types::ISubmodelElementCollection&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementList:
      return SerializeSubmodelElementListAsElement(
        dynamic_cast<
          const types::ISubmodelElementList&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeQualifierAsSequence(
  const types::IQualifier& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_kind(
    that.kind()
  );
  if (maybe_kind.has_value()) {
    types::QualifierKind the_kind(
      *maybe_kind
    );
    writer.StartElement(
      "kind"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeString(
      stringification::to_string(
        the_kind
      )
    );
    if (writer.error()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kKind
        )
      );

      return error;
    }
    writer.StopElement(
      "kind"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kKind
        )
      );

      return error;
    }
  }

  const std::wstring& the_type(
    that.type()
  );
  writer.StartElement(
    "type"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_type
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kType
      )
    );

    return error;
  }
  writer.StopElement(
    "type"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kType
      )
    );

    return error;
  }

  types::DataTypeDefXsd the_value_type(
    that.value_type()
  );
  writer.StartElement(
    "valueType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_value_type
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueType
      )
    );

    return error;
  }
  writer.StopElement(
    "valueType"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueType
      )
    );

    return error;
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::wstring& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_value
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  const auto& maybe_value_id(
    that.value_id()
  );
  if (maybe_value_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_value_id(
      *maybe_value_id
    );
    writer.StartElement(
      "valueId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_value_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return error;
    }
    writer.StopElement(
      "valueId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeQualifierAsElement(
  const types::IQualifier& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "qualifier"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeQualifierAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "qualifier"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAssetAdministrationShellAsSequence(
  const types::IAssetAdministrationShell& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_administration(
    that.administration()
  );
  if (maybe_administration.has_value()) {
    const std::shared_ptr<types::IAdministrativeInformation>& the_administration(
      *maybe_administration
    );
    writer.StartElement(
      "administration"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeAdministrativeInformationAsSequence(
      *the_administration,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return error;
    }
    writer.StopElement(
      "administration"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return error;
    }
  }

  const std::wstring& the_id(
    that.id()
  );
  writer.StartElement(
    "id"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_id
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kId
      )
    );

    return error;
  }
  writer.StopElement(
    "id"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kId
      )
    );

    return error;
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_derived_from(
    that.derived_from()
  );
  if (maybe_derived_from.has_value()) {
    const std::shared_ptr<types::IReference>& the_derived_from(
      *maybe_derived_from
    );
    writer.StartElement(
      "derivedFrom"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_derived_from,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDerivedFrom
        )
      );

      return error;
    }
    writer.StopElement(
      "derivedFrom"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDerivedFrom
        )
      );

      return error;
    }
  }

  const std::shared_ptr<types::IAssetInformation>& the_asset_information(
    that.asset_information()
  );
  writer.StartElement(
    "assetInformation"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeAssetInformationAsSequence(
    *the_asset_information,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kAssetInformation
      )
    );

    return error;
  }
  writer.StopElement(
    "assetInformation"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kAssetInformation
      )
    );

    return error;
  }

  const auto& maybe_submodels(
    that.submodels()
  );
  if (maybe_submodels.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_submodels(
      *maybe_submodels
    );
    writer.StartElement(
      "submodels"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_submodels.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_submodels[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubmodels
        )
      );

      return error;
    }
    writer.StopElement(
      "submodels"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubmodels
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeAssetAdministrationShellAsElement(
  const types::IAssetAdministrationShell& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "assetAdministrationShell"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeAssetAdministrationShellAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "assetAdministrationShell"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAssetInformationAsSequence(
  const types::IAssetInformation& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  types::AssetKind the_asset_kind(
    that.asset_kind()
  );
  writer.StartElement(
    "assetKind"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_asset_kind
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kAssetKind
      )
    );

    return error;
  }
  writer.StopElement(
    "assetKind"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kAssetKind
      )
    );

    return error;
  }

  const auto& maybe_global_asset_id(
    that.global_asset_id()
  );
  if (maybe_global_asset_id.has_value()) {
    const std::wstring& the_global_asset_id(
      *maybe_global_asset_id
    );
    writer.StartElement(
      "globalAssetId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_global_asset_id
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kGlobalAssetId
        )
      );

      return error;
    }
    writer.StopElement(
      "globalAssetId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kGlobalAssetId
        )
      );

      return error;
    }
  }

  const auto& maybe_specific_asset_ids(
    that.specific_asset_ids()
  );
  if (maybe_specific_asset_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >& the_specific_asset_ids(
      *maybe_specific_asset_ids
    );
    writer.StartElement(
      "specificAssetIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_specific_asset_ids.size(); ++i) {
      const std::shared_ptr<types::ISpecificAssetId>& item(
        the_specific_asset_ids[i]
      );

      error = SerializeSpecificAssetIdAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSpecificAssetIds
        )
      );

      return error;
    }
    writer.StopElement(
      "specificAssetIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSpecificAssetIds
        )
      );

      return error;
    }
  }

  const auto& maybe_asset_type(
    that.asset_type()
  );
  if (maybe_asset_type.has_value()) {
    const std::wstring& the_asset_type(
      *maybe_asset_type
    );
    writer.StartElement(
      "assetType"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_asset_type
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAssetType
        )
      );

      return error;
    }
    writer.StopElement(
      "assetType"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAssetType
        )
      );

      return error;
    }
  }

  const auto& maybe_default_thumbnail(
    that.default_thumbnail()
  );
  if (maybe_default_thumbnail.has_value()) {
    const std::shared_ptr<types::IResource>& the_default_thumbnail(
      *maybe_default_thumbnail
    );
    writer.StartElement(
      "defaultThumbnail"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeResourceAsSequence(
      *the_default_thumbnail,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDefaultThumbnail
        )
      );

      return error;
    }
    writer.StopElement(
      "defaultThumbnail"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDefaultThumbnail
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeAssetInformationAsElement(
  const types::IAssetInformation& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "assetInformation"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeAssetInformationAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "assetInformation"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeResourceAsSequence(
  const types::IResource& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::wstring& the_path(
    that.path()
  );
  writer.StartElement(
    "path"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_path
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kPath
      )
    );

    return error;
  }
  writer.StopElement(
    "path"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kPath
      )
    );

    return error;
  }

  const auto& maybe_content_type(
    that.content_type()
  );
  if (maybe_content_type.has_value()) {
    const std::wstring& the_content_type(
      *maybe_content_type
    );
    writer.StartElement(
      "contentType"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_content_type
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kContentType
        )
      );

      return error;
    }
    writer.StopElement(
      "contentType"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kContentType
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeResourceAsElement(
  const types::IResource& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "resource"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeResourceAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "resource"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSpecificAssetIdAsSequence(
  const types::ISpecificAssetId& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const std::wstring& the_name(
    that.name()
  );
  writer.StartElement(
    "name"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_name
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kName
      )
    );

    return error;
  }
  writer.StopElement(
    "name"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kName
      )
    );

    return error;
  }

  const std::wstring& the_value(
    that.value()
  );
  writer.StartElement(
    "value"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_value
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return error;
  }
  writer.StopElement(
    "value"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return error;
  }

  const auto& maybe_external_subject_id(
    that.external_subject_id()
  );
  if (maybe_external_subject_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_external_subject_id(
      *maybe_external_subject_id
    );
    writer.StartElement(
      "externalSubjectId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_external_subject_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExternalSubjectId
        )
      );

      return error;
    }
    writer.StopElement(
      "externalSubjectId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExternalSubjectId
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeSpecificAssetIdAsElement(
  const types::ISpecificAssetId& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "specificAssetId"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeSpecificAssetIdAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "specificAssetId"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSubmodelAsSequence(
  const types::ISubmodel& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_administration(
    that.administration()
  );
  if (maybe_administration.has_value()) {
    const std::shared_ptr<types::IAdministrativeInformation>& the_administration(
      *maybe_administration
    );
    writer.StartElement(
      "administration"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeAdministrativeInformationAsSequence(
      *the_administration,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return error;
    }
    writer.StopElement(
      "administration"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return error;
    }
  }

  const std::wstring& the_id(
    that.id()
  );
  writer.StartElement(
    "id"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_id
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kId
      )
    );

    return error;
  }
  writer.StopElement(
    "id"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kId
      )
    );

    return error;
  }

  const auto& maybe_kind(
    that.kind()
  );
  if (maybe_kind.has_value()) {
    types::ModellingKind the_kind(
      *maybe_kind
    );
    writer.StartElement(
      "kind"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeString(
      stringification::to_string(
        the_kind
      )
    );
    if (writer.error()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kKind
        )
      );

      return error;
    }
    writer.StopElement(
      "kind"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kKind
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_submodel_elements(
    that.submodel_elements()
  );
  if (maybe_submodel_elements.has_value()) {
    const std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >& the_submodel_elements(
      *maybe_submodel_elements
    );
    writer.StartElement(
      "submodelElements"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_submodel_elements.size(); ++i) {
      const std::shared_ptr<types::ISubmodelElement>& item(
        the_submodel_elements[i]
      );

      error = SerializeSubmodelElementAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubmodelElements
        )
      );

      return error;
    }
    writer.StopElement(
      "submodelElements"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubmodelElements
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeSubmodelAsElement(
  const types::ISubmodel& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "submodel"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeSubmodelAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "submodel"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeSubmodelElementAsElement(
  const types::ISubmodelElement& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kRelationshipElement:
      return SerializeRelationshipElementAsElement(
        dynamic_cast<
          const types::IRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return SerializeAnnotatedRelationshipElementAsElement(
        dynamic_cast<
          const types::IAnnotatedRelationshipElement&
        >(that),
        writer
      );
    case types::ModelType::kBasicEventElement:
      return SerializeBasicEventElementAsElement(
        dynamic_cast<
          const types::IBasicEventElement&
        >(that),
        writer
      );
    case types::ModelType::kBlob:
      return SerializeBlobAsElement(
        dynamic_cast<
          const types::IBlob&
        >(that),
        writer
      );
    case types::ModelType::kCapability:
      return SerializeCapabilityAsElement(
        dynamic_cast<
          const types::ICapability&
        >(that),
        writer
      );
    case types::ModelType::kEntity:
      return SerializeEntityAsElement(
        dynamic_cast<
          const types::IEntity&
        >(that),
        writer
      );
    case types::ModelType::kFile:
      return SerializeFileAsElement(
        dynamic_cast<
          const types::IFile&
        >(that),
        writer
      );
    case types::ModelType::kMultiLanguageProperty:
      return SerializeMultiLanguagePropertyAsElement(
        dynamic_cast<
          const types::IMultiLanguageProperty&
        >(that),
        writer
      );
    case types::ModelType::kOperation:
      return SerializeOperationAsElement(
        dynamic_cast<
          const types::IOperation&
        >(that),
        writer
      );
    case types::ModelType::kProperty:
      return SerializePropertyAsElement(
        dynamic_cast<
          const types::IProperty&
        >(that),
        writer
      );
    case types::ModelType::kRange:
      return SerializeRangeAsElement(
        dynamic_cast<
          const types::IRange&
        >(that),
        writer
      );
    case types::ModelType::kReferenceElement:
      return SerializeReferenceElementAsElement(
        dynamic_cast<
          const types::IReferenceElement&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementCollection:
      return SerializeSubmodelElementCollectionAsElement(
        dynamic_cast<
          const types::ISubmodelElementCollection&
        >(that),
        writer
      );
    case types::ModelType::kSubmodelElementList:
      return SerializeSubmodelElementListAsElement(
        dynamic_cast<
          const types::ISubmodelElementList&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeRelationshipElementAsSequence(
  const types::IRelationshipElement& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const std::shared_ptr<types::IReference>& the_first(
    that.first()
  );
  writer.StartElement(
    "first"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_first,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kFirst
      )
    );

    return error;
  }
  writer.StopElement(
    "first"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kFirst
      )
    );

    return error;
  }

  const std::shared_ptr<types::IReference>& the_second(
    that.second()
  );
  writer.StartElement(
    "second"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_second,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSecond
      )
    );

    return error;
  }
  writer.StopElement(
    "second"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSecond
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * Serialize \p that instance to an XML element
 * `<relationshipElement>`.
 *
 * No dispatch is performed in this function. It is expected that you call
 * \ref SerializeRelationshipElementAsElement, which will then dispatch into this function.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return an error, if any
 */
common::optional<SerializationError> SerializeConcreteRelationshipElementAsElement(
  const types::IRelationshipElement& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "relationshipElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeRelationshipElementAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "relationshipElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeRelationshipElementAsElement(
  const types::IRelationshipElement& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kRelationshipElement:
      return SerializeConcreteRelationshipElementAsElement(
        that,
        writer
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return SerializeAnnotatedRelationshipElementAsElement(
        dynamic_cast<
          const types::IAnnotatedRelationshipElement&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSubmodelElementListAsSequence(
  const types::ISubmodelElementList& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_order_relevant(
    that.order_relevant()
  );
  if (maybe_order_relevant.has_value()) {
    bool the_order_relevant(
      *maybe_order_relevant
    );
    writer.StartElement(
      "orderRelevant"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeBool(
      the_order_relevant
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kOrderRelevant
        )
      );

      return error;
    }
    writer.StopElement(
      "orderRelevant"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kOrderRelevant
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id_list_element(
    that.semantic_id_list_element()
  );
  if (maybe_semantic_id_list_element.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id_list_element(
      *maybe_semantic_id_list_element
    );
    writer.StartElement(
      "semanticIdListElement"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id_list_element,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticIdListElement
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticIdListElement"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticIdListElement
        )
      );

      return error;
    }
  }

  types::AasSubmodelElements the_type_value_list_element(
    that.type_value_list_element()
  );
  writer.StartElement(
    "typeValueListElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_type_value_list_element
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kTypeValueListElement
      )
    );

    return error;
  }
  writer.StopElement(
    "typeValueListElement"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kTypeValueListElement
      )
    );

    return error;
  }

  const auto& maybe_value_type_list_element(
    that.value_type_list_element()
  );
  if (maybe_value_type_list_element.has_value()) {
    types::DataTypeDefXsd the_value_type_list_element(
      *maybe_value_type_list_element
    );
    writer.StartElement(
      "valueTypeListElement"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeString(
      stringification::to_string(
        the_value_type_list_element
      )
    );
    if (writer.error()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueTypeListElement
        )
      );

      return error;
    }
    writer.StopElement(
      "valueTypeListElement"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueTypeListElement
        )
      );

      return error;
    }
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_value.size(); ++i) {
      const std::shared_ptr<types::ISubmodelElement>& item(
        the_value[i]
      );

      error = SerializeSubmodelElementAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeSubmodelElementListAsElement(
  const types::ISubmodelElementList& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "submodelElementList"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeSubmodelElementListAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "submodelElementList"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeSubmodelElementCollectionAsSequence(
  const types::ISubmodelElementCollection& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_value.size(); ++i) {
      const std::shared_ptr<types::ISubmodelElement>& item(
        the_value[i]
      );

      error = SerializeSubmodelElementAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeSubmodelElementCollectionAsElement(
  const types::ISubmodelElementCollection& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "submodelElementCollection"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeSubmodelElementCollectionAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "submodelElementCollection"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeDataElementAsElement(
  const types::IDataElement& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kBlob:
      return SerializeBlobAsElement(
        dynamic_cast<
          const types::IBlob&
        >(that),
        writer
      );
    case types::ModelType::kFile:
      return SerializeFileAsElement(
        dynamic_cast<
          const types::IFile&
        >(that),
        writer
      );
    case types::ModelType::kMultiLanguageProperty:
      return SerializeMultiLanguagePropertyAsElement(
        dynamic_cast<
          const types::IMultiLanguageProperty&
        >(that),
        writer
      );
    case types::ModelType::kProperty:
      return SerializePropertyAsElement(
        dynamic_cast<
          const types::IProperty&
        >(that),
        writer
      );
    case types::ModelType::kRange:
      return SerializeRangeAsElement(
        dynamic_cast<
          const types::IRange&
        >(that),
        writer
      );
    case types::ModelType::kReferenceElement:
      return SerializeReferenceElementAsElement(
        dynamic_cast<
          const types::IReferenceElement&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializePropertyAsSequence(
  const types::IProperty& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  types::DataTypeDefXsd the_value_type(
    that.value_type()
  );
  writer.StartElement(
    "valueType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_value_type
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueType
      )
    );

    return error;
  }
  writer.StopElement(
    "valueType"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueType
      )
    );

    return error;
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::wstring& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_value
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  const auto& maybe_value_id(
    that.value_id()
  );
  if (maybe_value_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_value_id(
      *maybe_value_id
    );
    writer.StartElement(
      "valueId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_value_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return error;
    }
    writer.StopElement(
      "valueId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializePropertyAsElement(
  const types::IProperty& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "property"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializePropertyAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "property"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeMultiLanguagePropertyAsSequence(
  const types::IMultiLanguageProperty& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_value.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_value[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  const auto& maybe_value_id(
    that.value_id()
  );
  if (maybe_value_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_value_id(
      *maybe_value_id
    );
    writer.StartElement(
      "valueId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_value_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return error;
    }
    writer.StopElement(
      "valueId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeMultiLanguagePropertyAsElement(
  const types::IMultiLanguageProperty& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "multiLanguageProperty"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeMultiLanguagePropertyAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "multiLanguageProperty"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeRangeAsSequence(
  const types::IRange& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  types::DataTypeDefXsd the_value_type(
    that.value_type()
  );
  writer.StartElement(
    "valueType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_value_type
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueType
      )
    );

    return error;
  }
  writer.StopElement(
    "valueType"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueType
      )
    );

    return error;
  }

  const auto& maybe_min(
    that.min()
  );
  if (maybe_min.has_value()) {
    const std::wstring& the_min(
      *maybe_min
    );
    writer.StartElement(
      "min"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_min
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMin
        )
      );

      return error;
    }
    writer.StopElement(
      "min"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMin
        )
      );

      return error;
    }
  }

  const auto& maybe_max(
    that.max()
  );
  if (maybe_max.has_value()) {
    const std::wstring& the_max(
      *maybe_max
    );
    writer.StartElement(
      "max"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_max
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMax
        )
      );

      return error;
    }
    writer.StopElement(
      "max"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMax
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeRangeAsElement(
  const types::IRange& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "range"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeRangeAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "range"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeReferenceElementAsSequence(
  const types::IReferenceElement& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::shared_ptr<types::IReference>& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_value,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeReferenceElementAsElement(
  const types::IReferenceElement& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "referenceElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeReferenceElementAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "referenceElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeBlobAsSequence(
  const types::IBlob& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::vector<std::uint8_t>& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeByteArray(
      the_value
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  const std::wstring& the_content_type(
    that.content_type()
  );
  writer.StartElement(
    "contentType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_content_type
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kContentType
      )
    );

    return error;
  }
  writer.StopElement(
    "contentType"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kContentType
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeBlobAsElement(
  const types::IBlob& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "blob"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeBlobAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "blob"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeFileAsSequence(
  const types::IFile& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::wstring& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_value
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  const std::wstring& the_content_type(
    that.content_type()
  );
  writer.StartElement(
    "contentType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_content_type
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kContentType
      )
    );

    return error;
  }
  writer.StopElement(
    "contentType"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kContentType
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeFileAsElement(
  const types::IFile& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "file"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeFileAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "file"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeAnnotatedRelationshipElementAsSequence(
  const types::IAnnotatedRelationshipElement& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const std::shared_ptr<types::IReference>& the_first(
    that.first()
  );
  writer.StartElement(
    "first"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_first,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kFirst
      )
    );

    return error;
  }
  writer.StopElement(
    "first"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kFirst
      )
    );

    return error;
  }

  const std::shared_ptr<types::IReference>& the_second(
    that.second()
  );
  writer.StartElement(
    "second"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_second,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSecond
      )
    );

    return error;
  }
  writer.StopElement(
    "second"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSecond
      )
    );

    return error;
  }

  const auto& maybe_annotations(
    that.annotations()
  );
  if (maybe_annotations.has_value()) {
    const std::vector<
      std::shared_ptr<types::IDataElement>
    >& the_annotations(
      *maybe_annotations
    );
    writer.StartElement(
      "annotations"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_annotations.size(); ++i) {
      const std::shared_ptr<types::IDataElement>& item(
        the_annotations[i]
      );

      error = SerializeDataElementAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAnnotations
        )
      );

      return error;
    }
    writer.StopElement(
      "annotations"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAnnotations
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeAnnotatedRelationshipElementAsElement(
  const types::IAnnotatedRelationshipElement& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "annotatedRelationshipElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeAnnotatedRelationshipElementAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "annotatedRelationshipElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEntityAsSequence(
  const types::IEntity& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_statements(
    that.statements()
  );
  if (maybe_statements.has_value()) {
    const std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >& the_statements(
      *maybe_statements
    );
    writer.StartElement(
      "statements"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_statements.size(); ++i) {
      const std::shared_ptr<types::ISubmodelElement>& item(
        the_statements[i]
      );

      error = SerializeSubmodelElementAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kStatements
        )
      );

      return error;
    }
    writer.StopElement(
      "statements"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kStatements
        )
      );

      return error;
    }
  }

  types::EntityType the_entity_type(
    that.entity_type()
  );
  writer.StartElement(
    "entityType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_entity_type
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kEntityType
      )
    );

    return error;
  }
  writer.StopElement(
    "entityType"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kEntityType
      )
    );

    return error;
  }

  const auto& maybe_global_asset_id(
    that.global_asset_id()
  );
  if (maybe_global_asset_id.has_value()) {
    const std::wstring& the_global_asset_id(
      *maybe_global_asset_id
    );
    writer.StartElement(
      "globalAssetId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_global_asset_id
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kGlobalAssetId
        )
      );

      return error;
    }
    writer.StopElement(
      "globalAssetId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kGlobalAssetId
        )
      );

      return error;
    }
  }

  const auto& maybe_specific_asset_ids(
    that.specific_asset_ids()
  );
  if (maybe_specific_asset_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >& the_specific_asset_ids(
      *maybe_specific_asset_ids
    );
    writer.StartElement(
      "specificAssetIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_specific_asset_ids.size(); ++i) {
      const std::shared_ptr<types::ISpecificAssetId>& item(
        the_specific_asset_ids[i]
      );

      error = SerializeSpecificAssetIdAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSpecificAssetIds
        )
      );

      return error;
    }
    writer.StopElement(
      "specificAssetIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSpecificAssetIds
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeEntityAsElement(
  const types::IEntity& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "entity"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeEntityAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "entity"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEventPayloadAsSequence(
  const types::IEventPayload& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::shared_ptr<types::IReference>& the_source(
    that.source()
  );
  writer.StartElement(
    "source"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_source,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSource
      )
    );

    return error;
  }
  writer.StopElement(
    "source"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSource
      )
    );

    return error;
  }

  const auto& maybe_source_semantic_id(
    that.source_semantic_id()
  );
  if (maybe_source_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_source_semantic_id(
      *maybe_source_semantic_id
    );
    writer.StartElement(
      "sourceSemanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_source_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSourceSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "sourceSemanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSourceSemanticId
        )
      );

      return error;
    }
  }

  const std::shared_ptr<types::IReference>& the_observable_reference(
    that.observable_reference()
  );
  writer.StartElement(
    "observableReference"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_observable_reference,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kObservableReference
      )
    );

    return error;
  }
  writer.StopElement(
    "observableReference"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kObservableReference
      )
    );

    return error;
  }

  const auto& maybe_observable_semantic_id(
    that.observable_semantic_id()
  );
  if (maybe_observable_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_observable_semantic_id(
      *maybe_observable_semantic_id
    );
    writer.StartElement(
      "observableSemanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_observable_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kObservableSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "observableSemanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kObservableSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_topic(
    that.topic()
  );
  if (maybe_topic.has_value()) {
    const std::wstring& the_topic(
      *maybe_topic
    );
    writer.StartElement(
      "topic"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_topic
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kTopic
        )
      );

      return error;
    }
    writer.StopElement(
      "topic"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kTopic
        )
      );

      return error;
    }
  }

  const auto& maybe_subject_id(
    that.subject_id()
  );
  if (maybe_subject_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_subject_id(
      *maybe_subject_id
    );
    writer.StartElement(
      "subjectId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_subject_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubjectId
        )
      );

      return error;
    }
    writer.StopElement(
      "subjectId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubjectId
        )
      );

      return error;
    }
  }

  const std::wstring& the_time_stamp(
    that.time_stamp()
  );
  writer.StartElement(
    "timeStamp"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_time_stamp
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kTimeStamp
      )
    );

    return error;
  }
  writer.StopElement(
    "timeStamp"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kTimeStamp
      )
    );

    return error;
  }

  const auto& maybe_payload(
    that.payload()
  );
  if (maybe_payload.has_value()) {
    const std::vector<std::uint8_t>& the_payload(
      *maybe_payload
    );
    writer.StartElement(
      "payload"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeByteArray(
      the_payload
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kPayload
        )
      );

      return error;
    }
    writer.StopElement(
      "payload"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kPayload
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeEventPayloadAsElement(
  const types::IEventPayload& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "eventPayload"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeEventPayloadAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "eventPayload"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeEventElementAsElement(
  const types::IEventElement& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kBasicEventElement:
      return SerializeBasicEventElementAsElement(
        dynamic_cast<
          const types::IBasicEventElement&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeBasicEventElementAsSequence(
  const types::IBasicEventElement& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const std::shared_ptr<types::IReference>& the_observed(
    that.observed()
  );
  writer.StartElement(
    "observed"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_observed,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kObserved
      )
    );

    return error;
  }
  writer.StopElement(
    "observed"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kObserved
      )
    );

    return error;
  }

  types::Direction the_direction(
    that.direction()
  );
  writer.StartElement(
    "direction"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_direction
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kDirection
      )
    );

    return error;
  }
  writer.StopElement(
    "direction"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kDirection
      )
    );

    return error;
  }

  types::StateOfEvent the_state(
    that.state()
  );
  writer.StartElement(
    "state"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_state
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kState
      )
    );

    return error;
  }
  writer.StopElement(
    "state"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kState
      )
    );

    return error;
  }

  const auto& maybe_message_topic(
    that.message_topic()
  );
  if (maybe_message_topic.has_value()) {
    const std::wstring& the_message_topic(
      *maybe_message_topic
    );
    writer.StartElement(
      "messageTopic"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_message_topic
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMessageTopic
        )
      );

      return error;
    }
    writer.StopElement(
      "messageTopic"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMessageTopic
        )
      );

      return error;
    }
  }

  const auto& maybe_message_broker(
    that.message_broker()
  );
  if (maybe_message_broker.has_value()) {
    const std::shared_ptr<types::IReference>& the_message_broker(
      *maybe_message_broker
    );
    writer.StartElement(
      "messageBroker"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_message_broker,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMessageBroker
        )
      );

      return error;
    }
    writer.StopElement(
      "messageBroker"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMessageBroker
        )
      );

      return error;
    }
  }

  const auto& maybe_last_update(
    that.last_update()
  );
  if (maybe_last_update.has_value()) {
    const std::wstring& the_last_update(
      *maybe_last_update
    );
    writer.StartElement(
      "lastUpdate"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_last_update
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kLastUpdate
        )
      );

      return error;
    }
    writer.StopElement(
      "lastUpdate"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kLastUpdate
        )
      );

      return error;
    }
  }

  const auto& maybe_min_interval(
    that.min_interval()
  );
  if (maybe_min_interval.has_value()) {
    const std::wstring& the_min_interval(
      *maybe_min_interval
    );
    writer.StartElement(
      "minInterval"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_min_interval
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMinInterval
        )
      );

      return error;
    }
    writer.StopElement(
      "minInterval"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMinInterval
        )
      );

      return error;
    }
  }

  const auto& maybe_max_interval(
    that.max_interval()
  );
  if (maybe_max_interval.has_value()) {
    const std::wstring& the_max_interval(
      *maybe_max_interval
    );
    writer.StartElement(
      "maxInterval"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_max_interval
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMaxInterval
        )
      );

      return error;
    }
    writer.StopElement(
      "maxInterval"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMaxInterval
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeBasicEventElementAsElement(
  const types::IBasicEventElement& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "basicEventElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeBasicEventElementAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "basicEventElement"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeOperationAsSequence(
  const types::IOperation& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_input_variables(
    that.input_variables()
  );
  if (maybe_input_variables.has_value()) {
    const std::vector<
      std::shared_ptr<types::IOperationVariable>
    >& the_input_variables(
      *maybe_input_variables
    );
    writer.StartElement(
      "inputVariables"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_input_variables.size(); ++i) {
      const std::shared_ptr<types::IOperationVariable>& item(
        the_input_variables[i]
      );

      error = SerializeOperationVariableAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kInputVariables
        )
      );

      return error;
    }
    writer.StopElement(
      "inputVariables"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kInputVariables
        )
      );

      return error;
    }
  }

  const auto& maybe_output_variables(
    that.output_variables()
  );
  if (maybe_output_variables.has_value()) {
    const std::vector<
      std::shared_ptr<types::IOperationVariable>
    >& the_output_variables(
      *maybe_output_variables
    );
    writer.StartElement(
      "outputVariables"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_output_variables.size(); ++i) {
      const std::shared_ptr<types::IOperationVariable>& item(
        the_output_variables[i]
      );

      error = SerializeOperationVariableAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kOutputVariables
        )
      );

      return error;
    }
    writer.StopElement(
      "outputVariables"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kOutputVariables
        )
      );

      return error;
    }
  }

  const auto& maybe_inoutput_variables(
    that.inoutput_variables()
  );
  if (maybe_inoutput_variables.has_value()) {
    const std::vector<
      std::shared_ptr<types::IOperationVariable>
    >& the_inoutput_variables(
      *maybe_inoutput_variables
    );
    writer.StartElement(
      "inoutputVariables"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_inoutput_variables.size(); ++i) {
      const std::shared_ptr<types::IOperationVariable>& item(
        the_inoutput_variables[i]
      );

      error = SerializeOperationVariableAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kInoutputVariables
        )
      );

      return error;
    }
    writer.StopElement(
      "inoutputVariables"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kInoutputVariables
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeOperationAsElement(
  const types::IOperation& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "operation"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeOperationAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "operation"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeOperationVariableAsSequence(
  const types::IOperationVariable& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::shared_ptr<types::ISubmodelElement>& the_value(
    that.value()
  );
  writer.StartElement(
    "value"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeSubmodelElementAsElement(
    *the_value,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return error;
  }
  writer.StopElement(
    "value"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeOperationVariableAsElement(
  const types::IOperationVariable& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "operationVariable"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeOperationVariableAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "operationVariable"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeCapabilityAsSequence(
  const types::ICapability& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_semantic_id(
      *maybe_semantic_id
    );
    writer.StartElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "semanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return error;
    }
  }

  const auto& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_supplemental_semantic_ids(
      *maybe_supplemental_semantic_ids
    );
    writer.StartElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_supplemental_semantic_ids.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_supplemental_semantic_ids[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
    writer.StopElement(
      "supplementalSemanticIds"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSupplementalSemanticIds
        )
      );

      return error;
    }
  }

  const auto& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    const std::vector<
      std::shared_ptr<types::IQualifier>
    >& the_qualifiers(
      *maybe_qualifiers
    );
    writer.StartElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_qualifiers.size(); ++i) {
      const std::shared_ptr<types::IQualifier>& item(
        the_qualifiers[i]
      );

      error = SerializeQualifierAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
    writer.StopElement(
      "qualifiers"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kQualifiers
        )
      );

      return error;
    }
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeCapabilityAsElement(
  const types::ICapability& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "capability"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeCapabilityAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "capability"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeConceptDescriptionAsSequence(
  const types::IConceptDescription& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IExtension>
    >& the_extensions(
      *maybe_extensions
    );
    writer.StartElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_extensions.size(); ++i) {
      const std::shared_ptr<types::IExtension>& item(
        the_extensions[i]
      );

      error = SerializeExtensionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
    writer.StopElement(
      "extensions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExtensions
        )
      );

      return error;
    }
  }

  const auto& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    const std::wstring& the_category(
      *maybe_category
    );
    writer.StartElement(
      "category"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_category
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
    writer.StopElement(
      "category"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCategory
        )
      );

      return error;
    }
  }

  const auto& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    const std::wstring& the_id_short(
      *maybe_id_short
    );
    writer.StartElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_id_short
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
    writer.StopElement(
      "idShort"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIdShort
        )
      );

      return error;
    }
  }

  const auto& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >& the_display_name(
      *maybe_display_name
    );
    writer.StartElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_display_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringNameType>& item(
        the_display_name[i]
      );

      error = SerializeLangStringNameTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
    writer.StopElement(
      "displayName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDisplayName
        )
      );

      return error;
    }
  }

  const auto& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >& the_description(
      *maybe_description
    );
    writer.StartElement(
      "description"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_description.size(); ++i) {
      const std::shared_ptr<types::ILangStringTextType>& item(
        the_description[i]
      );

      error = SerializeLangStringTextTypeAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
    writer.StopElement(
      "description"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDescription
        )
      );

      return error;
    }
  }

  const auto& maybe_administration(
    that.administration()
  );
  if (maybe_administration.has_value()) {
    const std::shared_ptr<types::IAdministrativeInformation>& the_administration(
      *maybe_administration
    );
    writer.StartElement(
      "administration"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeAdministrativeInformationAsSequence(
      *the_administration,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return error;
    }
    writer.StopElement(
      "administration"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return error;
    }
  }

  const std::wstring& the_id(
    that.id()
  );
  writer.StartElement(
    "id"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_id
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kId
      )
    );

    return error;
  }
  writer.StopElement(
    "id"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kId
      )
    );

    return error;
  }

  const auto& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    const std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >& the_embedded_data_specifications(
      *maybe_embedded_data_specifications
    );
    writer.StartElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_embedded_data_specifications.size(); ++i) {
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item(
        the_embedded_data_specifications[i]
      );

      error = SerializeEmbeddedDataSpecificationAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
    writer.StopElement(
      "embeddedDataSpecifications"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kEmbeddedDataSpecifications
        )
      );

      return error;
    }
  }

  const auto& maybe_is_case_of(
    that.is_case_of()
  );
  if (maybe_is_case_of.has_value()) {
    const std::vector<
      std::shared_ptr<types::IReference>
    >& the_is_case_of(
      *maybe_is_case_of
    );
    writer.StartElement(
      "isCaseOf"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_is_case_of.size(); ++i) {
      const std::shared_ptr<types::IReference>& item(
        the_is_case_of[i]
      );

      error = SerializeReferenceAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIsCaseOf
        )
      );

      return error;
    }
    writer.StopElement(
      "isCaseOf"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kIsCaseOf
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeConceptDescriptionAsElement(
  const types::IConceptDescription& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "conceptDescription"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeConceptDescriptionAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "conceptDescription"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeReferenceAsSequence(
  const types::IReference& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  types::ReferenceTypes the_type(
    that.type()
  );
  writer.StartElement(
    "type"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_type
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kType
      )
    );

    return error;
  }
  writer.StopElement(
    "type"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kType
      )
    );

    return error;
  }

  const auto& maybe_referred_semantic_id(
    that.referred_semantic_id()
  );
  if (maybe_referred_semantic_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_referred_semantic_id(
      *maybe_referred_semantic_id
    );
    writer.StartElement(
      "referredSemanticId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_referred_semantic_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kReferredSemanticId
        )
      );

      return error;
    }
    writer.StopElement(
      "referredSemanticId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kReferredSemanticId
        )
      );

      return error;
    }
  }

  const std::vector<
    std::shared_ptr<types::IKey>
  >& the_keys(
    that.keys()
  );
  writer.StartElement(
    "keys"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  for (size_t i = 0; i < the_keys.size(); ++i) {
    const std::shared_ptr<types::IKey>& item(
      the_keys[i]
    );

    error = SerializeKeyAsElement(
      *item,
      writer
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          i
        )
      );

      break;
    }
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kKeys
      )
    );

    return error;
  }
  writer.StopElement(
    "keys"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kKeys
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeReferenceAsElement(
  const types::IReference& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "reference"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeReferenceAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "reference"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeKeyAsSequence(
  const types::IKey& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  types::KeyTypes the_type(
    that.type()
  );
  writer.StartElement(
    "type"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeString(
    stringification::to_string(
      the_type
    )
  );
  if (writer.error()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kType
      )
    );

    return error;
  }
  writer.StopElement(
    "type"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kType
      )
    );

    return error;
  }

  const std::wstring& the_value(
    that.value()
  );
  writer.StartElement(
    "value"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_value
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return error;
  }
  writer.StopElement(
    "value"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeKeyAsElement(
  const types::IKey& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "key"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeKeyAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "key"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeAbstractLangStringAsElement(
  const types::IAbstractLangString& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      return SerializeLangStringDefinitionTypeIec61360AsElement(
        dynamic_cast<
          const types::ILangStringDefinitionTypeIec61360&
        >(that),
        writer
      );
    case types::ModelType::kLangStringNameType:
      return SerializeLangStringNameTypeAsElement(
        dynamic_cast<
          const types::ILangStringNameType&
        >(that),
        writer
      );
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      return SerializeLangStringPreferredNameTypeIec61360AsElement(
        dynamic_cast<
          const types::ILangStringPreferredNameTypeIec61360&
        >(that),
        writer
      );
    case types::ModelType::kLangStringShortNameTypeIec61360:
      return SerializeLangStringShortNameTypeIec61360AsElement(
        dynamic_cast<
          const types::ILangStringShortNameTypeIec61360&
        >(that),
        writer
      );
    case types::ModelType::kLangStringTextType:
      return SerializeLangStringTextTypeAsElement(
        dynamic_cast<
          const types::ILangStringTextType&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringNameTypeAsSequence(
  const types::ILangStringNameType& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::wstring& the_language(
    that.language()
  );
  writer.StartElement(
    "language"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_language
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }
  writer.StopElement(
    "language"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }

  const std::wstring& the_text(
    that.text()
  );
  writer.StartElement(
    "text"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_text
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }
  writer.StopElement(
    "text"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeLangStringNameTypeAsElement(
  const types::ILangStringNameType& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "langStringNameType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeLangStringNameTypeAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "langStringNameType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringTextTypeAsSequence(
  const types::ILangStringTextType& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::wstring& the_language(
    that.language()
  );
  writer.StartElement(
    "language"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_language
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }
  writer.StopElement(
    "language"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }

  const std::wstring& the_text(
    that.text()
  );
  writer.StartElement(
    "text"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_text
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }
  writer.StopElement(
    "text"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeLangStringTextTypeAsElement(
  const types::ILangStringTextType& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "langStringTextType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeLangStringTextTypeAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "langStringTextType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEnvironmentAsSequence(
  const types::IEnvironment& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const auto& maybe_asset_administration_shells(
    that.asset_administration_shells()
  );
  if (maybe_asset_administration_shells.has_value()) {
    const std::vector<
      std::shared_ptr<types::IAssetAdministrationShell>
    >& the_asset_administration_shells(
      *maybe_asset_administration_shells
    );
    writer.StartElement(
      "assetAdministrationShells"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_asset_administration_shells.size(); ++i) {
      const std::shared_ptr<types::IAssetAdministrationShell>& item(
        the_asset_administration_shells[i]
      );

      error = SerializeAssetAdministrationShellAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAssetAdministrationShells
        )
      );

      return error;
    }
    writer.StopElement(
      "assetAdministrationShells"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAssetAdministrationShells
        )
      );

      return error;
    }
  }

  const auto& maybe_submodels(
    that.submodels()
  );
  if (maybe_submodels.has_value()) {
    const std::vector<
      std::shared_ptr<types::ISubmodel>
    >& the_submodels(
      *maybe_submodels
    );
    writer.StartElement(
      "submodels"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_submodels.size(); ++i) {
      const std::shared_ptr<types::ISubmodel>& item(
        the_submodels[i]
      );

      error = SerializeSubmodelAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubmodels
        )
      );

      return error;
    }
    writer.StopElement(
      "submodels"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubmodels
        )
      );

      return error;
    }
  }

  const auto& maybe_concept_descriptions(
    that.concept_descriptions()
  );
  if (maybe_concept_descriptions.has_value()) {
    const std::vector<
      std::shared_ptr<types::IConceptDescription>
    >& the_concept_descriptions(
      *maybe_concept_descriptions
    );
    writer.StartElement(
      "conceptDescriptions"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_concept_descriptions.size(); ++i) {
      const std::shared_ptr<types::IConceptDescription>& item(
        the_concept_descriptions[i]
      );

      error = SerializeConceptDescriptionAsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kConceptDescriptions
        )
      );

      return error;
    }
    writer.StopElement(
      "conceptDescriptions"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kConceptDescriptions
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeEnvironmentAsElement(
  const types::IEnvironment& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "environment"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeEnvironmentAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "environment"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeDataSpecificationContentAsElement(
  const types::IDataSpecificationContent& that,
  SelfClosingWriter& writer
) {
  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kDataSpecificationIec61360:
      return SerializeDataSpecificationIec61360AsElement(
        dynamic_cast<
          const types::IDataSpecificationIec61360&
        >(that),
        writer
      );
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  };
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeEmbeddedDataSpecificationAsSequence(
  const types::IEmbeddedDataSpecification& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::shared_ptr<types::IDataSpecificationContent>& the_data_specification_content(
    that.data_specification_content()
  );
  writer.StartElement(
    "dataSpecificationContent"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeDataSpecificationContentAsElement(
    *the_data_specification_content,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kDataSpecificationContent
      )
    );

    return error;
  }
  writer.StopElement(
    "dataSpecificationContent"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kDataSpecificationContent
      )
    );

    return error;
  }

  const std::shared_ptr<types::IReference>& the_data_specification(
    that.data_specification()
  );
  writer.StartElement(
    "dataSpecification"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_data_specification,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kDataSpecification
      )
    );

    return error;
  }
  writer.StopElement(
    "dataSpecification"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kDataSpecification
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeEmbeddedDataSpecificationAsElement(
  const types::IEmbeddedDataSpecification& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "embeddedDataSpecification"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeEmbeddedDataSpecificationAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "embeddedDataSpecification"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLevelTypeAsSequence(
  const types::ILevelType& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  bool the_min(
    that.min()
  );
  writer.StartElement(
    "min"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeBool(
    the_min
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kMin
      )
    );

    return error;
  }
  writer.StopElement(
    "min"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kMin
      )
    );

    return error;
  }

  bool the_nom(
    that.nom()
  );
  writer.StartElement(
    "nom"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeBool(
    the_nom
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kNom
      )
    );

    return error;
  }
  writer.StopElement(
    "nom"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kNom
      )
    );

    return error;
  }

  bool the_typ(
    that.typ()
  );
  writer.StartElement(
    "typ"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeBool(
    the_typ
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kTyp
      )
    );

    return error;
  }
  writer.StopElement(
    "typ"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kTyp
      )
    );

    return error;
  }

  bool the_max(
    that.max()
  );
  writer.StartElement(
    "max"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeBool(
    the_max
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kMax
      )
    );

    return error;
  }
  writer.StopElement(
    "max"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kMax
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeLevelTypeAsElement(
  const types::ILevelType& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "levelType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeLevelTypeAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "levelType"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeValueReferencePairAsSequence(
  const types::IValueReferencePair& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::wstring& the_value(
    that.value()
  );
  writer.StartElement(
    "value"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_value
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return error;
  }
  writer.StopElement(
    "value"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return error;
  }

  const std::shared_ptr<types::IReference>& the_value_id(
    that.value_id()
  );
  writer.StartElement(
    "valueId"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  error = SerializeReferenceAsSequence(
    *the_value_id,
    writer
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueId
      )
    );

    return error;
  }
  writer.StopElement(
    "valueId"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueId
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeValueReferencePairAsElement(
  const types::IValueReferencePair& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "valueReferencePair"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeValueReferencePairAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "valueReferencePair"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeValueListAsSequence(
  const types::IValueList& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::vector<
    std::shared_ptr<types::IValueReferencePair>
  >& the_value_reference_pairs(
    that.value_reference_pairs()
  );
  writer.StartElement(
    "valueReferencePairs"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  for (size_t i = 0; i < the_value_reference_pairs.size(); ++i) {
    const std::shared_ptr<types::IValueReferencePair>& item(
      the_value_reference_pairs[i]
    );

    error = SerializeValueReferencePairAsElement(
      *item,
      writer
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          i
        )
      );

      break;
    }
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueReferencePairs
      )
    );

    return error;
  }
  writer.StopElement(
    "valueReferencePairs"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueReferencePairs
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeValueListAsElement(
  const types::IValueList& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "valueList"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeValueListAsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "valueList"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringPreferredNameTypeIec61360AsSequence(
  const types::ILangStringPreferredNameTypeIec61360& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::wstring& the_language(
    that.language()
  );
  writer.StartElement(
    "language"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_language
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }
  writer.StopElement(
    "language"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }

  const std::wstring& the_text(
    that.text()
  );
  writer.StartElement(
    "text"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_text
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }
  writer.StopElement(
    "text"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeLangStringPreferredNameTypeIec61360AsElement(
  const types::ILangStringPreferredNameTypeIec61360& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "langStringPreferredNameTypeIec61360"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeLangStringPreferredNameTypeIec61360AsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "langStringPreferredNameTypeIec61360"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringShortNameTypeIec61360AsSequence(
  const types::ILangStringShortNameTypeIec61360& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::wstring& the_language(
    that.language()
  );
  writer.StartElement(
    "language"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_language
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }
  writer.StopElement(
    "language"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }

  const std::wstring& the_text(
    that.text()
  );
  writer.StartElement(
    "text"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_text
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }
  writer.StopElement(
    "text"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeLangStringShortNameTypeIec61360AsElement(
  const types::ILangStringShortNameTypeIec61360& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "langStringShortNameTypeIec61360"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeLangStringShortNameTypeIec61360AsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "langStringShortNameTypeIec61360"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeLangStringDefinitionTypeIec61360AsSequence(
  const types::ILangStringDefinitionTypeIec61360& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::wstring& the_language(
    that.language()
  );
  writer.StartElement(
    "language"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_language
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }
  writer.StopElement(
    "language"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kLanguage
      )
    );

    return error;
  }

  const std::wstring& the_text(
    that.text()
  );
  writer.StartElement(
    "text"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  writer.SerializeWstring(
    the_text
  );
  if (writer.error().has_value()) {
    error = writer.move_error();
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }
  writer.StopElement(
    "text"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kText
      )
    );

    return error;
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeLangStringDefinitionTypeIec61360AsElement(
  const types::ILangStringDefinitionTypeIec61360& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "langStringDefinitionTypeIec61360"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeLangStringDefinitionTypeIec61360AsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "langStringDefinitionTypeIec61360"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

/**
 * \brief Serialize \p that instance as a sequence of XML elements.
 *
 * Each XML element corresponds to a property.
 *
 * \param that instance to be serialized
 * \param writer to write to
 * \return error, if any
 */
common::optional<SerializationError> SerializeDataSpecificationIec61360AsSequence(
  const types::IDataSpecificationIec61360& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  const std::vector<
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
  >& the_preferred_name(
    that.preferred_name()
  );
  writer.StartElement(
    "preferredName"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }
  for (size_t i = 0; i < the_preferred_name.size(); ++i) {
    const std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>& item(
      the_preferred_name[i]
    );

    error = SerializeLangStringPreferredNameTypeIec61360AsElement(
      *item,
      writer
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          i
        )
      );

      break;
    }
  }
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kPreferredName
      )
    );

    return error;
  }
  writer.StopElement(
    "preferredName"
  );
  if (writer.error().has_value()) {
    error = writer.move_error();

    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kPreferredName
      )
    );

    return error;
  }

  const auto& maybe_short_name(
    that.short_name()
  );
  if (maybe_short_name.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >& the_short_name(
      *maybe_short_name
    );
    writer.StartElement(
      "shortName"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_short_name.size(); ++i) {
      const std::shared_ptr<types::ILangStringShortNameTypeIec61360>& item(
        the_short_name[i]
      );

      error = SerializeLangStringShortNameTypeIec61360AsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kShortName
        )
      );

      return error;
    }
    writer.StopElement(
      "shortName"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kShortName
        )
      );

      return error;
    }
  }

  const auto& maybe_unit(
    that.unit()
  );
  if (maybe_unit.has_value()) {
    const std::wstring& the_unit(
      *maybe_unit
    );
    writer.StartElement(
      "unit"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_unit
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kUnit
        )
      );

      return error;
    }
    writer.StopElement(
      "unit"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kUnit
        )
      );

      return error;
    }
  }

  const auto& maybe_unit_id(
    that.unit_id()
  );
  if (maybe_unit_id.has_value()) {
    const std::shared_ptr<types::IReference>& the_unit_id(
      *maybe_unit_id
    );
    writer.StartElement(
      "unitId"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeReferenceAsSequence(
      *the_unit_id,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kUnitId
        )
      );

      return error;
    }
    writer.StopElement(
      "unitId"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kUnitId
        )
      );

      return error;
    }
  }

  const auto& maybe_source_of_definition(
    that.source_of_definition()
  );
  if (maybe_source_of_definition.has_value()) {
    const std::wstring& the_source_of_definition(
      *maybe_source_of_definition
    );
    writer.StartElement(
      "sourceOfDefinition"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_source_of_definition
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSourceOfDefinition
        )
      );

      return error;
    }
    writer.StopElement(
      "sourceOfDefinition"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSourceOfDefinition
        )
      );

      return error;
    }
  }

  const auto& maybe_symbol(
    that.symbol()
  );
  if (maybe_symbol.has_value()) {
    const std::wstring& the_symbol(
      *maybe_symbol
    );
    writer.StartElement(
      "symbol"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_symbol
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSymbol
        )
      );

      return error;
    }
    writer.StopElement(
      "symbol"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSymbol
        )
      );

      return error;
    }
  }

  const auto& maybe_data_type(
    that.data_type()
  );
  if (maybe_data_type.has_value()) {
    types::DataTypeIec61360 the_data_type(
      *maybe_data_type
    );
    writer.StartElement(
      "dataType"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeString(
      stringification::to_string(
        the_data_type
      )
    );
    if (writer.error()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDataType
        )
      );

      return error;
    }
    writer.StopElement(
      "dataType"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDataType
        )
      );

      return error;
    }
  }

  const auto& maybe_definition(
    that.definition()
  );
  if (maybe_definition.has_value()) {
    const std::vector<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >& the_definition(
      *maybe_definition
    );
    writer.StartElement(
      "definition"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    for (size_t i = 0; i < the_definition.size(); ++i) {
      const std::shared_ptr<types::ILangStringDefinitionTypeIec61360>& item(
        the_definition[i]
      );

      error = SerializeLangStringDefinitionTypeIec61360AsElement(
        *item,
        writer
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            i
          )
        );

        break;
      }
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDefinition
        )
      );

      return error;
    }
    writer.StopElement(
      "definition"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDefinition
        )
      );

      return error;
    }
  }

  const auto& maybe_value_format(
    that.value_format()
  );
  if (maybe_value_format.has_value()) {
    const std::wstring& the_value_format(
      *maybe_value_format
    );
    writer.StartElement(
      "valueFormat"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_value_format
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueFormat
        )
      );

      return error;
    }
    writer.StopElement(
      "valueFormat"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueFormat
        )
      );

      return error;
    }
  }

  const auto& maybe_value_list(
    that.value_list()
  );
  if (maybe_value_list.has_value()) {
    const std::shared_ptr<types::IValueList>& the_value_list(
      *maybe_value_list
    );
    writer.StartElement(
      "valueList"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeValueListAsSequence(
      *the_value_list,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueList
        )
      );

      return error;
    }
    writer.StopElement(
      "valueList"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueList
        )
      );

      return error;
    }
  }

  const auto& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    const std::wstring& the_value(
      *maybe_value
    );
    writer.StartElement(
      "value"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    writer.SerializeWstring(
      the_value
    );
    if (writer.error().has_value()) {
      error = writer.move_error();
    }
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
    writer.StopElement(
      "value"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return error;
    }
  }

  const auto& maybe_level_type(
    that.level_type()
  );
  if (maybe_level_type.has_value()) {
    const std::shared_ptr<types::ILevelType>& the_level_type(
      *maybe_level_type
    );
    writer.StartElement(
      "levelType"
    );
    if (writer.error().has_value()) {
      return writer.move_error();
    }
    error = SerializeLevelTypeAsSequence(
      *the_level_type,
      writer
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kLevelType
        )
      );

      return error;
    }
    writer.StopElement(
      "levelType"
    );
    if (writer.error().has_value()) {
      error = writer.move_error();

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kLevelType
        )
      );

      return error;
    }
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

common::optional<SerializationError> SerializeDataSpecificationIec61360AsElement(
  const types::IDataSpecificationIec61360& that,
  SelfClosingWriter& writer
) {
  common::optional<SerializationError> error;

  writer.StartElement(
    "dataSpecificationIec61360"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  error = SerializeDataSpecificationIec61360AsSequence(
    that,
    writer
  );
  if (error.has_value()) {
    return error;
  }

  writer.StopElement(
    "dataSpecificationIec61360"
  );
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  writer.Finish();
  if (writer.error().has_value()) {
    return writer.move_error();
  }

  return common::nullopt;
}

void Serialize(
  const types::IClass& that,
  const WritingOptions& options,
  std::ostream& os
) {
  if (options.write_declaration) {
    os << "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
    if (os.bad()) {
      throw SerializationException(
        kTheOutputStreamIsInABadState
      );
    }
  }

  SelfClosingWriter writer(
    os,
    options.prefix
  );

  common::optional<SerializationError> error;

  // NOTE (mristin):
  // Instead of using `Serialize*AsElement`, we write the root XML element
  // in this functions so that we check for the XML namespace only once, namely
  // here. Otherwise, we would have a condition check in <em>every</em> nested
  // `Serialize*AsElement` which could cause a significant efficiency hit.

  // NOTE (mristin):
  // The dynamic casts are necessary due to virtual inheritance. Otherwise,
  // we would have used static casts.

  switch (that.model_type()) {
    case types::ModelType::kExtension:
      if (options.write_namespace) {
        os << (
          "<extension "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<extension>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeExtensionAsSequence(
        dynamic_cast<
          const types::IExtension&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</extension>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kAdministrativeInformation:
      if (options.write_namespace) {
        os << (
          "<administrativeInformation "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<administrativeInformation>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeAdministrativeInformationAsSequence(
        dynamic_cast<
          const types::IAdministrativeInformation&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</administrativeInformation>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kQualifier:
      if (options.write_namespace) {
        os << (
          "<qualifier "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<qualifier>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeQualifierAsSequence(
        dynamic_cast<
          const types::IQualifier&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</qualifier>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kAssetAdministrationShell:
      if (options.write_namespace) {
        os << (
          "<assetAdministrationShell "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<assetAdministrationShell>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeAssetAdministrationShellAsSequence(
        dynamic_cast<
          const types::IAssetAdministrationShell&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</assetAdministrationShell>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kAssetInformation:
      if (options.write_namespace) {
        os << (
          "<assetInformation "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<assetInformation>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeAssetInformationAsSequence(
        dynamic_cast<
          const types::IAssetInformation&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</assetInformation>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kResource:
      if (options.write_namespace) {
        os << (
          "<resource "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<resource>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeResourceAsSequence(
        dynamic_cast<
          const types::IResource&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</resource>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kSpecificAssetId:
      if (options.write_namespace) {
        os << (
          "<specificAssetId "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<specificAssetId>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeSpecificAssetIdAsSequence(
        dynamic_cast<
          const types::ISpecificAssetId&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</specificAssetId>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kSubmodel:
      if (options.write_namespace) {
        os << (
          "<submodel "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<submodel>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeSubmodelAsSequence(
        dynamic_cast<
          const types::ISubmodel&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</submodel>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kRelationshipElement:
      if (options.write_namespace) {
        os << (
          "<relationshipElement "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<relationshipElement>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeRelationshipElementAsSequence(
        dynamic_cast<
          const types::IRelationshipElement&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</relationshipElement>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kSubmodelElementList:
      if (options.write_namespace) {
        os << (
          "<submodelElementList "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<submodelElementList>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeSubmodelElementListAsSequence(
        dynamic_cast<
          const types::ISubmodelElementList&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</submodelElementList>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kSubmodelElementCollection:
      if (options.write_namespace) {
        os << (
          "<submodelElementCollection "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<submodelElementCollection>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeSubmodelElementCollectionAsSequence(
        dynamic_cast<
          const types::ISubmodelElementCollection&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</submodelElementCollection>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kProperty:
      if (options.write_namespace) {
        os << (
          "<property "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<property>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializePropertyAsSequence(
        dynamic_cast<
          const types::IProperty&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</property>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kMultiLanguageProperty:
      if (options.write_namespace) {
        os << (
          "<multiLanguageProperty "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<multiLanguageProperty>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeMultiLanguagePropertyAsSequence(
        dynamic_cast<
          const types::IMultiLanguageProperty&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</multiLanguageProperty>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kRange:
      if (options.write_namespace) {
        os << (
          "<range "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<range>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeRangeAsSequence(
        dynamic_cast<
          const types::IRange&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</range>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kReferenceElement:
      if (options.write_namespace) {
        os << (
          "<referenceElement "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<referenceElement>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeReferenceElementAsSequence(
        dynamic_cast<
          const types::IReferenceElement&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</referenceElement>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kBlob:
      if (options.write_namespace) {
        os << (
          "<blob "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<blob>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeBlobAsSequence(
        dynamic_cast<
          const types::IBlob&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</blob>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kFile:
      if (options.write_namespace) {
        os << (
          "<file "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<file>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeFileAsSequence(
        dynamic_cast<
          const types::IFile&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</file>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      if (options.write_namespace) {
        os << (
          "<annotatedRelationshipElement "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<annotatedRelationshipElement>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeAnnotatedRelationshipElementAsSequence(
        dynamic_cast<
          const types::IAnnotatedRelationshipElement&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</annotatedRelationshipElement>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kEntity:
      if (options.write_namespace) {
        os << (
          "<entity "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<entity>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeEntityAsSequence(
        dynamic_cast<
          const types::IEntity&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</entity>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kEventPayload:
      if (options.write_namespace) {
        os << (
          "<eventPayload "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<eventPayload>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeEventPayloadAsSequence(
        dynamic_cast<
          const types::IEventPayload&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</eventPayload>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kBasicEventElement:
      if (options.write_namespace) {
        os << (
          "<basicEventElement "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<basicEventElement>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeBasicEventElementAsSequence(
        dynamic_cast<
          const types::IBasicEventElement&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</basicEventElement>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kOperation:
      if (options.write_namespace) {
        os << (
          "<operation "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<operation>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeOperationAsSequence(
        dynamic_cast<
          const types::IOperation&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</operation>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kOperationVariable:
      if (options.write_namespace) {
        os << (
          "<operationVariable "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<operationVariable>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeOperationVariableAsSequence(
        dynamic_cast<
          const types::IOperationVariable&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</operationVariable>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kCapability:
      if (options.write_namespace) {
        os << (
          "<capability "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<capability>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeCapabilityAsSequence(
        dynamic_cast<
          const types::ICapability&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</capability>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kConceptDescription:
      if (options.write_namespace) {
        os << (
          "<conceptDescription "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<conceptDescription>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeConceptDescriptionAsSequence(
        dynamic_cast<
          const types::IConceptDescription&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</conceptDescription>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kReference:
      if (options.write_namespace) {
        os << (
          "<reference "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<reference>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeReferenceAsSequence(
        dynamic_cast<
          const types::IReference&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</reference>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kKey:
      if (options.write_namespace) {
        os << (
          "<key "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<key>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeKeyAsSequence(
        dynamic_cast<
          const types::IKey&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</key>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kLangStringNameType:
      if (options.write_namespace) {
        os << (
          "<langStringNameType "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<langStringNameType>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeLangStringNameTypeAsSequence(
        dynamic_cast<
          const types::ILangStringNameType&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</langStringNameType>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kLangStringTextType:
      if (options.write_namespace) {
        os << (
          "<langStringTextType "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<langStringTextType>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeLangStringTextTypeAsSequence(
        dynamic_cast<
          const types::ILangStringTextType&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</langStringTextType>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kEnvironment:
      if (options.write_namespace) {
        os << (
          "<environment "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<environment>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeEnvironmentAsSequence(
        dynamic_cast<
          const types::IEnvironment&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</environment>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kEmbeddedDataSpecification:
      if (options.write_namespace) {
        os << (
          "<embeddedDataSpecification "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<embeddedDataSpecification>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeEmbeddedDataSpecificationAsSequence(
        dynamic_cast<
          const types::IEmbeddedDataSpecification&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</embeddedDataSpecification>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kLevelType:
      if (options.write_namespace) {
        os << (
          "<levelType "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<levelType>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeLevelTypeAsSequence(
        dynamic_cast<
          const types::ILevelType&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</levelType>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kValueReferencePair:
      if (options.write_namespace) {
        os << (
          "<valueReferencePair "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<valueReferencePair>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeValueReferencePairAsSequence(
        dynamic_cast<
          const types::IValueReferencePair&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</valueReferencePair>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kValueList:
      if (options.write_namespace) {
        os << (
          "<valueList "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<valueList>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeValueListAsSequence(
        dynamic_cast<
          const types::IValueList&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</valueList>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      if (options.write_namespace) {
        os << (
          "<langStringPreferredNameTypeIec61360 "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<langStringPreferredNameTypeIec61360>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeLangStringPreferredNameTypeIec61360AsSequence(
        dynamic_cast<
          const types::ILangStringPreferredNameTypeIec61360&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</langStringPreferredNameTypeIec61360>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kLangStringShortNameTypeIec61360:
      if (options.write_namespace) {
        os << (
          "<langStringShortNameTypeIec61360 "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<langStringShortNameTypeIec61360>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeLangStringShortNameTypeIec61360AsSequence(
        dynamic_cast<
          const types::ILangStringShortNameTypeIec61360&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</langStringShortNameTypeIec61360>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      if (options.write_namespace) {
        os << (
          "<langStringDefinitionTypeIec61360 "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<langStringDefinitionTypeIec61360>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeLangStringDefinitionTypeIec61360AsSequence(
        dynamic_cast<
          const types::ILangStringDefinitionTypeIec61360&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</langStringDefinitionTypeIec61360>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    case types::ModelType::kDataSpecificationIec61360:
      if (options.write_namespace) {
        os << (
          "<dataSpecificationIec61360 "
          "xmlns=\"https://admin-shell.io/aas/3/0\">"
        );
      } else {
        os << "<dataSpecificationIec61360>";
      }

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      error = SerializeDataSpecificationIec61360AsSequence(
        dynamic_cast<
          const types::IDataSpecificationIec61360&
        >(that),
        writer
      );
      if (error.has_value()) {
        break;
      }

      os << "</dataSpecificationIec61360>";

      error = CheckOstreamState(os);
      if (error.has_value()) {
        break;
      }

      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Invalid model type: ",
          stringification::to_string(that.model_type())
        )
      );
  }

  if (error.has_value()) {
    throw SerializationException(
      std::move(error->cause),
      std::move(error->path)
    );
  }
}

// endregion Serialization

}  // namespace xmlization
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
