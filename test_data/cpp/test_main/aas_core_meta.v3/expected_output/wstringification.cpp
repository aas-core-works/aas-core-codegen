// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/wstringification.hpp"

#pragma warning(push, 0)
#include <unordered_map>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {
namespace wstringification {

const std::unordered_map<
  std::wstring,
  types::ModelType
> kModelTypeFromWstringMap = {
  {
    L"Extension",
    types::ModelType::kExtension
  },
  {
    L"AdministrativeInformation",
    types::ModelType::kAdministrativeInformation
  },
  {
    L"Qualifier",
    types::ModelType::kQualifier
  },
  {
    L"AssetAdministrationShell",
    types::ModelType::kAssetAdministrationShell
  },
  {
    L"AssetInformation",
    types::ModelType::kAssetInformation
  },
  {
    L"Resource",
    types::ModelType::kResource
  },
  {
    L"SpecificAssetId",
    types::ModelType::kSpecificAssetId
  },
  {
    L"Submodel",
    types::ModelType::kSubmodel
  },
  {
    L"RelationshipElement",
    types::ModelType::kRelationshipElement
  },
  {
    L"SubmodelElementList",
    types::ModelType::kSubmodelElementList
  },
  {
    L"SubmodelElementCollection",
    types::ModelType::kSubmodelElementCollection
  },
  {
    L"Property",
    types::ModelType::kProperty
  },
  {
    L"MultiLanguageProperty",
    types::ModelType::kMultiLanguageProperty
  },
  {
    L"Range",
    types::ModelType::kRange
  },
  {
    L"ReferenceElement",
    types::ModelType::kReferenceElement
  },
  {
    L"Blob",
    types::ModelType::kBlob
  },
  {
    L"File",
    types::ModelType::kFile
  },
  {
    L"AnnotatedRelationshipElement",
    types::ModelType::kAnnotatedRelationshipElement
  },
  {
    L"Entity",
    types::ModelType::kEntity
  },
  {
    L"EventPayload",
    types::ModelType::kEventPayload
  },
  {
    L"BasicEventElement",
    types::ModelType::kBasicEventElement
  },
  {
    L"Operation",
    types::ModelType::kOperation
  },
  {
    L"OperationVariable",
    types::ModelType::kOperationVariable
  },
  {
    L"Capability",
    types::ModelType::kCapability
  },
  {
    L"ConceptDescription",
    types::ModelType::kConceptDescription
  },
  {
    L"Reference",
    types::ModelType::kReference
  },
  {
    L"Key",
    types::ModelType::kKey
  },
  {
    L"LangStringNameType",
    types::ModelType::kLangStringNameType
  },
  {
    L"LangStringTextType",
    types::ModelType::kLangStringTextType
  },
  {
    L"Environment",
    types::ModelType::kEnvironment
  },
  {
    L"EmbeddedDataSpecification",
    types::ModelType::kEmbeddedDataSpecification
  },
  {
    L"LevelType",
    types::ModelType::kLevelType
  },
  {
    L"ValueReferencePair",
    types::ModelType::kValueReferencePair
  },
  {
    L"ValueList",
    types::ModelType::kValueList
  },
  {
    L"LangStringPreferredNameTypeIec61360",
    types::ModelType::kLangStringPreferredNameTypeIec61360
  },
  {
    L"LangStringShortNameTypeIec61360",
    types::ModelType::kLangStringShortNameTypeIec61360
  },
  {
    L"LangStringDefinitionTypeIec61360",
    types::ModelType::kLangStringDefinitionTypeIec61360
  },
  {
    L"DataSpecificationIec61360",
    types::ModelType::kDataSpecificationIec61360
  }
};

common::optional<types::ModelType> ModelTypeFromWstring(
  const std::wstring& text
) {
  const auto it = kModelTypeFromWstringMap.find(
    text
  );
  if (it == kModelTypeFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::ModelType MustModelTypeFromWstring(
  const std::wstring& text
) {
  const auto it = kModelTypeFromWstringMap.find(
    text
  );
  if (it == kModelTypeFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected ModelType literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::ModelType model_type
) {
  switch (model_type) {
    case types::ModelType::kExtension:
    return L"Extension";
    case types::ModelType::kAdministrativeInformation:
    return L"AdministrativeInformation";
    case types::ModelType::kQualifier:
    return L"Qualifier";
    case types::ModelType::kAssetAdministrationShell:
    return L"AssetAdministrationShell";
    case types::ModelType::kAssetInformation:
    return L"AssetInformation";
    case types::ModelType::kResource:
    return L"Resource";
    case types::ModelType::kSpecificAssetId:
    return L"SpecificAssetId";
    case types::ModelType::kSubmodel:
    return L"Submodel";
    case types::ModelType::kRelationshipElement:
    return L"RelationshipElement";
    case types::ModelType::kSubmodelElementList:
    return L"SubmodelElementList";
    case types::ModelType::kSubmodelElementCollection:
    return L"SubmodelElementCollection";
    case types::ModelType::kProperty:
    return L"Property";
    case types::ModelType::kMultiLanguageProperty:
    return L"MultiLanguageProperty";
    case types::ModelType::kRange:
    return L"Range";
    case types::ModelType::kReferenceElement:
    return L"ReferenceElement";
    case types::ModelType::kBlob:
    return L"Blob";
    case types::ModelType::kFile:
    return L"File";
    case types::ModelType::kAnnotatedRelationshipElement:
    return L"AnnotatedRelationshipElement";
    case types::ModelType::kEntity:
    return L"Entity";
    case types::ModelType::kEventPayload:
    return L"EventPayload";
    case types::ModelType::kBasicEventElement:
    return L"BasicEventElement";
    case types::ModelType::kOperation:
    return L"Operation";
    case types::ModelType::kOperationVariable:
    return L"OperationVariable";
    case types::ModelType::kCapability:
    return L"Capability";
    case types::ModelType::kConceptDescription:
    return L"ConceptDescription";
    case types::ModelType::kReference:
    return L"Reference";
    case types::ModelType::kKey:
    return L"Key";
    case types::ModelType::kLangStringNameType:
    return L"LangStringNameType";
    case types::ModelType::kLangStringTextType:
    return L"LangStringTextType";
    case types::ModelType::kEnvironment:
    return L"Environment";
    case types::ModelType::kEmbeddedDataSpecification:
    return L"EmbeddedDataSpecification";
    case types::ModelType::kLevelType:
    return L"LevelType";
    case types::ModelType::kValueReferencePair:
    return L"ValueReferencePair";
    case types::ModelType::kValueList:
    return L"ValueList";
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
    return L"LangStringPreferredNameTypeIec61360";
    case types::ModelType::kLangStringShortNameTypeIec61360:
    return L"LangStringShortNameTypeIec61360";
    case types::ModelType::kLangStringDefinitionTypeIec61360:
    return L"LangStringDefinitionTypeIec61360";
    case types::ModelType::kDataSpecificationIec61360:
    return L"DataSpecificationIec61360";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected ModelType literal: ",
          std::to_string(
            static_cast<std::uint32_t>(model_type)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::ModellingKind
> kModellingKindFromWstringMap = {
  {
    L"Template",
    types::ModellingKind::kTemplate
  },
  {
    L"Instance",
    types::ModellingKind::kInstance
  }
};

common::optional<types::ModellingKind> ModellingKindFromWstring(
  const std::wstring& text
) {
  const auto it = kModellingKindFromWstringMap.find(
    text
  );
  if (it == kModellingKindFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::ModellingKind MustModellingKindFromWstring(
  const std::wstring& text
) {
  const auto it = kModellingKindFromWstringMap.find(
    text
  );
  if (it == kModellingKindFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected ModellingKind literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::ModellingKind literal
) {
  switch (literal) {
    case types::ModellingKind::kTemplate:
      return L"Template";
    case types::ModellingKind::kInstance:
      return L"Instance";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected ModellingKind literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::QualifierKind
> kQualifierKindFromWstringMap = {
  {
    L"ValueQualifier",
    types::QualifierKind::kValueQualifier
  },
  {
    L"ConceptQualifier",
    types::QualifierKind::kConceptQualifier
  },
  {
    L"TemplateQualifier",
    types::QualifierKind::kTemplateQualifier
  }
};

common::optional<types::QualifierKind> QualifierKindFromWstring(
  const std::wstring& text
) {
  const auto it = kQualifierKindFromWstringMap.find(
    text
  );
  if (it == kQualifierKindFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::QualifierKind MustQualifierKindFromWstring(
  const std::wstring& text
) {
  const auto it = kQualifierKindFromWstringMap.find(
    text
  );
  if (it == kQualifierKindFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected QualifierKind literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::QualifierKind literal
) {
  switch (literal) {
    case types::QualifierKind::kValueQualifier:
      return L"ValueQualifier";
    case types::QualifierKind::kConceptQualifier:
      return L"ConceptQualifier";
    case types::QualifierKind::kTemplateQualifier:
      return L"TemplateQualifier";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected QualifierKind literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::AssetKind
> kAssetKindFromWstringMap = {
  {
    L"Type",
    types::AssetKind::kType
  },
  {
    L"Instance",
    types::AssetKind::kInstance
  },
  {
    L"NotApplicable",
    types::AssetKind::kNotApplicable
  }
};

common::optional<types::AssetKind> AssetKindFromWstring(
  const std::wstring& text
) {
  const auto it = kAssetKindFromWstringMap.find(
    text
  );
  if (it == kAssetKindFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::AssetKind MustAssetKindFromWstring(
  const std::wstring& text
) {
  const auto it = kAssetKindFromWstringMap.find(
    text
  );
  if (it == kAssetKindFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected AssetKind literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::AssetKind literal
) {
  switch (literal) {
    case types::AssetKind::kType:
      return L"Type";
    case types::AssetKind::kInstance:
      return L"Instance";
    case types::AssetKind::kNotApplicable:
      return L"NotApplicable";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected AssetKind literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::AasSubmodelElements
> kAasSubmodelElementsFromWstringMap = {
  {
    L"AnnotatedRelationshipElement",
    types::AasSubmodelElements::kAnnotatedRelationshipElement
  },
  {
    L"BasicEventElement",
    types::AasSubmodelElements::kBasicEventElement
  },
  {
    L"Blob",
    types::AasSubmodelElements::kBlob
  },
  {
    L"Capability",
    types::AasSubmodelElements::kCapability
  },
  {
    L"DataElement",
    types::AasSubmodelElements::kDataElement
  },
  {
    L"Entity",
    types::AasSubmodelElements::kEntity
  },
  {
    L"EventElement",
    types::AasSubmodelElements::kEventElement
  },
  {
    L"File",
    types::AasSubmodelElements::kFile
  },
  {
    L"MultiLanguageProperty",
    types::AasSubmodelElements::kMultiLanguageProperty
  },
  {
    L"Operation",
    types::AasSubmodelElements::kOperation
  },
  {
    L"Property",
    types::AasSubmodelElements::kProperty
  },
  {
    L"Range",
    types::AasSubmodelElements::kRange
  },
  {
    L"ReferenceElement",
    types::AasSubmodelElements::kReferenceElement
  },
  {
    L"RelationshipElement",
    types::AasSubmodelElements::kRelationshipElement
  },
  {
    L"SubmodelElement",
    types::AasSubmodelElements::kSubmodelElement
  },
  {
    L"SubmodelElementList",
    types::AasSubmodelElements::kSubmodelElementList
  },
  {
    L"SubmodelElementCollection",
    types::AasSubmodelElements::kSubmodelElementCollection
  }
};

common::optional<types::AasSubmodelElements> AasSubmodelElementsFromWstring(
  const std::wstring& text
) {
  const auto it = kAasSubmodelElementsFromWstringMap.find(
    text
  );
  if (it == kAasSubmodelElementsFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::AasSubmodelElements MustAasSubmodelElementsFromWstring(
  const std::wstring& text
) {
  const auto it = kAasSubmodelElementsFromWstringMap.find(
    text
  );
  if (it == kAasSubmodelElementsFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected AasSubmodelElements literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::AasSubmodelElements literal
) {
  switch (literal) {
    case types::AasSubmodelElements::kAnnotatedRelationshipElement:
      return L"AnnotatedRelationshipElement";
    case types::AasSubmodelElements::kBasicEventElement:
      return L"BasicEventElement";
    case types::AasSubmodelElements::kBlob:
      return L"Blob";
    case types::AasSubmodelElements::kCapability:
      return L"Capability";
    case types::AasSubmodelElements::kDataElement:
      return L"DataElement";
    case types::AasSubmodelElements::kEntity:
      return L"Entity";
    case types::AasSubmodelElements::kEventElement:
      return L"EventElement";
    case types::AasSubmodelElements::kFile:
      return L"File";
    case types::AasSubmodelElements::kMultiLanguageProperty:
      return L"MultiLanguageProperty";
    case types::AasSubmodelElements::kOperation:
      return L"Operation";
    case types::AasSubmodelElements::kProperty:
      return L"Property";
    case types::AasSubmodelElements::kRange:
      return L"Range";
    case types::AasSubmodelElements::kReferenceElement:
      return L"ReferenceElement";
    case types::AasSubmodelElements::kRelationshipElement:
      return L"RelationshipElement";
    case types::AasSubmodelElements::kSubmodelElement:
      return L"SubmodelElement";
    case types::AasSubmodelElements::kSubmodelElementList:
      return L"SubmodelElementList";
    case types::AasSubmodelElements::kSubmodelElementCollection:
      return L"SubmodelElementCollection";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected AasSubmodelElements literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::EntityType
> kEntityTypeFromWstringMap = {
  {
    L"CoManagedEntity",
    types::EntityType::kCoManagedEntity
  },
  {
    L"SelfManagedEntity",
    types::EntityType::kSelfManagedEntity
  }
};

common::optional<types::EntityType> EntityTypeFromWstring(
  const std::wstring& text
) {
  const auto it = kEntityTypeFromWstringMap.find(
    text
  );
  if (it == kEntityTypeFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::EntityType MustEntityTypeFromWstring(
  const std::wstring& text
) {
  const auto it = kEntityTypeFromWstringMap.find(
    text
  );
  if (it == kEntityTypeFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected EntityType literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::EntityType literal
) {
  switch (literal) {
    case types::EntityType::kCoManagedEntity:
      return L"CoManagedEntity";
    case types::EntityType::kSelfManagedEntity:
      return L"SelfManagedEntity";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected EntityType literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::Direction
> kDirectionFromWstringMap = {
  {
    L"input",
    types::Direction::kInput
  },
  {
    L"output",
    types::Direction::kOutput
  }
};

common::optional<types::Direction> DirectionFromWstring(
  const std::wstring& text
) {
  const auto it = kDirectionFromWstringMap.find(
    text
  );
  if (it == kDirectionFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::Direction MustDirectionFromWstring(
  const std::wstring& text
) {
  const auto it = kDirectionFromWstringMap.find(
    text
  );
  if (it == kDirectionFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected Direction literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::Direction literal
) {
  switch (literal) {
    case types::Direction::kInput:
      return L"input";
    case types::Direction::kOutput:
      return L"output";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected Direction literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::StateOfEvent
> kStateOfEventFromWstringMap = {
  {
    L"on",
    types::StateOfEvent::kOn
  },
  {
    L"off",
    types::StateOfEvent::kOff
  }
};

common::optional<types::StateOfEvent> StateOfEventFromWstring(
  const std::wstring& text
) {
  const auto it = kStateOfEventFromWstringMap.find(
    text
  );
  if (it == kStateOfEventFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::StateOfEvent MustStateOfEventFromWstring(
  const std::wstring& text
) {
  const auto it = kStateOfEventFromWstringMap.find(
    text
  );
  if (it == kStateOfEventFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected StateOfEvent literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::StateOfEvent literal
) {
  switch (literal) {
    case types::StateOfEvent::kOn:
      return L"on";
    case types::StateOfEvent::kOff:
      return L"off";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected StateOfEvent literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::ReferenceTypes
> kReferenceTypesFromWstringMap = {
  {
    L"ExternalReference",
    types::ReferenceTypes::kExternalReference
  },
  {
    L"ModelReference",
    types::ReferenceTypes::kModelReference
  }
};

common::optional<types::ReferenceTypes> ReferenceTypesFromWstring(
  const std::wstring& text
) {
  const auto it = kReferenceTypesFromWstringMap.find(
    text
  );
  if (it == kReferenceTypesFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::ReferenceTypes MustReferenceTypesFromWstring(
  const std::wstring& text
) {
  const auto it = kReferenceTypesFromWstringMap.find(
    text
  );
  if (it == kReferenceTypesFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected ReferenceTypes literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::ReferenceTypes literal
) {
  switch (literal) {
    case types::ReferenceTypes::kExternalReference:
      return L"ExternalReference";
    case types::ReferenceTypes::kModelReference:
      return L"ModelReference";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected ReferenceTypes literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::KeyTypes
> kKeyTypesFromWstringMap = {
  {
    L"AnnotatedRelationshipElement",
    types::KeyTypes::kAnnotatedRelationshipElement
  },
  {
    L"AssetAdministrationShell",
    types::KeyTypes::kAssetAdministrationShell
  },
  {
    L"BasicEventElement",
    types::KeyTypes::kBasicEventElement
  },
  {
    L"Blob",
    types::KeyTypes::kBlob
  },
  {
    L"Capability",
    types::KeyTypes::kCapability
  },
  {
    L"ConceptDescription",
    types::KeyTypes::kConceptDescription
  },
  {
    L"DataElement",
    types::KeyTypes::kDataElement
  },
  {
    L"Entity",
    types::KeyTypes::kEntity
  },
  {
    L"EventElement",
    types::KeyTypes::kEventElement
  },
  {
    L"File",
    types::KeyTypes::kFile
  },
  {
    L"FragmentReference",
    types::KeyTypes::kFragmentReference
  },
  {
    L"GlobalReference",
    types::KeyTypes::kGlobalReference
  },
  {
    L"Identifiable",
    types::KeyTypes::kIdentifiable
  },
  {
    L"MultiLanguageProperty",
    types::KeyTypes::kMultiLanguageProperty
  },
  {
    L"Operation",
    types::KeyTypes::kOperation
  },
  {
    L"Property",
    types::KeyTypes::kProperty
  },
  {
    L"Range",
    types::KeyTypes::kRange
  },
  {
    L"Referable",
    types::KeyTypes::kReferable
  },
  {
    L"ReferenceElement",
    types::KeyTypes::kReferenceElement
  },
  {
    L"RelationshipElement",
    types::KeyTypes::kRelationshipElement
  },
  {
    L"Submodel",
    types::KeyTypes::kSubmodel
  },
  {
    L"SubmodelElement",
    types::KeyTypes::kSubmodelElement
  },
  {
    L"SubmodelElementCollection",
    types::KeyTypes::kSubmodelElementCollection
  },
  {
    L"SubmodelElementList",
    types::KeyTypes::kSubmodelElementList
  }
};

common::optional<types::KeyTypes> KeyTypesFromWstring(
  const std::wstring& text
) {
  const auto it = kKeyTypesFromWstringMap.find(
    text
  );
  if (it == kKeyTypesFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::KeyTypes MustKeyTypesFromWstring(
  const std::wstring& text
) {
  const auto it = kKeyTypesFromWstringMap.find(
    text
  );
  if (it == kKeyTypesFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected KeyTypes literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::KeyTypes literal
) {
  switch (literal) {
    case types::KeyTypes::kAnnotatedRelationshipElement:
      return L"AnnotatedRelationshipElement";
    case types::KeyTypes::kAssetAdministrationShell:
      return L"AssetAdministrationShell";
    case types::KeyTypes::kBasicEventElement:
      return L"BasicEventElement";
    case types::KeyTypes::kBlob:
      return L"Blob";
    case types::KeyTypes::kCapability:
      return L"Capability";
    case types::KeyTypes::kConceptDescription:
      return L"ConceptDescription";
    case types::KeyTypes::kDataElement:
      return L"DataElement";
    case types::KeyTypes::kEntity:
      return L"Entity";
    case types::KeyTypes::kEventElement:
      return L"EventElement";
    case types::KeyTypes::kFile:
      return L"File";
    case types::KeyTypes::kFragmentReference:
      return L"FragmentReference";
    case types::KeyTypes::kGlobalReference:
      return L"GlobalReference";
    case types::KeyTypes::kIdentifiable:
      return L"Identifiable";
    case types::KeyTypes::kMultiLanguageProperty:
      return L"MultiLanguageProperty";
    case types::KeyTypes::kOperation:
      return L"Operation";
    case types::KeyTypes::kProperty:
      return L"Property";
    case types::KeyTypes::kRange:
      return L"Range";
    case types::KeyTypes::kReferable:
      return L"Referable";
    case types::KeyTypes::kReferenceElement:
      return L"ReferenceElement";
    case types::KeyTypes::kRelationshipElement:
      return L"RelationshipElement";
    case types::KeyTypes::kSubmodel:
      return L"Submodel";
    case types::KeyTypes::kSubmodelElement:
      return L"SubmodelElement";
    case types::KeyTypes::kSubmodelElementCollection:
      return L"SubmodelElementCollection";
    case types::KeyTypes::kSubmodelElementList:
      return L"SubmodelElementList";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected KeyTypes literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::DataTypeDefXsd
> kDataTypeDefXsdFromWstringMap = {
  {
    L"xs:anyURI",
    types::DataTypeDefXsd::kAnyUri
  },
  {
    L"xs:base64Binary",
    types::DataTypeDefXsd::kBase64Binary
  },
  {
    L"xs:boolean",
    types::DataTypeDefXsd::kBoolean
  },
  {
    L"xs:byte",
    types::DataTypeDefXsd::kByte
  },
  {
    L"xs:date",
    types::DataTypeDefXsd::kDate
  },
  {
    L"xs:dateTime",
    types::DataTypeDefXsd::kDateTime
  },
  {
    L"xs:decimal",
    types::DataTypeDefXsd::kDecimal
  },
  {
    L"xs:double",
    types::DataTypeDefXsd::kDouble
  },
  {
    L"xs:duration",
    types::DataTypeDefXsd::kDuration
  },
  {
    L"xs:float",
    types::DataTypeDefXsd::kFloat
  },
  {
    L"xs:gDay",
    types::DataTypeDefXsd::kGDay
  },
  {
    L"xs:gMonth",
    types::DataTypeDefXsd::kGMonth
  },
  {
    L"xs:gMonthDay",
    types::DataTypeDefXsd::kGMonthDay
  },
  {
    L"xs:gYear",
    types::DataTypeDefXsd::kGYear
  },
  {
    L"xs:gYearMonth",
    types::DataTypeDefXsd::kGYearMonth
  },
  {
    L"xs:hexBinary",
    types::DataTypeDefXsd::kHexBinary
  },
  {
    L"xs:int",
    types::DataTypeDefXsd::kInt
  },
  {
    L"xs:integer",
    types::DataTypeDefXsd::kInteger
  },
  {
    L"xs:long",
    types::DataTypeDefXsd::kLong
  },
  {
    L"xs:negativeInteger",
    types::DataTypeDefXsd::kNegativeInteger
  },
  {
    L"xs:nonNegativeInteger",
    types::DataTypeDefXsd::kNonNegativeInteger
  },
  {
    L"xs:nonPositiveInteger",
    types::DataTypeDefXsd::kNonPositiveInteger
  },
  {
    L"xs:positiveInteger",
    types::DataTypeDefXsd::kPositiveInteger
  },
  {
    L"xs:short",
    types::DataTypeDefXsd::kShort
  },
  {
    L"xs:string",
    types::DataTypeDefXsd::kString
  },
  {
    L"xs:time",
    types::DataTypeDefXsd::kTime
  },
  {
    L"xs:unsignedByte",
    types::DataTypeDefXsd::kUnsignedByte
  },
  {
    L"xs:unsignedInt",
    types::DataTypeDefXsd::kUnsignedInt
  },
  {
    L"xs:unsignedLong",
    types::DataTypeDefXsd::kUnsignedLong
  },
  {
    L"xs:unsignedShort",
    types::DataTypeDefXsd::kUnsignedShort
  }
};

common::optional<types::DataTypeDefXsd> DataTypeDefXsdFromWstring(
  const std::wstring& text
) {
  const auto it = kDataTypeDefXsdFromWstringMap.find(
    text
  );
  if (it == kDataTypeDefXsdFromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::DataTypeDefXsd MustDataTypeDefXsdFromWstring(
  const std::wstring& text
) {
  const auto it = kDataTypeDefXsdFromWstringMap.find(
    text
  );
  if (it == kDataTypeDefXsdFromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected DataTypeDefXsd literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::DataTypeDefXsd literal
) {
  switch (literal) {
    case types::DataTypeDefXsd::kAnyUri:
      return L"xs:anyURI";
    case types::DataTypeDefXsd::kBase64Binary:
      return L"xs:base64Binary";
    case types::DataTypeDefXsd::kBoolean:
      return L"xs:boolean";
    case types::DataTypeDefXsd::kByte:
      return L"xs:byte";
    case types::DataTypeDefXsd::kDate:
      return L"xs:date";
    case types::DataTypeDefXsd::kDateTime:
      return L"xs:dateTime";
    case types::DataTypeDefXsd::kDecimal:
      return L"xs:decimal";
    case types::DataTypeDefXsd::kDouble:
      return L"xs:double";
    case types::DataTypeDefXsd::kDuration:
      return L"xs:duration";
    case types::DataTypeDefXsd::kFloat:
      return L"xs:float";
    case types::DataTypeDefXsd::kGDay:
      return L"xs:gDay";
    case types::DataTypeDefXsd::kGMonth:
      return L"xs:gMonth";
    case types::DataTypeDefXsd::kGMonthDay:
      return L"xs:gMonthDay";
    case types::DataTypeDefXsd::kGYear:
      return L"xs:gYear";
    case types::DataTypeDefXsd::kGYearMonth:
      return L"xs:gYearMonth";
    case types::DataTypeDefXsd::kHexBinary:
      return L"xs:hexBinary";
    case types::DataTypeDefXsd::kInt:
      return L"xs:int";
    case types::DataTypeDefXsd::kInteger:
      return L"xs:integer";
    case types::DataTypeDefXsd::kLong:
      return L"xs:long";
    case types::DataTypeDefXsd::kNegativeInteger:
      return L"xs:negativeInteger";
    case types::DataTypeDefXsd::kNonNegativeInteger:
      return L"xs:nonNegativeInteger";
    case types::DataTypeDefXsd::kNonPositiveInteger:
      return L"xs:nonPositiveInteger";
    case types::DataTypeDefXsd::kPositiveInteger:
      return L"xs:positiveInteger";
    case types::DataTypeDefXsd::kShort:
      return L"xs:short";
    case types::DataTypeDefXsd::kString:
      return L"xs:string";
    case types::DataTypeDefXsd::kTime:
      return L"xs:time";
    case types::DataTypeDefXsd::kUnsignedByte:
      return L"xs:unsignedByte";
    case types::DataTypeDefXsd::kUnsignedInt:
      return L"xs:unsignedInt";
    case types::DataTypeDefXsd::kUnsignedLong:
      return L"xs:unsignedLong";
    case types::DataTypeDefXsd::kUnsignedShort:
      return L"xs:unsignedShort";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected DataTypeDefXsd literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

const std::unordered_map<
  std::wstring,
  types::DataTypeIec61360
> kDataTypeIec61360FromWstringMap = {
  {
    L"DATE",
    types::DataTypeIec61360::kDate
  },
  {
    L"STRING",
    types::DataTypeIec61360::kString
  },
  {
    L"STRING_TRANSLATABLE",
    types::DataTypeIec61360::kStringTranslatable
  },
  {
    L"INTEGER_MEASURE",
    types::DataTypeIec61360::kIntegerMeasure
  },
  {
    L"INTEGER_COUNT",
    types::DataTypeIec61360::kIntegerCount
  },
  {
    L"INTEGER_CURRENCY",
    types::DataTypeIec61360::kIntegerCurrency
  },
  {
    L"REAL_MEASURE",
    types::DataTypeIec61360::kRealMeasure
  },
  {
    L"REAL_COUNT",
    types::DataTypeIec61360::kRealCount
  },
  {
    L"REAL_CURRENCY",
    types::DataTypeIec61360::kRealCurrency
  },
  {
    L"BOOLEAN",
    types::DataTypeIec61360::kBoolean
  },
  {
    L"IRI",
    types::DataTypeIec61360::kIri
  },
  {
    L"IRDI",
    types::DataTypeIec61360::kIrdi
  },
  {
    L"RATIONAL",
    types::DataTypeIec61360::kRational
  },
  {
    L"RATIONAL_MEASURE",
    types::DataTypeIec61360::kRationalMeasure
  },
  {
    L"TIME",
    types::DataTypeIec61360::kTime
  },
  {
    L"TIMESTAMP",
    types::DataTypeIec61360::kTimestamp
  },
  {
    L"FILE",
    types::DataTypeIec61360::kFile
  },
  {
    L"HTML",
    types::DataTypeIec61360::kHtml
  },
  {
    L"BLOB",
    types::DataTypeIec61360::kBlob
  }
};

common::optional<types::DataTypeIec61360> DataTypeIec61360FromWstring(
  const std::wstring& text
) {
  const auto it = kDataTypeIec61360FromWstringMap.find(
    text
  );
  if (it == kDataTypeIec61360FromWstringMap.end()) {
    return {};
  }
  return it->second;
}

types::DataTypeIec61360 MustDataTypeIec61360FromWstring(
  const std::wstring& text
) {
  const auto it = kDataTypeIec61360FromWstringMap.find(
    text
  );
  if (it == kDataTypeIec61360FromWstringMap.end()) {
    throw std::invalid_argument(
      common::WstringToUtf8(
        common::Concat(
          L"Unexpected DataTypeIec61360 literal: ",
          text
        )
      )
    );
  }
  return it->second;
}

std::wstring to_wstring(
  types::DataTypeIec61360 literal
) {
  switch (literal) {
    case types::DataTypeIec61360::kDate:
      return L"DATE";
    case types::DataTypeIec61360::kString:
      return L"STRING";
    case types::DataTypeIec61360::kStringTranslatable:
      return L"STRING_TRANSLATABLE";
    case types::DataTypeIec61360::kIntegerMeasure:
      return L"INTEGER_MEASURE";
    case types::DataTypeIec61360::kIntegerCount:
      return L"INTEGER_COUNT";
    case types::DataTypeIec61360::kIntegerCurrency:
      return L"INTEGER_CURRENCY";
    case types::DataTypeIec61360::kRealMeasure:
      return L"REAL_MEASURE";
    case types::DataTypeIec61360::kRealCount:
      return L"REAL_COUNT";
    case types::DataTypeIec61360::kRealCurrency:
      return L"REAL_CURRENCY";
    case types::DataTypeIec61360::kBoolean:
      return L"BOOLEAN";
    case types::DataTypeIec61360::kIri:
      return L"IRI";
    case types::DataTypeIec61360::kIrdi:
      return L"IRDI";
    case types::DataTypeIec61360::kRational:
      return L"RATIONAL";
    case types::DataTypeIec61360::kRationalMeasure:
      return L"RATIONAL_MEASURE";
    case types::DataTypeIec61360::kTime:
      return L"TIME";
    case types::DataTypeIec61360::kTimestamp:
      return L"TIMESTAMP";
    case types::DataTypeIec61360::kFile:
      return L"FILE";
    case types::DataTypeIec61360::kHtml:
      return L"HTML";
    case types::DataTypeIec61360::kBlob:
      return L"BLOB";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected DataTypeIec61360 literal: ",
          std::to_string(
            static_cast<std::uint32_t>(literal)
          )
        )
      );
  }
}

}  // namespace wstringification
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
