// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/stringification.hpp"

#pragma warning(push, 0)
#include <unordered_map>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {
namespace stringification {

const std::unordered_map<
  std::string,
  types::ModelType
> kModelTypeFromStringMap = {
  {
    "Extension",
    types::ModelType::kExtension
  },
  {
    "AdministrativeInformation",
    types::ModelType::kAdministrativeInformation
  },
  {
    "Qualifier",
    types::ModelType::kQualifier
  },
  {
    "AssetAdministrationShell",
    types::ModelType::kAssetAdministrationShell
  },
  {
    "AssetInformation",
    types::ModelType::kAssetInformation
  },
  {
    "Resource",
    types::ModelType::kResource
  },
  {
    "SpecificAssetId",
    types::ModelType::kSpecificAssetId
  },
  {
    "Submodel",
    types::ModelType::kSubmodel
  },
  {
    "RelationshipElement",
    types::ModelType::kRelationshipElement
  },
  {
    "SubmodelElementList",
    types::ModelType::kSubmodelElementList
  },
  {
    "SubmodelElementCollection",
    types::ModelType::kSubmodelElementCollection
  },
  {
    "Property",
    types::ModelType::kProperty
  },
  {
    "MultiLanguageProperty",
    types::ModelType::kMultiLanguageProperty
  },
  {
    "Range",
    types::ModelType::kRange
  },
  {
    "ReferenceElement",
    types::ModelType::kReferenceElement
  },
  {
    "Blob",
    types::ModelType::kBlob
  },
  {
    "File",
    types::ModelType::kFile
  },
  {
    "AnnotatedRelationshipElement",
    types::ModelType::kAnnotatedRelationshipElement
  },
  {
    "Entity",
    types::ModelType::kEntity
  },
  {
    "EventPayload",
    types::ModelType::kEventPayload
  },
  {
    "BasicEventElement",
    types::ModelType::kBasicEventElement
  },
  {
    "Operation",
    types::ModelType::kOperation
  },
  {
    "OperationVariable",
    types::ModelType::kOperationVariable
  },
  {
    "Capability",
    types::ModelType::kCapability
  },
  {
    "ConceptDescription",
    types::ModelType::kConceptDescription
  },
  {
    "Reference",
    types::ModelType::kReference
  },
  {
    "Key",
    types::ModelType::kKey
  },
  {
    "LangStringNameType",
    types::ModelType::kLangStringNameType
  },
  {
    "LangStringTextType",
    types::ModelType::kLangStringTextType
  },
  {
    "Environment",
    types::ModelType::kEnvironment
  },
  {
    "EmbeddedDataSpecification",
    types::ModelType::kEmbeddedDataSpecification
  },
  {
    "LevelType",
    types::ModelType::kLevelType
  },
  {
    "ValueReferencePair",
    types::ModelType::kValueReferencePair
  },
  {
    "ValueList",
    types::ModelType::kValueList
  },
  {
    "LangStringPreferredNameTypeIec61360",
    types::ModelType::kLangStringPreferredNameTypeIec61360
  },
  {
    "LangStringShortNameTypeIec61360",
    types::ModelType::kLangStringShortNameTypeIec61360
  },
  {
    "LangStringDefinitionTypeIec61360",
    types::ModelType::kLangStringDefinitionTypeIec61360
  },
  {
    "DataSpecificationIec61360",
    types::ModelType::kDataSpecificationIec61360
  }
};

common::optional<types::ModelType> ModelTypeFromString(
  const std::string& text
) {
  const auto it = kModelTypeFromStringMap.find(
    text
  );
  if (it == kModelTypeFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::ModelType MustModelTypeFromString(
  const std::string& text
) {
  const auto it = kModelTypeFromStringMap.find(
    text
  );
  if (it == kModelTypeFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::ModelType model_type
) {
  switch (model_type) {
    case types::ModelType::kExtension:
    return "Extension";
    case types::ModelType::kAdministrativeInformation:
    return "AdministrativeInformation";
    case types::ModelType::kQualifier:
    return "Qualifier";
    case types::ModelType::kAssetAdministrationShell:
    return "AssetAdministrationShell";
    case types::ModelType::kAssetInformation:
    return "AssetInformation";
    case types::ModelType::kResource:
    return "Resource";
    case types::ModelType::kSpecificAssetId:
    return "SpecificAssetId";
    case types::ModelType::kSubmodel:
    return "Submodel";
    case types::ModelType::kRelationshipElement:
    return "RelationshipElement";
    case types::ModelType::kSubmodelElementList:
    return "SubmodelElementList";
    case types::ModelType::kSubmodelElementCollection:
    return "SubmodelElementCollection";
    case types::ModelType::kProperty:
    return "Property";
    case types::ModelType::kMultiLanguageProperty:
    return "MultiLanguageProperty";
    case types::ModelType::kRange:
    return "Range";
    case types::ModelType::kReferenceElement:
    return "ReferenceElement";
    case types::ModelType::kBlob:
    return "Blob";
    case types::ModelType::kFile:
    return "File";
    case types::ModelType::kAnnotatedRelationshipElement:
    return "AnnotatedRelationshipElement";
    case types::ModelType::kEntity:
    return "Entity";
    case types::ModelType::kEventPayload:
    return "EventPayload";
    case types::ModelType::kBasicEventElement:
    return "BasicEventElement";
    case types::ModelType::kOperation:
    return "Operation";
    case types::ModelType::kOperationVariable:
    return "OperationVariable";
    case types::ModelType::kCapability:
    return "Capability";
    case types::ModelType::kConceptDescription:
    return "ConceptDescription";
    case types::ModelType::kReference:
    return "Reference";
    case types::ModelType::kKey:
    return "Key";
    case types::ModelType::kLangStringNameType:
    return "LangStringNameType";
    case types::ModelType::kLangStringTextType:
    return "LangStringTextType";
    case types::ModelType::kEnvironment:
    return "Environment";
    case types::ModelType::kEmbeddedDataSpecification:
    return "EmbeddedDataSpecification";
    case types::ModelType::kLevelType:
    return "LevelType";
    case types::ModelType::kValueReferencePair:
    return "ValueReferencePair";
    case types::ModelType::kValueList:
    return "ValueList";
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
    return "LangStringPreferredNameTypeIec61360";
    case types::ModelType::kLangStringShortNameTypeIec61360:
    return "LangStringShortNameTypeIec61360";
    case types::ModelType::kLangStringDefinitionTypeIec61360:
    return "LangStringDefinitionTypeIec61360";
    case types::ModelType::kDataSpecificationIec61360:
    return "DataSpecificationIec61360";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              model_type
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::ModellingKind
> kModellingKindFromStringMap = {
  {
    "Template",
    types::ModellingKind::kTemplate
  },
  {
    "Instance",
    types::ModellingKind::kInstance
  }
};

common::optional<types::ModellingKind> ModellingKindFromString(
  const std::string& text
) {
  const auto it = kModellingKindFromStringMap.find(
    text
  );
  if (it == kModellingKindFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::ModellingKind MustModellingKindFromString(
  const std::string& text
) {
  const auto it = kModellingKindFromStringMap.find(
    text
  );
  if (it == kModellingKindFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::ModellingKind literal
) {
  switch (literal) {
    case types::ModellingKind::kTemplate:
      return "Template";
    case types::ModellingKind::kInstance:
      return "Instance";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::QualifierKind
> kQualifierKindFromStringMap = {
  {
    "ValueQualifier",
    types::QualifierKind::kValueQualifier
  },
  {
    "ConceptQualifier",
    types::QualifierKind::kConceptQualifier
  },
  {
    "TemplateQualifier",
    types::QualifierKind::kTemplateQualifier
  }
};

common::optional<types::QualifierKind> QualifierKindFromString(
  const std::string& text
) {
  const auto it = kQualifierKindFromStringMap.find(
    text
  );
  if (it == kQualifierKindFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::QualifierKind MustQualifierKindFromString(
  const std::string& text
) {
  const auto it = kQualifierKindFromStringMap.find(
    text
  );
  if (it == kQualifierKindFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::QualifierKind literal
) {
  switch (literal) {
    case types::QualifierKind::kValueQualifier:
      return "ValueQualifier";
    case types::QualifierKind::kConceptQualifier:
      return "ConceptQualifier";
    case types::QualifierKind::kTemplateQualifier:
      return "TemplateQualifier";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::AssetKind
> kAssetKindFromStringMap = {
  {
    "Type",
    types::AssetKind::kType
  },
  {
    "Instance",
    types::AssetKind::kInstance
  },
  {
    "NotApplicable",
    types::AssetKind::kNotApplicable
  }
};

common::optional<types::AssetKind> AssetKindFromString(
  const std::string& text
) {
  const auto it = kAssetKindFromStringMap.find(
    text
  );
  if (it == kAssetKindFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::AssetKind MustAssetKindFromString(
  const std::string& text
) {
  const auto it = kAssetKindFromStringMap.find(
    text
  );
  if (it == kAssetKindFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::AssetKind literal
) {
  switch (literal) {
    case types::AssetKind::kType:
      return "Type";
    case types::AssetKind::kInstance:
      return "Instance";
    case types::AssetKind::kNotApplicable:
      return "NotApplicable";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::AasSubmodelElements
> kAasSubmodelElementsFromStringMap = {
  {
    "AnnotatedRelationshipElement",
    types::AasSubmodelElements::kAnnotatedRelationshipElement
  },
  {
    "BasicEventElement",
    types::AasSubmodelElements::kBasicEventElement
  },
  {
    "Blob",
    types::AasSubmodelElements::kBlob
  },
  {
    "Capability",
    types::AasSubmodelElements::kCapability
  },
  {
    "DataElement",
    types::AasSubmodelElements::kDataElement
  },
  {
    "Entity",
    types::AasSubmodelElements::kEntity
  },
  {
    "EventElement",
    types::AasSubmodelElements::kEventElement
  },
  {
    "File",
    types::AasSubmodelElements::kFile
  },
  {
    "MultiLanguageProperty",
    types::AasSubmodelElements::kMultiLanguageProperty
  },
  {
    "Operation",
    types::AasSubmodelElements::kOperation
  },
  {
    "Property",
    types::AasSubmodelElements::kProperty
  },
  {
    "Range",
    types::AasSubmodelElements::kRange
  },
  {
    "ReferenceElement",
    types::AasSubmodelElements::kReferenceElement
  },
  {
    "RelationshipElement",
    types::AasSubmodelElements::kRelationshipElement
  },
  {
    "SubmodelElement",
    types::AasSubmodelElements::kSubmodelElement
  },
  {
    "SubmodelElementList",
    types::AasSubmodelElements::kSubmodelElementList
  },
  {
    "SubmodelElementCollection",
    types::AasSubmodelElements::kSubmodelElementCollection
  }
};

common::optional<types::AasSubmodelElements> AasSubmodelElementsFromString(
  const std::string& text
) {
  const auto it = kAasSubmodelElementsFromStringMap.find(
    text
  );
  if (it == kAasSubmodelElementsFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::AasSubmodelElements MustAasSubmodelElementsFromString(
  const std::string& text
) {
  const auto it = kAasSubmodelElementsFromStringMap.find(
    text
  );
  if (it == kAasSubmodelElementsFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::AasSubmodelElements literal
) {
  switch (literal) {
    case types::AasSubmodelElements::kAnnotatedRelationshipElement:
      return "AnnotatedRelationshipElement";
    case types::AasSubmodelElements::kBasicEventElement:
      return "BasicEventElement";
    case types::AasSubmodelElements::kBlob:
      return "Blob";
    case types::AasSubmodelElements::kCapability:
      return "Capability";
    case types::AasSubmodelElements::kDataElement:
      return "DataElement";
    case types::AasSubmodelElements::kEntity:
      return "Entity";
    case types::AasSubmodelElements::kEventElement:
      return "EventElement";
    case types::AasSubmodelElements::kFile:
      return "File";
    case types::AasSubmodelElements::kMultiLanguageProperty:
      return "MultiLanguageProperty";
    case types::AasSubmodelElements::kOperation:
      return "Operation";
    case types::AasSubmodelElements::kProperty:
      return "Property";
    case types::AasSubmodelElements::kRange:
      return "Range";
    case types::AasSubmodelElements::kReferenceElement:
      return "ReferenceElement";
    case types::AasSubmodelElements::kRelationshipElement:
      return "RelationshipElement";
    case types::AasSubmodelElements::kSubmodelElement:
      return "SubmodelElement";
    case types::AasSubmodelElements::kSubmodelElementList:
      return "SubmodelElementList";
    case types::AasSubmodelElements::kSubmodelElementCollection:
      return "SubmodelElementCollection";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::EntityType
> kEntityTypeFromStringMap = {
  {
    "CoManagedEntity",
    types::EntityType::kCoManagedEntity
  },
  {
    "SelfManagedEntity",
    types::EntityType::kSelfManagedEntity
  }
};

common::optional<types::EntityType> EntityTypeFromString(
  const std::string& text
) {
  const auto it = kEntityTypeFromStringMap.find(
    text
  );
  if (it == kEntityTypeFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::EntityType MustEntityTypeFromString(
  const std::string& text
) {
  const auto it = kEntityTypeFromStringMap.find(
    text
  );
  if (it == kEntityTypeFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::EntityType literal
) {
  switch (literal) {
    case types::EntityType::kCoManagedEntity:
      return "CoManagedEntity";
    case types::EntityType::kSelfManagedEntity:
      return "SelfManagedEntity";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::Direction
> kDirectionFromStringMap = {
  {
    "input",
    types::Direction::kInput
  },
  {
    "output",
    types::Direction::kOutput
  }
};

common::optional<types::Direction> DirectionFromString(
  const std::string& text
) {
  const auto it = kDirectionFromStringMap.find(
    text
  );
  if (it == kDirectionFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::Direction MustDirectionFromString(
  const std::string& text
) {
  const auto it = kDirectionFromStringMap.find(
    text
  );
  if (it == kDirectionFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::Direction literal
) {
  switch (literal) {
    case types::Direction::kInput:
      return "input";
    case types::Direction::kOutput:
      return "output";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::StateOfEvent
> kStateOfEventFromStringMap = {
  {
    "on",
    types::StateOfEvent::kOn
  },
  {
    "off",
    types::StateOfEvent::kOff
  }
};

common::optional<types::StateOfEvent> StateOfEventFromString(
  const std::string& text
) {
  const auto it = kStateOfEventFromStringMap.find(
    text
  );
  if (it == kStateOfEventFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::StateOfEvent MustStateOfEventFromString(
  const std::string& text
) {
  const auto it = kStateOfEventFromStringMap.find(
    text
  );
  if (it == kStateOfEventFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::StateOfEvent literal
) {
  switch (literal) {
    case types::StateOfEvent::kOn:
      return "on";
    case types::StateOfEvent::kOff:
      return "off";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::ReferenceTypes
> kReferenceTypesFromStringMap = {
  {
    "ExternalReference",
    types::ReferenceTypes::kExternalReference
  },
  {
    "ModelReference",
    types::ReferenceTypes::kModelReference
  }
};

common::optional<types::ReferenceTypes> ReferenceTypesFromString(
  const std::string& text
) {
  const auto it = kReferenceTypesFromStringMap.find(
    text
  );
  if (it == kReferenceTypesFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::ReferenceTypes MustReferenceTypesFromString(
  const std::string& text
) {
  const auto it = kReferenceTypesFromStringMap.find(
    text
  );
  if (it == kReferenceTypesFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::ReferenceTypes literal
) {
  switch (literal) {
    case types::ReferenceTypes::kExternalReference:
      return "ExternalReference";
    case types::ReferenceTypes::kModelReference:
      return "ModelReference";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::KeyTypes
> kKeyTypesFromStringMap = {
  {
    "AnnotatedRelationshipElement",
    types::KeyTypes::kAnnotatedRelationshipElement
  },
  {
    "AssetAdministrationShell",
    types::KeyTypes::kAssetAdministrationShell
  },
  {
    "BasicEventElement",
    types::KeyTypes::kBasicEventElement
  },
  {
    "Blob",
    types::KeyTypes::kBlob
  },
  {
    "Capability",
    types::KeyTypes::kCapability
  },
  {
    "ConceptDescription",
    types::KeyTypes::kConceptDescription
  },
  {
    "DataElement",
    types::KeyTypes::kDataElement
  },
  {
    "Entity",
    types::KeyTypes::kEntity
  },
  {
    "EventElement",
    types::KeyTypes::kEventElement
  },
  {
    "File",
    types::KeyTypes::kFile
  },
  {
    "FragmentReference",
    types::KeyTypes::kFragmentReference
  },
  {
    "GlobalReference",
    types::KeyTypes::kGlobalReference
  },
  {
    "Identifiable",
    types::KeyTypes::kIdentifiable
  },
  {
    "MultiLanguageProperty",
    types::KeyTypes::kMultiLanguageProperty
  },
  {
    "Operation",
    types::KeyTypes::kOperation
  },
  {
    "Property",
    types::KeyTypes::kProperty
  },
  {
    "Range",
    types::KeyTypes::kRange
  },
  {
    "Referable",
    types::KeyTypes::kReferable
  },
  {
    "ReferenceElement",
    types::KeyTypes::kReferenceElement
  },
  {
    "RelationshipElement",
    types::KeyTypes::kRelationshipElement
  },
  {
    "Submodel",
    types::KeyTypes::kSubmodel
  },
  {
    "SubmodelElement",
    types::KeyTypes::kSubmodelElement
  },
  {
    "SubmodelElementCollection",
    types::KeyTypes::kSubmodelElementCollection
  },
  {
    "SubmodelElementList",
    types::KeyTypes::kSubmodelElementList
  }
};

common::optional<types::KeyTypes> KeyTypesFromString(
  const std::string& text
) {
  const auto it = kKeyTypesFromStringMap.find(
    text
  );
  if (it == kKeyTypesFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::KeyTypes MustKeyTypesFromString(
  const std::string& text
) {
  const auto it = kKeyTypesFromStringMap.find(
    text
  );
  if (it == kKeyTypesFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::KeyTypes literal
) {
  switch (literal) {
    case types::KeyTypes::kAnnotatedRelationshipElement:
      return "AnnotatedRelationshipElement";
    case types::KeyTypes::kAssetAdministrationShell:
      return "AssetAdministrationShell";
    case types::KeyTypes::kBasicEventElement:
      return "BasicEventElement";
    case types::KeyTypes::kBlob:
      return "Blob";
    case types::KeyTypes::kCapability:
      return "Capability";
    case types::KeyTypes::kConceptDescription:
      return "ConceptDescription";
    case types::KeyTypes::kDataElement:
      return "DataElement";
    case types::KeyTypes::kEntity:
      return "Entity";
    case types::KeyTypes::kEventElement:
      return "EventElement";
    case types::KeyTypes::kFile:
      return "File";
    case types::KeyTypes::kFragmentReference:
      return "FragmentReference";
    case types::KeyTypes::kGlobalReference:
      return "GlobalReference";
    case types::KeyTypes::kIdentifiable:
      return "Identifiable";
    case types::KeyTypes::kMultiLanguageProperty:
      return "MultiLanguageProperty";
    case types::KeyTypes::kOperation:
      return "Operation";
    case types::KeyTypes::kProperty:
      return "Property";
    case types::KeyTypes::kRange:
      return "Range";
    case types::KeyTypes::kReferable:
      return "Referable";
    case types::KeyTypes::kReferenceElement:
      return "ReferenceElement";
    case types::KeyTypes::kRelationshipElement:
      return "RelationshipElement";
    case types::KeyTypes::kSubmodel:
      return "Submodel";
    case types::KeyTypes::kSubmodelElement:
      return "SubmodelElement";
    case types::KeyTypes::kSubmodelElementCollection:
      return "SubmodelElementCollection";
    case types::KeyTypes::kSubmodelElementList:
      return "SubmodelElementList";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::DataTypeDefXsd
> kDataTypeDefXsdFromStringMap = {
  {
    "xs:anyURI",
    types::DataTypeDefXsd::kAnyUri
  },
  {
    "xs:base64Binary",
    types::DataTypeDefXsd::kBase64Binary
  },
  {
    "xs:boolean",
    types::DataTypeDefXsd::kBoolean
  },
  {
    "xs:byte",
    types::DataTypeDefXsd::kByte
  },
  {
    "xs:date",
    types::DataTypeDefXsd::kDate
  },
  {
    "xs:dateTime",
    types::DataTypeDefXsd::kDateTime
  },
  {
    "xs:decimal",
    types::DataTypeDefXsd::kDecimal
  },
  {
    "xs:double",
    types::DataTypeDefXsd::kDouble
  },
  {
    "xs:duration",
    types::DataTypeDefXsd::kDuration
  },
  {
    "xs:float",
    types::DataTypeDefXsd::kFloat
  },
  {
    "xs:gDay",
    types::DataTypeDefXsd::kGDay
  },
  {
    "xs:gMonth",
    types::DataTypeDefXsd::kGMonth
  },
  {
    "xs:gMonthDay",
    types::DataTypeDefXsd::kGMonthDay
  },
  {
    "xs:gYear",
    types::DataTypeDefXsd::kGYear
  },
  {
    "xs:gYearMonth",
    types::DataTypeDefXsd::kGYearMonth
  },
  {
    "xs:hexBinary",
    types::DataTypeDefXsd::kHexBinary
  },
  {
    "xs:int",
    types::DataTypeDefXsd::kInt
  },
  {
    "xs:integer",
    types::DataTypeDefXsd::kInteger
  },
  {
    "xs:long",
    types::DataTypeDefXsd::kLong
  },
  {
    "xs:negativeInteger",
    types::DataTypeDefXsd::kNegativeInteger
  },
  {
    "xs:nonNegativeInteger",
    types::DataTypeDefXsd::kNonNegativeInteger
  },
  {
    "xs:nonPositiveInteger",
    types::DataTypeDefXsd::kNonPositiveInteger
  },
  {
    "xs:positiveInteger",
    types::DataTypeDefXsd::kPositiveInteger
  },
  {
    "xs:short",
    types::DataTypeDefXsd::kShort
  },
  {
    "xs:string",
    types::DataTypeDefXsd::kString
  },
  {
    "xs:time",
    types::DataTypeDefXsd::kTime
  },
  {
    "xs:unsignedByte",
    types::DataTypeDefXsd::kUnsignedByte
  },
  {
    "xs:unsignedInt",
    types::DataTypeDefXsd::kUnsignedInt
  },
  {
    "xs:unsignedLong",
    types::DataTypeDefXsd::kUnsignedLong
  },
  {
    "xs:unsignedShort",
    types::DataTypeDefXsd::kUnsignedShort
  }
};

common::optional<types::DataTypeDefXsd> DataTypeDefXsdFromString(
  const std::string& text
) {
  const auto it = kDataTypeDefXsdFromStringMap.find(
    text
  );
  if (it == kDataTypeDefXsdFromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::DataTypeDefXsd MustDataTypeDefXsdFromString(
  const std::string& text
) {
  const auto it = kDataTypeDefXsdFromStringMap.find(
    text
  );
  if (it == kDataTypeDefXsdFromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::DataTypeDefXsd literal
) {
  switch (literal) {
    case types::DataTypeDefXsd::kAnyUri:
      return "xs:anyURI";
    case types::DataTypeDefXsd::kBase64Binary:
      return "xs:base64Binary";
    case types::DataTypeDefXsd::kBoolean:
      return "xs:boolean";
    case types::DataTypeDefXsd::kByte:
      return "xs:byte";
    case types::DataTypeDefXsd::kDate:
      return "xs:date";
    case types::DataTypeDefXsd::kDateTime:
      return "xs:dateTime";
    case types::DataTypeDefXsd::kDecimal:
      return "xs:decimal";
    case types::DataTypeDefXsd::kDouble:
      return "xs:double";
    case types::DataTypeDefXsd::kDuration:
      return "xs:duration";
    case types::DataTypeDefXsd::kFloat:
      return "xs:float";
    case types::DataTypeDefXsd::kGDay:
      return "xs:gDay";
    case types::DataTypeDefXsd::kGMonth:
      return "xs:gMonth";
    case types::DataTypeDefXsd::kGMonthDay:
      return "xs:gMonthDay";
    case types::DataTypeDefXsd::kGYear:
      return "xs:gYear";
    case types::DataTypeDefXsd::kGYearMonth:
      return "xs:gYearMonth";
    case types::DataTypeDefXsd::kHexBinary:
      return "xs:hexBinary";
    case types::DataTypeDefXsd::kInt:
      return "xs:int";
    case types::DataTypeDefXsd::kInteger:
      return "xs:integer";
    case types::DataTypeDefXsd::kLong:
      return "xs:long";
    case types::DataTypeDefXsd::kNegativeInteger:
      return "xs:negativeInteger";
    case types::DataTypeDefXsd::kNonNegativeInteger:
      return "xs:nonNegativeInteger";
    case types::DataTypeDefXsd::kNonPositiveInteger:
      return "xs:nonPositiveInteger";
    case types::DataTypeDefXsd::kPositiveInteger:
      return "xs:positiveInteger";
    case types::DataTypeDefXsd::kShort:
      return "xs:short";
    case types::DataTypeDefXsd::kString:
      return "xs:string";
    case types::DataTypeDefXsd::kTime:
      return "xs:time";
    case types::DataTypeDefXsd::kUnsignedByte:
      return "xs:unsignedByte";
    case types::DataTypeDefXsd::kUnsignedInt:
      return "xs:unsignedInt";
    case types::DataTypeDefXsd::kUnsignedLong:
      return "xs:unsignedLong";
    case types::DataTypeDefXsd::kUnsignedShort:
      return "xs:unsignedShort";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

const std::unordered_map<
  std::string,
  types::DataTypeIec61360
> kDataTypeIec61360FromStringMap = {
  {
    "DATE",
    types::DataTypeIec61360::kDate
  },
  {
    "STRING",
    types::DataTypeIec61360::kString
  },
  {
    "STRING_TRANSLATABLE",
    types::DataTypeIec61360::kStringTranslatable
  },
  {
    "INTEGER_MEASURE",
    types::DataTypeIec61360::kIntegerMeasure
  },
  {
    "INTEGER_COUNT",
    types::DataTypeIec61360::kIntegerCount
  },
  {
    "INTEGER_CURRENCY",
    types::DataTypeIec61360::kIntegerCurrency
  },
  {
    "REAL_MEASURE",
    types::DataTypeIec61360::kRealMeasure
  },
  {
    "REAL_COUNT",
    types::DataTypeIec61360::kRealCount
  },
  {
    "REAL_CURRENCY",
    types::DataTypeIec61360::kRealCurrency
  },
  {
    "BOOLEAN",
    types::DataTypeIec61360::kBoolean
  },
  {
    "IRI",
    types::DataTypeIec61360::kIri
  },
  {
    "IRDI",
    types::DataTypeIec61360::kIrdi
  },
  {
    "RATIONAL",
    types::DataTypeIec61360::kRational
  },
  {
    "RATIONAL_MEASURE",
    types::DataTypeIec61360::kRationalMeasure
  },
  {
    "TIME",
    types::DataTypeIec61360::kTime
  },
  {
    "TIMESTAMP",
    types::DataTypeIec61360::kTimestamp
  },
  {
    "FILE",
    types::DataTypeIec61360::kFile
  },
  {
    "HTML",
    types::DataTypeIec61360::kHtml
  },
  {
    "BLOB",
    types::DataTypeIec61360::kBlob
  }
};

common::optional<types::DataTypeIec61360> DataTypeIec61360FromString(
  const std::string& text
) {
  const auto it = kDataTypeIec61360FromStringMap.find(
    text
  );
  if (it == kDataTypeIec61360FromStringMap.end()) {
    return {};
  }
  return it->second;
}

types::DataTypeIec61360 MustDataTypeIec61360FromString(
  const std::string& text
) {
  const auto it = kDataTypeIec61360FromStringMap.find(
    text
  );
  if (it == kDataTypeIec61360FromStringMap.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected model type literal: ",
        text
      )
    );
  }
  return it->second;
}

std::string to_string(
  types::DataTypeIec61360 literal
) {
  switch (literal) {
    case types::DataTypeIec61360::kDate:
      return "DATE";
    case types::DataTypeIec61360::kString:
      return "STRING";
    case types::DataTypeIec61360::kStringTranslatable:
      return "STRING_TRANSLATABLE";
    case types::DataTypeIec61360::kIntegerMeasure:
      return "INTEGER_MEASURE";
    case types::DataTypeIec61360::kIntegerCount:
      return "INTEGER_COUNT";
    case types::DataTypeIec61360::kIntegerCurrency:
      return "INTEGER_CURRENCY";
    case types::DataTypeIec61360::kRealMeasure:
      return "REAL_MEASURE";
    case types::DataTypeIec61360::kRealCount:
      return "REAL_COUNT";
    case types::DataTypeIec61360::kRealCurrency:
      return "REAL_CURRENCY";
    case types::DataTypeIec61360::kBoolean:
      return "BOOLEAN";
    case types::DataTypeIec61360::kIri:
      return "IRI";
    case types::DataTypeIec61360::kIrdi:
      return "IRDI";
    case types::DataTypeIec61360::kRational:
      return "RATIONAL";
    case types::DataTypeIec61360::kRationalMeasure:
      return "RATIONAL_MEASURE";
    case types::DataTypeIec61360::kTime:
      return "TIME";
    case types::DataTypeIec61360::kTimestamp:
      return "TIMESTAMP";
    case types::DataTypeIec61360::kFile:
      return "FILE";
    case types::DataTypeIec61360::kHtml:
      return "HTML";
    case types::DataTypeIec61360::kBlob:
      return "BLOB";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected literal: ",
          std::to_string(
            static_cast<std::uint32_t>(
              literal
            )
          )
        )
      );
  }
}

// The following encoder has been adapted from Jouni Malinen <j@w1.fi> to work with
// std::string. The original source code is available at:
// https://web.mit.edu/freebsd/head/contrib/wpa/src/utils/base64.c
//
// See also the following StackOverflow question for a benchmark:
// https://stackoverflow.com/questions/342409/how-do-i-base64-encode-decode-in-c/41094722#41094722

constexpr std::size_t kCharBase64TableLen = 65;
static const unsigned char kCharBase64Table[kCharBase64TableLen](
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
);

std::string Base64Encode(
  const std::vector<std::uint8_t>& bytes
) {
  // See: https://cplusplus.com/reference/vector/vector/data/.
  // The data is guaranteed to be a continuous block in memory.
  const unsigned char* const src(
    bytes.data()
  );

  const std::size_t len = bytes.size();

  // 3-byte blocks to 4-byte
  const std::size_t olen = 4 * ((len + 2) / 3);

  // Integer overflow?
  if (olen < len) {
    throw std::invalid_argument(
      common::Concat(
        "The calculation of the output length overflowed. "
        "The length was: ",
        std::to_string(len),
        ", but the output length was calculated as: ",
        std::to_string(olen)
      )
    );
  }

  std::string out_string;
  out_string.resize(olen);

  unsigned char* out(
    reinterpret_cast<unsigned char*>(
      &out_string[0]
    )
  );

  const unsigned char* const end = src + len;

  const unsigned char* in = src;
  unsigned char* pos = out;

  while (end - in >= 3) {
    *pos++ = kCharBase64Table[in[0] >> 2];
    *pos++ = kCharBase64Table[((in[0] & 0x03) << 4) | (in[1] >> 4)];
    *pos++ = kCharBase64Table[((in[1] & 0x0f) << 2) | (in[2] >> 6)];
    *pos++ = kCharBase64Table[in[2] & 0x3f];
    in += 3;
  }

  if (end - in) {
    *pos++ = kCharBase64Table[in[0] >> 2];

    if (end - in == 1) {
      *pos++ = kCharBase64Table[(in[0] & 0x03) << 4];
      *pos++ = '=';
    } else {
      *pos++ = kCharBase64Table[
        ((in[0] & 0x03) << 4) | (in[1] >> 4)
      ];
      *pos++ = kCharBase64Table[(in[1] & 0x0f) << 2];
    }
    *pos++ = '=';
  }

  return out_string;
}

// The following decoder is vaguely based on:
// https://github.com/danguer/blog-examples/blob/master/js/base64-binary.js,
// https://github.com/niklasvh/base64-arraybuffer/blob/master/src/index.ts and
// https://github.com/beatgammit/base64-js/blob/master/index.js.

std::vector<std::uint8_t> ConstructBase64Lookup() {
  std::vector<std::uint8_t> lookup(256, 255);
  for (std::uint8_t i = 0; i < kCharBase64TableLen; ++i) {
    lookup.at(kCharBase64Table[i]) = i;
  }
  return lookup;
}
const std::vector<std::uint8_t> kBase64Lookup = ConstructBase64Lookup();

common::expected<
  std::vector<std::uint8_t>,
  std::string
> Base64Decode(
  const std::string& text
) {
  if (text.empty()) {
    return std::vector<std::uint8_t>();
  }

  const std::size_t len = text.size();
  std::size_t len_wo_pad = len;

  // NOTE (mristin):
  // Some implementations forget the padding, so we try to be robust and check
  // for the padding manually.
  std::size_t bytes_length = (len * 3) / 4;
  if (text[len - 1] == '=') {
    bytes_length--;
    len_wo_pad--;

    if (text[len - 2] == '=') {
      bytes_length--;
      len_wo_pad--;
    }
  }

  std::vector<std::uint8_t> bytes(bytes_length);

  const std::size_t base64_lookup_len = kBase64Lookup.size();

  std::size_t pointer = 0;

  for (std::size_t i = 0; i < len; i += 4) {
    // NOTE (mristin):
    // Admittedly, this is very verbose code, but we want to be efficient, so we
    // opted for performance over readability here.

    const unsigned char code0 = text[i];
    if (code0 >= base64_lookup_len) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i),
        ": ",
        std::to_string(code0),
        " (code: ",
        std::to_string(static_cast<int>(code0)),
        ")"
      );

      return common::make_unexpected(message);
    }
    const std::uint8_t encoded0 = kBase64Lookup[code0];
    if (encoded0 == 255) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i),
        ": ",
        std::to_string(code0),
        " (code: ",
        std::to_string(static_cast<int>(code0)),
        ")"
      );

      return common::make_unexpected(message);
    }

    const unsigned char code1 = text[i + 1];
    if (code1 >= base64_lookup_len) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 1),
        ": ",
        std::to_string(code1),
        " (code: ",
        std::to_string(static_cast<int>(code1)),
        ")"
      );

      return common::make_unexpected(message);
    }
    const std::uint8_t encoded1 = kBase64Lookup[code1];
    if (encoded1 == 255) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 1),
        ": ",
        std::to_string(code1),
        " (code: ",
        std::to_string(static_cast<int>(code1)),
        ")"
      );

      return common::make_unexpected(message);
    }

    // We map padding to 65, which is the value of "A".
    const unsigned char code2 = i + 2 < len_wo_pad ? text[i + 2] : 65;
    if (code2 >= base64_lookup_len) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 2),
        ": ",
        std::to_string(code2),
        " (code: ",
        std::to_string(static_cast<int>(code2)),
        ")"
      );

      return common::make_unexpected(message);
    }
    const std::uint8_t encoded2 = kBase64Lookup[code2];
    if (encoded2 == 255) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 2),
        ": ",
        std::to_string(code2),
        " (code: ",
        std::to_string(static_cast<int>(code2)),
        ")"
      );

      return common::make_unexpected(message);
    }

    // We map padding to 65, which is the value of 'A'.
    const unsigned char code3 = i + 3 < len_wo_pad ? text[i + 3] : 65;
    if (code3 >= base64_lookup_len) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 3),
        ": ",
        std::to_string(code3),
        " (code: ",
        std::to_string(static_cast<int>(code3)),
        ")"
      );

      return common::make_unexpected(message);
    }
    const std::uint8_t encoded3 = kBase64Lookup[code3];
    if (encoded3 == 255) {
      std::string message = common::Concat(
        "Expected a valid character from base64-encoded string, "
        "but got at index ",
        std::to_string(i + 3),
        ": ",
        std::to_string(code3),
        " (code: ",
        std::to_string(static_cast<int>(code3)),
        ")"
      );

      return common::make_unexpected(message);
    }

    if (pointer >= bytes_length) {
      break;
    }
    bytes[pointer] = (encoded0 << 2) | (encoded1 >> 4);
    pointer++;

    if (pointer >= bytes_length) {
      break;
    }
    bytes[pointer] = ((encoded1 & 15) << 4) | (encoded2 >> 2);
    pointer++;

    if (pointer >= bytes_length) {
      break;
    }
    bytes[pointer] = ((encoded2 & 3) << 6) | (encoded3 & 63);
    pointer++;
  }

  return bytes;
}

}  // namespace stringification
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
