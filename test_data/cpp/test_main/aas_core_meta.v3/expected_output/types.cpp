// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/types.hpp"

namespace aas_core {
namespace aas_3_0 {
namespace types {

// region Extension

Extension::Extension(
  std::wstring name,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<DataTypeDefXsd> value_type,
  common::optional<std::wstring> value,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > refers_to
) {
  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  name_ = std::move(name);

  value_type_ = std::move(value_type);

  value_ = std::move(value);

  refers_to_ = std::move(refers_to);
}

ModelType Extension::model_type() const {
  return ModelType::kExtension;
}

const common::optional<
  std::shared_ptr<IReference>
>& Extension::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Extension::mutable_semantic_id() {
  return semantic_id_;
}

void Extension::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Extension::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Extension::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Extension::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const std::wstring& Extension::name() const {
  return name_;
}

std::wstring& Extension::mutable_name() {
  return name_;
}

void Extension::set_name(
  std::wstring value
) {
  name_ = value;
}

const common::optional<DataTypeDefXsd>& Extension::value_type() const {
  return value_type_;
}

common::optional<DataTypeDefXsd>& Extension::mutable_value_type() {
  return value_type_;
}

void Extension::set_value_type(
  common::optional<DataTypeDefXsd> value
) {
  value_type_ = value;
}

const common::optional<std::wstring>& Extension::value() const {
  return value_;
}

common::optional<std::wstring>& Extension::mutable_value() {
  return value_;
}

void Extension::set_value(
  common::optional<std::wstring> value
) {
  value_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Extension::refers_to() const {
  return refers_to_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Extension::mutable_refers_to() {
  return refers_to_;
}

void Extension::set_refers_to(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  refers_to_ = value;
}

DataTypeDefXsd Extension::ValueTypeOrDefault() const {
  return value_type_.value_or(DataTypeDefXsd::kString);
}

// endregion Extension

// region AdministrativeInformation

AdministrativeInformation::AdministrativeInformation(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<std::wstring> version,
  common::optional<std::wstring> revision,
  common::optional<
    std::shared_ptr<IReference>
  > creator,
  common::optional<std::wstring> template_id
) {
  embedded_data_specifications_ = std::move(embedded_data_specifications);

  version_ = std::move(version);

  revision_ = std::move(revision);

  creator_ = std::move(creator);

  template_id_ = std::move(template_id);
}

ModelType AdministrativeInformation::model_type() const {
  return ModelType::kAdministrativeInformation;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& AdministrativeInformation::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& AdministrativeInformation::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void AdministrativeInformation::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<std::wstring>& AdministrativeInformation::version() const {
  return version_;
}

common::optional<std::wstring>& AdministrativeInformation::mutable_version() {
  return version_;
}

void AdministrativeInformation::set_version(
  common::optional<std::wstring> value
) {
  version_ = value;
}

const common::optional<std::wstring>& AdministrativeInformation::revision() const {
  return revision_;
}

common::optional<std::wstring>& AdministrativeInformation::mutable_revision() {
  return revision_;
}

void AdministrativeInformation::set_revision(
  common::optional<std::wstring> value
) {
  revision_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& AdministrativeInformation::creator() const {
  return creator_;
}

common::optional<
  std::shared_ptr<IReference>
>& AdministrativeInformation::mutable_creator() {
  return creator_;
}

void AdministrativeInformation::set_creator(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  creator_ = value;
}

const common::optional<std::wstring>& AdministrativeInformation::template_id() const {
  return template_id_;
}

common::optional<std::wstring>& AdministrativeInformation::mutable_template_id() {
  return template_id_;
}

void AdministrativeInformation::set_template_id(
  common::optional<std::wstring> value
) {
  template_id_ = value;
}

// endregion AdministrativeInformation

// region Qualifier

Qualifier::Qualifier(
  std::wstring type,
  DataTypeDefXsd value_type,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<QualifierKind> kind,
  common::optional<std::wstring> value,
  common::optional<
    std::shared_ptr<IReference>
  > value_id
) {
  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  type_ = std::move(type);

  value_type_ = value_type;

  kind_ = std::move(kind);

  value_ = std::move(value);

  value_id_ = std::move(value_id);
}

ModelType Qualifier::model_type() const {
  return ModelType::kQualifier;
}

const common::optional<
  std::shared_ptr<IReference>
>& Qualifier::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Qualifier::mutable_semantic_id() {
  return semantic_id_;
}

void Qualifier::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Qualifier::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Qualifier::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Qualifier::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<QualifierKind>& Qualifier::kind() const {
  return kind_;
}

common::optional<QualifierKind>& Qualifier::mutable_kind() {
  return kind_;
}

void Qualifier::set_kind(
  common::optional<QualifierKind> value
) {
  kind_ = value;
}

const std::wstring& Qualifier::type() const {
  return type_;
}

std::wstring& Qualifier::mutable_type() {
  return type_;
}

void Qualifier::set_type(
  std::wstring value
) {
  type_ = value;
}

DataTypeDefXsd Qualifier::value_type() const {
  return value_type_;
}

DataTypeDefXsd& Qualifier::mutable_value_type() {
  return value_type_;
}

void Qualifier::set_value_type(
  DataTypeDefXsd value
) {
  value_type_ = value;
}

const common::optional<std::wstring>& Qualifier::value() const {
  return value_;
}

common::optional<std::wstring>& Qualifier::mutable_value() {
  return value_;
}

void Qualifier::set_value(
  common::optional<std::wstring> value
) {
  value_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Qualifier::value_id() const {
  return value_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Qualifier::mutable_value_id() {
  return value_id_;
}

void Qualifier::set_value_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  value_id_ = value;
}

QualifierKind Qualifier::KindOrDefault() const {
  return kind_.value_or(QualifierKind::kConceptQualifier);
}

// endregion Qualifier

// region AssetAdministrationShell

AssetAdministrationShell::AssetAdministrationShell(
  std::wstring id,
  std::shared_ptr<IAssetInformation> asset_information,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > administration,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::shared_ptr<IReference>
  > derived_from,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > submodels
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  id_ = std::move(id);

  administration_ = std::move(administration);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  derived_from_ = std::move(derived_from);

  asset_information_ = std::move(asset_information);

  submodels_ = std::move(submodels);
}

ModelType AssetAdministrationShell::model_type() const {
  return ModelType::kAssetAdministrationShell;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& AssetAdministrationShell::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& AssetAdministrationShell::mutable_extensions() {
  return extensions_;
}

void AssetAdministrationShell::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& AssetAdministrationShell::category() const {
  return category_;
}

common::optional<std::wstring>& AssetAdministrationShell::mutable_category() {
  return category_;
}

void AssetAdministrationShell::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& AssetAdministrationShell::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& AssetAdministrationShell::mutable_id_short() {
  return id_short_;
}

void AssetAdministrationShell::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& AssetAdministrationShell::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& AssetAdministrationShell::mutable_display_name() {
  return display_name_;
}

void AssetAdministrationShell::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& AssetAdministrationShell::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& AssetAdministrationShell::mutable_description() {
  return description_;
}

void AssetAdministrationShell::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IAdministrativeInformation>
>& AssetAdministrationShell::administration() const {
  return administration_;
}

common::optional<
  std::shared_ptr<IAdministrativeInformation>
>& AssetAdministrationShell::mutable_administration() {
  return administration_;
}

void AssetAdministrationShell::set_administration(
  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > value
) {
  administration_ = value;
}

const std::wstring& AssetAdministrationShell::id() const {
  return id_;
}

std::wstring& AssetAdministrationShell::mutable_id() {
  return id_;
}

void AssetAdministrationShell::set_id(
  std::wstring value
) {
  id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& AssetAdministrationShell::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& AssetAdministrationShell::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void AssetAdministrationShell::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& AssetAdministrationShell::derived_from() const {
  return derived_from_;
}

common::optional<
  std::shared_ptr<IReference>
>& AssetAdministrationShell::mutable_derived_from() {
  return derived_from_;
}

void AssetAdministrationShell::set_derived_from(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  derived_from_ = value;
}

const std::shared_ptr<IAssetInformation>& AssetAdministrationShell::asset_information() const {
  return asset_information_;
}

std::shared_ptr<IAssetInformation>& AssetAdministrationShell::mutable_asset_information() {
  return asset_information_;
}

void AssetAdministrationShell::set_asset_information(
  std::shared_ptr<IAssetInformation> value
) {
  asset_information_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& AssetAdministrationShell::submodels() const {
  return submodels_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& AssetAdministrationShell::mutable_submodels() {
  return submodels_;
}

void AssetAdministrationShell::set_submodels(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  submodels_ = value;
}

// endregion AssetAdministrationShell

// region AssetInformation

AssetInformation::AssetInformation(
  AssetKind asset_kind,
  common::optional<std::wstring> global_asset_id,
  common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  > specific_asset_ids,
  common::optional<std::wstring> asset_type,
  common::optional<
    std::shared_ptr<IResource>
  > default_thumbnail
) {
  asset_kind_ = asset_kind;

  global_asset_id_ = std::move(global_asset_id);

  specific_asset_ids_ = std::move(specific_asset_ids);

  asset_type_ = std::move(asset_type);

  default_thumbnail_ = std::move(default_thumbnail);
}

ModelType AssetInformation::model_type() const {
  return ModelType::kAssetInformation;
}

AssetKind AssetInformation::asset_kind() const {
  return asset_kind_;
}

AssetKind& AssetInformation::mutable_asset_kind() {
  return asset_kind_;
}

void AssetInformation::set_asset_kind(
  AssetKind value
) {
  asset_kind_ = value;
}

const common::optional<std::wstring>& AssetInformation::global_asset_id() const {
  return global_asset_id_;
}

common::optional<std::wstring>& AssetInformation::mutable_global_asset_id() {
  return global_asset_id_;
}

void AssetInformation::set_global_asset_id(
  common::optional<std::wstring> value
) {
  global_asset_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ISpecificAssetId>
  >
>& AssetInformation::specific_asset_ids() const {
  return specific_asset_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<ISpecificAssetId>
  >
>& AssetInformation::mutable_specific_asset_ids() {
  return specific_asset_ids_;
}

void AssetInformation::set_specific_asset_ids(
  common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  > value
) {
  specific_asset_ids_ = value;
}

const common::optional<std::wstring>& AssetInformation::asset_type() const {
  return asset_type_;
}

common::optional<std::wstring>& AssetInformation::mutable_asset_type() {
  return asset_type_;
}

void AssetInformation::set_asset_type(
  common::optional<std::wstring> value
) {
  asset_type_ = value;
}

const common::optional<
  std::shared_ptr<IResource>
>& AssetInformation::default_thumbnail() const {
  return default_thumbnail_;
}

common::optional<
  std::shared_ptr<IResource>
>& AssetInformation::mutable_default_thumbnail() {
  return default_thumbnail_;
}

void AssetInformation::set_default_thumbnail(
  common::optional<
    std::shared_ptr<IResource>
  > value
) {
  default_thumbnail_ = value;
}

// endregion AssetInformation

// region Resource

Resource::Resource(
  std::wstring path,
  common::optional<std::wstring> content_type
) {
  path_ = std::move(path);

  content_type_ = std::move(content_type);
}

ModelType Resource::model_type() const {
  return ModelType::kResource;
}

const std::wstring& Resource::path() const {
  return path_;
}

std::wstring& Resource::mutable_path() {
  return path_;
}

void Resource::set_path(
  std::wstring value
) {
  path_ = value;
}

const common::optional<std::wstring>& Resource::content_type() const {
  return content_type_;
}

common::optional<std::wstring>& Resource::mutable_content_type() {
  return content_type_;
}

void Resource::set_content_type(
  common::optional<std::wstring> value
) {
  content_type_ = value;
}

// endregion Resource

// region SpecificAssetId

SpecificAssetId::SpecificAssetId(
  std::wstring name,
  std::wstring value,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::shared_ptr<IReference>
  > external_subject_id
) {
  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  name_ = std::move(name);

  value_ = std::move(value);

  external_subject_id_ = std::move(external_subject_id);
}

ModelType SpecificAssetId::model_type() const {
  return ModelType::kSpecificAssetId;
}

const common::optional<
  std::shared_ptr<IReference>
>& SpecificAssetId::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& SpecificAssetId::mutable_semantic_id() {
  return semantic_id_;
}

void SpecificAssetId::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& SpecificAssetId::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& SpecificAssetId::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void SpecificAssetId::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const std::wstring& SpecificAssetId::name() const {
  return name_;
}

std::wstring& SpecificAssetId::mutable_name() {
  return name_;
}

void SpecificAssetId::set_name(
  std::wstring value
) {
  name_ = value;
}

const std::wstring& SpecificAssetId::value() const {
  return value_;
}

std::wstring& SpecificAssetId::mutable_value() {
  return value_;
}

void SpecificAssetId::set_value(
  std::wstring value
) {
  value_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& SpecificAssetId::external_subject_id() const {
  return external_subject_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& SpecificAssetId::mutable_external_subject_id() {
  return external_subject_id_;
}

void SpecificAssetId::set_external_subject_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  external_subject_id_ = value;
}

// endregion SpecificAssetId

// region Submodel

Submodel::Submodel(
  std::wstring id,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > administration,
  common::optional<ModellingKind> kind,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > submodel_elements
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  id_ = std::move(id);

  administration_ = std::move(administration);

  kind_ = std::move(kind);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  submodel_elements_ = std::move(submodel_elements);
}

ModelType Submodel::model_type() const {
  return ModelType::kSubmodel;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Submodel::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Submodel::mutable_extensions() {
  return extensions_;
}

void Submodel::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& Submodel::category() const {
  return category_;
}

common::optional<std::wstring>& Submodel::mutable_category() {
  return category_;
}

void Submodel::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& Submodel::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& Submodel::mutable_id_short() {
  return id_short_;
}

void Submodel::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Submodel::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Submodel::mutable_display_name() {
  return display_name_;
}

void Submodel::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Submodel::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Submodel::mutable_description() {
  return description_;
}

void Submodel::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IAdministrativeInformation>
>& Submodel::administration() const {
  return administration_;
}

common::optional<
  std::shared_ptr<IAdministrativeInformation>
>& Submodel::mutable_administration() {
  return administration_;
}

void Submodel::set_administration(
  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > value
) {
  administration_ = value;
}

const std::wstring& Submodel::id() const {
  return id_;
}

std::wstring& Submodel::mutable_id() {
  return id_;
}

void Submodel::set_id(
  std::wstring value
) {
  id_ = value;
}

const common::optional<ModellingKind>& Submodel::kind() const {
  return kind_;
}

common::optional<ModellingKind>& Submodel::mutable_kind() {
  return kind_;
}

void Submodel::set_kind(
  common::optional<ModellingKind> value
) {
  kind_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Submodel::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Submodel::mutable_semantic_id() {
  return semantic_id_;
}

void Submodel::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Submodel::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Submodel::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Submodel::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Submodel::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Submodel::mutable_qualifiers() {
  return qualifiers_;
}

void Submodel::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Submodel::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Submodel::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void Submodel::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ISubmodelElement>
  >
>& Submodel::submodel_elements() const {
  return submodel_elements_;
}

common::optional<
  std::vector<
    std::shared_ptr<ISubmodelElement>
  >
>& Submodel::mutable_submodel_elements() {
  return submodel_elements_;
}

void Submodel::set_submodel_elements(
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > value
) {
  submodel_elements_ = value;
}

ModellingKind Submodel::KindOrDefault() const {
  return kind_.value_or(ModellingKind::kInstance);
}

// endregion Submodel

// region RelationshipElement

RelationshipElement::RelationshipElement(
  std::shared_ptr<IReference> first,
  std::shared_ptr<IReference> second,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  first_ = std::move(first);

  second_ = std::move(second);
}

ModelType RelationshipElement::model_type() const {
  return ModelType::kRelationshipElement;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& RelationshipElement::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& RelationshipElement::mutable_extensions() {
  return extensions_;
}

void RelationshipElement::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& RelationshipElement::category() const {
  return category_;
}

common::optional<std::wstring>& RelationshipElement::mutable_category() {
  return category_;
}

void RelationshipElement::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& RelationshipElement::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& RelationshipElement::mutable_id_short() {
  return id_short_;
}

void RelationshipElement::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& RelationshipElement::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& RelationshipElement::mutable_display_name() {
  return display_name_;
}

void RelationshipElement::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& RelationshipElement::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& RelationshipElement::mutable_description() {
  return description_;
}

void RelationshipElement::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& RelationshipElement::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& RelationshipElement::mutable_semantic_id() {
  return semantic_id_;
}

void RelationshipElement::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& RelationshipElement::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& RelationshipElement::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void RelationshipElement::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& RelationshipElement::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& RelationshipElement::mutable_qualifiers() {
  return qualifiers_;
}

void RelationshipElement::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& RelationshipElement::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& RelationshipElement::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void RelationshipElement::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const std::shared_ptr<IReference>& RelationshipElement::first() const {
  return first_;
}

std::shared_ptr<IReference>& RelationshipElement::mutable_first() {
  return first_;
}

void RelationshipElement::set_first(
  std::shared_ptr<IReference> value
) {
  first_ = value;
}

const std::shared_ptr<IReference>& RelationshipElement::second() const {
  return second_;
}

std::shared_ptr<IReference>& RelationshipElement::mutable_second() {
  return second_;
}

void RelationshipElement::set_second(
  std::shared_ptr<IReference> value
) {
  second_ = value;
}

// endregion RelationshipElement

// region SubmodelElementList

SubmodelElementList::SubmodelElementList(
  AasSubmodelElements type_value_list_element,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<bool> order_relevant,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_list_element,
  common::optional<DataTypeDefXsd> value_type_list_element,
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > value
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  type_value_list_element_ = type_value_list_element;

  order_relevant_ = std::move(order_relevant);

  semantic_id_list_element_ = std::move(semantic_id_list_element);

  value_type_list_element_ = std::move(value_type_list_element);

  value_ = std::move(value);
}

ModelType SubmodelElementList::model_type() const {
  return ModelType::kSubmodelElementList;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& SubmodelElementList::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& SubmodelElementList::mutable_extensions() {
  return extensions_;
}

void SubmodelElementList::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& SubmodelElementList::category() const {
  return category_;
}

common::optional<std::wstring>& SubmodelElementList::mutable_category() {
  return category_;
}

void SubmodelElementList::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& SubmodelElementList::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& SubmodelElementList::mutable_id_short() {
  return id_short_;
}

void SubmodelElementList::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& SubmodelElementList::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& SubmodelElementList::mutable_display_name() {
  return display_name_;
}

void SubmodelElementList::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& SubmodelElementList::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& SubmodelElementList::mutable_description() {
  return description_;
}

void SubmodelElementList::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& SubmodelElementList::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& SubmodelElementList::mutable_semantic_id() {
  return semantic_id_;
}

void SubmodelElementList::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& SubmodelElementList::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& SubmodelElementList::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void SubmodelElementList::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& SubmodelElementList::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& SubmodelElementList::mutable_qualifiers() {
  return qualifiers_;
}

void SubmodelElementList::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& SubmodelElementList::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& SubmodelElementList::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void SubmodelElementList::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<bool>& SubmodelElementList::order_relevant() const {
  return order_relevant_;
}

common::optional<bool>& SubmodelElementList::mutable_order_relevant() {
  return order_relevant_;
}

void SubmodelElementList::set_order_relevant(
  common::optional<bool> value
) {
  order_relevant_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& SubmodelElementList::semantic_id_list_element() const {
  return semantic_id_list_element_;
}

common::optional<
  std::shared_ptr<IReference>
>& SubmodelElementList::mutable_semantic_id_list_element() {
  return semantic_id_list_element_;
}

void SubmodelElementList::set_semantic_id_list_element(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_list_element_ = value;
}

AasSubmodelElements SubmodelElementList::type_value_list_element() const {
  return type_value_list_element_;
}

AasSubmodelElements& SubmodelElementList::mutable_type_value_list_element() {
  return type_value_list_element_;
}

void SubmodelElementList::set_type_value_list_element(
  AasSubmodelElements value
) {
  type_value_list_element_ = value;
}

const common::optional<DataTypeDefXsd>& SubmodelElementList::value_type_list_element() const {
  return value_type_list_element_;
}

common::optional<DataTypeDefXsd>& SubmodelElementList::mutable_value_type_list_element() {
  return value_type_list_element_;
}

void SubmodelElementList::set_value_type_list_element(
  common::optional<DataTypeDefXsd> value
) {
  value_type_list_element_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ISubmodelElement>
  >
>& SubmodelElementList::value() const {
  return value_;
}

common::optional<
  std::vector<
    std::shared_ptr<ISubmodelElement>
  >
>& SubmodelElementList::mutable_value() {
  return value_;
}

void SubmodelElementList::set_value(
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > value
) {
  value_ = value;
}

bool SubmodelElementList::OrderRelevantOrDefault() const {
  return order_relevant_.value_or(true);
}

// endregion SubmodelElementList

// region SubmodelElementCollection

SubmodelElementCollection::SubmodelElementCollection(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > value
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  value_ = std::move(value);
}

ModelType SubmodelElementCollection::model_type() const {
  return ModelType::kSubmodelElementCollection;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& SubmodelElementCollection::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& SubmodelElementCollection::mutable_extensions() {
  return extensions_;
}

void SubmodelElementCollection::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& SubmodelElementCollection::category() const {
  return category_;
}

common::optional<std::wstring>& SubmodelElementCollection::mutable_category() {
  return category_;
}

void SubmodelElementCollection::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& SubmodelElementCollection::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& SubmodelElementCollection::mutable_id_short() {
  return id_short_;
}

void SubmodelElementCollection::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& SubmodelElementCollection::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& SubmodelElementCollection::mutable_display_name() {
  return display_name_;
}

void SubmodelElementCollection::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& SubmodelElementCollection::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& SubmodelElementCollection::mutable_description() {
  return description_;
}

void SubmodelElementCollection::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& SubmodelElementCollection::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& SubmodelElementCollection::mutable_semantic_id() {
  return semantic_id_;
}

void SubmodelElementCollection::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& SubmodelElementCollection::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& SubmodelElementCollection::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void SubmodelElementCollection::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& SubmodelElementCollection::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& SubmodelElementCollection::mutable_qualifiers() {
  return qualifiers_;
}

void SubmodelElementCollection::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& SubmodelElementCollection::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& SubmodelElementCollection::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void SubmodelElementCollection::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ISubmodelElement>
  >
>& SubmodelElementCollection::value() const {
  return value_;
}

common::optional<
  std::vector<
    std::shared_ptr<ISubmodelElement>
  >
>& SubmodelElementCollection::mutable_value() {
  return value_;
}

void SubmodelElementCollection::set_value(
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > value
) {
  value_ = value;
}

// endregion SubmodelElementCollection

// region Property

Property::Property(
  DataTypeDefXsd value_type,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<std::wstring> value,
  common::optional<
    std::shared_ptr<IReference>
  > value_id
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  value_type_ = value_type;

  value_ = std::move(value);

  value_id_ = std::move(value_id);
}

ModelType Property::model_type() const {
  return ModelType::kProperty;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Property::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Property::mutable_extensions() {
  return extensions_;
}

void Property::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& Property::category() const {
  return category_;
}

common::optional<std::wstring>& Property::mutable_category() {
  return category_;
}

void Property::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& Property::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& Property::mutable_id_short() {
  return id_short_;
}

void Property::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Property::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Property::mutable_display_name() {
  return display_name_;
}

void Property::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Property::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Property::mutable_description() {
  return description_;
}

void Property::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Property::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Property::mutable_semantic_id() {
  return semantic_id_;
}

void Property::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Property::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Property::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Property::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Property::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Property::mutable_qualifiers() {
  return qualifiers_;
}

void Property::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Property::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Property::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void Property::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

DataTypeDefXsd Property::value_type() const {
  return value_type_;
}

DataTypeDefXsd& Property::mutable_value_type() {
  return value_type_;
}

void Property::set_value_type(
  DataTypeDefXsd value
) {
  value_type_ = value;
}

const common::optional<std::wstring>& Property::value() const {
  return value_;
}

common::optional<std::wstring>& Property::mutable_value() {
  return value_;
}

void Property::set_value(
  common::optional<std::wstring> value
) {
  value_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Property::value_id() const {
  return value_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Property::mutable_value_id() {
  return value_id_;
}

void Property::set_value_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  value_id_ = value;
}

std::wstring Property::CategoryOrDefault() const {
  std::wstring result = category_.value_or(L"VARIABLE");

  #ifdef DEBUG
  if (!constants::kValidCategoriesForDataElement.contains(result)) {
    std::wstringstream wss;
    wss
      << L"Unexpected default category: "
      << result;

    throw std::logic_error(
      common::WstringToUtf8(wss.str())
    );
  }
  #endif

  return result;
}

// endregion Property

// region MultiLanguageProperty

MultiLanguageProperty::MultiLanguageProperty(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value,
  common::optional<
    std::shared_ptr<IReference>
  > value_id
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  value_ = std::move(value);

  value_id_ = std::move(value_id);
}

ModelType MultiLanguageProperty::model_type() const {
  return ModelType::kMultiLanguageProperty;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& MultiLanguageProperty::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& MultiLanguageProperty::mutable_extensions() {
  return extensions_;
}

void MultiLanguageProperty::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& MultiLanguageProperty::category() const {
  return category_;
}

common::optional<std::wstring>& MultiLanguageProperty::mutable_category() {
  return category_;
}

void MultiLanguageProperty::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& MultiLanguageProperty::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& MultiLanguageProperty::mutable_id_short() {
  return id_short_;
}

void MultiLanguageProperty::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& MultiLanguageProperty::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& MultiLanguageProperty::mutable_display_name() {
  return display_name_;
}

void MultiLanguageProperty::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& MultiLanguageProperty::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& MultiLanguageProperty::mutable_description() {
  return description_;
}

void MultiLanguageProperty::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& MultiLanguageProperty::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& MultiLanguageProperty::mutable_semantic_id() {
  return semantic_id_;
}

void MultiLanguageProperty::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& MultiLanguageProperty::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& MultiLanguageProperty::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void MultiLanguageProperty::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& MultiLanguageProperty::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& MultiLanguageProperty::mutable_qualifiers() {
  return qualifiers_;
}

void MultiLanguageProperty::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& MultiLanguageProperty::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& MultiLanguageProperty::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void MultiLanguageProperty::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& MultiLanguageProperty::value() const {
  return value_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& MultiLanguageProperty::mutable_value() {
  return value_;
}

void MultiLanguageProperty::set_value(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  value_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& MultiLanguageProperty::value_id() const {
  return value_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& MultiLanguageProperty::mutable_value_id() {
  return value_id_;
}

void MultiLanguageProperty::set_value_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  value_id_ = value;
}

std::wstring MultiLanguageProperty::CategoryOrDefault() const {
  std::wstring result = category_.value_or(L"VARIABLE");

  #ifdef DEBUG
  if (!constants::kValidCategoriesForDataElement.contains(result)) {
    std::wstringstream wss;
    wss
      << L"Unexpected default category: "
      << result;

    throw std::logic_error(
      common::WstringToUtf8(wss.str())
    );
  }
  #endif

  return result;
}

// endregion MultiLanguageProperty

// region Range

Range::Range(
  DataTypeDefXsd value_type,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<std::wstring> min,
  common::optional<std::wstring> max
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  value_type_ = value_type;

  min_ = std::move(min);

  max_ = std::move(max);
}

ModelType Range::model_type() const {
  return ModelType::kRange;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Range::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Range::mutable_extensions() {
  return extensions_;
}

void Range::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& Range::category() const {
  return category_;
}

common::optional<std::wstring>& Range::mutable_category() {
  return category_;
}

void Range::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& Range::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& Range::mutable_id_short() {
  return id_short_;
}

void Range::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Range::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Range::mutable_display_name() {
  return display_name_;
}

void Range::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Range::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Range::mutable_description() {
  return description_;
}

void Range::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Range::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Range::mutable_semantic_id() {
  return semantic_id_;
}

void Range::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Range::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Range::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Range::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Range::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Range::mutable_qualifiers() {
  return qualifiers_;
}

void Range::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Range::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Range::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void Range::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

DataTypeDefXsd Range::value_type() const {
  return value_type_;
}

DataTypeDefXsd& Range::mutable_value_type() {
  return value_type_;
}

void Range::set_value_type(
  DataTypeDefXsd value
) {
  value_type_ = value;
}

const common::optional<std::wstring>& Range::min() const {
  return min_;
}

common::optional<std::wstring>& Range::mutable_min() {
  return min_;
}

void Range::set_min(
  common::optional<std::wstring> value
) {
  min_ = value;
}

const common::optional<std::wstring>& Range::max() const {
  return max_;
}

common::optional<std::wstring>& Range::mutable_max() {
  return max_;
}

void Range::set_max(
  common::optional<std::wstring> value
) {
  max_ = value;
}

std::wstring Range::CategoryOrDefault() const {
  std::wstring result = category_.value_or(L"VARIABLE");

  #ifdef DEBUG
  if (!constants::kValidCategoriesForDataElement.contains(result)) {
    std::wstringstream wss;
    wss
      << L"Unexpected default category: "
      << result;

    throw std::logic_error(
      common::WstringToUtf8(wss.str())
    );
  }
  #endif

  return result;
}

// endregion Range

// region ReferenceElement

ReferenceElement::ReferenceElement(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  value_ = std::move(value);
}

ModelType ReferenceElement::model_type() const {
  return ModelType::kReferenceElement;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& ReferenceElement::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& ReferenceElement::mutable_extensions() {
  return extensions_;
}

void ReferenceElement::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& ReferenceElement::category() const {
  return category_;
}

common::optional<std::wstring>& ReferenceElement::mutable_category() {
  return category_;
}

void ReferenceElement::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& ReferenceElement::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& ReferenceElement::mutable_id_short() {
  return id_short_;
}

void ReferenceElement::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& ReferenceElement::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& ReferenceElement::mutable_display_name() {
  return display_name_;
}

void ReferenceElement::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& ReferenceElement::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& ReferenceElement::mutable_description() {
  return description_;
}

void ReferenceElement::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& ReferenceElement::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& ReferenceElement::mutable_semantic_id() {
  return semantic_id_;
}

void ReferenceElement::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& ReferenceElement::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& ReferenceElement::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void ReferenceElement::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& ReferenceElement::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& ReferenceElement::mutable_qualifiers() {
  return qualifiers_;
}

void ReferenceElement::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& ReferenceElement::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& ReferenceElement::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void ReferenceElement::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& ReferenceElement::value() const {
  return value_;
}

common::optional<
  std::shared_ptr<IReference>
>& ReferenceElement::mutable_value() {
  return value_;
}

void ReferenceElement::set_value(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  value_ = value;
}

std::wstring ReferenceElement::CategoryOrDefault() const {
  std::wstring result = category_.value_or(L"VARIABLE");

  #ifdef DEBUG
  if (!constants::kValidCategoriesForDataElement.contains(result)) {
    std::wstringstream wss;
    wss
      << L"Unexpected default category: "
      << result;

    throw std::logic_error(
      common::WstringToUtf8(wss.str())
    );
  }
  #endif

  return result;
}

// endregion ReferenceElement

// region Blob

Blob::Blob(
  std::wstring content_type,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::vector<std::uint8_t>
  > value
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  content_type_ = std::move(content_type);

  value_ = std::move(value);
}

ModelType Blob::model_type() const {
  return ModelType::kBlob;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Blob::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Blob::mutable_extensions() {
  return extensions_;
}

void Blob::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& Blob::category() const {
  return category_;
}

common::optional<std::wstring>& Blob::mutable_category() {
  return category_;
}

void Blob::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& Blob::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& Blob::mutable_id_short() {
  return id_short_;
}

void Blob::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Blob::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Blob::mutable_display_name() {
  return display_name_;
}

void Blob::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Blob::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Blob::mutable_description() {
  return description_;
}

void Blob::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Blob::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Blob::mutable_semantic_id() {
  return semantic_id_;
}

void Blob::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Blob::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Blob::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Blob::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Blob::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Blob::mutable_qualifiers() {
  return qualifiers_;
}

void Blob::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Blob::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Blob::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void Blob::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::vector<std::uint8_t>
>& Blob::value() const {
  return value_;
}

common::optional<
  std::vector<std::uint8_t>
>& Blob::mutable_value() {
  return value_;
}

void Blob::set_value(
  common::optional<
    std::vector<std::uint8_t>
  > value
) {
  value_ = value;
}

const std::wstring& Blob::content_type() const {
  return content_type_;
}

std::wstring& Blob::mutable_content_type() {
  return content_type_;
}

void Blob::set_content_type(
  std::wstring value
) {
  content_type_ = value;
}

std::wstring Blob::CategoryOrDefault() const {
  std::wstring result = category_.value_or(L"VARIABLE");

  #ifdef DEBUG
  if (!constants::kValidCategoriesForDataElement.contains(result)) {
    std::wstringstream wss;
    wss
      << L"Unexpected default category: "
      << result;

    throw std::logic_error(
      common::WstringToUtf8(wss.str())
    );
  }
  #endif

  return result;
}

// endregion Blob

// region File

File::File(
  std::wstring content_type,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<std::wstring> value
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  content_type_ = std::move(content_type);

  value_ = std::move(value);
}

ModelType File::model_type() const {
  return ModelType::kFile;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& File::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& File::mutable_extensions() {
  return extensions_;
}

void File::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& File::category() const {
  return category_;
}

common::optional<std::wstring>& File::mutable_category() {
  return category_;
}

void File::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& File::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& File::mutable_id_short() {
  return id_short_;
}

void File::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& File::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& File::mutable_display_name() {
  return display_name_;
}

void File::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& File::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& File::mutable_description() {
  return description_;
}

void File::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& File::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& File::mutable_semantic_id() {
  return semantic_id_;
}

void File::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& File::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& File::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void File::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& File::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& File::mutable_qualifiers() {
  return qualifiers_;
}

void File::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& File::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& File::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void File::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<std::wstring>& File::value() const {
  return value_;
}

common::optional<std::wstring>& File::mutable_value() {
  return value_;
}

void File::set_value(
  common::optional<std::wstring> value
) {
  value_ = value;
}

const std::wstring& File::content_type() const {
  return content_type_;
}

std::wstring& File::mutable_content_type() {
  return content_type_;
}

void File::set_content_type(
  std::wstring value
) {
  content_type_ = value;
}

std::wstring File::CategoryOrDefault() const {
  std::wstring result = category_.value_or(L"VARIABLE");

  #ifdef DEBUG
  if (!constants::kValidCategoriesForDataElement.contains(result)) {
    std::wstringstream wss;
    wss
      << L"Unexpected default category: "
      << result;

    throw std::logic_error(
      common::WstringToUtf8(wss.str())
    );
  }
  #endif

  return result;
}

// endregion File

// region AnnotatedRelationshipElement

AnnotatedRelationshipElement::AnnotatedRelationshipElement(
  std::shared_ptr<IReference> first,
  std::shared_ptr<IReference> second,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::vector<
      std::shared_ptr<IDataElement>
    >
  > annotations
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  first_ = std::move(first);

  second_ = std::move(second);

  annotations_ = std::move(annotations);
}

ModelType AnnotatedRelationshipElement::model_type() const {
  return ModelType::kAnnotatedRelationshipElement;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& AnnotatedRelationshipElement::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& AnnotatedRelationshipElement::mutable_extensions() {
  return extensions_;
}

void AnnotatedRelationshipElement::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& AnnotatedRelationshipElement::category() const {
  return category_;
}

common::optional<std::wstring>& AnnotatedRelationshipElement::mutable_category() {
  return category_;
}

void AnnotatedRelationshipElement::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& AnnotatedRelationshipElement::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& AnnotatedRelationshipElement::mutable_id_short() {
  return id_short_;
}

void AnnotatedRelationshipElement::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& AnnotatedRelationshipElement::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& AnnotatedRelationshipElement::mutable_display_name() {
  return display_name_;
}

void AnnotatedRelationshipElement::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& AnnotatedRelationshipElement::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& AnnotatedRelationshipElement::mutable_description() {
  return description_;
}

void AnnotatedRelationshipElement::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& AnnotatedRelationshipElement::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& AnnotatedRelationshipElement::mutable_semantic_id() {
  return semantic_id_;
}

void AnnotatedRelationshipElement::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& AnnotatedRelationshipElement::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& AnnotatedRelationshipElement::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void AnnotatedRelationshipElement::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& AnnotatedRelationshipElement::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& AnnotatedRelationshipElement::mutable_qualifiers() {
  return qualifiers_;
}

void AnnotatedRelationshipElement::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& AnnotatedRelationshipElement::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& AnnotatedRelationshipElement::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void AnnotatedRelationshipElement::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const std::shared_ptr<IReference>& AnnotatedRelationshipElement::first() const {
  return first_;
}

std::shared_ptr<IReference>& AnnotatedRelationshipElement::mutable_first() {
  return first_;
}

void AnnotatedRelationshipElement::set_first(
  std::shared_ptr<IReference> value
) {
  first_ = value;
}

const std::shared_ptr<IReference>& AnnotatedRelationshipElement::second() const {
  return second_;
}

std::shared_ptr<IReference>& AnnotatedRelationshipElement::mutable_second() {
  return second_;
}

void AnnotatedRelationshipElement::set_second(
  std::shared_ptr<IReference> value
) {
  second_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IDataElement>
  >
>& AnnotatedRelationshipElement::annotations() const {
  return annotations_;
}

common::optional<
  std::vector<
    std::shared_ptr<IDataElement>
  >
>& AnnotatedRelationshipElement::mutable_annotations() {
  return annotations_;
}

void AnnotatedRelationshipElement::set_annotations(
  common::optional<
    std::vector<
      std::shared_ptr<IDataElement>
    >
  > value
) {
  annotations_ = value;
}

// endregion AnnotatedRelationshipElement

// region Entity

Entity::Entity(
  EntityType entity_type,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > statements,
  common::optional<std::wstring> global_asset_id,
  common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  > specific_asset_ids
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  statements_ = std::move(statements);

  entity_type_ = entity_type;

  global_asset_id_ = std::move(global_asset_id);

  specific_asset_ids_ = std::move(specific_asset_ids);
}

ModelType Entity::model_type() const {
  return ModelType::kEntity;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Entity::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Entity::mutable_extensions() {
  return extensions_;
}

void Entity::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& Entity::category() const {
  return category_;
}

common::optional<std::wstring>& Entity::mutable_category() {
  return category_;
}

void Entity::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& Entity::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& Entity::mutable_id_short() {
  return id_short_;
}

void Entity::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Entity::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Entity::mutable_display_name() {
  return display_name_;
}

void Entity::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Entity::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Entity::mutable_description() {
  return description_;
}

void Entity::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Entity::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Entity::mutable_semantic_id() {
  return semantic_id_;
}

void Entity::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Entity::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Entity::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Entity::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Entity::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Entity::mutable_qualifiers() {
  return qualifiers_;
}

void Entity::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Entity::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Entity::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void Entity::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ISubmodelElement>
  >
>& Entity::statements() const {
  return statements_;
}

common::optional<
  std::vector<
    std::shared_ptr<ISubmodelElement>
  >
>& Entity::mutable_statements() {
  return statements_;
}

void Entity::set_statements(
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > value
) {
  statements_ = value;
}

EntityType Entity::entity_type() const {
  return entity_type_;
}

EntityType& Entity::mutable_entity_type() {
  return entity_type_;
}

void Entity::set_entity_type(
  EntityType value
) {
  entity_type_ = value;
}

const common::optional<std::wstring>& Entity::global_asset_id() const {
  return global_asset_id_;
}

common::optional<std::wstring>& Entity::mutable_global_asset_id() {
  return global_asset_id_;
}

void Entity::set_global_asset_id(
  common::optional<std::wstring> value
) {
  global_asset_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ISpecificAssetId>
  >
>& Entity::specific_asset_ids() const {
  return specific_asset_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<ISpecificAssetId>
  >
>& Entity::mutable_specific_asset_ids() {
  return specific_asset_ids_;
}

void Entity::set_specific_asset_ids(
  common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  > value
) {
  specific_asset_ids_ = value;
}

// endregion Entity

// region EventPayload

EventPayload::EventPayload(
  std::shared_ptr<IReference> source,
  std::shared_ptr<IReference> observable_reference,
  std::wstring time_stamp,
  common::optional<
    std::shared_ptr<IReference>
  > source_semantic_id,
  common::optional<
    std::shared_ptr<IReference>
  > observable_semantic_id,
  common::optional<std::wstring> topic,
  common::optional<
    std::shared_ptr<IReference>
  > subject_id,
  common::optional<
    std::vector<std::uint8_t>
  > payload
) {
  source_ = std::move(source);

  observable_reference_ = std::move(observable_reference);

  time_stamp_ = std::move(time_stamp);

  source_semantic_id_ = std::move(source_semantic_id);

  observable_semantic_id_ = std::move(observable_semantic_id);

  topic_ = std::move(topic);

  subject_id_ = std::move(subject_id);

  payload_ = std::move(payload);
}

ModelType EventPayload::model_type() const {
  return ModelType::kEventPayload;
}

const std::shared_ptr<IReference>& EventPayload::source() const {
  return source_;
}

std::shared_ptr<IReference>& EventPayload::mutable_source() {
  return source_;
}

void EventPayload::set_source(
  std::shared_ptr<IReference> value
) {
  source_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& EventPayload::source_semantic_id() const {
  return source_semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& EventPayload::mutable_source_semantic_id() {
  return source_semantic_id_;
}

void EventPayload::set_source_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  source_semantic_id_ = value;
}

const std::shared_ptr<IReference>& EventPayload::observable_reference() const {
  return observable_reference_;
}

std::shared_ptr<IReference>& EventPayload::mutable_observable_reference() {
  return observable_reference_;
}

void EventPayload::set_observable_reference(
  std::shared_ptr<IReference> value
) {
  observable_reference_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& EventPayload::observable_semantic_id() const {
  return observable_semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& EventPayload::mutable_observable_semantic_id() {
  return observable_semantic_id_;
}

void EventPayload::set_observable_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  observable_semantic_id_ = value;
}

const common::optional<std::wstring>& EventPayload::topic() const {
  return topic_;
}

common::optional<std::wstring>& EventPayload::mutable_topic() {
  return topic_;
}

void EventPayload::set_topic(
  common::optional<std::wstring> value
) {
  topic_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& EventPayload::subject_id() const {
  return subject_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& EventPayload::mutable_subject_id() {
  return subject_id_;
}

void EventPayload::set_subject_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  subject_id_ = value;
}

const std::wstring& EventPayload::time_stamp() const {
  return time_stamp_;
}

std::wstring& EventPayload::mutable_time_stamp() {
  return time_stamp_;
}

void EventPayload::set_time_stamp(
  std::wstring value
) {
  time_stamp_ = value;
}

const common::optional<
  std::vector<std::uint8_t>
>& EventPayload::payload() const {
  return payload_;
}

common::optional<
  std::vector<std::uint8_t>
>& EventPayload::mutable_payload() {
  return payload_;
}

void EventPayload::set_payload(
  common::optional<
    std::vector<std::uint8_t>
  > value
) {
  payload_ = value;
}

// endregion EventPayload

// region BasicEventElement

BasicEventElement::BasicEventElement(
  std::shared_ptr<IReference> observed,
  Direction direction,
  StateOfEvent state,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<std::wstring> message_topic,
  common::optional<
    std::shared_ptr<IReference>
  > message_broker,
  common::optional<std::wstring> last_update,
  common::optional<std::wstring> min_interval,
  common::optional<std::wstring> max_interval
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  observed_ = std::move(observed);

  direction_ = direction;

  state_ = state;

  message_topic_ = std::move(message_topic);

  message_broker_ = std::move(message_broker);

  last_update_ = std::move(last_update);

  min_interval_ = std::move(min_interval);

  max_interval_ = std::move(max_interval);
}

ModelType BasicEventElement::model_type() const {
  return ModelType::kBasicEventElement;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& BasicEventElement::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& BasicEventElement::mutable_extensions() {
  return extensions_;
}

void BasicEventElement::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& BasicEventElement::category() const {
  return category_;
}

common::optional<std::wstring>& BasicEventElement::mutable_category() {
  return category_;
}

void BasicEventElement::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& BasicEventElement::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& BasicEventElement::mutable_id_short() {
  return id_short_;
}

void BasicEventElement::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& BasicEventElement::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& BasicEventElement::mutable_display_name() {
  return display_name_;
}

void BasicEventElement::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& BasicEventElement::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& BasicEventElement::mutable_description() {
  return description_;
}

void BasicEventElement::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& BasicEventElement::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& BasicEventElement::mutable_semantic_id() {
  return semantic_id_;
}

void BasicEventElement::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& BasicEventElement::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& BasicEventElement::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void BasicEventElement::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& BasicEventElement::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& BasicEventElement::mutable_qualifiers() {
  return qualifiers_;
}

void BasicEventElement::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& BasicEventElement::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& BasicEventElement::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void BasicEventElement::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const std::shared_ptr<IReference>& BasicEventElement::observed() const {
  return observed_;
}

std::shared_ptr<IReference>& BasicEventElement::mutable_observed() {
  return observed_;
}

void BasicEventElement::set_observed(
  std::shared_ptr<IReference> value
) {
  observed_ = value;
}

Direction BasicEventElement::direction() const {
  return direction_;
}

Direction& BasicEventElement::mutable_direction() {
  return direction_;
}

void BasicEventElement::set_direction(
  Direction value
) {
  direction_ = value;
}

StateOfEvent BasicEventElement::state() const {
  return state_;
}

StateOfEvent& BasicEventElement::mutable_state() {
  return state_;
}

void BasicEventElement::set_state(
  StateOfEvent value
) {
  state_ = value;
}

const common::optional<std::wstring>& BasicEventElement::message_topic() const {
  return message_topic_;
}

common::optional<std::wstring>& BasicEventElement::mutable_message_topic() {
  return message_topic_;
}

void BasicEventElement::set_message_topic(
  common::optional<std::wstring> value
) {
  message_topic_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& BasicEventElement::message_broker() const {
  return message_broker_;
}

common::optional<
  std::shared_ptr<IReference>
>& BasicEventElement::mutable_message_broker() {
  return message_broker_;
}

void BasicEventElement::set_message_broker(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  message_broker_ = value;
}

const common::optional<std::wstring>& BasicEventElement::last_update() const {
  return last_update_;
}

common::optional<std::wstring>& BasicEventElement::mutable_last_update() {
  return last_update_;
}

void BasicEventElement::set_last_update(
  common::optional<std::wstring> value
) {
  last_update_ = value;
}

const common::optional<std::wstring>& BasicEventElement::min_interval() const {
  return min_interval_;
}

common::optional<std::wstring>& BasicEventElement::mutable_min_interval() {
  return min_interval_;
}

void BasicEventElement::set_min_interval(
  common::optional<std::wstring> value
) {
  min_interval_ = value;
}

const common::optional<std::wstring>& BasicEventElement::max_interval() const {
  return max_interval_;
}

common::optional<std::wstring>& BasicEventElement::mutable_max_interval() {
  return max_interval_;
}

void BasicEventElement::set_max_interval(
  common::optional<std::wstring> value
) {
  max_interval_ = value;
}

// endregion BasicEventElement

// region Operation

Operation::Operation(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > input_variables,
  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > output_variables,
  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > inoutput_variables
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  input_variables_ = std::move(input_variables);

  output_variables_ = std::move(output_variables);

  inoutput_variables_ = std::move(inoutput_variables);
}

ModelType Operation::model_type() const {
  return ModelType::kOperation;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Operation::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Operation::mutable_extensions() {
  return extensions_;
}

void Operation::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& Operation::category() const {
  return category_;
}

common::optional<std::wstring>& Operation::mutable_category() {
  return category_;
}

void Operation::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& Operation::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& Operation::mutable_id_short() {
  return id_short_;
}

void Operation::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Operation::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Operation::mutable_display_name() {
  return display_name_;
}

void Operation::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Operation::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Operation::mutable_description() {
  return description_;
}

void Operation::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Operation::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Operation::mutable_semantic_id() {
  return semantic_id_;
}

void Operation::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Operation::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Operation::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Operation::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Operation::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Operation::mutable_qualifiers() {
  return qualifiers_;
}

void Operation::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Operation::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Operation::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void Operation::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IOperationVariable>
  >
>& Operation::input_variables() const {
  return input_variables_;
}

common::optional<
  std::vector<
    std::shared_ptr<IOperationVariable>
  >
>& Operation::mutable_input_variables() {
  return input_variables_;
}

void Operation::set_input_variables(
  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > value
) {
  input_variables_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IOperationVariable>
  >
>& Operation::output_variables() const {
  return output_variables_;
}

common::optional<
  std::vector<
    std::shared_ptr<IOperationVariable>
  >
>& Operation::mutable_output_variables() {
  return output_variables_;
}

void Operation::set_output_variables(
  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > value
) {
  output_variables_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IOperationVariable>
  >
>& Operation::inoutput_variables() const {
  return inoutput_variables_;
}

common::optional<
  std::vector<
    std::shared_ptr<IOperationVariable>
  >
>& Operation::mutable_inoutput_variables() {
  return inoutput_variables_;
}

void Operation::set_inoutput_variables(
  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > value
) {
  inoutput_variables_ = value;
}

// endregion Operation

// region OperationVariable

OperationVariable::OperationVariable(
  std::shared_ptr<ISubmodelElement> value
) {
  value_ = std::move(value);
}

ModelType OperationVariable::model_type() const {
  return ModelType::kOperationVariable;
}

const std::shared_ptr<ISubmodelElement>& OperationVariable::value() const {
  return value_;
}

std::shared_ptr<ISubmodelElement>& OperationVariable::mutable_value() {
  return value_;
}

void OperationVariable::set_value(
  std::shared_ptr<ISubmodelElement> value
) {
  value_ = value;
}

// endregion OperationVariable

// region Capability

Capability::Capability(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids,
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  semantic_id_ = std::move(semantic_id);

  supplemental_semantic_ids_ = std::move(supplemental_semantic_ids);

  qualifiers_ = std::move(qualifiers);

  embedded_data_specifications_ = std::move(embedded_data_specifications);
}

ModelType Capability::model_type() const {
  return ModelType::kCapability;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Capability::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& Capability::mutable_extensions() {
  return extensions_;
}

void Capability::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& Capability::category() const {
  return category_;
}

common::optional<std::wstring>& Capability::mutable_category() {
  return category_;
}

void Capability::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& Capability::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& Capability::mutable_id_short() {
  return id_short_;
}

void Capability::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Capability::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& Capability::mutable_display_name() {
  return display_name_;
}

void Capability::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Capability::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& Capability::mutable_description() {
  return description_;
}

void Capability::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Capability::semantic_id() const {
  return semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Capability::mutable_semantic_id() {
  return semantic_id_;
}

void Capability::set_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  semantic_id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Capability::supplemental_semantic_ids() const {
  return supplemental_semantic_ids_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& Capability::mutable_supplemental_semantic_ids() {
  return supplemental_semantic_ids_;
}

void Capability::set_supplemental_semantic_ids(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  supplemental_semantic_ids_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Capability::qualifiers() const {
  return qualifiers_;
}

common::optional<
  std::vector<
    std::shared_ptr<IQualifier>
  >
>& Capability::mutable_qualifiers() {
  return qualifiers_;
}

void Capability::set_qualifiers(
  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > value
) {
  qualifiers_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Capability::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& Capability::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void Capability::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

// endregion Capability

// region ConceptDescription

ConceptDescription::ConceptDescription(
  std::wstring id,
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions,
  common::optional<std::wstring> category,
  common::optional<std::wstring> id_short,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description,
  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > administration,
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications,
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > is_case_of
) {
  extensions_ = std::move(extensions);

  id_short_ = std::move(id_short);

  display_name_ = std::move(display_name);

  category_ = std::move(category);

  description_ = std::move(description);

  id_ = std::move(id);

  administration_ = std::move(administration);

  embedded_data_specifications_ = std::move(embedded_data_specifications);

  is_case_of_ = std::move(is_case_of);
}

ModelType ConceptDescription::model_type() const {
  return ModelType::kConceptDescription;
}

const common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& ConceptDescription::extensions() const {
  return extensions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IExtension>
  >
>& ConceptDescription::mutable_extensions() {
  return extensions_;
}

void ConceptDescription::set_extensions(
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > value
) {
  extensions_ = value;
}

const common::optional<std::wstring>& ConceptDescription::category() const {
  return category_;
}

common::optional<std::wstring>& ConceptDescription::mutable_category() {
  return category_;
}

void ConceptDescription::set_category(
  common::optional<std::wstring> value
) {
  category_ = value;
}

const common::optional<std::wstring>& ConceptDescription::id_short() const {
  return id_short_;
}

common::optional<std::wstring>& ConceptDescription::mutable_id_short() {
  return id_short_;
}

void ConceptDescription::set_id_short(
  common::optional<std::wstring> value
) {
  id_short_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& ConceptDescription::display_name() const {
  return display_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringNameType>
  >
>& ConceptDescription::mutable_display_name() {
  return display_name_;
}

void ConceptDescription::set_display_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > value
) {
  display_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& ConceptDescription::description() const {
  return description_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringTextType>
  >
>& ConceptDescription::mutable_description() {
  return description_;
}

void ConceptDescription::set_description(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value
) {
  description_ = value;
}

const common::optional<
  std::shared_ptr<IAdministrativeInformation>
>& ConceptDescription::administration() const {
  return administration_;
}

common::optional<
  std::shared_ptr<IAdministrativeInformation>
>& ConceptDescription::mutable_administration() {
  return administration_;
}

void ConceptDescription::set_administration(
  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > value
) {
  administration_ = value;
}

const std::wstring& ConceptDescription::id() const {
  return id_;
}

std::wstring& ConceptDescription::mutable_id() {
  return id_;
}

void ConceptDescription::set_id(
  std::wstring value
) {
  id_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& ConceptDescription::embedded_data_specifications() const {
  return embedded_data_specifications_;
}

common::optional<
  std::vector<
    std::shared_ptr<IEmbeddedDataSpecification>
  >
>& ConceptDescription::mutable_embedded_data_specifications() {
  return embedded_data_specifications_;
}

void ConceptDescription::set_embedded_data_specifications(
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > value
) {
  embedded_data_specifications_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& ConceptDescription::is_case_of() const {
  return is_case_of_;
}

common::optional<
  std::vector<
    std::shared_ptr<IReference>
  >
>& ConceptDescription::mutable_is_case_of() {
  return is_case_of_;
}

void ConceptDescription::set_is_case_of(
  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > value
) {
  is_case_of_ = value;
}

// endregion ConceptDescription

// region Reference

Reference::Reference(
  ReferenceTypes type,
  std::vector<
    std::shared_ptr<IKey>
  > keys,
  common::optional<
    std::shared_ptr<IReference>
  > referred_semantic_id
) {
  type_ = type;

  keys_ = std::move(keys);

  referred_semantic_id_ = std::move(referred_semantic_id);
}

ModelType Reference::model_type() const {
  return ModelType::kReference;
}

ReferenceTypes Reference::type() const {
  return type_;
}

ReferenceTypes& Reference::mutable_type() {
  return type_;
}

void Reference::set_type(
  ReferenceTypes value
) {
  type_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& Reference::referred_semantic_id() const {
  return referred_semantic_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& Reference::mutable_referred_semantic_id() {
  return referred_semantic_id_;
}

void Reference::set_referred_semantic_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  referred_semantic_id_ = value;
}

const std::vector<
  std::shared_ptr<IKey>
>& Reference::keys() const {
  return keys_;
}

std::vector<
  std::shared_ptr<IKey>
>& Reference::mutable_keys() {
  return keys_;
}

void Reference::set_keys(
  std::vector<
    std::shared_ptr<IKey>
  > value
) {
  keys_ = value;
}

// endregion Reference

// region Key

Key::Key(
  KeyTypes type,
  std::wstring value
) {
  type_ = type;

  value_ = std::move(value);
}

ModelType Key::model_type() const {
  return ModelType::kKey;
}

KeyTypes Key::type() const {
  return type_;
}

KeyTypes& Key::mutable_type() {
  return type_;
}

void Key::set_type(
  KeyTypes value
) {
  type_ = value;
}

const std::wstring& Key::value() const {
  return value_;
}

std::wstring& Key::mutable_value() {
  return value_;
}

void Key::set_value(
  std::wstring value
) {
  value_ = value;
}

// endregion Key

// region LangStringNameType

LangStringNameType::LangStringNameType(
  std::wstring language,
  std::wstring text
) {
  language_ = std::move(language);

  text_ = std::move(text);
}

ModelType LangStringNameType::model_type() const {
  return ModelType::kLangStringNameType;
}

const std::wstring& LangStringNameType::language() const {
  return language_;
}

std::wstring& LangStringNameType::mutable_language() {
  return language_;
}

void LangStringNameType::set_language(
  std::wstring value
) {
  language_ = value;
}

const std::wstring& LangStringNameType::text() const {
  return text_;
}

std::wstring& LangStringNameType::mutable_text() {
  return text_;
}

void LangStringNameType::set_text(
  std::wstring value
) {
  text_ = value;
}

// endregion LangStringNameType

// region LangStringTextType

LangStringTextType::LangStringTextType(
  std::wstring language,
  std::wstring text
) {
  language_ = std::move(language);

  text_ = std::move(text);
}

ModelType LangStringTextType::model_type() const {
  return ModelType::kLangStringTextType;
}

const std::wstring& LangStringTextType::language() const {
  return language_;
}

std::wstring& LangStringTextType::mutable_language() {
  return language_;
}

void LangStringTextType::set_language(
  std::wstring value
) {
  language_ = value;
}

const std::wstring& LangStringTextType::text() const {
  return text_;
}

std::wstring& LangStringTextType::mutable_text() {
  return text_;
}

void LangStringTextType::set_text(
  std::wstring value
) {
  text_ = value;
}

// endregion LangStringTextType

// region Environment

Environment::Environment(
  common::optional<
    std::vector<
      std::shared_ptr<IAssetAdministrationShell>
    >
  > asset_administration_shells,
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodel>
    >
  > submodels,
  common::optional<
    std::vector<
      std::shared_ptr<IConceptDescription>
    >
  > concept_descriptions
) {
  asset_administration_shells_ = std::move(asset_administration_shells);

  submodels_ = std::move(submodels);

  concept_descriptions_ = std::move(concept_descriptions);
}

ModelType Environment::model_type() const {
  return ModelType::kEnvironment;
}

const common::optional<
  std::vector<
    std::shared_ptr<IAssetAdministrationShell>
  >
>& Environment::asset_administration_shells() const {
  return asset_administration_shells_;
}

common::optional<
  std::vector<
    std::shared_ptr<IAssetAdministrationShell>
  >
>& Environment::mutable_asset_administration_shells() {
  return asset_administration_shells_;
}

void Environment::set_asset_administration_shells(
  common::optional<
    std::vector<
      std::shared_ptr<IAssetAdministrationShell>
    >
  > value
) {
  asset_administration_shells_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ISubmodel>
  >
>& Environment::submodels() const {
  return submodels_;
}

common::optional<
  std::vector<
    std::shared_ptr<ISubmodel>
  >
>& Environment::mutable_submodels() {
  return submodels_;
}

void Environment::set_submodels(
  common::optional<
    std::vector<
      std::shared_ptr<ISubmodel>
    >
  > value
) {
  submodels_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<IConceptDescription>
  >
>& Environment::concept_descriptions() const {
  return concept_descriptions_;
}

common::optional<
  std::vector<
    std::shared_ptr<IConceptDescription>
  >
>& Environment::mutable_concept_descriptions() {
  return concept_descriptions_;
}

void Environment::set_concept_descriptions(
  common::optional<
    std::vector<
      std::shared_ptr<IConceptDescription>
    >
  > value
) {
  concept_descriptions_ = value;
}

// endregion Environment

// region EmbeddedDataSpecification

EmbeddedDataSpecification::EmbeddedDataSpecification(
  std::shared_ptr<IDataSpecificationContent> data_specification_content,
  std::shared_ptr<IReference> data_specification
) {
  data_specification_content_ = std::move(data_specification_content);

  data_specification_ = std::move(data_specification);
}

ModelType EmbeddedDataSpecification::model_type() const {
  return ModelType::kEmbeddedDataSpecification;
}

const std::shared_ptr<IDataSpecificationContent>& EmbeddedDataSpecification::data_specification_content() const {
  return data_specification_content_;
}

std::shared_ptr<IDataSpecificationContent>& EmbeddedDataSpecification::mutable_data_specification_content() {
  return data_specification_content_;
}

void EmbeddedDataSpecification::set_data_specification_content(
  std::shared_ptr<IDataSpecificationContent> value
) {
  data_specification_content_ = value;
}

const std::shared_ptr<IReference>& EmbeddedDataSpecification::data_specification() const {
  return data_specification_;
}

std::shared_ptr<IReference>& EmbeddedDataSpecification::mutable_data_specification() {
  return data_specification_;
}

void EmbeddedDataSpecification::set_data_specification(
  std::shared_ptr<IReference> value
) {
  data_specification_ = value;
}

// endregion EmbeddedDataSpecification

// region LevelType

LevelType::LevelType(
  bool min,
  bool nom,
  bool typ,
  bool max
) {
  min_ = min;

  nom_ = nom;

  typ_ = typ;

  max_ = max;
}

ModelType LevelType::model_type() const {
  return ModelType::kLevelType;
}

bool LevelType::min() const {
  return min_;
}

bool& LevelType::mutable_min() {
  return min_;
}

void LevelType::set_min(
  bool value
) {
  min_ = value;
}

bool LevelType::nom() const {
  return nom_;
}

bool& LevelType::mutable_nom() {
  return nom_;
}

void LevelType::set_nom(
  bool value
) {
  nom_ = value;
}

bool LevelType::typ() const {
  return typ_;
}

bool& LevelType::mutable_typ() {
  return typ_;
}

void LevelType::set_typ(
  bool value
) {
  typ_ = value;
}

bool LevelType::max() const {
  return max_;
}

bool& LevelType::mutable_max() {
  return max_;
}

void LevelType::set_max(
  bool value
) {
  max_ = value;
}

// endregion LevelType

// region ValueReferencePair

ValueReferencePair::ValueReferencePair(
  std::wstring value,
  std::shared_ptr<IReference> value_id
) {
  value_ = std::move(value);

  value_id_ = std::move(value_id);
}

ModelType ValueReferencePair::model_type() const {
  return ModelType::kValueReferencePair;
}

const std::wstring& ValueReferencePair::value() const {
  return value_;
}

std::wstring& ValueReferencePair::mutable_value() {
  return value_;
}

void ValueReferencePair::set_value(
  std::wstring value
) {
  value_ = value;
}

const std::shared_ptr<IReference>& ValueReferencePair::value_id() const {
  return value_id_;
}

std::shared_ptr<IReference>& ValueReferencePair::mutable_value_id() {
  return value_id_;
}

void ValueReferencePair::set_value_id(
  std::shared_ptr<IReference> value
) {
  value_id_ = value;
}

// endregion ValueReferencePair

// region ValueList

ValueList::ValueList(
  std::vector<
    std::shared_ptr<IValueReferencePair>
  > value_reference_pairs
) {
  value_reference_pairs_ = std::move(value_reference_pairs);
}

ModelType ValueList::model_type() const {
  return ModelType::kValueList;
}

const std::vector<
  std::shared_ptr<IValueReferencePair>
>& ValueList::value_reference_pairs() const {
  return value_reference_pairs_;
}

std::vector<
  std::shared_ptr<IValueReferencePair>
>& ValueList::mutable_value_reference_pairs() {
  return value_reference_pairs_;
}

void ValueList::set_value_reference_pairs(
  std::vector<
    std::shared_ptr<IValueReferencePair>
  > value
) {
  value_reference_pairs_ = value;
}

// endregion ValueList

// region LangStringPreferredNameTypeIec61360

LangStringPreferredNameTypeIec61360::LangStringPreferredNameTypeIec61360(
  std::wstring language,
  std::wstring text
) {
  language_ = std::move(language);

  text_ = std::move(text);
}

ModelType LangStringPreferredNameTypeIec61360::model_type() const {
  return ModelType::kLangStringPreferredNameTypeIec61360;
}

const std::wstring& LangStringPreferredNameTypeIec61360::language() const {
  return language_;
}

std::wstring& LangStringPreferredNameTypeIec61360::mutable_language() {
  return language_;
}

void LangStringPreferredNameTypeIec61360::set_language(
  std::wstring value
) {
  language_ = value;
}

const std::wstring& LangStringPreferredNameTypeIec61360::text() const {
  return text_;
}

std::wstring& LangStringPreferredNameTypeIec61360::mutable_text() {
  return text_;
}

void LangStringPreferredNameTypeIec61360::set_text(
  std::wstring value
) {
  text_ = value;
}

// endregion LangStringPreferredNameTypeIec61360

// region LangStringShortNameTypeIec61360

LangStringShortNameTypeIec61360::LangStringShortNameTypeIec61360(
  std::wstring language,
  std::wstring text
) {
  language_ = std::move(language);

  text_ = std::move(text);
}

ModelType LangStringShortNameTypeIec61360::model_type() const {
  return ModelType::kLangStringShortNameTypeIec61360;
}

const std::wstring& LangStringShortNameTypeIec61360::language() const {
  return language_;
}

std::wstring& LangStringShortNameTypeIec61360::mutable_language() {
  return language_;
}

void LangStringShortNameTypeIec61360::set_language(
  std::wstring value
) {
  language_ = value;
}

const std::wstring& LangStringShortNameTypeIec61360::text() const {
  return text_;
}

std::wstring& LangStringShortNameTypeIec61360::mutable_text() {
  return text_;
}

void LangStringShortNameTypeIec61360::set_text(
  std::wstring value
) {
  text_ = value;
}

// endregion LangStringShortNameTypeIec61360

// region LangStringDefinitionTypeIec61360

LangStringDefinitionTypeIec61360::LangStringDefinitionTypeIec61360(
  std::wstring language,
  std::wstring text
) {
  language_ = std::move(language);

  text_ = std::move(text);
}

ModelType LangStringDefinitionTypeIec61360::model_type() const {
  return ModelType::kLangStringDefinitionTypeIec61360;
}

const std::wstring& LangStringDefinitionTypeIec61360::language() const {
  return language_;
}

std::wstring& LangStringDefinitionTypeIec61360::mutable_language() {
  return language_;
}

void LangStringDefinitionTypeIec61360::set_language(
  std::wstring value
) {
  language_ = value;
}

const std::wstring& LangStringDefinitionTypeIec61360::text() const {
  return text_;
}

std::wstring& LangStringDefinitionTypeIec61360::mutable_text() {
  return text_;
}

void LangStringDefinitionTypeIec61360::set_text(
  std::wstring value
) {
  text_ = value;
}

// endregion LangStringDefinitionTypeIec61360

// region DataSpecificationIec61360

DataSpecificationIec61360::DataSpecificationIec61360(
  std::vector<
    std::shared_ptr<ILangStringPreferredNameTypeIec61360>
  > preferred_name,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringShortNameTypeIec61360>
    >
  > short_name,
  common::optional<std::wstring> unit,
  common::optional<
    std::shared_ptr<IReference>
  > unit_id,
  common::optional<std::wstring> source_of_definition,
  common::optional<std::wstring> symbol,
  common::optional<DataTypeIec61360> data_type,
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringDefinitionTypeIec61360>
    >
  > definition,
  common::optional<std::wstring> value_format,
  common::optional<
    std::shared_ptr<IValueList>
  > value_list,
  common::optional<std::wstring> value,
  common::optional<
    std::shared_ptr<ILevelType>
  > level_type
) {
  preferred_name_ = std::move(preferred_name);

  short_name_ = std::move(short_name);

  unit_ = std::move(unit);

  unit_id_ = std::move(unit_id);

  source_of_definition_ = std::move(source_of_definition);

  symbol_ = std::move(symbol);

  data_type_ = std::move(data_type);

  definition_ = std::move(definition);

  value_format_ = std::move(value_format);

  value_list_ = std::move(value_list);

  value_ = std::move(value);

  level_type_ = std::move(level_type);
}

ModelType DataSpecificationIec61360::model_type() const {
  return ModelType::kDataSpecificationIec61360;
}

const std::vector<
  std::shared_ptr<ILangStringPreferredNameTypeIec61360>
>& DataSpecificationIec61360::preferred_name() const {
  return preferred_name_;
}

std::vector<
  std::shared_ptr<ILangStringPreferredNameTypeIec61360>
>& DataSpecificationIec61360::mutable_preferred_name() {
  return preferred_name_;
}

void DataSpecificationIec61360::set_preferred_name(
  std::vector<
    std::shared_ptr<ILangStringPreferredNameTypeIec61360>
  > value
) {
  preferred_name_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringShortNameTypeIec61360>
  >
>& DataSpecificationIec61360::short_name() const {
  return short_name_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringShortNameTypeIec61360>
  >
>& DataSpecificationIec61360::mutable_short_name() {
  return short_name_;
}

void DataSpecificationIec61360::set_short_name(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringShortNameTypeIec61360>
    >
  > value
) {
  short_name_ = value;
}

const common::optional<std::wstring>& DataSpecificationIec61360::unit() const {
  return unit_;
}

common::optional<std::wstring>& DataSpecificationIec61360::mutable_unit() {
  return unit_;
}

void DataSpecificationIec61360::set_unit(
  common::optional<std::wstring> value
) {
  unit_ = value;
}

const common::optional<
  std::shared_ptr<IReference>
>& DataSpecificationIec61360::unit_id() const {
  return unit_id_;
}

common::optional<
  std::shared_ptr<IReference>
>& DataSpecificationIec61360::mutable_unit_id() {
  return unit_id_;
}

void DataSpecificationIec61360::set_unit_id(
  common::optional<
    std::shared_ptr<IReference>
  > value
) {
  unit_id_ = value;
}

const common::optional<std::wstring>& DataSpecificationIec61360::source_of_definition() const {
  return source_of_definition_;
}

common::optional<std::wstring>& DataSpecificationIec61360::mutable_source_of_definition() {
  return source_of_definition_;
}

void DataSpecificationIec61360::set_source_of_definition(
  common::optional<std::wstring> value
) {
  source_of_definition_ = value;
}

const common::optional<std::wstring>& DataSpecificationIec61360::symbol() const {
  return symbol_;
}

common::optional<std::wstring>& DataSpecificationIec61360::mutable_symbol() {
  return symbol_;
}

void DataSpecificationIec61360::set_symbol(
  common::optional<std::wstring> value
) {
  symbol_ = value;
}

const common::optional<DataTypeIec61360>& DataSpecificationIec61360::data_type() const {
  return data_type_;
}

common::optional<DataTypeIec61360>& DataSpecificationIec61360::mutable_data_type() {
  return data_type_;
}

void DataSpecificationIec61360::set_data_type(
  common::optional<DataTypeIec61360> value
) {
  data_type_ = value;
}

const common::optional<
  std::vector<
    std::shared_ptr<ILangStringDefinitionTypeIec61360>
  >
>& DataSpecificationIec61360::definition() const {
  return definition_;
}

common::optional<
  std::vector<
    std::shared_ptr<ILangStringDefinitionTypeIec61360>
  >
>& DataSpecificationIec61360::mutable_definition() {
  return definition_;
}

void DataSpecificationIec61360::set_definition(
  common::optional<
    std::vector<
      std::shared_ptr<ILangStringDefinitionTypeIec61360>
    >
  > value
) {
  definition_ = value;
}

const common::optional<std::wstring>& DataSpecificationIec61360::value_format() const {
  return value_format_;
}

common::optional<std::wstring>& DataSpecificationIec61360::mutable_value_format() {
  return value_format_;
}

void DataSpecificationIec61360::set_value_format(
  common::optional<std::wstring> value
) {
  value_format_ = value;
}

const common::optional<
  std::shared_ptr<IValueList>
>& DataSpecificationIec61360::value_list() const {
  return value_list_;
}

common::optional<
  std::shared_ptr<IValueList>
>& DataSpecificationIec61360::mutable_value_list() {
  return value_list_;
}

void DataSpecificationIec61360::set_value_list(
  common::optional<
    std::shared_ptr<IValueList>
  > value
) {
  value_list_ = value;
}

const common::optional<std::wstring>& DataSpecificationIec61360::value() const {
  return value_;
}

common::optional<std::wstring>& DataSpecificationIec61360::mutable_value() {
  return value_;
}

void DataSpecificationIec61360::set_value(
  common::optional<std::wstring> value
) {
  value_ = value;
}

const common::optional<
  std::shared_ptr<ILevelType>
>& DataSpecificationIec61360::level_type() const {
  return level_type_;
}

common::optional<
  std::shared_ptr<ILevelType>
>& DataSpecificationIec61360::mutable_level_type() {
  return level_type_;
}

void DataSpecificationIec61360::set_level_type(
  common::optional<
    std::shared_ptr<ILevelType>
  > value
) {
  level_type_ = value;
}

// endregion DataSpecificationIec61360

// region Is-a functions

bool IsHasSemantics(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return true;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return true;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return true;
    case ModelType::kSubmodel:
      return true;
    case ModelType::kRelationshipElement:
      return true;
    case ModelType::kSubmodelElementList:
      return true;
    case ModelType::kSubmodelElementCollection:
      return true;
    case ModelType::kProperty:
      return true;
    case ModelType::kMultiLanguageProperty:
      return true;
    case ModelType::kRange:
      return true;
    case ModelType::kReferenceElement:
      return true;
    case ModelType::kBlob:
      return true;
    case ModelType::kFile:
      return true;
    case ModelType::kAnnotatedRelationshipElement:
      return true;
    case ModelType::kEntity:
      return true;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return true;
    case ModelType::kOperation:
      return true;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return true;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsExtension(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return true;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsHasExtensions(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return true;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return true;
    case ModelType::kRelationshipElement:
      return true;
    case ModelType::kSubmodelElementList:
      return true;
    case ModelType::kSubmodelElementCollection:
      return true;
    case ModelType::kProperty:
      return true;
    case ModelType::kMultiLanguageProperty:
      return true;
    case ModelType::kRange:
      return true;
    case ModelType::kReferenceElement:
      return true;
    case ModelType::kBlob:
      return true;
    case ModelType::kFile:
      return true;
    case ModelType::kAnnotatedRelationshipElement:
      return true;
    case ModelType::kEntity:
      return true;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return true;
    case ModelType::kOperation:
      return true;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return true;
    case ModelType::kConceptDescription:
      return true;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsReferable(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return true;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return true;
    case ModelType::kRelationshipElement:
      return true;
    case ModelType::kSubmodelElementList:
      return true;
    case ModelType::kSubmodelElementCollection:
      return true;
    case ModelType::kProperty:
      return true;
    case ModelType::kMultiLanguageProperty:
      return true;
    case ModelType::kRange:
      return true;
    case ModelType::kReferenceElement:
      return true;
    case ModelType::kBlob:
      return true;
    case ModelType::kFile:
      return true;
    case ModelType::kAnnotatedRelationshipElement:
      return true;
    case ModelType::kEntity:
      return true;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return true;
    case ModelType::kOperation:
      return true;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return true;
    case ModelType::kConceptDescription:
      return true;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsIdentifiable(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return true;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return true;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return true;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsHasKind(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return true;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsHasDataSpecification(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return true;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return true;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return true;
    case ModelType::kRelationshipElement:
      return true;
    case ModelType::kSubmodelElementList:
      return true;
    case ModelType::kSubmodelElementCollection:
      return true;
    case ModelType::kProperty:
      return true;
    case ModelType::kMultiLanguageProperty:
      return true;
    case ModelType::kRange:
      return true;
    case ModelType::kReferenceElement:
      return true;
    case ModelType::kBlob:
      return true;
    case ModelType::kFile:
      return true;
    case ModelType::kAnnotatedRelationshipElement:
      return true;
    case ModelType::kEntity:
      return true;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return true;
    case ModelType::kOperation:
      return true;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return true;
    case ModelType::kConceptDescription:
      return true;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsAdministrativeInformation(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return true;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsQualifiable(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return true;
    case ModelType::kRelationshipElement:
      return true;
    case ModelType::kSubmodelElementList:
      return true;
    case ModelType::kSubmodelElementCollection:
      return true;
    case ModelType::kProperty:
      return true;
    case ModelType::kMultiLanguageProperty:
      return true;
    case ModelType::kRange:
      return true;
    case ModelType::kReferenceElement:
      return true;
    case ModelType::kBlob:
      return true;
    case ModelType::kFile:
      return true;
    case ModelType::kAnnotatedRelationshipElement:
      return true;
    case ModelType::kEntity:
      return true;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return true;
    case ModelType::kOperation:
      return true;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return true;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsQualifier(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return true;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsAssetAdministrationShell(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return true;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsAssetInformation(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return true;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsResource(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return true;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsSpecificAssetId(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return true;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsSubmodel(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return true;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsSubmodelElement(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return true;
    case ModelType::kSubmodelElementList:
      return true;
    case ModelType::kSubmodelElementCollection:
      return true;
    case ModelType::kProperty:
      return true;
    case ModelType::kMultiLanguageProperty:
      return true;
    case ModelType::kRange:
      return true;
    case ModelType::kReferenceElement:
      return true;
    case ModelType::kBlob:
      return true;
    case ModelType::kFile:
      return true;
    case ModelType::kAnnotatedRelationshipElement:
      return true;
    case ModelType::kEntity:
      return true;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return true;
    case ModelType::kOperation:
      return true;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return true;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsRelationshipElement(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return true;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return true;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsSubmodelElementList(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return true;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsSubmodelElementCollection(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return true;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsDataElement(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return true;
    case ModelType::kMultiLanguageProperty:
      return true;
    case ModelType::kRange:
      return true;
    case ModelType::kReferenceElement:
      return true;
    case ModelType::kBlob:
      return true;
    case ModelType::kFile:
      return true;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsProperty(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return true;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsMultiLanguageProperty(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return true;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsRange(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return true;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsReferenceElement(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return true;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsBlob(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return true;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsFile(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return true;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsAnnotatedRelationshipElement(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return true;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsEntity(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return true;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsEventPayload(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return true;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsEventElement(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return true;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsBasicEventElement(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return true;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsOperation(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return true;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsOperationVariable(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return true;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsCapability(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return true;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsConceptDescription(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return true;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsReference(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return true;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsKey(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return true;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsAbstractLangString(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return true;
    case ModelType::kLangStringTextType:
      return true;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return true;
    case ModelType::kLangStringShortNameTypeIec61360:
      return true;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return true;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsLangStringNameType(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return true;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsLangStringTextType(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return true;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsEnvironment(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return true;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsDataSpecificationContent(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return true;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsEmbeddedDataSpecification(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return true;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsLevelType(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return true;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsValueReferencePair(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return true;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsValueList(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return true;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsLangStringPreferredNameTypeIec61360(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return true;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsLangStringShortNameTypeIec61360(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return true;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsLangStringDefinitionTypeIec61360(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return true;
    case ModelType::kDataSpecificationIec61360:
      return false;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

bool IsDataSpecificationIec61360(
  const IClass& that
) {
  switch (that.model_type()) {
    case ModelType::kExtension:
      return false;
    case ModelType::kAdministrativeInformation:
      return false;
    case ModelType::kQualifier:
      return false;
    case ModelType::kAssetAdministrationShell:
      return false;
    case ModelType::kAssetInformation:
      return false;
    case ModelType::kResource:
      return false;
    case ModelType::kSpecificAssetId:
      return false;
    case ModelType::kSubmodel:
      return false;
    case ModelType::kRelationshipElement:
      return false;
    case ModelType::kSubmodelElementList:
      return false;
    case ModelType::kSubmodelElementCollection:
      return false;
    case ModelType::kProperty:
      return false;
    case ModelType::kMultiLanguageProperty:
      return false;
    case ModelType::kRange:
      return false;
    case ModelType::kReferenceElement:
      return false;
    case ModelType::kBlob:
      return false;
    case ModelType::kFile:
      return false;
    case ModelType::kAnnotatedRelationshipElement:
      return false;
    case ModelType::kEntity:
      return false;
    case ModelType::kEventPayload:
      return false;
    case ModelType::kBasicEventElement:
      return false;
    case ModelType::kOperation:
      return false;
    case ModelType::kOperationVariable:
      return false;
    case ModelType::kCapability:
      return false;
    case ModelType::kConceptDescription:
      return false;
    case ModelType::kReference:
      return false;
    case ModelType::kKey:
      return false;
    case ModelType::kLangStringNameType:
      return false;
    case ModelType::kLangStringTextType:
      return false;
    case ModelType::kEnvironment:
      return false;
    case ModelType::kEmbeddedDataSpecification:
      return false;
    case ModelType::kLevelType:
      return false;
    case ModelType::kValueReferencePair:
      return false;
    case ModelType::kValueList:
      return false;
    case ModelType::kLangStringPreferredNameTypeIec61360:
      return false;
    case ModelType::kLangStringShortNameTypeIec61360:
      return false;
    case ModelType::kLangStringDefinitionTypeIec61360:
      return false;
    case ModelType::kDataSpecificationIec61360:
      return true;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(that.model_type())
          )
        )
      );
  }
}

// endregion Is-a functions

}  // namespace types
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
