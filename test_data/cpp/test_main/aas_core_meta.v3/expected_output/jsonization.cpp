// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/jsonization.hpp"
#include "aas_core/aas_3_0/stringification.hpp"
#include "aas_core/aas_3_0/wstringification.hpp"

#pragma warning(push, 0)
#include <functional>
#include <map>
#include <set>
#include <sstream>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {
namespace jsonization {

// region PropertySegment

PropertySegment::PropertySegment(
  std::wstring a_name
) :
  name(std::move(a_name)) {
  // Intentionally empty.
}

std::wstring PropertySegment::ToWstring() const {
  return common::Concat(
    L".",
    name
  );
}

std::unique_ptr<ISegment> PropertySegment::Clone() const {
  return common::make_unique<PropertySegment>(*this);
}

// endregion PropertySegment

// region IndexSegment

IndexSegment::IndexSegment(
  size_t an_index
) :
  index(an_index) {
  // Intentionally empty.
}

std::wstring IndexSegment::ToWstring() const {
  return common::Concat(
    L"[",
    std::to_wstring(index),
    L"]"
  );
}

std::unique_ptr<ISegment> IndexSegment::Clone() const {
  return common::make_unique<IndexSegment>(*this);
}

// endregion IndexSegment

// region struct Path

Path::Path() {
  // Intentionally empty.
}

Path::Path(const Path& other) {
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
}

Path::Path(Path&& other) {
  segments = std::move(other.segments);
}

Path& Path::operator=(const Path& other) {
  segments.clear();
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
  return *this;
}

Path& Path::operator=(Path&& other) {
  if (this != &other) {
    segments = std::move(other.segments);
  }
  return *this;
}

std::wstring Path::ToWstring() const {
  if (segments.empty()) {
    return L"";
  }

  std::deque<std::wstring> parts;
  for (const std::unique_ptr<ISegment>& segment : segments ) {
    parts.emplace_back(segment->ToWstring());
  }

  size_t out_len = 0;
  for (const std::wstring& part : parts) {
    out_len += part.size();
  }

  std::wstring out;
  out.reserve(out_len);
  for (const std::wstring& part : parts) {
    out.append(part);
  }

  return out;
}

// endregion struct Path

// region De-serialization

// region class DeserializationError

DeserializationError::DeserializationError(
  std::wstring a_cause
) :
  cause(a_cause) {
  // Intentionally empty.
}

DeserializationError::DeserializationError(
  std::wstring a_cause,
  Path a_path
) :
  cause(a_cause),
  path(a_path) {
  // Intentionally empty.
}

// endregion class DeserializationError

std::pair<
  common::optional<bool>,
  common::optional<DeserializationError>
> DeserializeBool(
  const nlohmann::json& json
) {
  if (!json.is_boolean()) {
    std::wstring message = common::Concat(
      L"Expected a boolean, but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<bool>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return std::make_pair<
    common::optional<bool>,
    common::optional<DeserializationError>
  >(
    json.get<bool>(),
    common::nullopt
  );
}

std::pair<
  common::optional<int64_t>,
  common::optional<DeserializationError>
> DeserializeInt64(
  const nlohmann::json& json
) {
  if (!json.is_number()) {
    std::wstring message = common::Concat(
      L"Expected an integer number, but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  static_assert(
    std::is_same<nlohmann::json::number_integer_t, int64_t>::value,
    "Expected nlohmann::json::number_integer_t to equal int64_t, "
    "but it does not."
  );

  if (json.is_number_integer()) {
    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      json.get<int64_t>(),
      common::nullopt
    );
  }

  if (json.is_number_unsigned()) {
    std::wstring message = common::Concat(
      L"Expected a 64-bit integer number, "
      L"but got an unsigned integer number which does not fit in that range: ",
      std::to_wstring(json.get<nlohmann::json::number_unsigned_t>())
    );

    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  // NOTE (mristin):
  // We have to check that the number is an integer even though it can
  // not be stored in int64_t in order to give an informative message.

  const nlohmann::json::number_float_t number(
    json.get<nlohmann::json::number_float_t>()
  );

  nlohmann::json::number_float_t integer_part;
  const bool is_integer(
    std::modf(number, &integer_part) == 0
  );
  if (is_integer) {
    std::wstring message = common::Concat(
      L"Expected a 64-bit integer number, "
      L"but got an integer number which does not fit in that range: ",
      std::to_wstring(number)
    );

    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  } else {
    std::wstring message = common::Concat(
      L"Expected a 64-bit integer number, "
      L"but got a non-integer number: ",
      std::to_wstring(number)
    );

    return std::make_pair<
      common::optional<int64_t>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }
}

std::pair<
  common::optional<double>,
  common::optional<DeserializationError>
> DeserializeDouble(
  const nlohmann::json& json
) {
  if (!json.is_number()) {
    std::wstring message = common::Concat(
      L"Expected a number, but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<double>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  static_assert(
    std::is_same<nlohmann::json::number_float_t, double>::value,
    "Expected nlohmann::json::number_float_t to equal double, "
    "but it does not."
  );

  return std::make_pair<
    common::optional<double>,
    common::optional<DeserializationError>
  >(
    json.get<double>(),
    common::nullopt
  );
}

std::pair<
  common::optional<std::wstring>,
  common::optional<DeserializationError>
> DeserializeWstring(
  const nlohmann::json& json
) {
  if (!json.is_string()) {
    std::wstring message = common::Concat(
      L"Expected a string, but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::wstring>,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return std::make_pair<
    common::optional<std::wstring>,
    common::optional<DeserializationError>
  >(
    common::Utf8ToWstring(*(json.get_ptr<const std::string*>())),
    common::nullopt
  );
}

std::pair<
  common::optional<std::vector<std::uint8_t> >,
  common::optional<DeserializationError>
> DeserializeByteArray(
  const nlohmann::json& json
) {
  if (!json.is_string()) {
    std::wstring message = common::Concat(
      L"Expected a base64-encoded byte array as a string, "
      L"but got a value of type: ",
      common::Utf8ToWstring(json.type_name())
    );;

    return std::make_pair<
      common::optional<std::vector<std::uint8_t> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  common::expected<
    std::vector<std::uint8_t>,
    std::string
  > bytes = stringification::Base64Decode(
    *(json.get_ptr<const std::string*>())
  );

  if (!bytes.has_value()) {
    std::wstring message = common::Concat(
      L"Failed to base64-decode the bytes from a string: ",
      common::Utf8ToWstring(bytes.error())
    );

    return std::make_pair<
      common::optional<std::vector<std::uint8_t> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return std::make_pair<
    common::optional<std::vector<std::uint8_t> >,
    common::optional<DeserializationError>
  >(
    std::move(*bytes),
    common::nullopt
  );
}

/**
 * Get the property `modelType` from the JSON value expected as a JSON object.
 */
std::pair<
  const std::string*,
  common::optional<DeserializationError>
> GetModelTypeFrom(
  const nlohmann::json& json
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      const std::string*,
      common::optional<DeserializationError>
    >(
      nullptr,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      const std::string*,
      common::optional<DeserializationError>
    >(
      nullptr,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  const nlohmann::json& model_type_prop = json["modelType"];
  if (!model_type_prop.is_string()) {
    std::wstring message = common::Concat(
      L"Expected modelType to be a string, but got: ",
      common::Utf8ToWstring(model_type_prop.type_name())
    );

    common::optional<DeserializationError> error(
      common::make_optional<DeserializationError>(
        message
      )
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    // NOTE (mristin):
    // We have to explicitly use the constructor instead of std::make_pair
    // as `const std::string*` can not be automatically converted to a rvalue.
    return std::pair<
      const std::string*,
      common::optional<DeserializationError>
    >(
      nullptr,
      error
    );
  }

  static_assert(
    std::is_same<nlohmann::json::string_t, std::string>::value,
    "Expected nlohmann::json::string_t to equal std::string, but it does not."
  );

  const std::string* model_type(
    model_type_prop.get_ptr<const std::string*>()
  );

  // NOTE (mristin):
  // We have to explicitly use the constructor instead of std::make_pair
  // as `const std::string*` can not be automatically converted to a rvalue.
  return std::pair<
    const std::string*,
    common::optional<DeserializationError>
  >(
    model_type,
    common::nullopt
  );
}

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IHasSemantics.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IHasSemantics>
  >,
  common::optional<DeserializationError>
> DeserializeHasSemantics(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IExtension.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IExtension>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeExtension(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IHasExtensions.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IHasExtensions>
  >,
  common::optional<DeserializationError>
> DeserializeHasExtensions(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IReferable.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IReferable>
  >,
  common::optional<DeserializationError>
> DeserializeReferable(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IIdentifiable.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IIdentifiable>
  >,
  common::optional<DeserializationError>
> DeserializeIdentifiable(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IHasKind.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IHasKind>
  >,
  common::optional<DeserializationError>
> DeserializeHasKind(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IHasDataSpecification.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IHasDataSpecification>
  >,
  common::optional<DeserializationError>
> DeserializeHasDataSpecification(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IAdministrativeInformation.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAdministrativeInformation>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeAdministrativeInformation(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IQualifiable.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IQualifiable>
  >,
  common::optional<DeserializationError>
> DeserializeQualifiable(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IQualifier.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IQualifier>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeQualifier(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IAssetAdministrationShell.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAssetAdministrationShell>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeAssetAdministrationShell(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IAssetInformation.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IAssetInformation>
  >,
  common::optional<DeserializationError>
> DeserializeAssetInformation(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IResource.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IResource>
  >,
  common::optional<DeserializationError>
> DeserializeResource(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ISpecificAssetId.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISpecificAssetId>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeSpecificAssetId(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ISubmodel.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodel>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeSubmodel(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::ISubmodelElement.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodelElement>
  >,
  common::optional<DeserializationError>
> DeserializeSubmodelElement(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IRelationshipElement.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IRelationshipElement>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ConcretelyDeserializeRelationshipElement(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IRelationshipElement.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IRelationshipElement>
  >,
  common::optional<DeserializationError>
> DeserializeRelationshipElement(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ISubmodelElementList.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodelElementList>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeSubmodelElementList(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ISubmodelElementCollection.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodelElementCollection>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeSubmodelElementCollection(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IDataElement.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IDataElement>
  >,
  common::optional<DeserializationError>
> DeserializeDataElement(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IProperty.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IProperty>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeProperty(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IMultiLanguageProperty.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IMultiLanguageProperty>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeMultiLanguageProperty(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IRange.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IRange>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeRange(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IReferenceElement.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IReferenceElement>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeReferenceElement(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IBlob.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IBlob>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeBlob(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IFile.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IFile>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeFile(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IAnnotatedRelationshipElement.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAnnotatedRelationshipElement>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeAnnotatedRelationshipElement(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IEntity.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEntity>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeEntity(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IEventPayload.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IEventPayload>
  >,
  common::optional<DeserializationError>
> DeserializeEventPayload(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IEventElement.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IEventElement>
  >,
  common::optional<DeserializationError>
> DeserializeEventElement(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IBasicEventElement.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IBasicEventElement>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeBasicEventElement(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IOperation.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IOperation>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeOperation(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IOperationVariable.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IOperationVariable>
  >,
  common::optional<DeserializationError>
> DeserializeOperationVariable(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ICapability.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ICapability>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeCapability(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IConceptDescription.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IConceptDescription>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeConceptDescription(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IReference.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IReference>
  >,
  common::optional<DeserializationError>
> DeserializeReference(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IKey.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IKey>
  >,
  common::optional<DeserializationError>
> DeserializeKey(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IAbstractLangString.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IAbstractLangString>
  >,
  common::optional<DeserializationError>
> DeserializeAbstractLangString(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ILangStringNameType.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringNameType>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringNameType(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ILangStringTextType.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringTextType>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringTextType(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IEnvironment.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IEnvironment>
  >,
  common::optional<DeserializationError>
> DeserializeEnvironment(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Dispatch the deserialization for an instance
 * of types::IDataSpecificationContent.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IDataSpecificationContent>
  >,
  common::optional<DeserializationError>
> DeserializeDataSpecificationContent(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IEmbeddedDataSpecification.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >,
  common::optional<DeserializationError>
> DeserializeEmbeddedDataSpecification(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ILevelType.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::ILevelType>
  >,
  common::optional<DeserializationError>
> DeserializeLevelType(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IValueReferencePair.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IValueReferencePair>
  >,
  common::optional<DeserializationError>
> DeserializeValueReferencePair(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IValueList.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
std::pair<
  common::optional<
    std::shared_ptr<types::IValueList>
  >,
  common::optional<DeserializationError>
> DeserializeValueList(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ILangStringPreferredNameTypeIec61360.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringPreferredNameTypeIec61360>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringPreferredNameTypeIec61360(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ILangStringShortNameTypeIec61360.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringShortNameTypeIec61360>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringShortNameTypeIec61360(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::ILangStringDefinitionTypeIec61360.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringDefinitionTypeIec61360>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringDefinitionTypeIec61360(
  const nlohmann::json& json,
  bool additional_properties
);

/**
 * \brief Deserialize concretely an instance
 * of types::IDataSpecificationIec61360.
 *
 * \param json value to be de-serialized
 * \param additional_properties if not set, check that \p json contains
 * no additional properties
 * \return the deserialized instance, or an error, if any
 */
template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IDataSpecificationIec61360>::value
  >::type* = nullptr
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeDataSpecificationIec61360(
  const nlohmann::json& json,
  bool additional_properties
);

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IHasSemantics> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeHasSemanticsByModelType = {
  {
    "RelationshipElement",
    ConcretelyDeserializeRelationshipElement<
      types::IHasSemantics
    >
  },
  {
    "AnnotatedRelationshipElement",
    DeserializeAnnotatedRelationshipElement<
      types::IHasSemantics
    >
  },
  {
    "BasicEventElement",
    DeserializeBasicEventElement<
      types::IHasSemantics
    >
  },
  {
    "Blob",
    DeserializeBlob<
      types::IHasSemantics
    >
  },
  {
    "Capability",
    DeserializeCapability<
      types::IHasSemantics
    >
  },
  {
    "Entity",
    DeserializeEntity<
      types::IHasSemantics
    >
  },
  {
    "Extension",
    DeserializeExtension<
      types::IHasSemantics
    >
  },
  {
    "File",
    DeserializeFile<
      types::IHasSemantics
    >
  },
  {
    "MultiLanguageProperty",
    DeserializeMultiLanguageProperty<
      types::IHasSemantics
    >
  },
  {
    "Operation",
    DeserializeOperation<
      types::IHasSemantics
    >
  },
  {
    "Property",
    DeserializeProperty<
      types::IHasSemantics
    >
  },
  {
    "Qualifier",
    DeserializeQualifier<
      types::IHasSemantics
    >
  },
  {
    "Range",
    DeserializeRange<
      types::IHasSemantics
    >
  },
  {
    "ReferenceElement",
    DeserializeReferenceElement<
      types::IHasSemantics
    >
  },
  {
    "SpecificAssetId",
    DeserializeSpecificAssetId<
      types::IHasSemantics
    >
  },
  {
    "Submodel",
    DeserializeSubmodel<
      types::IHasSemantics
    >
  },
  {
    "SubmodelElementCollection",
    DeserializeSubmodelElementCollection<
      types::IHasSemantics
    >
  },
  {
    "SubmodelElementList",
    DeserializeSubmodelElementList<
      types::IHasSemantics
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IHasSemantics>
  >,
  common::optional<DeserializationError>
> DeserializeHasSemantics(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IHasSemantics> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeHasSemanticsByModelType.find(*model_type);
  if (it == kDeserializeHasSemanticsByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IHasSemantics "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IHasSemantics> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInExtension = {
  "semanticId",
  "supplementalSemanticIds",
  "name",
  "valueType",
  "value",
  "refersTo"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IExtension>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeExtension(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInExtension.find(key_val.key())
      );
      if (it == kPropertiesInExtension.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("name")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property name is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<std::wstring> the_name;

  common::optional<types::DataTypeDefXsd> the_value_type;

  common::optional<std::wstring> the_value;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_refers_to;

  // endregion Initialization

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize name

  std::tie(
    the_name,
    error
  ) = DeserializeWstring(
    json["name"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"name"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize name

  // region De-serialize valueType

  if (json.contains("valueType")) {
    common::optional<std::wstring> text_value_type;

    std::tie(
      text_value_type,
      error
    ) = DeserializeWstring(
      json["valueType"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueType"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_value_type = std::move(
      wstringification::DataTypeDefXsdFromWstring(
        *text_value_type
      )
    );
    if (!the_value_type.has_value()) {
      std::wstring message = common::Concat(
        L"Invalid literal for DataTypeDefXsd: ",
        *text_value_type
      );

      error = common::make_optional<DeserializationError>(
        message
      );
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueType"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize valueType

  // region De-serialize value

  if (json.contains("value")) {
    std::tie(
      the_value,
      error
    ) = DeserializeWstring(
      json["value"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize value

  // region De-serialize refersTo

  if (json.contains("refersTo")) {
    const nlohmann::json& json_refers_to(
      json["refersTo"]
    );
    if (!json_refers_to.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_refers_to.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"refersTo"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_refers_to = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_refers_to->reserve(json_refers_to.size());

    size_t index_refers_to = 0;

    for (
      const nlohmann::json& item
      : json_refers_to
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_refers_to
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"refersTo"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_refers_to->emplace_back(
        std::move(*deserialized)
      );

      ++index_refers_to;
    }
  }

  // endregion De-serialize refersTo

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Extension(
        std::move(*the_name),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_value_type),
        std::move(the_value),
        std::move(the_refers_to)
      )
    ),
    common::nullopt
  );
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IHasExtensions> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeHasExtensionsByModelType = {
  {
    "RelationshipElement",
    ConcretelyDeserializeRelationshipElement<
      types::IHasExtensions
    >
  },
  {
    "AnnotatedRelationshipElement",
    DeserializeAnnotatedRelationshipElement<
      types::IHasExtensions
    >
  },
  {
    "AssetAdministrationShell",
    DeserializeAssetAdministrationShell<
      types::IHasExtensions
    >
  },
  {
    "BasicEventElement",
    DeserializeBasicEventElement<
      types::IHasExtensions
    >
  },
  {
    "Blob",
    DeserializeBlob<
      types::IHasExtensions
    >
  },
  {
    "Capability",
    DeserializeCapability<
      types::IHasExtensions
    >
  },
  {
    "ConceptDescription",
    DeserializeConceptDescription<
      types::IHasExtensions
    >
  },
  {
    "Entity",
    DeserializeEntity<
      types::IHasExtensions
    >
  },
  {
    "File",
    DeserializeFile<
      types::IHasExtensions
    >
  },
  {
    "MultiLanguageProperty",
    DeserializeMultiLanguageProperty<
      types::IHasExtensions
    >
  },
  {
    "Operation",
    DeserializeOperation<
      types::IHasExtensions
    >
  },
  {
    "Property",
    DeserializeProperty<
      types::IHasExtensions
    >
  },
  {
    "Range",
    DeserializeRange<
      types::IHasExtensions
    >
  },
  {
    "ReferenceElement",
    DeserializeReferenceElement<
      types::IHasExtensions
    >
  },
  {
    "Submodel",
    DeserializeSubmodel<
      types::IHasExtensions
    >
  },
  {
    "SubmodelElementCollection",
    DeserializeSubmodelElementCollection<
      types::IHasExtensions
    >
  },
  {
    "SubmodelElementList",
    DeserializeSubmodelElementList<
      types::IHasExtensions
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IHasExtensions>
  >,
  common::optional<DeserializationError>
> DeserializeHasExtensions(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IHasExtensions> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeHasExtensionsByModelType.find(*model_type);
  if (it == kDeserializeHasExtensionsByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IHasExtensions "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IHasExtensions> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IReferable> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeReferableByModelType = {
  {
    "RelationshipElement",
    ConcretelyDeserializeRelationshipElement<
      types::IReferable
    >
  },
  {
    "AnnotatedRelationshipElement",
    DeserializeAnnotatedRelationshipElement<
      types::IReferable
    >
  },
  {
    "AssetAdministrationShell",
    DeserializeAssetAdministrationShell<
      types::IReferable
    >
  },
  {
    "BasicEventElement",
    DeserializeBasicEventElement<
      types::IReferable
    >
  },
  {
    "Blob",
    DeserializeBlob<
      types::IReferable
    >
  },
  {
    "Capability",
    DeserializeCapability<
      types::IReferable
    >
  },
  {
    "ConceptDescription",
    DeserializeConceptDescription<
      types::IReferable
    >
  },
  {
    "Entity",
    DeserializeEntity<
      types::IReferable
    >
  },
  {
    "File",
    DeserializeFile<
      types::IReferable
    >
  },
  {
    "MultiLanguageProperty",
    DeserializeMultiLanguageProperty<
      types::IReferable
    >
  },
  {
    "Operation",
    DeserializeOperation<
      types::IReferable
    >
  },
  {
    "Property",
    DeserializeProperty<
      types::IReferable
    >
  },
  {
    "Range",
    DeserializeRange<
      types::IReferable
    >
  },
  {
    "ReferenceElement",
    DeserializeReferenceElement<
      types::IReferable
    >
  },
  {
    "Submodel",
    DeserializeSubmodel<
      types::IReferable
    >
  },
  {
    "SubmodelElementCollection",
    DeserializeSubmodelElementCollection<
      types::IReferable
    >
  },
  {
    "SubmodelElementList",
    DeserializeSubmodelElementList<
      types::IReferable
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IReferable>
  >,
  common::optional<DeserializationError>
> DeserializeReferable(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IReferable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeReferableByModelType.find(*model_type);
  if (it == kDeserializeReferableByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IReferable "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IReferable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IIdentifiable> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeIdentifiableByModelType = {
  {
    "AssetAdministrationShell",
    DeserializeAssetAdministrationShell<
      types::IIdentifiable
    >
  },
  {
    "ConceptDescription",
    DeserializeConceptDescription<
      types::IIdentifiable
    >
  },
  {
    "Submodel",
    DeserializeSubmodel<
      types::IIdentifiable
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IIdentifiable>
  >,
  common::optional<DeserializationError>
> DeserializeIdentifiable(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IIdentifiable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeIdentifiableByModelType.find(*model_type);
  if (it == kDeserializeIdentifiableByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IIdentifiable "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IIdentifiable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IHasKind> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeHasKindByModelType = {
  {
    "Submodel",
    DeserializeSubmodel<
      types::IHasKind
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IHasKind>
  >,
  common::optional<DeserializationError>
> DeserializeHasKind(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IHasKind> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeHasKindByModelType.find(*model_type);
  if (it == kDeserializeHasKindByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IHasKind "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IHasKind> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IHasDataSpecification> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeHasDataSpecificationByModelType = {
  {
    "AdministrativeInformation",
    DeserializeAdministrativeInformation<
      types::IHasDataSpecification
    >
  },
  {
    "RelationshipElement",
    ConcretelyDeserializeRelationshipElement<
      types::IHasDataSpecification
    >
  },
  {
    "AnnotatedRelationshipElement",
    DeserializeAnnotatedRelationshipElement<
      types::IHasDataSpecification
    >
  },
  {
    "AssetAdministrationShell",
    DeserializeAssetAdministrationShell<
      types::IHasDataSpecification
    >
  },
  {
    "BasicEventElement",
    DeserializeBasicEventElement<
      types::IHasDataSpecification
    >
  },
  {
    "Blob",
    DeserializeBlob<
      types::IHasDataSpecification
    >
  },
  {
    "Capability",
    DeserializeCapability<
      types::IHasDataSpecification
    >
  },
  {
    "ConceptDescription",
    DeserializeConceptDescription<
      types::IHasDataSpecification
    >
  },
  {
    "Entity",
    DeserializeEntity<
      types::IHasDataSpecification
    >
  },
  {
    "File",
    DeserializeFile<
      types::IHasDataSpecification
    >
  },
  {
    "MultiLanguageProperty",
    DeserializeMultiLanguageProperty<
      types::IHasDataSpecification
    >
  },
  {
    "Operation",
    DeserializeOperation<
      types::IHasDataSpecification
    >
  },
  {
    "Property",
    DeserializeProperty<
      types::IHasDataSpecification
    >
  },
  {
    "Range",
    DeserializeRange<
      types::IHasDataSpecification
    >
  },
  {
    "ReferenceElement",
    DeserializeReferenceElement<
      types::IHasDataSpecification
    >
  },
  {
    "Submodel",
    DeserializeSubmodel<
      types::IHasDataSpecification
    >
  },
  {
    "SubmodelElementCollection",
    DeserializeSubmodelElementCollection<
      types::IHasDataSpecification
    >
  },
  {
    "SubmodelElementList",
    DeserializeSubmodelElementList<
      types::IHasDataSpecification
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IHasDataSpecification>
  >,
  common::optional<DeserializationError>
> DeserializeHasDataSpecification(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IHasDataSpecification> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeHasDataSpecificationByModelType.find(*model_type);
  if (it == kDeserializeHasDataSpecificationByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IHasDataSpecification "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IHasDataSpecification> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInAdministrativeInformation = {
  "embeddedDataSpecifications",
  "version",
  "revision",
  "creator",
  "templateId"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAdministrativeInformation>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeAdministrativeInformation(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInAdministrativeInformation.find(key_val.key())
      );
      if (it == kPropertiesInAdministrativeInformation.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::wstring> the_version;

  common::optional<std::wstring> the_revision;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_creator;

  common::optional<std::wstring> the_template_id;

  // endregion Initialization

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize version

  if (json.contains("version")) {
    std::tie(
      the_version,
      error
    ) = DeserializeWstring(
      json["version"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"version"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize version

  // region De-serialize revision

  if (json.contains("revision")) {
    std::tie(
      the_revision,
      error
    ) = DeserializeWstring(
      json["revision"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"revision"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize revision

  // region De-serialize creator

  if (json.contains("creator")) {
    std::tie(
      the_creator,
      error
    ) = DeserializeReference(
      json["creator"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"creator"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize creator

  // region De-serialize templateId

  if (json.contains("templateId")) {
    std::tie(
      the_template_id,
      error
    ) = DeserializeWstring(
      json["templateId"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"templateId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize templateId

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::AdministrativeInformation(
        std::move(the_embedded_data_specifications),
        std::move(the_version),
        std::move(the_revision),
        std::move(the_creator),
        std::move(the_template_id)
      )
    ),
    common::nullopt
  );
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IQualifiable> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeQualifiableByModelType = {
  {
    "RelationshipElement",
    ConcretelyDeserializeRelationshipElement<
      types::IQualifiable
    >
  },
  {
    "AnnotatedRelationshipElement",
    DeserializeAnnotatedRelationshipElement<
      types::IQualifiable
    >
  },
  {
    "BasicEventElement",
    DeserializeBasicEventElement<
      types::IQualifiable
    >
  },
  {
    "Blob",
    DeserializeBlob<
      types::IQualifiable
    >
  },
  {
    "Capability",
    DeserializeCapability<
      types::IQualifiable
    >
  },
  {
    "Entity",
    DeserializeEntity<
      types::IQualifiable
    >
  },
  {
    "File",
    DeserializeFile<
      types::IQualifiable
    >
  },
  {
    "MultiLanguageProperty",
    DeserializeMultiLanguageProperty<
      types::IQualifiable
    >
  },
  {
    "Operation",
    DeserializeOperation<
      types::IQualifiable
    >
  },
  {
    "Property",
    DeserializeProperty<
      types::IQualifiable
    >
  },
  {
    "Range",
    DeserializeRange<
      types::IQualifiable
    >
  },
  {
    "ReferenceElement",
    DeserializeReferenceElement<
      types::IQualifiable
    >
  },
  {
    "Submodel",
    DeserializeSubmodel<
      types::IQualifiable
    >
  },
  {
    "SubmodelElementCollection",
    DeserializeSubmodelElementCollection<
      types::IQualifiable
    >
  },
  {
    "SubmodelElementList",
    DeserializeSubmodelElementList<
      types::IQualifiable
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IQualifiable>
  >,
  common::optional<DeserializationError>
> DeserializeQualifiable(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IQualifiable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeQualifiableByModelType.find(*model_type);
  if (it == kDeserializeQualifiableByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IQualifiable "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IQualifiable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInQualifier = {
  "semanticId",
  "supplementalSemanticIds",
  "kind",
  "type",
  "valueType",
  "value",
  "valueId"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IQualifier>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeQualifier(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInQualifier.find(key_val.key())
      );
      if (it == kPropertiesInQualifier.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("type")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property type is missing"
      )
    );
  }

  if (!json.contains("valueType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property valueType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<types::QualifierKind> the_kind;

  common::optional<std::wstring> the_type;

  common::optional<types::DataTypeDefXsd> the_value_type;

  common::optional<std::wstring> the_value;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_value_id;

  // endregion Initialization

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize kind

  if (json.contains("kind")) {
    common::optional<std::wstring> text_kind;

    std::tie(
      text_kind,
      error
    ) = DeserializeWstring(
      json["kind"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"kind"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_kind = std::move(
      wstringification::QualifierKindFromWstring(
        *text_kind
      )
    );
    if (!the_kind.has_value()) {
      std::wstring message = common::Concat(
        L"Invalid literal for QualifierKind: ",
        *text_kind
      );

      error = common::make_optional<DeserializationError>(
        message
      );
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"kind"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize kind

  // region De-serialize type

  std::tie(
    the_type,
    error
  ) = DeserializeWstring(
    json["type"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"type"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize type

  // region De-serialize valueType

  common::optional<std::wstring> text_value_type;

  std::tie(
    text_value_type,
    error
  ) = DeserializeWstring(
    json["valueType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"valueType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_value_type = std::move(
    wstringification::DataTypeDefXsdFromWstring(
      *text_value_type
    )
  );
  if (!the_value_type.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for DataTypeDefXsd: ",
      *text_value_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"valueType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize valueType

  // region De-serialize value

  if (json.contains("value")) {
    std::tie(
      the_value,
      error
    ) = DeserializeWstring(
      json["value"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize value

  // region De-serialize valueId

  if (json.contains("valueId")) {
    std::tie(
      the_value_id,
      error
    ) = DeserializeReference(
      json["valueId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize valueId

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Qualifier(
        std::move(*the_type),
        std::move(*the_value_type),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_kind),
        std::move(the_value),
        std::move(the_value_id)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInAssetAdministrationShell = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "administration",
  "id",
  "embeddedDataSpecifications",
  "derivedFrom",
  "assetInformation",
  "submodels",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAssetAdministrationShell>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeAssetAdministrationShell(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInAssetAdministrationShell.find(key_val.key())
      );
      if (it == kPropertiesInAssetAdministrationShell.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("id")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property id is missing"
      )
    );
  }

  if (!json.contains("assetInformation")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property assetInformation is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > the_administration;

  common::optional<std::wstring> the_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_derived_from;

  common::optional<std::shared_ptr<types::IAssetInformation> > the_asset_information;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_submodels;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize administration

  if (json.contains("administration")) {
    std::tie(
      the_administration,
      error
    ) = DeserializeAdministrativeInformation<
      types::IAdministrativeInformation
    >(
      json["administration"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"administration"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize administration

  // region De-serialize id

  std::tie(
    the_id,
    error
  ) = DeserializeWstring(
    json["id"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"id"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize id

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize derivedFrom

  if (json.contains("derivedFrom")) {
    std::tie(
      the_derived_from,
      error
    ) = DeserializeReference(
      json["derivedFrom"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"derivedFrom"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize derivedFrom

  // region De-serialize assetInformation

  std::tie(
    the_asset_information,
    error
  ) = DeserializeAssetInformation(
    json["assetInformation"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"assetInformation"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize assetInformation

  // region De-serialize submodels

  if (json.contains("submodels")) {
    const nlohmann::json& json_submodels(
      json["submodels"]
    );
    if (!json_submodels.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_submodels.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"submodels"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_submodels = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_submodels->reserve(json_submodels.size());

    size_t index_submodels = 0;

    for (
      const nlohmann::json& item
      : json_submodels
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_submodels
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"submodels"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_submodels->emplace_back(
        std::move(*deserialized)
      );

      ++index_submodels;
    }
  }

  // endregion De-serialize submodels

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"AssetAdministrationShell") {
    std::wstring message = common::Concat(
      L"Expected model type 'AssetAdministrationShell', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::AssetAdministrationShell(
        std::move(*the_id),
        std::move(*the_asset_information),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_administration),
        std::move(the_embedded_data_specifications),
        std::move(the_derived_from),
        std::move(the_submodels)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInAssetInformation = {
  "assetKind",
  "globalAssetId",
  "specificAssetIds",
  "assetType",
  "defaultThumbnail"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IAssetInformation>
  >,
  common::optional<DeserializationError>
> DeserializeAssetInformation(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IAssetInformation> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInAssetInformation.find(key_val.key())
      );
      if (it == kPropertiesInAssetInformation.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IAssetInformation> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("assetKind")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IAssetInformation> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property assetKind is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<types::AssetKind> the_asset_kind;

  common::optional<std::wstring> the_global_asset_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  > the_specific_asset_ids;

  common::optional<std::wstring> the_asset_type;

  common::optional<
    std::shared_ptr<types::IResource>
  > the_default_thumbnail;

  // endregion Initialization

  // region De-serialize assetKind

  common::optional<std::wstring> text_asset_kind;

  std::tie(
    text_asset_kind,
    error
  ) = DeserializeWstring(
    json["assetKind"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"assetKind"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IAssetInformation> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_asset_kind = std::move(
    wstringification::AssetKindFromWstring(
      *text_asset_kind
    )
  );
  if (!the_asset_kind.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for AssetKind: ",
      *text_asset_kind
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"assetKind"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IAssetInformation> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize assetKind

  // region De-serialize globalAssetId

  if (json.contains("globalAssetId")) {
    std::tie(
      the_global_asset_id,
      error
    ) = DeserializeWstring(
      json["globalAssetId"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"globalAssetId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IAssetInformation> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize globalAssetId

  // region De-serialize specificAssetIds

  if (json.contains("specificAssetIds")) {
    const nlohmann::json& json_specific_asset_ids(
      json["specificAssetIds"]
    );
    if (!json_specific_asset_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_specific_asset_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"specificAssetIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IAssetInformation> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_specific_asset_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::ISpecificAssetId>
      >
    >();

    the_specific_asset_ids->reserve(json_specific_asset_ids.size());

    size_t index_specific_asset_ids = 0;

    for (
      const nlohmann::json& item
      : json_specific_asset_ids
    ) {
      common::optional<
        std::shared_ptr<types::ISpecificAssetId>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeSpecificAssetId<
        types::ISpecificAssetId
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_specific_asset_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"specificAssetIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IAssetInformation> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_specific_asset_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_specific_asset_ids;
    }
  }

  // endregion De-serialize specificAssetIds

  // region De-serialize assetType

  if (json.contains("assetType")) {
    std::tie(
      the_asset_type,
      error
    ) = DeserializeWstring(
      json["assetType"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"assetType"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IAssetInformation> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize assetType

  // region De-serialize defaultThumbnail

  if (json.contains("defaultThumbnail")) {
    std::tie(
      the_default_thumbnail,
      error
    ) = DeserializeResource(
      json["defaultThumbnail"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"defaultThumbnail"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IAssetInformation> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize defaultThumbnail

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IAssetInformation>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::AssetInformation(
        std::move(*the_asset_kind),
        std::move(the_global_asset_id),
        std::move(the_specific_asset_ids),
        std::move(the_asset_type),
        std::move(the_default_thumbnail)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInResource = {
  "path",
  "contentType"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IResource>
  >,
  common::optional<DeserializationError>
> DeserializeResource(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IResource> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInResource.find(key_val.key())
      );
      if (it == kPropertiesInResource.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IResource> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("path")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IResource> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property path is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::wstring> the_path;

  common::optional<std::wstring> the_content_type;

  // endregion Initialization

  // region De-serialize path

  std::tie(
    the_path,
    error
  ) = DeserializeWstring(
    json["path"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"path"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IResource> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize path

  // region De-serialize contentType

  if (json.contains("contentType")) {
    std::tie(
      the_content_type,
      error
    ) = DeserializeWstring(
      json["contentType"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"contentType"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IResource> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize contentType

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IResource>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Resource(
        std::move(*the_path),
        std::move(the_content_type)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInSpecificAssetId = {
  "semanticId",
  "supplementalSemanticIds",
  "name",
  "value",
  "externalSubjectId"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISpecificAssetId>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeSpecificAssetId(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInSpecificAssetId.find(key_val.key())
      );
      if (it == kPropertiesInSpecificAssetId.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("name")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property name is missing"
      )
    );
  }

  if (!json.contains("value")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property value is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<std::wstring> the_name;

  common::optional<std::wstring> the_value;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_external_subject_id;

  // endregion Initialization

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize name

  std::tie(
    the_name,
    error
  ) = DeserializeWstring(
    json["name"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"name"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize name

  // region De-serialize value

  std::tie(
    the_value,
    error
  ) = DeserializeWstring(
    json["value"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"value"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize value

  // region De-serialize externalSubjectId

  if (json.contains("externalSubjectId")) {
    std::tie(
      the_external_subject_id,
      error
    ) = DeserializeReference(
      json["externalSubjectId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"externalSubjectId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize externalSubjectId

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::SpecificAssetId(
        std::move(*the_name),
        std::move(*the_value),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_external_subject_id)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInSubmodel = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "administration",
  "id",
  "kind",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "submodelElements",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodel>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeSubmodel(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInSubmodel.find(key_val.key())
      );
      if (it == kPropertiesInSubmodel.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("id")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property id is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > the_administration;

  common::optional<std::wstring> the_id;

  common::optional<types::ModellingKind> the_kind;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  > the_submodel_elements;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize administration

  if (json.contains("administration")) {
    std::tie(
      the_administration,
      error
    ) = DeserializeAdministrativeInformation<
      types::IAdministrativeInformation
    >(
      json["administration"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"administration"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize administration

  // region De-serialize id

  std::tie(
    the_id,
    error
  ) = DeserializeWstring(
    json["id"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"id"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize id

  // region De-serialize kind

  if (json.contains("kind")) {
    common::optional<std::wstring> text_kind;

    std::tie(
      text_kind,
      error
    ) = DeserializeWstring(
      json["kind"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"kind"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_kind = std::move(
      wstringification::ModellingKindFromWstring(
        *text_kind
      )
    );
    if (!the_kind.has_value()) {
      std::wstring message = common::Concat(
        L"Invalid literal for ModellingKind: ",
        *text_kind
      );

      error = common::make_optional<DeserializationError>(
        message
      );
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"kind"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize kind

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize submodelElements

  if (json.contains("submodelElements")) {
    const nlohmann::json& json_submodel_elements(
      json["submodelElements"]
    );
    if (!json_submodel_elements.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_submodel_elements.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"submodelElements"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_submodel_elements = common::make_optional<
      std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >
    >();

    the_submodel_elements->reserve(json_submodel_elements.size());

    size_t index_submodel_elements = 0;

    for (
      const nlohmann::json& item
      : json_submodel_elements
    ) {
      common::optional<
        std::shared_ptr<types::ISubmodelElement>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeSubmodelElement(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_submodel_elements
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"submodelElements"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_submodel_elements->emplace_back(
        std::move(*deserialized)
      );

      ++index_submodel_elements;
    }
  }

  // endregion De-serialize submodelElements

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"Submodel") {
    std::wstring message = common::Concat(
      L"Expected model type 'Submodel', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Submodel(
        std::move(*the_id),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_administration),
        std::move(the_kind),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_submodel_elements)
      )
    ),
    common::nullopt
  );
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::ISubmodelElement> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeSubmodelElementByModelType = {
  {
    "RelationshipElement",
    ConcretelyDeserializeRelationshipElement<
      types::ISubmodelElement
    >
  },
  {
    "AnnotatedRelationshipElement",
    DeserializeAnnotatedRelationshipElement<
      types::ISubmodelElement
    >
  },
  {
    "BasicEventElement",
    DeserializeBasicEventElement<
      types::ISubmodelElement
    >
  },
  {
    "Blob",
    DeserializeBlob<
      types::ISubmodelElement
    >
  },
  {
    "Capability",
    DeserializeCapability<
      types::ISubmodelElement
    >
  },
  {
    "Entity",
    DeserializeEntity<
      types::ISubmodelElement
    >
  },
  {
    "File",
    DeserializeFile<
      types::ISubmodelElement
    >
  },
  {
    "MultiLanguageProperty",
    DeserializeMultiLanguageProperty<
      types::ISubmodelElement
    >
  },
  {
    "Operation",
    DeserializeOperation<
      types::ISubmodelElement
    >
  },
  {
    "Property",
    DeserializeProperty<
      types::ISubmodelElement
    >
  },
  {
    "Range",
    DeserializeRange<
      types::ISubmodelElement
    >
  },
  {
    "ReferenceElement",
    DeserializeReferenceElement<
      types::ISubmodelElement
    >
  },
  {
    "SubmodelElementCollection",
    DeserializeSubmodelElementCollection<
      types::ISubmodelElement
    >
  },
  {
    "SubmodelElementList",
    DeserializeSubmodelElementList<
      types::ISubmodelElement
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::ISubmodelElement>
  >,
  common::optional<DeserializationError>
> DeserializeSubmodelElement(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::ISubmodelElement> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeSubmodelElementByModelType.find(*model_type);
  if (it == kDeserializeSubmodelElementByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::ISubmodelElement "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::ISubmodelElement> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInRelationshipElement = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "first",
  "second",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IRelationshipElement>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> ConcretelyDeserializeRelationshipElement(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInRelationshipElement.find(key_val.key())
      );
      if (it == kPropertiesInRelationshipElement.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("first")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property first is missing"
      )
    );
  }

  if (!json.contains("second")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property second is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::shared_ptr<types::IReference> > the_first;

  common::optional<std::shared_ptr<types::IReference> > the_second;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize first

  std::tie(
    the_first,
    error
  ) = DeserializeReference(
    json["first"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"first"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize first

  // region De-serialize second

  std::tie(
    the_second,
    error
  ) = DeserializeReference(
    json["second"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"second"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize second

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"RelationshipElement") {
    std::wstring message = common::Concat(
      L"Expected model type 'RelationshipElement', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::RelationshipElement(
        std::move(*the_first),
        std::move(*the_second),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications)
      )
    ),
    common::nullopt
  );
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IRelationshipElement> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeRelationshipElementByModelType = {
  {
    "RelationshipElement",
    ConcretelyDeserializeRelationshipElement<
      types::IRelationshipElement
    >
  },
  {
    "AnnotatedRelationshipElement",
    DeserializeAnnotatedRelationshipElement<
      types::IRelationshipElement
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IRelationshipElement>
  >,
  common::optional<DeserializationError>
> DeserializeRelationshipElement(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IRelationshipElement> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeRelationshipElementByModelType.find(*model_type);
  if (it == kDeserializeRelationshipElementByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IRelationshipElement "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IRelationshipElement> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInSubmodelElementList = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "orderRelevant",
  "semanticIdListElement",
  "typeValueListElement",
  "valueTypeListElement",
  "value",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodelElementList>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeSubmodelElementList(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInSubmodelElementList.find(key_val.key())
      );
      if (it == kPropertiesInSubmodelElementList.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("typeValueListElement")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property typeValueListElement is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<bool> the_order_relevant;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id_list_element;

  common::optional<types::AasSubmodelElements> the_type_value_list_element;

  common::optional<types::DataTypeDefXsd> the_value_type_list_element;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  > the_value;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize orderRelevant

  if (json.contains("orderRelevant")) {
    std::tie(
      the_order_relevant,
      error
    ) = DeserializeBool(
      json["orderRelevant"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"orderRelevant"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize orderRelevant

  // region De-serialize semanticIdListElement

  if (json.contains("semanticIdListElement")) {
    std::tie(
      the_semantic_id_list_element,
      error
    ) = DeserializeReference(
      json["semanticIdListElement"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticIdListElement"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticIdListElement

  // region De-serialize typeValueListElement

  common::optional<std::wstring> text_type_value_list_element;

  std::tie(
    text_type_value_list_element,
    error
  ) = DeserializeWstring(
    json["typeValueListElement"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"typeValueListElement"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_type_value_list_element = std::move(
    wstringification::AasSubmodelElementsFromWstring(
      *text_type_value_list_element
    )
  );
  if (!the_type_value_list_element.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for AasSubmodelElements: ",
      *text_type_value_list_element
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"typeValueListElement"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize typeValueListElement

  // region De-serialize valueTypeListElement

  if (json.contains("valueTypeListElement")) {
    common::optional<std::wstring> text_value_type_list_element;

    std::tie(
      text_value_type_list_element,
      error
    ) = DeserializeWstring(
      json["valueTypeListElement"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueTypeListElement"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_value_type_list_element = std::move(
      wstringification::DataTypeDefXsdFromWstring(
        *text_value_type_list_element
      )
    );
    if (!the_value_type_list_element.has_value()) {
      std::wstring message = common::Concat(
        L"Invalid literal for DataTypeDefXsd: ",
        *text_value_type_list_element
      );

      error = common::make_optional<DeserializationError>(
        message
      );
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueTypeListElement"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize valueTypeListElement

  // region De-serialize value

  if (json.contains("value")) {
    const nlohmann::json& json_value(
      json["value"]
    );
    if (!json_value.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_value.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_value = common::make_optional<
      std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >
    >();

    the_value->reserve(json_value.size());

    size_t index_value = 0;

    for (
      const nlohmann::json& item
      : json_value
    ) {
      common::optional<
        std::shared_ptr<types::ISubmodelElement>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeSubmodelElement(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_value
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"value"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_value->emplace_back(
        std::move(*deserialized)
      );

      ++index_value;
    }
  }

  // endregion De-serialize value

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"SubmodelElementList") {
    std::wstring message = common::Concat(
      L"Expected model type 'SubmodelElementList', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::SubmodelElementList(
        std::move(*the_type_value_list_element),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_order_relevant),
        std::move(the_semantic_id_list_element),
        std::move(the_value_type_list_element),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInSubmodelElementCollection = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "value",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ISubmodelElementCollection>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeSubmodelElementCollection(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInSubmodelElementCollection.find(key_val.key())
      );
      if (it == kPropertiesInSubmodelElementCollection.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  > the_value;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize value

  if (json.contains("value")) {
    const nlohmann::json& json_value(
      json["value"]
    );
    if (!json_value.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_value.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_value = common::make_optional<
      std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >
    >();

    the_value->reserve(json_value.size());

    size_t index_value = 0;

    for (
      const nlohmann::json& item
      : json_value
    ) {
      common::optional<
        std::shared_ptr<types::ISubmodelElement>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeSubmodelElement(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_value
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"value"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_value->emplace_back(
        std::move(*deserialized)
      );

      ++index_value;
    }
  }

  // endregion De-serialize value

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"SubmodelElementCollection") {
    std::wstring message = common::Concat(
      L"Expected model type 'SubmodelElementCollection', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::SubmodelElementCollection(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IDataElement> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeDataElementByModelType = {
  {
    "Blob",
    DeserializeBlob<
      types::IDataElement
    >
  },
  {
    "File",
    DeserializeFile<
      types::IDataElement
    >
  },
  {
    "MultiLanguageProperty",
    DeserializeMultiLanguageProperty<
      types::IDataElement
    >
  },
  {
    "Property",
    DeserializeProperty<
      types::IDataElement
    >
  },
  {
    "Range",
    DeserializeRange<
      types::IDataElement
    >
  },
  {
    "ReferenceElement",
    DeserializeReferenceElement<
      types::IDataElement
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IDataElement>
  >,
  common::optional<DeserializationError>
> DeserializeDataElement(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IDataElement> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeDataElementByModelType.find(*model_type);
  if (it == kDeserializeDataElementByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IDataElement "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IDataElement> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInProperty = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "valueType",
  "value",
  "valueId",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IProperty>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeProperty(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInProperty.find(key_val.key())
      );
      if (it == kPropertiesInProperty.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("valueType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property valueType is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<types::DataTypeDefXsd> the_value_type;

  common::optional<std::wstring> the_value;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_value_id;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize valueType

  common::optional<std::wstring> text_value_type;

  std::tie(
    text_value_type,
    error
  ) = DeserializeWstring(
    json["valueType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"valueType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_value_type = std::move(
    wstringification::DataTypeDefXsdFromWstring(
      *text_value_type
    )
  );
  if (!the_value_type.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for DataTypeDefXsd: ",
      *text_value_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"valueType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize valueType

  // region De-serialize value

  if (json.contains("value")) {
    std::tie(
      the_value,
      error
    ) = DeserializeWstring(
      json["value"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize value

  // region De-serialize valueId

  if (json.contains("valueId")) {
    std::tie(
      the_value_id,
      error
    ) = DeserializeReference(
      json["valueId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize valueId

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"Property") {
    std::wstring message = common::Concat(
      L"Expected model type 'Property', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Property(
        std::move(*the_value_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value),
        std::move(the_value_id)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInMultiLanguageProperty = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "value",
  "valueId",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IMultiLanguageProperty>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeMultiLanguageProperty(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInMultiLanguageProperty.find(key_val.key())
      );
      if (it == kPropertiesInMultiLanguageProperty.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_value;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_value_id;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize value

  if (json.contains("value")) {
    const nlohmann::json& json_value(
      json["value"]
    );
    if (!json_value.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_value.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_value = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_value->reserve(json_value.size());

    size_t index_value = 0;

    for (
      const nlohmann::json& item
      : json_value
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_value
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"value"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_value->emplace_back(
        std::move(*deserialized)
      );

      ++index_value;
    }
  }

  // endregion De-serialize value

  // region De-serialize valueId

  if (json.contains("valueId")) {
    std::tie(
      the_value_id,
      error
    ) = DeserializeReference(
      json["valueId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize valueId

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"MultiLanguageProperty") {
    std::wstring message = common::Concat(
      L"Expected model type 'MultiLanguageProperty', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::MultiLanguageProperty(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value),
        std::move(the_value_id)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInRange = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "valueType",
  "min",
  "max",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IRange>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeRange(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInRange.find(key_val.key())
      );
      if (it == kPropertiesInRange.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("valueType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property valueType is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<types::DataTypeDefXsd> the_value_type;

  common::optional<std::wstring> the_min;

  common::optional<std::wstring> the_max;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize valueType

  common::optional<std::wstring> text_value_type;

  std::tie(
    text_value_type,
    error
  ) = DeserializeWstring(
    json["valueType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"valueType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_value_type = std::move(
    wstringification::DataTypeDefXsdFromWstring(
      *text_value_type
    )
  );
  if (!the_value_type.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for DataTypeDefXsd: ",
      *text_value_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"valueType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize valueType

  // region De-serialize min

  if (json.contains("min")) {
    std::tie(
      the_min,
      error
    ) = DeserializeWstring(
      json["min"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"min"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize min

  // region De-serialize max

  if (json.contains("max")) {
    std::tie(
      the_max,
      error
    ) = DeserializeWstring(
      json["max"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"max"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize max

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"Range") {
    std::wstring message = common::Concat(
      L"Expected model type 'Range', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Range(
        std::move(*the_value_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_min),
        std::move(the_max)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInReferenceElement = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "value",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IReferenceElement>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeReferenceElement(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInReferenceElement.find(key_val.key())
      );
      if (it == kPropertiesInReferenceElement.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_value;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize value

  if (json.contains("value")) {
    std::tie(
      the_value,
      error
    ) = DeserializeReference(
      json["value"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize value

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"ReferenceElement") {
    std::wstring message = common::Concat(
      L"Expected model type 'ReferenceElement', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ReferenceElement(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInBlob = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "value",
  "contentType",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IBlob>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeBlob(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInBlob.find(key_val.key())
      );
      if (it == kPropertiesInBlob.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("contentType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property contentType is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<std::uint8_t>
  > the_value;

  common::optional<std::wstring> the_content_type;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize value

  if (json.contains("value")) {
    std::tie(
      the_value,
      error
    ) = DeserializeByteArray(
      json["value"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize value

  // region De-serialize contentType

  std::tie(
    the_content_type,
    error
  ) = DeserializeWstring(
    json["contentType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"contentType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize contentType

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"Blob") {
    std::wstring message = common::Concat(
      L"Expected model type 'Blob', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Blob(
        std::move(*the_content_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInFile = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "value",
  "contentType",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IFile>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeFile(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInFile.find(key_val.key())
      );
      if (it == kPropertiesInFile.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("contentType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property contentType is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::wstring> the_value;

  common::optional<std::wstring> the_content_type;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize value

  if (json.contains("value")) {
    std::tie(
      the_value,
      error
    ) = DeserializeWstring(
      json["value"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize value

  // region De-serialize contentType

  std::tie(
    the_content_type,
    error
  ) = DeserializeWstring(
    json["contentType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"contentType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize contentType

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"File") {
    std::wstring message = common::Concat(
      L"Expected model type 'File', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::File(
        std::move(*the_content_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_value)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInAnnotatedRelationshipElement = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "first",
  "second",
  "annotations",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IAnnotatedRelationshipElement>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeAnnotatedRelationshipElement(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInAnnotatedRelationshipElement.find(key_val.key())
      );
      if (it == kPropertiesInAnnotatedRelationshipElement.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("first")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property first is missing"
      )
    );
  }

  if (!json.contains("second")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property second is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::shared_ptr<types::IReference> > the_first;

  common::optional<std::shared_ptr<types::IReference> > the_second;

  common::optional<
    std::vector<
      std::shared_ptr<types::IDataElement>
    >
  > the_annotations;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize first

  std::tie(
    the_first,
    error
  ) = DeserializeReference(
    json["first"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"first"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize first

  // region De-serialize second

  std::tie(
    the_second,
    error
  ) = DeserializeReference(
    json["second"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"second"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize second

  // region De-serialize annotations

  if (json.contains("annotations")) {
    const nlohmann::json& json_annotations(
      json["annotations"]
    );
    if (!json_annotations.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_annotations.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"annotations"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_annotations = common::make_optional<
      std::vector<
        std::shared_ptr<types::IDataElement>
      >
    >();

    the_annotations->reserve(json_annotations.size());

    size_t index_annotations = 0;

    for (
      const nlohmann::json& item
      : json_annotations
    ) {
      common::optional<
        std::shared_ptr<types::IDataElement>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeDataElement(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_annotations
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"annotations"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_annotations->emplace_back(
        std::move(*deserialized)
      );

      ++index_annotations;
    }
  }

  // endregion De-serialize annotations

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"AnnotatedRelationshipElement") {
    std::wstring message = common::Concat(
      L"Expected model type 'AnnotatedRelationshipElement', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::AnnotatedRelationshipElement(
        std::move(*the_first),
        std::move(*the_second),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_annotations)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInEntity = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "statements",
  "entityType",
  "globalAssetId",
  "specificAssetIds",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IEntity>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeEntity(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInEntity.find(key_val.key())
      );
      if (it == kPropertiesInEntity.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("entityType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property entityType is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  > the_statements;

  common::optional<types::EntityType> the_entity_type;

  common::optional<std::wstring> the_global_asset_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  > the_specific_asset_ids;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize statements

  if (json.contains("statements")) {
    const nlohmann::json& json_statements(
      json["statements"]
    );
    if (!json_statements.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_statements.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"statements"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_statements = common::make_optional<
      std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >
    >();

    the_statements->reserve(json_statements.size());

    size_t index_statements = 0;

    for (
      const nlohmann::json& item
      : json_statements
    ) {
      common::optional<
        std::shared_ptr<types::ISubmodelElement>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeSubmodelElement(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_statements
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"statements"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_statements->emplace_back(
        std::move(*deserialized)
      );

      ++index_statements;
    }
  }

  // endregion De-serialize statements

  // region De-serialize entityType

  common::optional<std::wstring> text_entity_type;

  std::tie(
    text_entity_type,
    error
  ) = DeserializeWstring(
    json["entityType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"entityType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_entity_type = std::move(
    wstringification::EntityTypeFromWstring(
      *text_entity_type
    )
  );
  if (!the_entity_type.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for EntityType: ",
      *text_entity_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"entityType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize entityType

  // region De-serialize globalAssetId

  if (json.contains("globalAssetId")) {
    std::tie(
      the_global_asset_id,
      error
    ) = DeserializeWstring(
      json["globalAssetId"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"globalAssetId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize globalAssetId

  // region De-serialize specificAssetIds

  if (json.contains("specificAssetIds")) {
    const nlohmann::json& json_specific_asset_ids(
      json["specificAssetIds"]
    );
    if (!json_specific_asset_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_specific_asset_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"specificAssetIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_specific_asset_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::ISpecificAssetId>
      >
    >();

    the_specific_asset_ids->reserve(json_specific_asset_ids.size());

    size_t index_specific_asset_ids = 0;

    for (
      const nlohmann::json& item
      : json_specific_asset_ids
    ) {
      common::optional<
        std::shared_ptr<types::ISpecificAssetId>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeSpecificAssetId<
        types::ISpecificAssetId
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_specific_asset_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"specificAssetIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_specific_asset_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_specific_asset_ids;
    }
  }

  // endregion De-serialize specificAssetIds

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"Entity") {
    std::wstring message = common::Concat(
      L"Expected model type 'Entity', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Entity(
        std::move(*the_entity_type),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_statements),
        std::move(the_global_asset_id),
        std::move(the_specific_asset_ids)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInEventPayload = {
  "source",
  "sourceSemanticId",
  "observableReference",
  "observableSemanticId",
  "topic",
  "subjectId",
  "timeStamp",
  "payload"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IEventPayload>
  >,
  common::optional<DeserializationError>
> DeserializeEventPayload(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventPayload> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInEventPayload.find(key_val.key())
      );
      if (it == kPropertiesInEventPayload.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IEventPayload> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("source")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventPayload> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property source is missing"
      )
    );
  }

  if (!json.contains("observableReference")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventPayload> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property observableReference is missing"
      )
    );
  }

  if (!json.contains("timeStamp")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventPayload> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property timeStamp is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::shared_ptr<types::IReference> > the_source;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_source_semantic_id;

  common::optional<std::shared_ptr<types::IReference> > the_observable_reference;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_observable_semantic_id;

  common::optional<std::wstring> the_topic;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_subject_id;

  common::optional<std::wstring> the_time_stamp;

  common::optional<
    std::vector<std::uint8_t>
  > the_payload;

  // endregion Initialization

  // region De-serialize source

  std::tie(
    the_source,
    error
  ) = DeserializeReference(
    json["source"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"source"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventPayload> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize source

  // region De-serialize sourceSemanticId

  if (json.contains("sourceSemanticId")) {
    std::tie(
      the_source_semantic_id,
      error
    ) = DeserializeReference(
      json["sourceSemanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"sourceSemanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEventPayload> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize sourceSemanticId

  // region De-serialize observableReference

  std::tie(
    the_observable_reference,
    error
  ) = DeserializeReference(
    json["observableReference"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"observableReference"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventPayload> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize observableReference

  // region De-serialize observableSemanticId

  if (json.contains("observableSemanticId")) {
    std::tie(
      the_observable_semantic_id,
      error
    ) = DeserializeReference(
      json["observableSemanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"observableSemanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEventPayload> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize observableSemanticId

  // region De-serialize topic

  if (json.contains("topic")) {
    std::tie(
      the_topic,
      error
    ) = DeserializeWstring(
      json["topic"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"topic"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEventPayload> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize topic

  // region De-serialize subjectId

  if (json.contains("subjectId")) {
    std::tie(
      the_subject_id,
      error
    ) = DeserializeReference(
      json["subjectId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"subjectId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEventPayload> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize subjectId

  // region De-serialize timeStamp

  std::tie(
    the_time_stamp,
    error
  ) = DeserializeWstring(
    json["timeStamp"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"timeStamp"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventPayload> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize timeStamp

  // region De-serialize payload

  if (json.contains("payload")) {
    std::tie(
      the_payload,
      error
    ) = DeserializeByteArray(
      json["payload"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"payload"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEventPayload> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize payload

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IEventPayload>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::EventPayload(
        std::move(*the_source),
        std::move(*the_observable_reference),
        std::move(*the_time_stamp),
        std::move(the_source_semantic_id),
        std::move(the_observable_semantic_id),
        std::move(the_topic),
        std::move(the_subject_id),
        std::move(the_payload)
      )
    ),
    common::nullopt
  );
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IEventElement> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeEventElementByModelType = {
  {
    "BasicEventElement",
    DeserializeBasicEventElement<
      types::IEventElement
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IEventElement>
  >,
  common::optional<DeserializationError>
> DeserializeEventElement(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventElement> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeEventElementByModelType.find(*model_type);
  if (it == kDeserializeEventElementByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IEventElement "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IEventElement> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInBasicEventElement = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "observed",
  "direction",
  "state",
  "messageTopic",
  "messageBroker",
  "lastUpdate",
  "minInterval",
  "maxInterval",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IBasicEventElement>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeBasicEventElement(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInBasicEventElement.find(key_val.key())
      );
      if (it == kPropertiesInBasicEventElement.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("observed")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property observed is missing"
      )
    );
  }

  if (!json.contains("direction")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property direction is missing"
      )
    );
  }

  if (!json.contains("state")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property state is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<std::shared_ptr<types::IReference> > the_observed;

  common::optional<types::Direction> the_direction;

  common::optional<types::StateOfEvent> the_state;

  common::optional<std::wstring> the_message_topic;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_message_broker;

  common::optional<std::wstring> the_last_update;

  common::optional<std::wstring> the_min_interval;

  common::optional<std::wstring> the_max_interval;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize observed

  std::tie(
    the_observed,
    error
  ) = DeserializeReference(
    json["observed"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"observed"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize observed

  // region De-serialize direction

  common::optional<std::wstring> text_direction;

  std::tie(
    text_direction,
    error
  ) = DeserializeWstring(
    json["direction"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"direction"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_direction = std::move(
    wstringification::DirectionFromWstring(
      *text_direction
    )
  );
  if (!the_direction.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for Direction: ",
      *text_direction
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"direction"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize direction

  // region De-serialize state

  common::optional<std::wstring> text_state;

  std::tie(
    text_state,
    error
  ) = DeserializeWstring(
    json["state"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"state"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_state = std::move(
    wstringification::StateOfEventFromWstring(
      *text_state
    )
  );
  if (!the_state.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for StateOfEvent: ",
      *text_state
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"state"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize state

  // region De-serialize messageTopic

  if (json.contains("messageTopic")) {
    std::tie(
      the_message_topic,
      error
    ) = DeserializeWstring(
      json["messageTopic"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"messageTopic"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize messageTopic

  // region De-serialize messageBroker

  if (json.contains("messageBroker")) {
    std::tie(
      the_message_broker,
      error
    ) = DeserializeReference(
      json["messageBroker"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"messageBroker"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize messageBroker

  // region De-serialize lastUpdate

  if (json.contains("lastUpdate")) {
    std::tie(
      the_last_update,
      error
    ) = DeserializeWstring(
      json["lastUpdate"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"lastUpdate"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize lastUpdate

  // region De-serialize minInterval

  if (json.contains("minInterval")) {
    std::tie(
      the_min_interval,
      error
    ) = DeserializeWstring(
      json["minInterval"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"minInterval"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize minInterval

  // region De-serialize maxInterval

  if (json.contains("maxInterval")) {
    std::tie(
      the_max_interval,
      error
    ) = DeserializeWstring(
      json["maxInterval"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"maxInterval"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize maxInterval

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"BasicEventElement") {
    std::wstring message = common::Concat(
      L"Expected model type 'BasicEventElement', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::BasicEventElement(
        std::move(*the_observed),
        std::move(*the_direction),
        std::move(*the_state),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_message_topic),
        std::move(the_message_broker),
        std::move(the_last_update),
        std::move(the_min_interval),
        std::move(the_max_interval)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInOperation = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "inputVariables",
  "outputVariables",
  "inoutputVariables",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IOperation>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeOperation(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInOperation.find(key_val.key())
      );
      if (it == kPropertiesInOperation.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  > the_input_variables;

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  > the_output_variables;

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  > the_inoutput_variables;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize inputVariables

  if (json.contains("inputVariables")) {
    const nlohmann::json& json_input_variables(
      json["inputVariables"]
    );
    if (!json_input_variables.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_input_variables.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"inputVariables"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_input_variables = common::make_optional<
      std::vector<
        std::shared_ptr<types::IOperationVariable>
      >
    >();

    the_input_variables->reserve(json_input_variables.size());

    size_t index_input_variables = 0;

    for (
      const nlohmann::json& item
      : json_input_variables
    ) {
      common::optional<
        std::shared_ptr<types::IOperationVariable>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeOperationVariable(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_input_variables
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"inputVariables"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_input_variables->emplace_back(
        std::move(*deserialized)
      );

      ++index_input_variables;
    }
  }

  // endregion De-serialize inputVariables

  // region De-serialize outputVariables

  if (json.contains("outputVariables")) {
    const nlohmann::json& json_output_variables(
      json["outputVariables"]
    );
    if (!json_output_variables.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_output_variables.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"outputVariables"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_output_variables = common::make_optional<
      std::vector<
        std::shared_ptr<types::IOperationVariable>
      >
    >();

    the_output_variables->reserve(json_output_variables.size());

    size_t index_output_variables = 0;

    for (
      const nlohmann::json& item
      : json_output_variables
    ) {
      common::optional<
        std::shared_ptr<types::IOperationVariable>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeOperationVariable(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_output_variables
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"outputVariables"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_output_variables->emplace_back(
        std::move(*deserialized)
      );

      ++index_output_variables;
    }
  }

  // endregion De-serialize outputVariables

  // region De-serialize inoutputVariables

  if (json.contains("inoutputVariables")) {
    const nlohmann::json& json_inoutput_variables(
      json["inoutputVariables"]
    );
    if (!json_inoutput_variables.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_inoutput_variables.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"inoutputVariables"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_inoutput_variables = common::make_optional<
      std::vector<
        std::shared_ptr<types::IOperationVariable>
      >
    >();

    the_inoutput_variables->reserve(json_inoutput_variables.size());

    size_t index_inoutput_variables = 0;

    for (
      const nlohmann::json& item
      : json_inoutput_variables
    ) {
      common::optional<
        std::shared_ptr<types::IOperationVariable>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeOperationVariable(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_inoutput_variables
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"inoutputVariables"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_inoutput_variables->emplace_back(
        std::move(*deserialized)
      );

      ++index_inoutput_variables;
    }
  }

  // endregion De-serialize inoutputVariables

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"Operation") {
    std::wstring message = common::Concat(
      L"Expected model type 'Operation', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Operation(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications),
        std::move(the_input_variables),
        std::move(the_output_variables),
        std::move(the_inoutput_variables)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInOperationVariable = {
  "value"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IOperationVariable>
  >,
  common::optional<DeserializationError>
> DeserializeOperationVariable(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IOperationVariable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInOperationVariable.find(key_val.key())
      );
      if (it == kPropertiesInOperationVariable.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IOperationVariable> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("value")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IOperationVariable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property value is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::shared_ptr<types::ISubmodelElement> > the_value;

  // endregion Initialization

  // region De-serialize value

  std::tie(
    the_value,
    error
  ) = DeserializeSubmodelElement(
    json["value"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"value"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IOperationVariable> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize value

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IOperationVariable>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::OperationVariable(
        std::move(*the_value)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInCapability = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "semanticId",
  "supplementalSemanticIds",
  "qualifiers",
  "embeddedDataSpecifications",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ICapability>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeCapability(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInCapability.find(key_val.key())
      );
      if (it == kPropertiesInCapability.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_supplemental_semantic_ids;

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  > the_qualifiers;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize semanticId

  if (json.contains("semanticId")) {
    std::tie(
      the_semantic_id,
      error
    ) = DeserializeReference(
      json["semanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"semanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize semanticId

  // region De-serialize supplementalSemanticIds

  if (json.contains("supplementalSemanticIds")) {
    const nlohmann::json& json_supplemental_semantic_ids(
      json["supplementalSemanticIds"]
    );
    if (!json_supplemental_semantic_ids.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_supplemental_semantic_ids.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"supplementalSemanticIds"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_supplemental_semantic_ids = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_supplemental_semantic_ids->reserve(json_supplemental_semantic_ids.size());

    size_t index_supplemental_semantic_ids = 0;

    for (
      const nlohmann::json& item
      : json_supplemental_semantic_ids
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"supplementalSemanticIds"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_supplemental_semantic_ids->emplace_back(
        std::move(*deserialized)
      );

      ++index_supplemental_semantic_ids;
    }
  }

  // endregion De-serialize supplementalSemanticIds

  // region De-serialize qualifiers

  if (json.contains("qualifiers")) {
    const nlohmann::json& json_qualifiers(
      json["qualifiers"]
    );
    if (!json_qualifiers.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_qualifiers.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"qualifiers"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_qualifiers = common::make_optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    >();

    the_qualifiers->reserve(json_qualifiers.size());

    size_t index_qualifiers = 0;

    for (
      const nlohmann::json& item
      : json_qualifiers
    ) {
      common::optional<
        std::shared_ptr<types::IQualifier>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeQualifier<
        types::IQualifier
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"qualifiers"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_qualifiers->emplace_back(
        std::move(*deserialized)
      );

      ++index_qualifiers;
    }
  }

  // endregion De-serialize qualifiers

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"Capability") {
    std::wstring message = common::Concat(
      L"Expected model type 'Capability', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Capability(
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_semantic_id),
        std::move(the_supplemental_semantic_ids),
        std::move(the_qualifiers),
        std::move(the_embedded_data_specifications)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInConceptDescription = {
  "extensions",
  "category",
  "idShort",
  "displayName",
  "description",
  "administration",
  "id",
  "embeddedDataSpecifications",
  "isCaseOf",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IConceptDescription>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeConceptDescription(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInConceptDescription.find(key_val.key())
      );
      if (it == kPropertiesInConceptDescription.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("id")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property id is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  > the_extensions;

  common::optional<std::wstring> the_category;

  common::optional<std::wstring> the_id_short;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  > the_display_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  > the_description;

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > the_administration;

  common::optional<std::wstring> the_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  > the_embedded_data_specifications;

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  > the_is_case_of;

  // endregion Initialization

  // region De-serialize extensions

  if (json.contains("extensions")) {
    const nlohmann::json& json_extensions(
      json["extensions"]
    );
    if (!json_extensions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_extensions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"extensions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_extensions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    >();

    the_extensions->reserve(json_extensions.size());

    size_t index_extensions = 0;

    for (
      const nlohmann::json& item
      : json_extensions
    ) {
      common::optional<
        std::shared_ptr<types::IExtension>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeExtension<
        types::IExtension
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"extensions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_extensions->emplace_back(
        std::move(*deserialized)
      );

      ++index_extensions;
    }
  }

  // endregion De-serialize extensions

  // region De-serialize category

  if (json.contains("category")) {
    std::tie(
      the_category,
      error
    ) = DeserializeWstring(
      json["category"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"category"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize category

  // region De-serialize idShort

  if (json.contains("idShort")) {
    std::tie(
      the_id_short,
      error
    ) = DeserializeWstring(
      json["idShort"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"idShort"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize idShort

  // region De-serialize displayName

  if (json.contains("displayName")) {
    const nlohmann::json& json_display_name(
      json["displayName"]
    );
    if (!json_display_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_display_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"displayName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_display_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    >();

    the_display_name->reserve(json_display_name.size());

    size_t index_display_name = 0;

    for (
      const nlohmann::json& item
      : json_display_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringNameType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringNameType<
        types::ILangStringNameType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"displayName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_display_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_display_name;
    }
  }

  // endregion De-serialize displayName

  // region De-serialize description

  if (json.contains("description")) {
    const nlohmann::json& json_description(
      json["description"]
    );
    if (!json_description.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_description.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"description"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_description = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    >();

    the_description->reserve(json_description.size());

    size_t index_description = 0;

    for (
      const nlohmann::json& item
      : json_description
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringTextType>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringTextType<
        types::ILangStringTextType
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"description"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_description->emplace_back(
        std::move(*deserialized)
      );

      ++index_description;
    }
  }

  // endregion De-serialize description

  // region De-serialize administration

  if (json.contains("administration")) {
    std::tie(
      the_administration,
      error
    ) = DeserializeAdministrativeInformation<
      types::IAdministrativeInformation
    >(
      json["administration"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"administration"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize administration

  // region De-serialize id

  std::tie(
    the_id,
    error
  ) = DeserializeWstring(
    json["id"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"id"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize id

  // region De-serialize embeddedDataSpecifications

  if (json.contains("embeddedDataSpecifications")) {
    const nlohmann::json& json_embedded_data_specifications(
      json["embeddedDataSpecifications"]
    );
    if (!json_embedded_data_specifications.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_embedded_data_specifications.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"embeddedDataSpecifications"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_embedded_data_specifications = common::make_optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    >();

    the_embedded_data_specifications->reserve(json_embedded_data_specifications.size());

    size_t index_embedded_data_specifications = 0;

    for (
      const nlohmann::json& item
      : json_embedded_data_specifications
    ) {
      common::optional<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeEmbeddedDataSpecification(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"embeddedDataSpecifications"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_embedded_data_specifications->emplace_back(
        std::move(*deserialized)
      );

      ++index_embedded_data_specifications;
    }
  }

  // endregion De-serialize embeddedDataSpecifications

  // region De-serialize isCaseOf

  if (json.contains("isCaseOf")) {
    const nlohmann::json& json_is_case_of(
      json["isCaseOf"]
    );
    if (!json_is_case_of.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_is_case_of.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"isCaseOf"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_is_case_of = common::make_optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    >();

    the_is_case_of->reserve(json_is_case_of.size());

    size_t index_is_case_of = 0;

    for (
      const nlohmann::json& item
      : json_is_case_of
    ) {
      common::optional<
        std::shared_ptr<types::IReference>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeReference(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_is_case_of
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"isCaseOf"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_is_case_of->emplace_back(
        std::move(*deserialized)
      );

      ++index_is_case_of;
    }
  }

  // endregion De-serialize isCaseOf

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"ConceptDescription") {
    std::wstring message = common::Concat(
      L"Expected model type 'ConceptDescription', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ConceptDescription(
        std::move(*the_id),
        std::move(the_extensions),
        std::move(the_category),
        std::move(the_id_short),
        std::move(the_display_name),
        std::move(the_description),
        std::move(the_administration),
        std::move(the_embedded_data_specifications),
        std::move(the_is_case_of)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInReference = {
  "type",
  "referredSemanticId",
  "keys"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IReference>
  >,
  common::optional<DeserializationError>
> DeserializeReference(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IReference> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInReference.find(key_val.key())
      );
      if (it == kPropertiesInReference.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IReference> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("type")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IReference> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property type is missing"
      )
    );
  }

  if (!json.contains("keys")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IReference> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property keys is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<types::ReferenceTypes> the_type;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_referred_semantic_id;

  common::optional<
    std::vector<
      std::shared_ptr<types::IKey>
    >
  > the_keys;

  // endregion Initialization

  // region De-serialize type

  common::optional<std::wstring> text_type;

  std::tie(
    text_type,
    error
  ) = DeserializeWstring(
    json["type"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"type"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IReference> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_type = std::move(
    wstringification::ReferenceTypesFromWstring(
      *text_type
    )
  );
  if (!the_type.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for ReferenceTypes: ",
      *text_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"type"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IReference> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize type

  // region De-serialize referredSemanticId

  if (json.contains("referredSemanticId")) {
    std::tie(
      the_referred_semantic_id,
      error
    ) = DeserializeReference(
      json["referredSemanticId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"referredSemanticId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IReference> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize referredSemanticId

  // region De-serialize keys

  const nlohmann::json& json_keys(
    json["keys"]
  );
  if (!json_keys.is_array()) {
    error = common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected an array, but got: ",
        common::Utf8ToWstring(
          json_keys.type_name()
        )
      )
    );

    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"keys"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IReference> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_keys = common::make_optional<
    std::vector<
      std::shared_ptr<types::IKey>
    >
  >();

  the_keys->reserve(json_keys.size());

  size_t index_keys = 0;

  for (
    const nlohmann::json& item
    : json_keys
  ) {
    common::optional<
      std::shared_ptr<types::IKey>
    > deserialized;

    std::tie(
      deserialized,
      error
    ) = DeserializeKey(
      item,
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<IndexSegment>(
          index_keys
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"keys"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IReference> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_keys->emplace_back(
      std::move(*deserialized)
    );

    ++index_keys;
  }

  // endregion De-serialize keys

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IReference>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Reference(
        std::move(*the_type),
        std::move(*the_keys),
        std::move(the_referred_semantic_id)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInKey = {
  "type",
  "value"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IKey>
  >,
  common::optional<DeserializationError>
> DeserializeKey(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IKey> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInKey.find(key_val.key())
      );
      if (it == kPropertiesInKey.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IKey> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("type")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IKey> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property type is missing"
      )
    );
  }

  if (!json.contains("value")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IKey> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property value is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<types::KeyTypes> the_type;

  common::optional<std::wstring> the_value;

  // endregion Initialization

  // region De-serialize type

  common::optional<std::wstring> text_type;

  std::tie(
    text_type,
    error
  ) = DeserializeWstring(
    json["type"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"type"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IKey> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_type = std::move(
    wstringification::KeyTypesFromWstring(
      *text_type
    )
  );
  if (!the_type.has_value()) {
    std::wstring message = common::Concat(
      L"Invalid literal for KeyTypes: ",
      *text_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"type"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IKey> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize type

  // region De-serialize value

  std::tie(
    the_value,
    error
  ) = DeserializeWstring(
    json["value"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"value"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IKey> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize value

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IKey>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Key(
        std::move(*the_type),
        std::move(*the_value)
      )
    ),
    common::nullopt
  );
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IAbstractLangString> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeAbstractLangStringByModelType = {
  {
    "LangStringDefinitionTypeIec61360",
    DeserializeLangStringDefinitionTypeIec61360<
      types::IAbstractLangString
    >
  },
  {
    "LangStringNameType",
    DeserializeLangStringNameType<
      types::IAbstractLangString
    >
  },
  {
    "LangStringPreferredNameTypeIec61360",
    DeserializeLangStringPreferredNameTypeIec61360<
      types::IAbstractLangString
    >
  },
  {
    "LangStringShortNameTypeIec61360",
    DeserializeLangStringShortNameTypeIec61360<
      types::IAbstractLangString
    >
  },
  {
    "LangStringTextType",
    DeserializeLangStringTextType<
      types::IAbstractLangString
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IAbstractLangString>
  >,
  common::optional<DeserializationError>
> DeserializeAbstractLangString(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IAbstractLangString> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeAbstractLangStringByModelType.find(*model_type);
  if (it == kDeserializeAbstractLangStringByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IAbstractLangString "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IAbstractLangString> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInLangStringNameType = {
  "language",
  "text"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringNameType>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringNameType(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInLangStringNameType.find(key_val.key())
      );
      if (it == kPropertiesInLangStringNameType.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("language")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property language is missing"
      )
    );
  }

  if (!json.contains("text")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property text is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  // region De-serialize language

  std::tie(
    the_language,
    error
  ) = DeserializeWstring(
    json["language"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"language"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize language

  // region De-serialize text

  std::tie(
    the_text,
    error
  ) = DeserializeWstring(
    json["text"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"text"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize text

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringNameType(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInLangStringTextType = {
  "language",
  "text"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringTextType>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringTextType(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInLangStringTextType.find(key_val.key())
      );
      if (it == kPropertiesInLangStringTextType.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("language")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property language is missing"
      )
    );
  }

  if (!json.contains("text")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property text is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  // region De-serialize language

  std::tie(
    the_language,
    error
  ) = DeserializeWstring(
    json["language"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"language"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize language

  // region De-serialize text

  std::tie(
    the_text,
    error
  ) = DeserializeWstring(
    json["text"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"text"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize text

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringTextType(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInEnvironment = {
  "assetAdministrationShells",
  "submodels",
  "conceptDescriptions"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IEnvironment>
  >,
  common::optional<DeserializationError>
> DeserializeEnvironment(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IEnvironment> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInEnvironment.find(key_val.key())
      );
      if (it == kPropertiesInEnvironment.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IEnvironment> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IAssetAdministrationShell>
    >
  > the_asset_administration_shells;

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodel>
    >
  > the_submodels;

  common::optional<
    std::vector<
      std::shared_ptr<types::IConceptDescription>
    >
  > the_concept_descriptions;

  // endregion Initialization

  // region De-serialize assetAdministrationShells

  if (json.contains("assetAdministrationShells")) {
    const nlohmann::json& json_asset_administration_shells(
      json["assetAdministrationShells"]
    );
    if (!json_asset_administration_shells.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_asset_administration_shells.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"assetAdministrationShells"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEnvironment> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_asset_administration_shells = common::make_optional<
      std::vector<
        std::shared_ptr<types::IAssetAdministrationShell>
      >
    >();

    the_asset_administration_shells->reserve(json_asset_administration_shells.size());

    size_t index_asset_administration_shells = 0;

    for (
      const nlohmann::json& item
      : json_asset_administration_shells
    ) {
      common::optional<
        std::shared_ptr<types::IAssetAdministrationShell>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeAssetAdministrationShell<
        types::IAssetAdministrationShell
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_asset_administration_shells
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"assetAdministrationShells"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IEnvironment> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_asset_administration_shells->emplace_back(
        std::move(*deserialized)
      );

      ++index_asset_administration_shells;
    }
  }

  // endregion De-serialize assetAdministrationShells

  // region De-serialize submodels

  if (json.contains("submodels")) {
    const nlohmann::json& json_submodels(
      json["submodels"]
    );
    if (!json_submodels.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_submodels.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"submodels"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEnvironment> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_submodels = common::make_optional<
      std::vector<
        std::shared_ptr<types::ISubmodel>
      >
    >();

    the_submodels->reserve(json_submodels.size());

    size_t index_submodels = 0;

    for (
      const nlohmann::json& item
      : json_submodels
    ) {
      common::optional<
        std::shared_ptr<types::ISubmodel>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeSubmodel<
        types::ISubmodel
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_submodels
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"submodels"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IEnvironment> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_submodels->emplace_back(
        std::move(*deserialized)
      );

      ++index_submodels;
    }
  }

  // endregion De-serialize submodels

  // region De-serialize conceptDescriptions

  if (json.contains("conceptDescriptions")) {
    const nlohmann::json& json_concept_descriptions(
      json["conceptDescriptions"]
    );
    if (!json_concept_descriptions.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_concept_descriptions.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"conceptDescriptions"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEnvironment> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_concept_descriptions = common::make_optional<
      std::vector<
        std::shared_ptr<types::IConceptDescription>
      >
    >();

    the_concept_descriptions->reserve(json_concept_descriptions.size());

    size_t index_concept_descriptions = 0;

    for (
      const nlohmann::json& item
      : json_concept_descriptions
    ) {
      common::optional<
        std::shared_ptr<types::IConceptDescription>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeConceptDescription<
        types::IConceptDescription
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_concept_descriptions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"conceptDescriptions"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IEnvironment> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_concept_descriptions->emplace_back(
        std::move(*deserialized)
      );

      ++index_concept_descriptions;
    }
  }

  // endregion De-serialize conceptDescriptions

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IEnvironment>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::Environment(
        std::move(the_asset_administration_shells),
        std::move(the_submodels),
        std::move(the_concept_descriptions)
      )
    ),
    common::nullopt
  );
}

std::map<
  std::string,
  std::function<
    std::pair<
      common::optional<std::shared_ptr<types::IDataSpecificationContent> >,
      common::optional<DeserializationError>
    >(const nlohmann::json&, bool)
  >
> kDeserializeDataSpecificationContentByModelType = {
  {
    "DataSpecificationIec61360",
    DeserializeDataSpecificationIec61360<
      types::IDataSpecificationContent
    >
  }
};

std::pair<
  common::optional<
    std::shared_ptr<types::IDataSpecificationContent>
  >,
  common::optional<DeserializationError>
> DeserializeDataSpecificationContent(
  const nlohmann::json& json,
  bool additional_properties
) {
  const std::string* model_type;
  common::optional<DeserializationError> error;

  std::tie(
    model_type,
    error
  ) = GetModelTypeFrom(json);

  if (error.has_value()) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IDataSpecificationContent> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  const auto it = kDeserializeDataSpecificationContentByModelType.find(*model_type);
  if (it == kDeserializeDataSpecificationContentByModelType.end()) {
    std::wstring message = common::Concat(
      L"The dispatch to the JSON de-serialization of "
      L"types::IDataSpecificationContent "
      L"is not defined for model type: ",
      common::Utf8ToWstring(*model_type)
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IDataSpecificationContent> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  return (it->second)(json, additional_properties);
}

std::set<std::string> kPropertiesInEmbeddedDataSpecification = {
  "dataSpecificationContent",
  "dataSpecification"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >,
  common::optional<DeserializationError>
> DeserializeEmbeddedDataSpecification(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IEmbeddedDataSpecification> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInEmbeddedDataSpecification.find(key_val.key())
      );
      if (it == kPropertiesInEmbeddedDataSpecification.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IEmbeddedDataSpecification> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("dataSpecificationContent")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IEmbeddedDataSpecification> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property dataSpecificationContent is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::shared_ptr<types::IDataSpecificationContent> > the_data_specification_content;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_data_specification;

  // endregion Initialization

  // region De-serialize dataSpecificationContent

  std::tie(
    the_data_specification_content,
    error
  ) = DeserializeDataSpecificationContent(
    json["dataSpecificationContent"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"dataSpecificationContent"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IEmbeddedDataSpecification> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize dataSpecificationContent

  // region De-serialize dataSpecification

  if (json.contains("dataSpecification")) {
    std::tie(
      the_data_specification,
      error
    ) = DeserializeReference(
      json["dataSpecification"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"dataSpecification"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IEmbeddedDataSpecification> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize dataSpecification

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::EmbeddedDataSpecification(
        std::move(*the_data_specification_content),
        std::move(the_data_specification)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInLevelType = {
  "min",
  "nom",
  "typ",
  "max"
};

std::pair<
  common::optional<
    std::shared_ptr<types::ILevelType>
  >,
  common::optional<DeserializationError>
> DeserializeLevelType(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInLevelType.find(key_val.key())
      );
      if (it == kPropertiesInLevelType.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::ILevelType> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("min")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property min is missing"
      )
    );
  }

  if (!json.contains("nom")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property nom is missing"
      )
    );
  }

  if (!json.contains("typ")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property typ is missing"
      )
    );
  }

  if (!json.contains("max")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property max is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<bool> the_min;

  common::optional<bool> the_nom;

  common::optional<bool> the_typ;

  common::optional<bool> the_max;

  // endregion Initialization

  // region De-serialize min

  std::tie(
    the_min,
    error
  ) = DeserializeBool(
    json["min"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"min"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize min

  // region De-serialize nom

  std::tie(
    the_nom,
    error
  ) = DeserializeBool(
    json["nom"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"nom"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize nom

  // region De-serialize typ

  std::tie(
    the_typ,
    error
  ) = DeserializeBool(
    json["typ"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"typ"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize typ

  // region De-serialize max

  std::tie(
    the_max,
    error
  ) = DeserializeBool(
    json["max"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"max"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::ILevelType> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize max

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::ILevelType>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LevelType(
        std::move(*the_min),
        std::move(*the_nom),
        std::move(*the_typ),
        std::move(*the_max)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInValueReferencePair = {
  "value",
  "valueId"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IValueReferencePair>
  >,
  common::optional<DeserializationError>
> DeserializeValueReferencePair(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IValueReferencePair> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInValueReferencePair.find(key_val.key())
      );
      if (it == kPropertiesInValueReferencePair.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IValueReferencePair> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("value")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IValueReferencePair> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property value is missing"
      )
    );
  }

  if (!json.contains("valueId")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IValueReferencePair> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property valueId is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::wstring> the_value;

  common::optional<std::shared_ptr<types::IReference> > the_value_id;

  // endregion Initialization

  // region De-serialize value

  std::tie(
    the_value,
    error
  ) = DeserializeWstring(
    json["value"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"value"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IValueReferencePair> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize value

  // region De-serialize valueId

  std::tie(
    the_value_id,
    error
  ) = DeserializeReference(
    json["valueId"],
    additional_properties
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"valueId"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IValueReferencePair> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize valueId

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IValueReferencePair>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ValueReferencePair(
        std::move(*the_value),
        std::move(*the_value_id)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInValueList = {
  "valueReferencePairs"
};

std::pair<
  common::optional<
    std::shared_ptr<types::IValueList>
  >,
  common::optional<DeserializationError>
> DeserializeValueList(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IValueList> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInValueList.find(key_val.key())
      );
      if (it == kPropertiesInValueList.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<types::IValueList> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("valueReferencePairs")) {
    return std::make_pair<
      common::optional<std::shared_ptr<types::IValueList> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property valueReferencePairs is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::IValueReferencePair>
    >
  > the_value_reference_pairs;

  // endregion Initialization

  // region De-serialize valueReferencePairs

  const nlohmann::json& json_value_reference_pairs(
    json["valueReferencePairs"]
  );
  if (!json_value_reference_pairs.is_array()) {
    error = common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected an array, but got: ",
        common::Utf8ToWstring(
          json_value_reference_pairs.type_name()
        )
      )
    );

    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"valueReferencePairs"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<types::IValueList> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_value_reference_pairs = common::make_optional<
    std::vector<
      std::shared_ptr<types::IValueReferencePair>
    >
  >();

  the_value_reference_pairs->reserve(json_value_reference_pairs.size());

  size_t index_value_reference_pairs = 0;

  for (
    const nlohmann::json& item
    : json_value_reference_pairs
  ) {
    common::optional<
      std::shared_ptr<types::IValueReferencePair>
    > deserialized;

    std::tie(
      deserialized,
      error
    ) = DeserializeValueReferencePair(
      item,
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<IndexSegment>(
          index_value_reference_pairs
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueReferencePairs"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<types::IValueList> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_value_reference_pairs->emplace_back(
      std::move(*deserialized)
    );

    ++index_value_reference_pairs;
  }

  // endregion De-serialize valueReferencePairs

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<types::IValueList>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::ValueList(
        std::move(*the_value_reference_pairs)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInLangStringPreferredNameTypeIec61360 = {
  "language",
  "text"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringPreferredNameTypeIec61360>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringPreferredNameTypeIec61360(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInLangStringPreferredNameTypeIec61360.find(key_val.key())
      );
      if (it == kPropertiesInLangStringPreferredNameTypeIec61360.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("language")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property language is missing"
      )
    );
  }

  if (!json.contains("text")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property text is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  // region De-serialize language

  std::tie(
    the_language,
    error
  ) = DeserializeWstring(
    json["language"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"language"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize language

  // region De-serialize text

  std::tie(
    the_text,
    error
  ) = DeserializeWstring(
    json["text"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"text"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize text

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringPreferredNameTypeIec61360(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInLangStringShortNameTypeIec61360 = {
  "language",
  "text"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringShortNameTypeIec61360>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringShortNameTypeIec61360(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInLangStringShortNameTypeIec61360.find(key_val.key())
      );
      if (it == kPropertiesInLangStringShortNameTypeIec61360.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("language")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property language is missing"
      )
    );
  }

  if (!json.contains("text")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property text is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  // region De-serialize language

  std::tie(
    the_language,
    error
  ) = DeserializeWstring(
    json["language"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"language"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize language

  // region De-serialize text

  std::tie(
    the_text,
    error
  ) = DeserializeWstring(
    json["text"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"text"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize text

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringShortNameTypeIec61360(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInLangStringDefinitionTypeIec61360 = {
  "language",
  "text"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::ILangStringDefinitionTypeIec61360>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeLangStringDefinitionTypeIec61360(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInLangStringDefinitionTypeIec61360.find(key_val.key())
      );
      if (it == kPropertiesInLangStringDefinitionTypeIec61360.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("language")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property language is missing"
      )
    );
  }

  if (!json.contains("text")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property text is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<std::wstring> the_language;

  common::optional<std::wstring> the_text;

  // endregion Initialization

  // region De-serialize language

  std::tie(
    the_language,
    error
  ) = DeserializeWstring(
    json["language"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"language"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize language

  // region De-serialize text

  std::tie(
    the_text,
    error
  ) = DeserializeWstring(
    json["text"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"text"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion De-serialize text

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::LangStringDefinitionTypeIec61360(
        std::move(*the_language),
        std::move(*the_text)
      )
    ),
    common::nullopt
  );
}

std::set<std::string> kPropertiesInDataSpecificationIec61360 = {
  "preferredName",
  "shortName",
  "unit",
  "unitId",
  "sourceOfDefinition",
  "symbol",
  "dataType",
  "definition",
  "valueFormat",
  "valueList",
  "value",
  "levelType",
  "modelType"
};

template <
  typename T,
  typename std::enable_if<
    std::is_base_of<T, types::IDataSpecificationIec61360>::value
  >::type*
>
std::pair<
  common::optional<std::shared_ptr<T> >,
  common::optional<DeserializationError>
> DeserializeDataSpecificationIec61360(
  const nlohmann::json& json,
  bool additional_properties
) {
  if (!json.is_object()) {
    std::wstring message = common::Concat(
      L"Expected an object, but got: ",
      common::Utf8ToWstring(json.type_name())
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        message
      )
    );
  }

  if (!additional_properties) {
    for (const auto& key_val : json.items()) {
      auto it(
        kPropertiesInDataSpecificationIec61360.find(key_val.key())
      );
      if (it == kPropertiesInDataSpecificationIec61360.end()) {
        std::wstring message = common::Concat(
          L"Unexpected additional property: ",
          common::Utf8ToWstring(key_val.key())
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          common::make_optional<DeserializationError>(
            message
          )
        );
      }
    }
  }

  // region Check required properties

  if (!json.contains("preferredName")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property preferredName is missing"
      )
    );
  }

  if (!json.contains("modelType")) {
    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      common::make_optional<DeserializationError>(
        L"The required property modelType is missing"
      )
    );
  }

  // endregion Check required properties

  // region Initialization

  common::optional<DeserializationError> error;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >
  > the_preferred_name;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >
  > the_short_name;

  common::optional<std::wstring> the_unit;

  common::optional<
    std::shared_ptr<types::IReference>
  > the_unit_id;

  common::optional<std::wstring> the_source_of_definition;

  common::optional<std::wstring> the_symbol;

  common::optional<types::DataTypeIec61360> the_data_type;

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >
  > the_definition;

  common::optional<std::wstring> the_value_format;

  common::optional<
    std::shared_ptr<types::IValueList>
  > the_value_list;

  common::optional<std::wstring> the_value;

  common::optional<
    std::shared_ptr<types::ILevelType>
  > the_level_type;

  // endregion Initialization

  // region De-serialize preferredName

  const nlohmann::json& json_preferred_name(
    json["preferredName"]
  );
  if (!json_preferred_name.is_array()) {
    error = common::make_optional<DeserializationError>(
      common::Concat(
        L"Expected an array, but got: ",
        common::Utf8ToWstring(
          json_preferred_name.type_name()
        )
      )
    );

    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"preferredName"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  the_preferred_name = common::make_optional<
    std::vector<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >
  >();

  the_preferred_name->reserve(json_preferred_name.size());

  size_t index_preferred_name = 0;

  for (
    const nlohmann::json& item
    : json_preferred_name
  ) {
    common::optional<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    > deserialized;

    std::tie(
      deserialized,
      error
    ) = DeserializeLangStringPreferredNameTypeIec61360<
      types::ILangStringPreferredNameTypeIec61360
    >(
      item,
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<IndexSegment>(
          index_preferred_name
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"preferredName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_preferred_name->emplace_back(
      std::move(*deserialized)
    );

    ++index_preferred_name;
  }

  // endregion De-serialize preferredName

  // region De-serialize shortName

  if (json.contains("shortName")) {
    const nlohmann::json& json_short_name(
      json["shortName"]
    );
    if (!json_short_name.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_short_name.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"shortName"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_short_name = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringShortNameTypeIec61360>
      >
    >();

    the_short_name->reserve(json_short_name.size());

    size_t index_short_name = 0;

    for (
      const nlohmann::json& item
      : json_short_name
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringShortNameTypeIec61360>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringShortNameTypeIec61360<
        types::ILangStringShortNameTypeIec61360
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_short_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"shortName"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_short_name->emplace_back(
        std::move(*deserialized)
      );

      ++index_short_name;
    }
  }

  // endregion De-serialize shortName

  // region De-serialize unit

  if (json.contains("unit")) {
    std::tie(
      the_unit,
      error
    ) = DeserializeWstring(
      json["unit"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"unit"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize unit

  // region De-serialize unitId

  if (json.contains("unitId")) {
    std::tie(
      the_unit_id,
      error
    ) = DeserializeReference(
      json["unitId"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"unitId"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize unitId

  // region De-serialize sourceOfDefinition

  if (json.contains("sourceOfDefinition")) {
    std::tie(
      the_source_of_definition,
      error
    ) = DeserializeWstring(
      json["sourceOfDefinition"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"sourceOfDefinition"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize sourceOfDefinition

  // region De-serialize symbol

  if (json.contains("symbol")) {
    std::tie(
      the_symbol,
      error
    ) = DeserializeWstring(
      json["symbol"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"symbol"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize symbol

  // region De-serialize dataType

  if (json.contains("dataType")) {
    common::optional<std::wstring> text_data_type;

    std::tie(
      text_data_type,
      error
    ) = DeserializeWstring(
      json["dataType"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"dataType"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_data_type = std::move(
      wstringification::DataTypeIec61360FromWstring(
        *text_data_type
      )
    );
    if (!the_data_type.has_value()) {
      std::wstring message = common::Concat(
        L"Invalid literal for DataTypeIec61360: ",
        *text_data_type
      );

      error = common::make_optional<DeserializationError>(
        message
      );
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"dataType"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize dataType

  // region De-serialize definition

  if (json.contains("definition")) {
    const nlohmann::json& json_definition(
      json["definition"]
    );
    if (!json_definition.is_array()) {
      error = common::make_optional<DeserializationError>(
        common::Concat(
          L"Expected an array, but got: ",
          common::Utf8ToWstring(
            json_definition.type_name()
          )
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"definition"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    the_definition = common::make_optional<
      std::vector<
        std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
      >
    >();

    the_definition->reserve(json_definition.size());

    size_t index_definition = 0;

    for (
      const nlohmann::json& item
      : json_definition
    ) {
      common::optional<
        std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
      > deserialized;

      std::tie(
        deserialized,
        error
      ) = DeserializeLangStringDefinitionTypeIec61360<
        types::ILangStringDefinitionTypeIec61360
      >(
        item,
        additional_properties
      );

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<IndexSegment>(
            index_definition
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<PropertySegment>(
            L"definition"
          )
        );

        return std::make_pair<
          common::optional<std::shared_ptr<T> >,
          common::optional<DeserializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      the_definition->emplace_back(
        std::move(*deserialized)
      );

      ++index_definition;
    }
  }

  // endregion De-serialize definition

  // region De-serialize valueFormat

  if (json.contains("valueFormat")) {
    std::tie(
      the_value_format,
      error
    ) = DeserializeWstring(
      json["valueFormat"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueFormat"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize valueFormat

  // region De-serialize valueList

  if (json.contains("valueList")) {
    std::tie(
      the_value_list,
      error
    ) = DeserializeValueList(
      json["valueList"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"valueList"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize valueList

  // region De-serialize value

  if (json.contains("value")) {
    std::tie(
      the_value,
      error
    ) = DeserializeWstring(
      json["value"]
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"value"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize value

  // region De-serialize levelType

  if (json.contains("levelType")) {
    std::tie(
      the_level_type,
      error
    ) = DeserializeLevelType(
      json["levelType"],
      additional_properties
    );

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<PropertySegment>(
          L"levelType"
        )
      );

      return std::make_pair<
        common::optional<std::shared_ptr<T> >,
        common::optional<DeserializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }
  }

  // endregion De-serialize levelType

  // region Check model type
  // This check is intended only for verification, not for dispatch.

  common::optional<
    std::wstring
  > model_type;

  std::tie(
    model_type,
    error
  ) = DeserializeWstring(
    json["modelType"]
  );

  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<PropertySegment>(
        L"modelType"
      )
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  if (*model_type != L"DataSpecificationIec61360") {
    std::wstring message = common::Concat(
      L"Expected model type 'DataSpecificationIec61360', "
      L"but got: ",
      *model_type
    );

    error = common::make_optional<DeserializationError>(
      message
    );

    return std::make_pair<
      common::optional<std::shared_ptr<T> >,
      common::optional<DeserializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  // endregion Check model type

  return std::make_pair(
    common::make_optional<
      std::shared_ptr<T>
    >(
      // NOTE (mristin):
      // We deliberately do not use std::make_shared here to avoid an unnecessary
      // upcast.
      new types::DataSpecificationIec61360(
        std::move(*the_preferred_name),
        std::move(the_short_name),
        std::move(the_unit),
        std::move(the_unit_id),
        std::move(the_source_of_definition),
        std::move(the_symbol),
        std::move(the_data_type),
        std::move(the_definition),
        std::move(the_value_format),
        std::move(the_value_list),
        std::move(the_value),
        std::move(the_level_type)
      )
    ),
    common::nullopt
  );
}

common::expected<
  std::shared_ptr<types::IHasSemantics>,
  DeserializationError
> HasSemanticsFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IHasSemantics>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeHasSemantics(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IExtension>,
  DeserializationError
> ExtensionFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IExtension>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeExtension<
    types::IExtension
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IHasExtensions>,
  DeserializationError
> HasExtensionsFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IHasExtensions>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeHasExtensions(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IReferable>,
  DeserializationError
> ReferableFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IReferable>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeReferable(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IIdentifiable>,
  DeserializationError
> IdentifiableFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IIdentifiable>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeIdentifiable(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IHasKind>,
  DeserializationError
> HasKindFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IHasKind>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeHasKind(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IHasDataSpecification>,
  DeserializationError
> HasDataSpecificationFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IHasDataSpecification>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeHasDataSpecification(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IAdministrativeInformation>,
  DeserializationError
> AdministrativeInformationFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeAdministrativeInformation<
    types::IAdministrativeInformation
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IQualifiable>,
  DeserializationError
> QualifiableFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IQualifiable>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeQualifiable(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IQualifier>,
  DeserializationError
> QualifierFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IQualifier>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeQualifier<
    types::IQualifier
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IAssetAdministrationShell>,
  DeserializationError
> AssetAdministrationShellFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IAssetAdministrationShell>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeAssetAdministrationShell<
    types::IAssetAdministrationShell
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IAssetInformation>,
  DeserializationError
> AssetInformationFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IAssetInformation>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeAssetInformation(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IResource>,
  DeserializationError
> ResourceFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IResource>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeResource(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ISpecificAssetId>,
  DeserializationError
> SpecificAssetIdFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ISpecificAssetId>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeSpecificAssetId<
    types::ISpecificAssetId
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ISubmodel>,
  DeserializationError
> SubmodelFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ISubmodel>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeSubmodel<
    types::ISubmodel
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ISubmodelElement>,
  DeserializationError
> SubmodelElementFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ISubmodelElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeSubmodelElement(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IRelationshipElement>,
  DeserializationError
> RelationshipElementFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IRelationshipElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeRelationshipElement(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ISubmodelElementList>,
  DeserializationError
> SubmodelElementListFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ISubmodelElementList>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeSubmodelElementList<
    types::ISubmodelElementList
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ISubmodelElementCollection>,
  DeserializationError
> SubmodelElementCollectionFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ISubmodelElementCollection>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeSubmodelElementCollection<
    types::ISubmodelElementCollection
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IDataElement>,
  DeserializationError
> DataElementFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IDataElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeDataElement(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IProperty>,
  DeserializationError
> PropertyFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IProperty>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeProperty<
    types::IProperty
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IMultiLanguageProperty>,
  DeserializationError
> MultiLanguagePropertyFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IMultiLanguageProperty>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeMultiLanguageProperty<
    types::IMultiLanguageProperty
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IRange>,
  DeserializationError
> RangeFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IRange>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeRange<
    types::IRange
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IReferenceElement>,
  DeserializationError
> ReferenceElementFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IReferenceElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeReferenceElement<
    types::IReferenceElement
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IBlob>,
  DeserializationError
> BlobFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IBlob>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeBlob<
    types::IBlob
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IFile>,
  DeserializationError
> FileFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IFile>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeFile<
    types::IFile
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IAnnotatedRelationshipElement>,
  DeserializationError
> AnnotatedRelationshipElementFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IAnnotatedRelationshipElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeAnnotatedRelationshipElement<
    types::IAnnotatedRelationshipElement
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IEntity>,
  DeserializationError
> EntityFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IEntity>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeEntity<
    types::IEntity
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IEventPayload>,
  DeserializationError
> EventPayloadFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IEventPayload>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeEventPayload(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IEventElement>,
  DeserializationError
> EventElementFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IEventElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeEventElement(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IBasicEventElement>,
  DeserializationError
> BasicEventElementFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IBasicEventElement>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeBasicEventElement<
    types::IBasicEventElement
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IOperation>,
  DeserializationError
> OperationFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IOperation>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeOperation<
    types::IOperation
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IOperationVariable>,
  DeserializationError
> OperationVariableFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IOperationVariable>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeOperationVariable(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ICapability>,
  DeserializationError
> CapabilityFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ICapability>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeCapability<
    types::ICapability
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IConceptDescription>,
  DeserializationError
> ConceptDescriptionFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IConceptDescription>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeConceptDescription<
    types::IConceptDescription
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IReference>,
  DeserializationError
> ReferenceFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IReference>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeReference(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IKey>,
  DeserializationError
> KeyFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IKey>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeKey(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IAbstractLangString>,
  DeserializationError
> AbstractLangStringFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IAbstractLangString>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeAbstractLangString(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ILangStringNameType>,
  DeserializationError
> LangStringNameTypeFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ILangStringNameType>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeLangStringNameType<
    types::ILangStringNameType
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ILangStringTextType>,
  DeserializationError
> LangStringTextTypeFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ILangStringTextType>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeLangStringTextType<
    types::ILangStringTextType
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IEnvironment>,
  DeserializationError
> EnvironmentFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IEnvironment>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeEnvironment(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IDataSpecificationContent>,
  DeserializationError
> DataSpecificationContentFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IDataSpecificationContent>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeDataSpecificationContent(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IEmbeddedDataSpecification>,
  DeserializationError
> EmbeddedDataSpecificationFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeEmbeddedDataSpecification(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ILevelType>,
  DeserializationError
> LevelTypeFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ILevelType>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeLevelType(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IValueReferencePair>,
  DeserializationError
> ValueReferencePairFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IValueReferencePair>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeValueReferencePair(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IValueList>,
  DeserializationError
> ValueListFrom(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IValueList>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeValueList(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>,
  DeserializationError
> LangStringPreferredNameTypeIec61360From(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeLangStringPreferredNameTypeIec61360<
    types::ILangStringPreferredNameTypeIec61360
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ILangStringShortNameTypeIec61360>,
  DeserializationError
> LangStringShortNameTypeIec61360From(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ILangStringShortNameTypeIec61360>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeLangStringShortNameTypeIec61360<
    types::ILangStringShortNameTypeIec61360
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::ILangStringDefinitionTypeIec61360>,
  DeserializationError
> LangStringDefinitionTypeIec61360From(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeLangStringDefinitionTypeIec61360<
    types::ILangStringDefinitionTypeIec61360
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

common::expected<
  std::shared_ptr<types::IDataSpecificationIec61360>,
  DeserializationError
> DataSpecificationIec61360From(
  const nlohmann::json& json,
  bool additional_properties
) {
  common::optional<
    std::shared_ptr<types::IDataSpecificationIec61360>
  > instance;

  common::optional<DeserializationError> error;

  std::tie(
    instance,
    error
  ) = DeserializeDataSpecificationIec61360<
    types::IDataSpecificationIec61360
  >(
    json,
    additional_properties
  );

  if (instance.has_value()) {
    return std::move(*instance);
  }

  if (!error.has_value()) {
    throw std::logic_error(
      "Unexpected null error when null instance."
    );
  }
  return common::make_unexpected(
    std::move(*error)
  );
}

// endregion De-serialization

// region Serialization

/**
 * \brief Represent a serialization error.
 *
 * We use this error internally to avoid unnecessary stack unwinding,
 * but throw the \ref SerializationException at the final site of
 * the serialization for the user.
 */
struct SerializationError {
  /**
   * Human-readable description of the error
   */
  std::wstring cause;

  /**
   * Path to the value that caused the error
   */
  iteration::Path path;

  explicit SerializationError(
    std::wstring a_cause
  ) : cause(std::move(a_cause)) {
    // Intentionally empty.
  }
};  // struct SerializationError

// region SerializationException

std::string RenderSerializationErrorMessage(
  const std::wstring& cause,
  const iteration::Path& path
) {
  return common::WstringToUtf8(
    common::Concat(
      L"Serialization failed at ",
      path.ToWstring(),
      L": ",
      cause
    )
  );
}

SerializationException::SerializationException(
  std::wstring cause,
  iteration::Path path
) :
  cause_(std::move(cause)),
  path_(std::move(path)),
  msg_(RenderSerializationErrorMessage(cause, path)) {
  // Intentionally empty.
}

const char* SerializationException::what() const noexcept {
  return msg_.c_str();
}

const std::wstring& SerializationException::cause() const noexcept {
  return cause_;
}

const iteration::Path& SerializationException::path() const noexcept {
  return path_;
}

// endregion SerializationException

/**
 * \brief Serialize the given number to a JSON value.
 *
 * We verify that the integer is within the range representable by 64-bit floats
 * for interoperability with other de-serializers.
 */
std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeInt64(int64_t value) {
  if (
    value < -9007199254740991L
    || value > 9007199254740991L
  ) {
    const std::wstring message = common::Concat(
      L"The integer ",
      std::to_wstring(value),
      L" can not be serialized to JSON "
      L"as it is outside the range [-2^53 + 1, 2^53 - 1] and can not "
      L"be exactly represented as a 64-bit floating point number."
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      common::make_optional<SerializationError>(
        message
      )
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(value),
    common::nullopt
  );
}

/**
 * Serialize the given text to a JSON value.
 */
nlohmann::json SerializeWstring(
  const std::wstring& text
) {
  return nlohmann::json(
    common::WstringToUtf8(text)
  );
}

/**
 * Serialize the given bytes to a JSON value.
 */
nlohmann::json SerializeByteArray(
  const std::vector<std::uint8_t>& bytes
) {
  return nlohmann::json(
    std::move(
      stringification::Base64Encode(bytes)
    )
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeIClass(
  const types::IClass& that
);

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeExtension(
  const types::IExtension& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  result["name"] = SerializeWstring(
    that.name()
  );

  const common::optional<types::DataTypeDefXsd>& maybe_value_type(
    that.value_type()
  );
  if (maybe_value_type.has_value()) {
    result["valueType"] = stringification::to_string(
      *maybe_value_type
    );
  }

  const common::optional<std::wstring>& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    result["value"] = SerializeWstring(
      *maybe_value
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_refers_to(
    that.refers_to()
  );
  if (maybe_refers_to.has_value()) {
    nlohmann::json json_refers_to = nlohmann::json::array();
    json_refers_to.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_refers_to->size()
    );
    size_t index_refers_to = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_refers_to
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_refers_to
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kRefersTo
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_refers_to.emplace_back(
        std::move(*json_item)
      );

      ++index_refers_to;
    }
    result["refersTo"] = std::move(
      json_refers_to
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeAdministrativeInformation(
  const types::IAdministrativeInformation& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<std::wstring>& maybe_version(
    that.version()
  );
  if (maybe_version.has_value()) {
    result["version"] = SerializeWstring(
      *maybe_version
    );
  }

  const common::optional<std::wstring>& maybe_revision(
    that.revision()
  );
  if (maybe_revision.has_value()) {
    result["revision"] = SerializeWstring(
      *maybe_revision
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_creator(
    that.creator()
  );
  if (maybe_creator.has_value()) {
    common::optional<nlohmann::json> json_creator;
    std::tie(
      json_creator,
      error
    ) = SerializeIClass(
      **maybe_creator
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kCreator
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["creator"] = std::move(
      *json_creator
    );
  }

  const common::optional<std::wstring>& maybe_template_id(
    that.template_id()
  );
  if (maybe_template_id.has_value()) {
    result["templateId"] = SerializeWstring(
      *maybe_template_id
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeQualifier(
  const types::IQualifier& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<types::QualifierKind>& maybe_kind(
    that.kind()
  );
  if (maybe_kind.has_value()) {
    result["kind"] = stringification::to_string(
      *maybe_kind
    );
  }

  result["type"] = SerializeWstring(
    that.type()
  );

  result["valueType"] = stringification::to_string(
    that.value_type()
  );

  const common::optional<std::wstring>& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    result["value"] = SerializeWstring(
      *maybe_value
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_value_id(
    that.value_id()
  );
  if (maybe_value_id.has_value()) {
    common::optional<nlohmann::json> json_value_id;
    std::tie(
      json_value_id,
      error
    ) = SerializeIClass(
      **maybe_value_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["valueId"] = std::move(
      *json_value_id
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeAssetAdministrationShell(
  const types::IAssetAdministrationShell& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& maybe_administration(
    that.administration()
  );
  if (maybe_administration.has_value()) {
    common::optional<nlohmann::json> json_administration;
    std::tie(
      json_administration,
      error
    ) = SerializeIClass(
      **maybe_administration
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["administration"] = std::move(
      *json_administration
    );
  }

  result["id"] = SerializeWstring(
    that.id()
  );

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_derived_from(
    that.derived_from()
  );
  if (maybe_derived_from.has_value()) {
    common::optional<nlohmann::json> json_derived_from;
    std::tie(
      json_derived_from,
      error
    ) = SerializeIClass(
      **maybe_derived_from
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDerivedFrom
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["derivedFrom"] = std::move(
      *json_derived_from
    );
  }

  common::optional<nlohmann::json> json_asset_information;
  std::tie(
    json_asset_information,
    error
  ) = SerializeIClass(
    *that.asset_information()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kAssetInformation
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["assetInformation"] = std::move(
    *json_asset_information
  );

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_submodels(
    that.submodels()
  );
  if (maybe_submodels.has_value()) {
    nlohmann::json json_submodels = nlohmann::json::array();
    json_submodels.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_submodels->size()
    );
    size_t index_submodels = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_submodels
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_submodels
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSubmodels
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_submodels.emplace_back(
        std::move(*json_item)
      );

      ++index_submodels;
    }
    result["submodels"] = std::move(
      json_submodels
    );
  }

  result["modelType"] = "AssetAdministrationShell";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeAssetInformation(
  const types::IAssetInformation& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["assetKind"] = stringification::to_string(
    that.asset_kind()
  );

  const common::optional<std::wstring>& maybe_global_asset_id(
    that.global_asset_id()
  );
  if (maybe_global_asset_id.has_value()) {
    result["globalAssetId"] = SerializeWstring(
      *maybe_global_asset_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  >& maybe_specific_asset_ids(
    that.specific_asset_ids()
  );
  if (maybe_specific_asset_ids.has_value()) {
    nlohmann::json json_specific_asset_ids = nlohmann::json::array();
    json_specific_asset_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_specific_asset_ids->size()
    );
    size_t index_specific_asset_ids = 0;
    for (
      const std::shared_ptr<types::ISpecificAssetId>& item
      : *maybe_specific_asset_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_specific_asset_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSpecificAssetIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_specific_asset_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_specific_asset_ids;
    }
    result["specificAssetIds"] = std::move(
      json_specific_asset_ids
    );
  }

  const common::optional<std::wstring>& maybe_asset_type(
    that.asset_type()
  );
  if (maybe_asset_type.has_value()) {
    result["assetType"] = SerializeWstring(
      *maybe_asset_type
    );
  }

  const common::optional<
    std::shared_ptr<types::IResource>
  >& maybe_default_thumbnail(
    that.default_thumbnail()
  );
  if (maybe_default_thumbnail.has_value()) {
    common::optional<nlohmann::json> json_default_thumbnail;
    std::tie(
      json_default_thumbnail,
      error
    ) = SerializeIClass(
      **maybe_default_thumbnail
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDefaultThumbnail
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["defaultThumbnail"] = std::move(
      *json_default_thumbnail
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeResource(
  const types::IResource& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["path"] = SerializeWstring(
    that.path()
  );

  const common::optional<std::wstring>& maybe_content_type(
    that.content_type()
  );
  if (maybe_content_type.has_value()) {
    result["contentType"] = SerializeWstring(
      *maybe_content_type
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeSpecificAssetId(
  const types::ISpecificAssetId& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  result["name"] = SerializeWstring(
    that.name()
  );

  result["value"] = SerializeWstring(
    that.value()
  );

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_external_subject_id(
    that.external_subject_id()
  );
  if (maybe_external_subject_id.has_value()) {
    common::optional<nlohmann::json> json_external_subject_id;
    std::tie(
      json_external_subject_id,
      error
    ) = SerializeIClass(
      **maybe_external_subject_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kExternalSubjectId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["externalSubjectId"] = std::move(
      *json_external_subject_id
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeSubmodel(
  const types::ISubmodel& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& maybe_administration(
    that.administration()
  );
  if (maybe_administration.has_value()) {
    common::optional<nlohmann::json> json_administration;
    std::tie(
      json_administration,
      error
    ) = SerializeIClass(
      **maybe_administration
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["administration"] = std::move(
      *json_administration
    );
  }

  result["id"] = SerializeWstring(
    that.id()
  );

  const common::optional<types::ModellingKind>& maybe_kind(
    that.kind()
  );
  if (maybe_kind.has_value()) {
    result["kind"] = stringification::to_string(
      *maybe_kind
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& maybe_submodel_elements(
    that.submodel_elements()
  );
  if (maybe_submodel_elements.has_value()) {
    nlohmann::json json_submodel_elements = nlohmann::json::array();
    json_submodel_elements.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_submodel_elements->size()
    );
    size_t index_submodel_elements = 0;
    for (
      const std::shared_ptr<types::ISubmodelElement>& item
      : *maybe_submodel_elements
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_submodel_elements
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSubmodelElements
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_submodel_elements.emplace_back(
        std::move(*json_item)
      );

      ++index_submodel_elements;
    }
    result["submodelElements"] = std::move(
      json_submodel_elements
    );
  }

  result["modelType"] = "Submodel";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeRelationshipElement(
  const types::IRelationshipElement& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  common::optional<nlohmann::json> json_first;
  std::tie(
    json_first,
    error
  ) = SerializeIClass(
    *that.first()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kFirst
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["first"] = std::move(
    *json_first
  );

  common::optional<nlohmann::json> json_second;
  std::tie(
    json_second,
    error
  ) = SerializeIClass(
    *that.second()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSecond
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["second"] = std::move(
    *json_second
  );

  result["modelType"] = "RelationshipElement";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeSubmodelElementList(
  const types::ISubmodelElementList& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<bool>& maybe_order_relevant(
    that.order_relevant()
  );
  if (maybe_order_relevant.has_value()) {
    result["orderRelevant"] = *maybe_order_relevant;
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id_list_element(
    that.semantic_id_list_element()
  );
  if (maybe_semantic_id_list_element.has_value()) {
    common::optional<nlohmann::json> json_semantic_id_list_element;
    std::tie(
      json_semantic_id_list_element,
      error
    ) = SerializeIClass(
      **maybe_semantic_id_list_element
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticIdListElement
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticIdListElement"] = std::move(
      *json_semantic_id_list_element
    );
  }

  result["typeValueListElement"] = stringification::to_string(
    that.type_value_list_element()
  );

  const common::optional<types::DataTypeDefXsd>& maybe_value_type_list_element(
    that.value_type_list_element()
  );
  if (maybe_value_type_list_element.has_value()) {
    result["valueTypeListElement"] = stringification::to_string(
      *maybe_value_type_list_element
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    nlohmann::json json_value = nlohmann::json::array();
    json_value.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_value->size()
    );
    size_t index_value = 0;
    for (
      const std::shared_ptr<types::ISubmodelElement>& item
      : *maybe_value
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_value
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_value.emplace_back(
        std::move(*json_item)
      );

      ++index_value;
    }
    result["value"] = std::move(
      json_value
    );
  }

  result["modelType"] = "SubmodelElementList";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeSubmodelElementCollection(
  const types::ISubmodelElementCollection& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    nlohmann::json json_value = nlohmann::json::array();
    json_value.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_value->size()
    );
    size_t index_value = 0;
    for (
      const std::shared_ptr<types::ISubmodelElement>& item
      : *maybe_value
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_value
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_value.emplace_back(
        std::move(*json_item)
      );

      ++index_value;
    }
    result["value"] = std::move(
      json_value
    );
  }

  result["modelType"] = "SubmodelElementCollection";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeProperty(
  const types::IProperty& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  result["valueType"] = stringification::to_string(
    that.value_type()
  );

  const common::optional<std::wstring>& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    result["value"] = SerializeWstring(
      *maybe_value
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_value_id(
    that.value_id()
  );
  if (maybe_value_id.has_value()) {
    common::optional<nlohmann::json> json_value_id;
    std::tie(
      json_value_id,
      error
    ) = SerializeIClass(
      **maybe_value_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["valueId"] = std::move(
      *json_value_id
    );
  }

  result["modelType"] = "Property";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeMultiLanguageProperty(
  const types::IMultiLanguageProperty& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    nlohmann::json json_value = nlohmann::json::array();
    json_value.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_value->size()
    );
    size_t index_value = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_value
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_value
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_value.emplace_back(
        std::move(*json_item)
      );

      ++index_value;
    }
    result["value"] = std::move(
      json_value
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_value_id(
    that.value_id()
  );
  if (maybe_value_id.has_value()) {
    common::optional<nlohmann::json> json_value_id;
    std::tie(
      json_value_id,
      error
    ) = SerializeIClass(
      **maybe_value_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["valueId"] = std::move(
      *json_value_id
    );
  }

  result["modelType"] = "MultiLanguageProperty";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeRange(
  const types::IRange& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  result["valueType"] = stringification::to_string(
    that.value_type()
  );

  const common::optional<std::wstring>& maybe_min(
    that.min()
  );
  if (maybe_min.has_value()) {
    result["min"] = SerializeWstring(
      *maybe_min
    );
  }

  const common::optional<std::wstring>& maybe_max(
    that.max()
  );
  if (maybe_max.has_value()) {
    result["max"] = SerializeWstring(
      *maybe_max
    );
  }

  result["modelType"] = "Range";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeReferenceElement(
  const types::IReferenceElement& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    common::optional<nlohmann::json> json_value;
    std::tie(
      json_value,
      error
    ) = SerializeIClass(
      **maybe_value
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValue
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["value"] = std::move(
      *json_value
    );
  }

  result["modelType"] = "ReferenceElement";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeBlob(
  const types::IBlob& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::vector<std::uint8_t>
  >& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    result["value"] = stringification::Base64Encode(
      *maybe_value
    );
  }

  result["contentType"] = SerializeWstring(
    that.content_type()
  );

  result["modelType"] = "Blob";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeFile(
  const types::IFile& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<std::wstring>& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    result["value"] = SerializeWstring(
      *maybe_value
    );
  }

  result["contentType"] = SerializeWstring(
    that.content_type()
  );

  result["modelType"] = "File";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeAnnotatedRelationshipElement(
  const types::IAnnotatedRelationshipElement& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  common::optional<nlohmann::json> json_first;
  std::tie(
    json_first,
    error
  ) = SerializeIClass(
    *that.first()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kFirst
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["first"] = std::move(
    *json_first
  );

  common::optional<nlohmann::json> json_second;
  std::tie(
    json_second,
    error
  ) = SerializeIClass(
    *that.second()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSecond
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["second"] = std::move(
    *json_second
  );

  const common::optional<
    std::vector<
      std::shared_ptr<types::IDataElement>
    >
  >& maybe_annotations(
    that.annotations()
  );
  if (maybe_annotations.has_value()) {
    nlohmann::json json_annotations = nlohmann::json::array();
    json_annotations.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_annotations->size()
    );
    size_t index_annotations = 0;
    for (
      const std::shared_ptr<types::IDataElement>& item
      : *maybe_annotations
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_annotations
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kAnnotations
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_annotations.emplace_back(
        std::move(*json_item)
      );

      ++index_annotations;
    }
    result["annotations"] = std::move(
      json_annotations
    );
  }

  result["modelType"] = "AnnotatedRelationshipElement";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeEntity(
  const types::IEntity& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& maybe_statements(
    that.statements()
  );
  if (maybe_statements.has_value()) {
    nlohmann::json json_statements = nlohmann::json::array();
    json_statements.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_statements->size()
    );
    size_t index_statements = 0;
    for (
      const std::shared_ptr<types::ISubmodelElement>& item
      : *maybe_statements
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_statements
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kStatements
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_statements.emplace_back(
        std::move(*json_item)
      );

      ++index_statements;
    }
    result["statements"] = std::move(
      json_statements
    );
  }

  result["entityType"] = stringification::to_string(
    that.entity_type()
  );

  const common::optional<std::wstring>& maybe_global_asset_id(
    that.global_asset_id()
  );
  if (maybe_global_asset_id.has_value()) {
    result["globalAssetId"] = SerializeWstring(
      *maybe_global_asset_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  >& maybe_specific_asset_ids(
    that.specific_asset_ids()
  );
  if (maybe_specific_asset_ids.has_value()) {
    nlohmann::json json_specific_asset_ids = nlohmann::json::array();
    json_specific_asset_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_specific_asset_ids->size()
    );
    size_t index_specific_asset_ids = 0;
    for (
      const std::shared_ptr<types::ISpecificAssetId>& item
      : *maybe_specific_asset_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_specific_asset_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSpecificAssetIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_specific_asset_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_specific_asset_ids;
    }
    result["specificAssetIds"] = std::move(
      json_specific_asset_ids
    );
  }

  result["modelType"] = "Entity";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeEventPayload(
  const types::IEventPayload& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  common::optional<nlohmann::json> json_source;
  std::tie(
    json_source,
    error
  ) = SerializeIClass(
    *that.source()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kSource
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["source"] = std::move(
    *json_source
  );

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_source_semantic_id(
    that.source_semantic_id()
  );
  if (maybe_source_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_source_semantic_id;
    std::tie(
      json_source_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_source_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSourceSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["sourceSemanticId"] = std::move(
      *json_source_semantic_id
    );
  }

  common::optional<nlohmann::json> json_observable_reference;
  std::tie(
    json_observable_reference,
    error
  ) = SerializeIClass(
    *that.observable_reference()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kObservableReference
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["observableReference"] = std::move(
    *json_observable_reference
  );

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_observable_semantic_id(
    that.observable_semantic_id()
  );
  if (maybe_observable_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_observable_semantic_id;
    std::tie(
      json_observable_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_observable_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kObservableSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["observableSemanticId"] = std::move(
      *json_observable_semantic_id
    );
  }

  const common::optional<std::wstring>& maybe_topic(
    that.topic()
  );
  if (maybe_topic.has_value()) {
    result["topic"] = SerializeWstring(
      *maybe_topic
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_subject_id(
    that.subject_id()
  );
  if (maybe_subject_id.has_value()) {
    common::optional<nlohmann::json> json_subject_id;
    std::tie(
      json_subject_id,
      error
    ) = SerializeIClass(
      **maybe_subject_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSubjectId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["subjectId"] = std::move(
      *json_subject_id
    );
  }

  result["timeStamp"] = SerializeWstring(
    that.time_stamp()
  );

  const common::optional<
    std::vector<std::uint8_t>
  >& maybe_payload(
    that.payload()
  );
  if (maybe_payload.has_value()) {
    result["payload"] = stringification::Base64Encode(
      *maybe_payload
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeBasicEventElement(
  const types::IBasicEventElement& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  common::optional<nlohmann::json> json_observed;
  std::tie(
    json_observed,
    error
  ) = SerializeIClass(
    *that.observed()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kObserved
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["observed"] = std::move(
    *json_observed
  );

  result["direction"] = stringification::to_string(
    that.direction()
  );

  result["state"] = stringification::to_string(
    that.state()
  );

  const common::optional<std::wstring>& maybe_message_topic(
    that.message_topic()
  );
  if (maybe_message_topic.has_value()) {
    result["messageTopic"] = SerializeWstring(
      *maybe_message_topic
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_message_broker(
    that.message_broker()
  );
  if (maybe_message_broker.has_value()) {
    common::optional<nlohmann::json> json_message_broker;
    std::tie(
      json_message_broker,
      error
    ) = SerializeIClass(
      **maybe_message_broker
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kMessageBroker
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["messageBroker"] = std::move(
      *json_message_broker
    );
  }

  const common::optional<std::wstring>& maybe_last_update(
    that.last_update()
  );
  if (maybe_last_update.has_value()) {
    result["lastUpdate"] = SerializeWstring(
      *maybe_last_update
    );
  }

  const common::optional<std::wstring>& maybe_min_interval(
    that.min_interval()
  );
  if (maybe_min_interval.has_value()) {
    result["minInterval"] = SerializeWstring(
      *maybe_min_interval
    );
  }

  const common::optional<std::wstring>& maybe_max_interval(
    that.max_interval()
  );
  if (maybe_max_interval.has_value()) {
    result["maxInterval"] = SerializeWstring(
      *maybe_max_interval
    );
  }

  result["modelType"] = "BasicEventElement";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeOperation(
  const types::IOperation& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& maybe_input_variables(
    that.input_variables()
  );
  if (maybe_input_variables.has_value()) {
    nlohmann::json json_input_variables = nlohmann::json::array();
    json_input_variables.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_input_variables->size()
    );
    size_t index_input_variables = 0;
    for (
      const std::shared_ptr<types::IOperationVariable>& item
      : *maybe_input_variables
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_input_variables
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kInputVariables
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_input_variables.emplace_back(
        std::move(*json_item)
      );

      ++index_input_variables;
    }
    result["inputVariables"] = std::move(
      json_input_variables
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& maybe_output_variables(
    that.output_variables()
  );
  if (maybe_output_variables.has_value()) {
    nlohmann::json json_output_variables = nlohmann::json::array();
    json_output_variables.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_output_variables->size()
    );
    size_t index_output_variables = 0;
    for (
      const std::shared_ptr<types::IOperationVariable>& item
      : *maybe_output_variables
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_output_variables
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kOutputVariables
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_output_variables.emplace_back(
        std::move(*json_item)
      );

      ++index_output_variables;
    }
    result["outputVariables"] = std::move(
      json_output_variables
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& maybe_inoutput_variables(
    that.inoutput_variables()
  );
  if (maybe_inoutput_variables.has_value()) {
    nlohmann::json json_inoutput_variables = nlohmann::json::array();
    json_inoutput_variables.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_inoutput_variables->size()
    );
    size_t index_inoutput_variables = 0;
    for (
      const std::shared_ptr<types::IOperationVariable>& item
      : *maybe_inoutput_variables
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_inoutput_variables
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kInoutputVariables
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_inoutput_variables.emplace_back(
        std::move(*json_item)
      );

      ++index_inoutput_variables;
    }
    result["inoutputVariables"] = std::move(
      json_inoutput_variables
    );
  }

  result["modelType"] = "Operation";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeOperationVariable(
  const types::IOperationVariable& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  common::optional<nlohmann::json> json_value;
  std::tie(
    json_value,
    error
  ) = SerializeIClass(
    *that.value()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValue
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["value"] = std::move(
    *json_value
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeCapability(
  const types::ICapability& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_semantic_id(
    that.semantic_id()
  );
  if (maybe_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_semantic_id;
    std::tie(
      json_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["semanticId"] = std::move(
      *json_semantic_id
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_supplemental_semantic_ids(
    that.supplemental_semantic_ids()
  );
  if (maybe_supplemental_semantic_ids.has_value()) {
    nlohmann::json json_supplemental_semantic_ids = nlohmann::json::array();
    json_supplemental_semantic_ids.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_supplemental_semantic_ids->size()
    );
    size_t index_supplemental_semantic_ids = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_supplemental_semantic_ids
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_supplemental_semantic_ids
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSupplementalSemanticIds
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_supplemental_semantic_ids.emplace_back(
        std::move(*json_item)
      );

      ++index_supplemental_semantic_ids;
    }
    result["supplementalSemanticIds"] = std::move(
      json_supplemental_semantic_ids
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& maybe_qualifiers(
    that.qualifiers()
  );
  if (maybe_qualifiers.has_value()) {
    nlohmann::json json_qualifiers = nlohmann::json::array();
    json_qualifiers.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_qualifiers->size()
    );
    size_t index_qualifiers = 0;
    for (
      const std::shared_ptr<types::IQualifier>& item
      : *maybe_qualifiers
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_qualifiers
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kQualifiers
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_qualifiers.emplace_back(
        std::move(*json_item)
      );

      ++index_qualifiers;
    }
    result["qualifiers"] = std::move(
      json_qualifiers
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  result["modelType"] = "Capability";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeConceptDescription(
  const types::IConceptDescription& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& maybe_extensions(
    that.extensions()
  );
  if (maybe_extensions.has_value()) {
    nlohmann::json json_extensions = nlohmann::json::array();
    json_extensions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_extensions->size()
    );
    size_t index_extensions = 0;
    for (
      const std::shared_ptr<types::IExtension>& item
      : *maybe_extensions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_extensions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kExtensions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_extensions.emplace_back(
        std::move(*json_item)
      );

      ++index_extensions;
    }
    result["extensions"] = std::move(
      json_extensions
    );
  }

  const common::optional<std::wstring>& maybe_category(
    that.category()
  );
  if (maybe_category.has_value()) {
    result["category"] = SerializeWstring(
      *maybe_category
    );
  }

  const common::optional<std::wstring>& maybe_id_short(
    that.id_short()
  );
  if (maybe_id_short.has_value()) {
    result["idShort"] = SerializeWstring(
      *maybe_id_short
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& maybe_display_name(
    that.display_name()
  );
  if (maybe_display_name.has_value()) {
    nlohmann::json json_display_name = nlohmann::json::array();
    json_display_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_display_name->size()
    );
    size_t index_display_name = 0;
    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : *maybe_display_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_display_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDisplayName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_display_name.emplace_back(
        std::move(*json_item)
      );

      ++index_display_name;
    }
    result["displayName"] = std::move(
      json_display_name
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& maybe_description(
    that.description()
  );
  if (maybe_description.has_value()) {
    nlohmann::json json_description = nlohmann::json::array();
    json_description.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_description->size()
    );
    size_t index_description = 0;
    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : *maybe_description
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_description
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDescription
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_description.emplace_back(
        std::move(*json_item)
      );

      ++index_description;
    }
    result["description"] = std::move(
      json_description
    );
  }

  const common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& maybe_administration(
    that.administration()
  );
  if (maybe_administration.has_value()) {
    common::optional<nlohmann::json> json_administration;
    std::tie(
      json_administration,
      error
    ) = SerializeIClass(
      **maybe_administration
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kAdministration
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["administration"] = std::move(
      *json_administration
    );
  }

  result["id"] = SerializeWstring(
    that.id()
  );

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& maybe_embedded_data_specifications(
    that.embedded_data_specifications()
  );
  if (maybe_embedded_data_specifications.has_value()) {
    nlohmann::json json_embedded_data_specifications = nlohmann::json::array();
    json_embedded_data_specifications.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_embedded_data_specifications->size()
    );
    size_t index_embedded_data_specifications = 0;
    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : *maybe_embedded_data_specifications
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_embedded_data_specifications
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kEmbeddedDataSpecifications
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_embedded_data_specifications.emplace_back(
        std::move(*json_item)
      );

      ++index_embedded_data_specifications;
    }
    result["embeddedDataSpecifications"] = std::move(
      json_embedded_data_specifications
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& maybe_is_case_of(
    that.is_case_of()
  );
  if (maybe_is_case_of.has_value()) {
    nlohmann::json json_is_case_of = nlohmann::json::array();
    json_is_case_of.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_is_case_of->size()
    );
    size_t index_is_case_of = 0;
    for (
      const std::shared_ptr<types::IReference>& item
      : *maybe_is_case_of
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_is_case_of
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIsCaseOf
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_is_case_of.emplace_back(
        std::move(*json_item)
      );

      ++index_is_case_of;
    }
    result["isCaseOf"] = std::move(
      json_is_case_of
    );
  }

  result["modelType"] = "ConceptDescription";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeReference(
  const types::IReference& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["type"] = stringification::to_string(
    that.type()
  );

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_referred_semantic_id(
    that.referred_semantic_id()
  );
  if (maybe_referred_semantic_id.has_value()) {
    common::optional<nlohmann::json> json_referred_semantic_id;
    std::tie(
      json_referred_semantic_id,
      error
    ) = SerializeIClass(
      **maybe_referred_semantic_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kReferredSemanticId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["referredSemanticId"] = std::move(
      *json_referred_semantic_id
    );
  }

  nlohmann::json json_keys = nlohmann::json::array();
  json_keys.get_ptr<nlohmann::json::array_t*>()->reserve(
    that.keys().size()
  );
  size_t index_keys = 0;
  for (
    const std::shared_ptr<types::IKey>& item
    : that.keys()
  ) {
    common::optional<nlohmann::json> json_item;
    std::tie(
      json_item,
      error
    ) = SerializeIClass(*item);

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          index_keys
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kKeys
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    json_keys.emplace_back(
      std::move(*json_item)
    );

    ++index_keys;
  }
  result["keys"] = std::move(
    json_keys
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeKey(
  const types::IKey& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["type"] = stringification::to_string(
    that.type()
  );

  result["value"] = SerializeWstring(
    that.value()
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeLangStringNameType(
  const types::ILangStringNameType& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["language"] = SerializeWstring(
    that.language()
  );

  result["text"] = SerializeWstring(
    that.text()
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeLangStringTextType(
  const types::ILangStringTextType& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["language"] = SerializeWstring(
    that.language()
  );

  result["text"] = SerializeWstring(
    that.text()
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeEnvironment(
  const types::IEnvironment& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  const common::optional<
    std::vector<
      std::shared_ptr<types::IAssetAdministrationShell>
    >
  >& maybe_asset_administration_shells(
    that.asset_administration_shells()
  );
  if (maybe_asset_administration_shells.has_value()) {
    nlohmann::json json_asset_administration_shells = nlohmann::json::array();
    json_asset_administration_shells.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_asset_administration_shells->size()
    );
    size_t index_asset_administration_shells = 0;
    for (
      const std::shared_ptr<types::IAssetAdministrationShell>& item
      : *maybe_asset_administration_shells
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_asset_administration_shells
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kAssetAdministrationShells
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_asset_administration_shells.emplace_back(
        std::move(*json_item)
      );

      ++index_asset_administration_shells;
    }
    result["assetAdministrationShells"] = std::move(
      json_asset_administration_shells
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodel>
    >
  >& maybe_submodels(
    that.submodels()
  );
  if (maybe_submodels.has_value()) {
    nlohmann::json json_submodels = nlohmann::json::array();
    json_submodels.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_submodels->size()
    );
    size_t index_submodels = 0;
    for (
      const std::shared_ptr<types::ISubmodel>& item
      : *maybe_submodels
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_submodels
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSubmodels
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_submodels.emplace_back(
        std::move(*json_item)
      );

      ++index_submodels;
    }
    result["submodels"] = std::move(
      json_submodels
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IConceptDescription>
    >
  >& maybe_concept_descriptions(
    that.concept_descriptions()
  );
  if (maybe_concept_descriptions.has_value()) {
    nlohmann::json json_concept_descriptions = nlohmann::json::array();
    json_concept_descriptions.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_concept_descriptions->size()
    );
    size_t index_concept_descriptions = 0;
    for (
      const std::shared_ptr<types::IConceptDescription>& item
      : *maybe_concept_descriptions
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_concept_descriptions
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kConceptDescriptions
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_concept_descriptions.emplace_back(
        std::move(*json_item)
      );

      ++index_concept_descriptions;
    }
    result["conceptDescriptions"] = std::move(
      json_concept_descriptions
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeEmbeddedDataSpecification(
  const types::IEmbeddedDataSpecification& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  common::optional<nlohmann::json> json_data_specification_content;
  std::tie(
    json_data_specification_content,
    error
  ) = SerializeIClass(
    *that.data_specification_content()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kDataSpecificationContent
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["dataSpecificationContent"] = std::move(
    *json_data_specification_content
  );

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_data_specification(
    that.data_specification()
  );
  if (maybe_data_specification.has_value()) {
    common::optional<nlohmann::json> json_data_specification;
    std::tie(
      json_data_specification,
      error
    ) = SerializeIClass(
      **maybe_data_specification
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kDataSpecification
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["dataSpecification"] = std::move(
      *json_data_specification
    );
  }

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeLevelType(
  const types::ILevelType& that
) {
  nlohmann::json result = nlohmann::json::object();

  result["min"] = that.min();

  result["nom"] = that.nom();

  result["typ"] = that.typ();

  result["max"] = that.max();

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeValueReferencePair(
  const types::IValueReferencePair& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["value"] = SerializeWstring(
    that.value()
  );

  common::optional<nlohmann::json> json_value_id;
  std::tie(
    json_value_id,
    error
  ) = SerializeIClass(
    *that.value_id()
  );
  if (error.has_value()) {
    error->path.segments.emplace_front(
      common::make_unique<iteration::PropertySegment>(
        iteration::Property::kValueId
      )
    );

    return std::make_pair<
      common::optional<nlohmann::json>,
      common::optional<SerializationError>
    >(
      common::nullopt,
      std::move(error)
    );
  }

  result["valueId"] = std::move(
    *json_value_id
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeValueList(
  const types::IValueList& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  nlohmann::json json_value_reference_pairs = nlohmann::json::array();
  json_value_reference_pairs.get_ptr<nlohmann::json::array_t*>()->reserve(
    that.value_reference_pairs().size()
  );
  size_t index_value_reference_pairs = 0;
  for (
    const std::shared_ptr<types::IValueReferencePair>& item
    : that.value_reference_pairs()
  ) {
    common::optional<nlohmann::json> json_item;
    std::tie(
      json_item,
      error
    ) = SerializeIClass(*item);

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          index_value_reference_pairs
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueReferencePairs
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    json_value_reference_pairs.emplace_back(
      std::move(*json_item)
    );

    ++index_value_reference_pairs;
  }
  result["valueReferencePairs"] = std::move(
    json_value_reference_pairs
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeLangStringPreferredNameTypeIec61360(
  const types::ILangStringPreferredNameTypeIec61360& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["language"] = SerializeWstring(
    that.language()
  );

  result["text"] = SerializeWstring(
    that.text()
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeLangStringShortNameTypeIec61360(
  const types::ILangStringShortNameTypeIec61360& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["language"] = SerializeWstring(
    that.language()
  );

  result["text"] = SerializeWstring(
    that.text()
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeLangStringDefinitionTypeIec61360(
  const types::ILangStringDefinitionTypeIec61360& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  result["language"] = SerializeWstring(
    that.language()
  );

  result["text"] = SerializeWstring(
    that.text()
  );

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeDataSpecificationIec61360(
  const types::IDataSpecificationIec61360& that
) {
  nlohmann::json result = nlohmann::json::object();

  common::optional<SerializationError> error;

  nlohmann::json json_preferred_name = nlohmann::json::array();
  json_preferred_name.get_ptr<nlohmann::json::array_t*>()->reserve(
    that.preferred_name().size()
  );
  size_t index_preferred_name = 0;
  for (
    const std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>& item
    : that.preferred_name()
  ) {
    common::optional<nlohmann::json> json_item;
    std::tie(
      json_item,
      error
    ) = SerializeIClass(*item);

    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::IndexSegment>(
          index_preferred_name
        )
      );

      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kPreferredName
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    json_preferred_name.emplace_back(
      std::move(*json_item)
    );

    ++index_preferred_name;
  }
  result["preferredName"] = std::move(
    json_preferred_name
  );

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >
  >& maybe_short_name(
    that.short_name()
  );
  if (maybe_short_name.has_value()) {
    nlohmann::json json_short_name = nlohmann::json::array();
    json_short_name.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_short_name->size()
    );
    size_t index_short_name = 0;
    for (
      const std::shared_ptr<types::ILangStringShortNameTypeIec61360>& item
      : *maybe_short_name
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_short_name
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kShortName
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_short_name.emplace_back(
        std::move(*json_item)
      );

      ++index_short_name;
    }
    result["shortName"] = std::move(
      json_short_name
    );
  }

  const common::optional<std::wstring>& maybe_unit(
    that.unit()
  );
  if (maybe_unit.has_value()) {
    result["unit"] = SerializeWstring(
      *maybe_unit
    );
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& maybe_unit_id(
    that.unit_id()
  );
  if (maybe_unit_id.has_value()) {
    common::optional<nlohmann::json> json_unit_id;
    std::tie(
      json_unit_id,
      error
    ) = SerializeIClass(
      **maybe_unit_id
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kUnitId
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["unitId"] = std::move(
      *json_unit_id
    );
  }

  const common::optional<std::wstring>& maybe_source_of_definition(
    that.source_of_definition()
  );
  if (maybe_source_of_definition.has_value()) {
    result["sourceOfDefinition"] = SerializeWstring(
      *maybe_source_of_definition
    );
  }

  const common::optional<std::wstring>& maybe_symbol(
    that.symbol()
  );
  if (maybe_symbol.has_value()) {
    result["symbol"] = SerializeWstring(
      *maybe_symbol
    );
  }

  const common::optional<types::DataTypeIec61360>& maybe_data_type(
    that.data_type()
  );
  if (maybe_data_type.has_value()) {
    result["dataType"] = stringification::to_string(
      *maybe_data_type
    );
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >
  >& maybe_definition(
    that.definition()
  );
  if (maybe_definition.has_value()) {
    nlohmann::json json_definition = nlohmann::json::array();
    json_definition.get_ptr<nlohmann::json::array_t*>()->reserve(
      maybe_definition->size()
    );
    size_t index_definition = 0;
    for (
      const std::shared_ptr<types::ILangStringDefinitionTypeIec61360>& item
      : *maybe_definition
    ) {
      common::optional<nlohmann::json> json_item;
      std::tie(
        json_item,
        error
      ) = SerializeIClass(*item);

      if (error.has_value()) {
        error->path.segments.emplace_front(
          common::make_unique<iteration::IndexSegment>(
            index_definition
          )
        );

        error->path.segments.emplace_front(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kDefinition
          )
        );

        return std::make_pair<
          common::optional<nlohmann::json>,
          common::optional<SerializationError>
        >(
          common::nullopt,
          std::move(error)
        );
      }

      json_definition.emplace_back(
        std::move(*json_item)
      );

      ++index_definition;
    }
    result["definition"] = std::move(
      json_definition
    );
  }

  const common::optional<std::wstring>& maybe_value_format(
    that.value_format()
  );
  if (maybe_value_format.has_value()) {
    result["valueFormat"] = SerializeWstring(
      *maybe_value_format
    );
  }

  const common::optional<
    std::shared_ptr<types::IValueList>
  >& maybe_value_list(
    that.value_list()
  );
  if (maybe_value_list.has_value()) {
    common::optional<nlohmann::json> json_value_list;
    std::tie(
      json_value_list,
      error
    ) = SerializeIClass(
      **maybe_value_list
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kValueList
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["valueList"] = std::move(
      *json_value_list
    );
  }

  const common::optional<std::wstring>& maybe_value(
    that.value()
  );
  if (maybe_value.has_value()) {
    result["value"] = SerializeWstring(
      *maybe_value
    );
  }

  const common::optional<
    std::shared_ptr<types::ILevelType>
  >& maybe_level_type(
    that.level_type()
  );
  if (maybe_level_type.has_value()) {
    common::optional<nlohmann::json> json_level_type;
    std::tie(
      json_level_type,
      error
    ) = SerializeIClass(
      **maybe_level_type
    );
    if (error.has_value()) {
      error->path.segments.emplace_front(
        common::make_unique<iteration::PropertySegment>(
          iteration::Property::kLevelType
        )
      );

      return std::make_pair<
        common::optional<nlohmann::json>,
        common::optional<SerializationError>
      >(
        common::nullopt,
        std::move(error)
      );
    }

    result["levelType"] = std::move(
      *json_level_type
    );
  }

  result["modelType"] = "DataSpecificationIec61360";

  return std::make_pair<
    common::optional<nlohmann::json>,
    common::optional<SerializationError>
  >(
    common::make_optional<nlohmann::json>(std::move(result)),
    common::nullopt
  );
}

std::pair<
  common::optional<nlohmann::json>,
  common::optional<SerializationError>
> SerializeIClass(
  const types::IClass& that
) {
  switch (that.model_type()) {
    case types::ModelType::kExtension:
      return SerializeExtension(
        dynamic_cast<const types::IExtension&>(that)
      );
    case types::ModelType::kAdministrativeInformation:
      return SerializeAdministrativeInformation(
        dynamic_cast<const types::IAdministrativeInformation&>(that)
      );
    case types::ModelType::kQualifier:
      return SerializeQualifier(
        dynamic_cast<const types::IQualifier&>(that)
      );
    case types::ModelType::kAssetAdministrationShell:
      return SerializeAssetAdministrationShell(
        dynamic_cast<const types::IAssetAdministrationShell&>(that)
      );
    case types::ModelType::kAssetInformation:
      return SerializeAssetInformation(
        dynamic_cast<const types::IAssetInformation&>(that)
      );
    case types::ModelType::kResource:
      return SerializeResource(
        dynamic_cast<const types::IResource&>(that)
      );
    case types::ModelType::kSpecificAssetId:
      return SerializeSpecificAssetId(
        dynamic_cast<const types::ISpecificAssetId&>(that)
      );
    case types::ModelType::kSubmodel:
      return SerializeSubmodel(
        dynamic_cast<const types::ISubmodel&>(that)
      );
    case types::ModelType::kRelationshipElement:
      return SerializeRelationshipElement(
        dynamic_cast<const types::IRelationshipElement&>(that)
      );
    case types::ModelType::kSubmodelElementList:
      return SerializeSubmodelElementList(
        dynamic_cast<const types::ISubmodelElementList&>(that)
      );
    case types::ModelType::kSubmodelElementCollection:
      return SerializeSubmodelElementCollection(
        dynamic_cast<const types::ISubmodelElementCollection&>(that)
      );
    case types::ModelType::kProperty:
      return SerializeProperty(
        dynamic_cast<const types::IProperty&>(that)
      );
    case types::ModelType::kMultiLanguageProperty:
      return SerializeMultiLanguageProperty(
        dynamic_cast<const types::IMultiLanguageProperty&>(that)
      );
    case types::ModelType::kRange:
      return SerializeRange(
        dynamic_cast<const types::IRange&>(that)
      );
    case types::ModelType::kReferenceElement:
      return SerializeReferenceElement(
        dynamic_cast<const types::IReferenceElement&>(that)
      );
    case types::ModelType::kBlob:
      return SerializeBlob(
        dynamic_cast<const types::IBlob&>(that)
      );
    case types::ModelType::kFile:
      return SerializeFile(
        dynamic_cast<const types::IFile&>(that)
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return SerializeAnnotatedRelationshipElement(
        dynamic_cast<const types::IAnnotatedRelationshipElement&>(that)
      );
    case types::ModelType::kEntity:
      return SerializeEntity(
        dynamic_cast<const types::IEntity&>(that)
      );
    case types::ModelType::kEventPayload:
      return SerializeEventPayload(
        dynamic_cast<const types::IEventPayload&>(that)
      );
    case types::ModelType::kBasicEventElement:
      return SerializeBasicEventElement(
        dynamic_cast<const types::IBasicEventElement&>(that)
      );
    case types::ModelType::kOperation:
      return SerializeOperation(
        dynamic_cast<const types::IOperation&>(that)
      );
    case types::ModelType::kOperationVariable:
      return SerializeOperationVariable(
        dynamic_cast<const types::IOperationVariable&>(that)
      );
    case types::ModelType::kCapability:
      return SerializeCapability(
        dynamic_cast<const types::ICapability&>(that)
      );
    case types::ModelType::kConceptDescription:
      return SerializeConceptDescription(
        dynamic_cast<const types::IConceptDescription&>(that)
      );
    case types::ModelType::kReference:
      return SerializeReference(
        dynamic_cast<const types::IReference&>(that)
      );
    case types::ModelType::kKey:
      return SerializeKey(
        dynamic_cast<const types::IKey&>(that)
      );
    case types::ModelType::kLangStringNameType:
      return SerializeLangStringNameType(
        dynamic_cast<const types::ILangStringNameType&>(that)
      );
    case types::ModelType::kLangStringTextType:
      return SerializeLangStringTextType(
        dynamic_cast<const types::ILangStringTextType&>(that)
      );
    case types::ModelType::kEnvironment:
      return SerializeEnvironment(
        dynamic_cast<const types::IEnvironment&>(that)
      );
    case types::ModelType::kEmbeddedDataSpecification:
      return SerializeEmbeddedDataSpecification(
        dynamic_cast<const types::IEmbeddedDataSpecification&>(that)
      );
    case types::ModelType::kLevelType:
      return SerializeLevelType(
        dynamic_cast<const types::ILevelType&>(that)
      );
    case types::ModelType::kValueReferencePair:
      return SerializeValueReferencePair(
        dynamic_cast<const types::IValueReferencePair&>(that)
      );
    case types::ModelType::kValueList:
      return SerializeValueList(
        dynamic_cast<const types::IValueList&>(that)
      );
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      return SerializeLangStringPreferredNameTypeIec61360(
        dynamic_cast<const types::ILangStringPreferredNameTypeIec61360&>(that)
      );
    case types::ModelType::kLangStringShortNameTypeIec61360:
      return SerializeLangStringShortNameTypeIec61360(
        dynamic_cast<const types::ILangStringShortNameTypeIec61360&>(that)
      );
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      return SerializeLangStringDefinitionTypeIec61360(
        dynamic_cast<const types::ILangStringDefinitionTypeIec61360&>(that)
      );
    case types::ModelType::kDataSpecificationIec61360:
      return SerializeDataSpecificationIec61360(
        dynamic_cast<const types::IDataSpecificationIec61360&>(that)
      );
    default: {
      std::string message = common::Concat(
        "Unexpected model type: ",
        std::to_string(
          static_cast<std::uint32_t>(
            that.model_type()
          )
        )
      );

      throw std::invalid_argument(message);
    }
  };
}

nlohmann::json Serialize(
  const types::IClass& that
) {
  common::optional<nlohmann::json> result;
  common::optional<SerializationError> error;

  std::tie(
    result,
    error
  ) = SerializeIClass(that);

  if (error.has_value()) {
    throw SerializationException(
      std::move(error->cause),
      std::move(error->path)
    );
  }

  return std::move(*result);
}

// endregion Serialization

}  // namespace jsonization
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
