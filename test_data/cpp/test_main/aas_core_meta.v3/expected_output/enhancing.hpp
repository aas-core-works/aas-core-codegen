#ifndef AAS_CORE_AAS_3_0_ENHANCING_GUARD_
#define AAS_CORE_AAS_3_0_ENHANCING_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/stringification.hpp"
#include "aas_core/aas_3_0/types.hpp"

#pragma warning(push, 0)
#include <sstream>
#include <stdexcept>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup enhancing Enhance instances of the model with your custom enhancements.
 * @{{
 */
namespace enhancing {

// region Forward declarations

template <typename E>
std::shared_ptr<
  types::IHasSemantics
> Wrap(
  const std::shared_ptr<
    types::IHasSemantics
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IExtension
> Wrap(
  const std::shared_ptr<
    types::IExtension
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IHasExtensions
> Wrap(
  const std::shared_ptr<
    types::IHasExtensions
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IReferable
> Wrap(
  const std::shared_ptr<
    types::IReferable
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IIdentifiable
> Wrap(
  const std::shared_ptr<
    types::IIdentifiable
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IHasKind
> Wrap(
  const std::shared_ptr<
    types::IHasKind
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IHasDataSpecification
> Wrap(
  const std::shared_ptr<
    types::IHasDataSpecification
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IAdministrativeInformation
> Wrap(
  const std::shared_ptr<
    types::IAdministrativeInformation
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IQualifiable
> Wrap(
  const std::shared_ptr<
    types::IQualifiable
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IQualifier
> Wrap(
  const std::shared_ptr<
    types::IQualifier
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IAssetAdministrationShell
> Wrap(
  const std::shared_ptr<
    types::IAssetAdministrationShell
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IAssetInformation
> Wrap(
  const std::shared_ptr<
    types::IAssetInformation
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IResource
> Wrap(
  const std::shared_ptr<
    types::IResource
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ISpecificAssetId
> Wrap(
  const std::shared_ptr<
    types::ISpecificAssetId
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ISubmodel
> Wrap(
  const std::shared_ptr<
    types::ISubmodel
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ISubmodelElement
> Wrap(
  const std::shared_ptr<
    types::ISubmodelElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IRelationshipElement
> Wrap(
  const std::shared_ptr<
    types::IRelationshipElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ISubmodelElementList
> Wrap(
  const std::shared_ptr<
    types::ISubmodelElementList
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ISubmodelElementCollection
> Wrap(
  const std::shared_ptr<
    types::ISubmodelElementCollection
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IDataElement
> Wrap(
  const std::shared_ptr<
    types::IDataElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IProperty
> Wrap(
  const std::shared_ptr<
    types::IProperty
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IMultiLanguageProperty
> Wrap(
  const std::shared_ptr<
    types::IMultiLanguageProperty
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IRange
> Wrap(
  const std::shared_ptr<
    types::IRange
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IReferenceElement
> Wrap(
  const std::shared_ptr<
    types::IReferenceElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IBlob
> Wrap(
  const std::shared_ptr<
    types::IBlob
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IFile
> Wrap(
  const std::shared_ptr<
    types::IFile
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IAnnotatedRelationshipElement
> Wrap(
  const std::shared_ptr<
    types::IAnnotatedRelationshipElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IEntity
> Wrap(
  const std::shared_ptr<
    types::IEntity
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IEventPayload
> Wrap(
  const std::shared_ptr<
    types::IEventPayload
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IEventElement
> Wrap(
  const std::shared_ptr<
    types::IEventElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IBasicEventElement
> Wrap(
  const std::shared_ptr<
    types::IBasicEventElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IOperation
> Wrap(
  const std::shared_ptr<
    types::IOperation
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IOperationVariable
> Wrap(
  const std::shared_ptr<
    types::IOperationVariable
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ICapability
> Wrap(
  const std::shared_ptr<
    types::ICapability
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IConceptDescription
> Wrap(
  const std::shared_ptr<
    types::IConceptDescription
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IReference
> Wrap(
  const std::shared_ptr<
    types::IReference
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IKey
> Wrap(
  const std::shared_ptr<
    types::IKey
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IAbstractLangString
> Wrap(
  const std::shared_ptr<
    types::IAbstractLangString
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ILangStringNameType
> Wrap(
  const std::shared_ptr<
    types::ILangStringNameType
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ILangStringTextType
> Wrap(
  const std::shared_ptr<
    types::ILangStringTextType
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IEnvironment
> Wrap(
  const std::shared_ptr<
    types::IEnvironment
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IDataSpecificationContent
> Wrap(
  const std::shared_ptr<
    types::IDataSpecificationContent
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IEmbeddedDataSpecification
> Wrap(
  const std::shared_ptr<
    types::IEmbeddedDataSpecification
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ILevelType
> Wrap(
  const std::shared_ptr<
    types::ILevelType
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IValueReferencePair
> Wrap(
  const std::shared_ptr<
    types::IValueReferencePair
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IValueList
> Wrap(
  const std::shared_ptr<
    types::IValueList
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ILangStringPreferredNameTypeIec61360
> Wrap(
  const std::shared_ptr<
    types::ILangStringPreferredNameTypeIec61360
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ILangStringShortNameTypeIec61360
> Wrap(
  const std::shared_ptr<
    types::ILangStringShortNameTypeIec61360
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::ILangStringDefinitionTypeIec61360
> Wrap(
  const std::shared_ptr<
    types::ILangStringDefinitionTypeIec61360
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

template <typename E>
std::shared_ptr<
  types::IDataSpecificationIec61360
> Wrap(
  const std::shared_ptr<
    types::IDataSpecificationIec61360
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
);

// endregion Forward declarations

/// \cond HIDDEN
namespace impl {

template<typename E>
class IEnhanced {
 public:
  virtual const std::shared_ptr<E>& enhancement() const = 0;

  virtual std::shared_ptr<E>& mutable_enhancement() = 0;

  virtual void set_enhancement(
    std::shared_ptr<E> value
  ) = 0;

  virtual ~IEnhanced() = default;
};

template<class E>
class EnhancedExtension
    : virtual public types::IExtension,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kExtension;
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const std::wstring& name() const override {
    return instance_->name();
  }

  std::wstring& mutable_name() override {
    return instance_->mutable_name();
  }

  void set_name(
    std::wstring value
  ) override {
    instance_->set_name(value);
  }

  const common::optional<types::DataTypeDefXsd>& value_type() const override {
    return instance_->value_type();
  }

  common::optional<types::DataTypeDefXsd>& mutable_value_type() override {
    return instance_->mutable_value_type();
  }

  void set_value_type(
    common::optional<types::DataTypeDefXsd> value
  ) override {
    instance_->set_value_type(value);
  }

  const common::optional<std::wstring>& value() const override {
    return instance_->value();
  }

  common::optional<std::wstring>& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<std::wstring> value
  ) override {
    instance_->set_value(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& refers_to() const override {
    return instance_->refers_to();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_refers_to() override {
    return instance_->mutable_refers_to();
  }

  void set_refers_to(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_refers_to(value);
  }

  types::DataTypeDefXsd ValueTypeOrDefault() const override {
    return instance_->ValueTypeOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedExtension(
    std::shared_ptr<types::IExtension> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedExtension() = default;

 private:
  std::shared_ptr<types::IExtension> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedAdministrativeInformation
    : virtual public types::IAdministrativeInformation,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kAdministrativeInformation;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<std::wstring>& version() const override {
    return instance_->version();
  }

  common::optional<std::wstring>& mutable_version() override {
    return instance_->mutable_version();
  }

  void set_version(
    common::optional<std::wstring> value
  ) override {
    instance_->set_version(value);
  }

  const common::optional<std::wstring>& revision() const override {
    return instance_->revision();
  }

  common::optional<std::wstring>& mutable_revision() override {
    return instance_->mutable_revision();
  }

  void set_revision(
    common::optional<std::wstring> value
  ) override {
    instance_->set_revision(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& creator() const override {
    return instance_->creator();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_creator() override {
    return instance_->mutable_creator();
  }

  void set_creator(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_creator(value);
  }

  const common::optional<std::wstring>& template_id() const override {
    return instance_->template_id();
  }

  common::optional<std::wstring>& mutable_template_id() override {
    return instance_->mutable_template_id();
  }

  void set_template_id(
    common::optional<std::wstring> value
  ) override {
    instance_->set_template_id(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedAdministrativeInformation(
    std::shared_ptr<types::IAdministrativeInformation> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedAdministrativeInformation() = default;

 private:
  std::shared_ptr<types::IAdministrativeInformation> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedQualifier
    : virtual public types::IQualifier,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kQualifier;
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<types::QualifierKind>& kind() const override {
    return instance_->kind();
  }

  common::optional<types::QualifierKind>& mutable_kind() override {
    return instance_->mutable_kind();
  }

  void set_kind(
    common::optional<types::QualifierKind> value
  ) override {
    instance_->set_kind(value);
  }

  const std::wstring& type() const override {
    return instance_->type();
  }

  std::wstring& mutable_type() override {
    return instance_->mutable_type();
  }

  void set_type(
    std::wstring value
  ) override {
    instance_->set_type(value);
  }

  types::DataTypeDefXsd value_type() const override {
    return instance_->value_type();
  }

  types::DataTypeDefXsd& mutable_value_type() override {
    return instance_->mutable_value_type();
  }

  void set_value_type(
    types::DataTypeDefXsd value
  ) override {
    instance_->set_value_type(value);
  }

  const common::optional<std::wstring>& value() const override {
    return instance_->value();
  }

  common::optional<std::wstring>& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<std::wstring> value
  ) override {
    instance_->set_value(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& value_id() const override {
    return instance_->value_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_value_id() override {
    return instance_->mutable_value_id();
  }

  void set_value_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_value_id(value);
  }

  types::QualifierKind KindOrDefault() const override {
    return instance_->KindOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedQualifier(
    std::shared_ptr<types::IQualifier> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedQualifier() = default;

 private:
  std::shared_ptr<types::IQualifier> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedAssetAdministrationShell
    : virtual public types::IAssetAdministrationShell,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kAssetAdministrationShell;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& administration() const override {
    return instance_->administration();
  }

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& mutable_administration() override {
    return instance_->mutable_administration();
  }

  void set_administration(
    common::optional<
      std::shared_ptr<types::IAdministrativeInformation>
    > value
  ) override {
    instance_->set_administration(value);
  }

  const std::wstring& id() const override {
    return instance_->id();
  }

  std::wstring& mutable_id() override {
    return instance_->mutable_id();
  }

  void set_id(
    std::wstring value
  ) override {
    instance_->set_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& derived_from() const override {
    return instance_->derived_from();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_derived_from() override {
    return instance_->mutable_derived_from();
  }

  void set_derived_from(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_derived_from(value);
  }

  const std::shared_ptr<types::IAssetInformation>& asset_information() const override {
    return instance_->asset_information();
  }

  std::shared_ptr<types::IAssetInformation>& mutable_asset_information() override {
    return instance_->mutable_asset_information();
  }

  void set_asset_information(
    std::shared_ptr<types::IAssetInformation> value
  ) override {
    instance_->set_asset_information(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& submodels() const override {
    return instance_->submodels();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_submodels() override {
    return instance_->mutable_submodels();
  }

  void set_submodels(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_submodels(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedAssetAdministrationShell(
    std::shared_ptr<types::IAssetAdministrationShell> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedAssetAdministrationShell() = default;

 private:
  std::shared_ptr<types::IAssetAdministrationShell> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedAssetInformation
    : virtual public types::IAssetInformation,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kAssetInformation;
  }

  types::AssetKind asset_kind() const override {
    return instance_->asset_kind();
  }

  types::AssetKind& mutable_asset_kind() override {
    return instance_->mutable_asset_kind();
  }

  void set_asset_kind(
    types::AssetKind value
  ) override {
    instance_->set_asset_kind(value);
  }

  const common::optional<std::wstring>& global_asset_id() const override {
    return instance_->global_asset_id();
  }

  common::optional<std::wstring>& mutable_global_asset_id() override {
    return instance_->mutable_global_asset_id();
  }

  void set_global_asset_id(
    common::optional<std::wstring> value
  ) override {
    instance_->set_global_asset_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  >& specific_asset_ids() const override {
    return instance_->specific_asset_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  >& mutable_specific_asset_ids() override {
    return instance_->mutable_specific_asset_ids();
  }

  void set_specific_asset_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::ISpecificAssetId>
      >
    > value
  ) override {
    instance_->set_specific_asset_ids(value);
  }

  const common::optional<std::wstring>& asset_type() const override {
    return instance_->asset_type();
  }

  common::optional<std::wstring>& mutable_asset_type() override {
    return instance_->mutable_asset_type();
  }

  void set_asset_type(
    common::optional<std::wstring> value
  ) override {
    instance_->set_asset_type(value);
  }

  const common::optional<
    std::shared_ptr<types::IResource>
  >& default_thumbnail() const override {
    return instance_->default_thumbnail();
  }

  common::optional<
    std::shared_ptr<types::IResource>
  >& mutable_default_thumbnail() override {
    return instance_->mutable_default_thumbnail();
  }

  void set_default_thumbnail(
    common::optional<
      std::shared_ptr<types::IResource>
    > value
  ) override {
    instance_->set_default_thumbnail(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedAssetInformation(
    std::shared_ptr<types::IAssetInformation> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedAssetInformation() = default;

 private:
  std::shared_ptr<types::IAssetInformation> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedResource
    : virtual public types::IResource,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kResource;
  }

  const std::wstring& path() const override {
    return instance_->path();
  }

  std::wstring& mutable_path() override {
    return instance_->mutable_path();
  }

  void set_path(
    std::wstring value
  ) override {
    instance_->set_path(value);
  }

  const common::optional<std::wstring>& content_type() const override {
    return instance_->content_type();
  }

  common::optional<std::wstring>& mutable_content_type() override {
    return instance_->mutable_content_type();
  }

  void set_content_type(
    common::optional<std::wstring> value
  ) override {
    instance_->set_content_type(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedResource(
    std::shared_ptr<types::IResource> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedResource() = default;

 private:
  std::shared_ptr<types::IResource> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedSpecificAssetId
    : virtual public types::ISpecificAssetId,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kSpecificAssetId;
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const std::wstring& name() const override {
    return instance_->name();
  }

  std::wstring& mutable_name() override {
    return instance_->mutable_name();
  }

  void set_name(
    std::wstring value
  ) override {
    instance_->set_name(value);
  }

  const std::wstring& value() const override {
    return instance_->value();
  }

  std::wstring& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    std::wstring value
  ) override {
    instance_->set_value(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& external_subject_id() const override {
    return instance_->external_subject_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_external_subject_id() override {
    return instance_->mutable_external_subject_id();
  }

  void set_external_subject_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_external_subject_id(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedSpecificAssetId(
    std::shared_ptr<types::ISpecificAssetId> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedSpecificAssetId() = default;

 private:
  std::shared_ptr<types::ISpecificAssetId> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedSubmodel
    : virtual public types::ISubmodel,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kSubmodel;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& administration() const override {
    return instance_->administration();
  }

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& mutable_administration() override {
    return instance_->mutable_administration();
  }

  void set_administration(
    common::optional<
      std::shared_ptr<types::IAdministrativeInformation>
    > value
  ) override {
    instance_->set_administration(value);
  }

  const std::wstring& id() const override {
    return instance_->id();
  }

  std::wstring& mutable_id() override {
    return instance_->mutable_id();
  }

  void set_id(
    std::wstring value
  ) override {
    instance_->set_id(value);
  }

  const common::optional<types::ModellingKind>& kind() const override {
    return instance_->kind();
  }

  common::optional<types::ModellingKind>& mutable_kind() override {
    return instance_->mutable_kind();
  }

  void set_kind(
    common::optional<types::ModellingKind> value
  ) override {
    instance_->set_kind(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& submodel_elements() const override {
    return instance_->submodel_elements();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& mutable_submodel_elements() override {
    return instance_->mutable_submodel_elements();
  }

  void set_submodel_elements(
    common::optional<
      std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >
    > value
  ) override {
    instance_->set_submodel_elements(value);
  }

  types::ModellingKind KindOrDefault() const override {
    return instance_->KindOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedSubmodel(
    std::shared_ptr<types::ISubmodel> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedSubmodel() = default;

 private:
  std::shared_ptr<types::ISubmodel> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedRelationshipElement
    : virtual public types::IRelationshipElement,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kRelationshipElement;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const std::shared_ptr<types::IReference>& first() const override {
    return instance_->first();
  }

  std::shared_ptr<types::IReference>& mutable_first() override {
    return instance_->mutable_first();
  }

  void set_first(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_first(value);
  }

  const std::shared_ptr<types::IReference>& second() const override {
    return instance_->second();
  }

  std::shared_ptr<types::IReference>& mutable_second() override {
    return instance_->mutable_second();
  }

  void set_second(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_second(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedRelationshipElement(
    std::shared_ptr<types::IRelationshipElement> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedRelationshipElement() = default;

 private:
  std::shared_ptr<types::IRelationshipElement> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedSubmodelElementList
    : virtual public types::ISubmodelElementList,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kSubmodelElementList;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<bool>& order_relevant() const override {
    return instance_->order_relevant();
  }

  common::optional<bool>& mutable_order_relevant() override {
    return instance_->mutable_order_relevant();
  }

  void set_order_relevant(
    common::optional<bool> value
  ) override {
    instance_->set_order_relevant(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id_list_element() const override {
    return instance_->semantic_id_list_element();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id_list_element() override {
    return instance_->mutable_semantic_id_list_element();
  }

  void set_semantic_id_list_element(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id_list_element(value);
  }

  types::AasSubmodelElements type_value_list_element() const override {
    return instance_->type_value_list_element();
  }

  types::AasSubmodelElements& mutable_type_value_list_element() override {
    return instance_->mutable_type_value_list_element();
  }

  void set_type_value_list_element(
    types::AasSubmodelElements value
  ) override {
    instance_->set_type_value_list_element(value);
  }

  const common::optional<types::DataTypeDefXsd>& value_type_list_element() const override {
    return instance_->value_type_list_element();
  }

  common::optional<types::DataTypeDefXsd>& mutable_value_type_list_element() override {
    return instance_->mutable_value_type_list_element();
  }

  void set_value_type_list_element(
    common::optional<types::DataTypeDefXsd> value
  ) override {
    instance_->set_value_type_list_element(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& value() const override {
    return instance_->value();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >
    > value
  ) override {
    instance_->set_value(value);
  }

  bool OrderRelevantOrDefault() const override {
    return instance_->OrderRelevantOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedSubmodelElementList(
    std::shared_ptr<types::ISubmodelElementList> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedSubmodelElementList() = default;

 private:
  std::shared_ptr<types::ISubmodelElementList> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedSubmodelElementCollection
    : virtual public types::ISubmodelElementCollection,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kSubmodelElementCollection;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& value() const override {
    return instance_->value();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >
    > value
  ) override {
    instance_->set_value(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedSubmodelElementCollection(
    std::shared_ptr<types::ISubmodelElementCollection> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedSubmodelElementCollection() = default;

 private:
  std::shared_ptr<types::ISubmodelElementCollection> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedProperty
    : virtual public types::IProperty,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kProperty;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  types::DataTypeDefXsd value_type() const override {
    return instance_->value_type();
  }

  types::DataTypeDefXsd& mutable_value_type() override {
    return instance_->mutable_value_type();
  }

  void set_value_type(
    types::DataTypeDefXsd value
  ) override {
    instance_->set_value_type(value);
  }

  const common::optional<std::wstring>& value() const override {
    return instance_->value();
  }

  common::optional<std::wstring>& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<std::wstring> value
  ) override {
    instance_->set_value(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& value_id() const override {
    return instance_->value_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_value_id() override {
    return instance_->mutable_value_id();
  }

  void set_value_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_value_id(value);
  }

  std::wstring CategoryOrDefault() const override {
    return instance_->CategoryOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedProperty(
    std::shared_ptr<types::IProperty> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedProperty() = default;

 private:
  std::shared_ptr<types::IProperty> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedMultiLanguageProperty
    : virtual public types::IMultiLanguageProperty,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kMultiLanguageProperty;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& value() const override {
    return instance_->value();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_value(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& value_id() const override {
    return instance_->value_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_value_id() override {
    return instance_->mutable_value_id();
  }

  void set_value_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_value_id(value);
  }

  std::wstring CategoryOrDefault() const override {
    return instance_->CategoryOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedMultiLanguageProperty(
    std::shared_ptr<types::IMultiLanguageProperty> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedMultiLanguageProperty() = default;

 private:
  std::shared_ptr<types::IMultiLanguageProperty> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedRange
    : virtual public types::IRange,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kRange;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  types::DataTypeDefXsd value_type() const override {
    return instance_->value_type();
  }

  types::DataTypeDefXsd& mutable_value_type() override {
    return instance_->mutable_value_type();
  }

  void set_value_type(
    types::DataTypeDefXsd value
  ) override {
    instance_->set_value_type(value);
  }

  const common::optional<std::wstring>& min() const override {
    return instance_->min();
  }

  common::optional<std::wstring>& mutable_min() override {
    return instance_->mutable_min();
  }

  void set_min(
    common::optional<std::wstring> value
  ) override {
    instance_->set_min(value);
  }

  const common::optional<std::wstring>& max() const override {
    return instance_->max();
  }

  common::optional<std::wstring>& mutable_max() override {
    return instance_->mutable_max();
  }

  void set_max(
    common::optional<std::wstring> value
  ) override {
    instance_->set_max(value);
  }

  std::wstring CategoryOrDefault() const override {
    return instance_->CategoryOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedRange(
    std::shared_ptr<types::IRange> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedRange() = default;

 private:
  std::shared_ptr<types::IRange> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedReferenceElement
    : virtual public types::IReferenceElement,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kReferenceElement;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& value() const override {
    return instance_->value();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_value(value);
  }

  std::wstring CategoryOrDefault() const override {
    return instance_->CategoryOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedReferenceElement(
    std::shared_ptr<types::IReferenceElement> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedReferenceElement() = default;

 private:
  std::shared_ptr<types::IReferenceElement> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedBlob
    : virtual public types::IBlob,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kBlob;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::vector<std::uint8_t>
  >& value() const override {
    return instance_->value();
  }

  common::optional<
    std::vector<std::uint8_t>
  >& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<
      std::vector<std::uint8_t>
    > value
  ) override {
    instance_->set_value(value);
  }

  const std::wstring& content_type() const override {
    return instance_->content_type();
  }

  std::wstring& mutable_content_type() override {
    return instance_->mutable_content_type();
  }

  void set_content_type(
    std::wstring value
  ) override {
    instance_->set_content_type(value);
  }

  std::wstring CategoryOrDefault() const override {
    return instance_->CategoryOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedBlob(
    std::shared_ptr<types::IBlob> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedBlob() = default;

 private:
  std::shared_ptr<types::IBlob> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedFile
    : virtual public types::IFile,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kFile;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<std::wstring>& value() const override {
    return instance_->value();
  }

  common::optional<std::wstring>& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<std::wstring> value
  ) override {
    instance_->set_value(value);
  }

  const std::wstring& content_type() const override {
    return instance_->content_type();
  }

  std::wstring& mutable_content_type() override {
    return instance_->mutable_content_type();
  }

  void set_content_type(
    std::wstring value
  ) override {
    instance_->set_content_type(value);
  }

  std::wstring CategoryOrDefault() const override {
    return instance_->CategoryOrDefault();
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedFile(
    std::shared_ptr<types::IFile> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedFile() = default;

 private:
  std::shared_ptr<types::IFile> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedAnnotatedRelationshipElement
    : virtual public types::IAnnotatedRelationshipElement,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kAnnotatedRelationshipElement;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const std::shared_ptr<types::IReference>& first() const override {
    return instance_->first();
  }

  std::shared_ptr<types::IReference>& mutable_first() override {
    return instance_->mutable_first();
  }

  void set_first(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_first(value);
  }

  const std::shared_ptr<types::IReference>& second() const override {
    return instance_->second();
  }

  std::shared_ptr<types::IReference>& mutable_second() override {
    return instance_->mutable_second();
  }

  void set_second(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_second(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IDataElement>
    >
  >& annotations() const override {
    return instance_->annotations();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IDataElement>
    >
  >& mutable_annotations() override {
    return instance_->mutable_annotations();
  }

  void set_annotations(
    common::optional<
      std::vector<
        std::shared_ptr<types::IDataElement>
      >
    > value
  ) override {
    instance_->set_annotations(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedAnnotatedRelationshipElement(
    std::shared_ptr<types::IAnnotatedRelationshipElement> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedAnnotatedRelationshipElement() = default;

 private:
  std::shared_ptr<types::IAnnotatedRelationshipElement> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedEntity
    : virtual public types::IEntity,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kEntity;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& statements() const override {
    return instance_->statements();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    >
  >& mutable_statements() override {
    return instance_->mutable_statements();
  }

  void set_statements(
    common::optional<
      std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >
    > value
  ) override {
    instance_->set_statements(value);
  }

  types::EntityType entity_type() const override {
    return instance_->entity_type();
  }

  types::EntityType& mutable_entity_type() override {
    return instance_->mutable_entity_type();
  }

  void set_entity_type(
    types::EntityType value
  ) override {
    instance_->set_entity_type(value);
  }

  const common::optional<std::wstring>& global_asset_id() const override {
    return instance_->global_asset_id();
  }

  common::optional<std::wstring>& mutable_global_asset_id() override {
    return instance_->mutable_global_asset_id();
  }

  void set_global_asset_id(
    common::optional<std::wstring> value
  ) override {
    instance_->set_global_asset_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  >& specific_asset_ids() const override {
    return instance_->specific_asset_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    >
  >& mutable_specific_asset_ids() override {
    return instance_->mutable_specific_asset_ids();
  }

  void set_specific_asset_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::ISpecificAssetId>
      >
    > value
  ) override {
    instance_->set_specific_asset_ids(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedEntity(
    std::shared_ptr<types::IEntity> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedEntity() = default;

 private:
  std::shared_ptr<types::IEntity> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedEventPayload
    : virtual public types::IEventPayload,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kEventPayload;
  }

  const std::shared_ptr<types::IReference>& source() const override {
    return instance_->source();
  }

  std::shared_ptr<types::IReference>& mutable_source() override {
    return instance_->mutable_source();
  }

  void set_source(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_source(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& source_semantic_id() const override {
    return instance_->source_semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_source_semantic_id() override {
    return instance_->mutable_source_semantic_id();
  }

  void set_source_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_source_semantic_id(value);
  }

  const std::shared_ptr<types::IReference>& observable_reference() const override {
    return instance_->observable_reference();
  }

  std::shared_ptr<types::IReference>& mutable_observable_reference() override {
    return instance_->mutable_observable_reference();
  }

  void set_observable_reference(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_observable_reference(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& observable_semantic_id() const override {
    return instance_->observable_semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_observable_semantic_id() override {
    return instance_->mutable_observable_semantic_id();
  }

  void set_observable_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_observable_semantic_id(value);
  }

  const common::optional<std::wstring>& topic() const override {
    return instance_->topic();
  }

  common::optional<std::wstring>& mutable_topic() override {
    return instance_->mutable_topic();
  }

  void set_topic(
    common::optional<std::wstring> value
  ) override {
    instance_->set_topic(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& subject_id() const override {
    return instance_->subject_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_subject_id() override {
    return instance_->mutable_subject_id();
  }

  void set_subject_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_subject_id(value);
  }

  const std::wstring& time_stamp() const override {
    return instance_->time_stamp();
  }

  std::wstring& mutable_time_stamp() override {
    return instance_->mutable_time_stamp();
  }

  void set_time_stamp(
    std::wstring value
  ) override {
    instance_->set_time_stamp(value);
  }

  const common::optional<
    std::vector<std::uint8_t>
  >& payload() const override {
    return instance_->payload();
  }

  common::optional<
    std::vector<std::uint8_t>
  >& mutable_payload() override {
    return instance_->mutable_payload();
  }

  void set_payload(
    common::optional<
      std::vector<std::uint8_t>
    > value
  ) override {
    instance_->set_payload(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedEventPayload(
    std::shared_ptr<types::IEventPayload> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedEventPayload() = default;

 private:
  std::shared_ptr<types::IEventPayload> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedBasicEventElement
    : virtual public types::IBasicEventElement,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kBasicEventElement;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const std::shared_ptr<types::IReference>& observed() const override {
    return instance_->observed();
  }

  std::shared_ptr<types::IReference>& mutable_observed() override {
    return instance_->mutable_observed();
  }

  void set_observed(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_observed(value);
  }

  types::Direction direction() const override {
    return instance_->direction();
  }

  types::Direction& mutable_direction() override {
    return instance_->mutable_direction();
  }

  void set_direction(
    types::Direction value
  ) override {
    instance_->set_direction(value);
  }

  types::StateOfEvent state() const override {
    return instance_->state();
  }

  types::StateOfEvent& mutable_state() override {
    return instance_->mutable_state();
  }

  void set_state(
    types::StateOfEvent value
  ) override {
    instance_->set_state(value);
  }

  const common::optional<std::wstring>& message_topic() const override {
    return instance_->message_topic();
  }

  common::optional<std::wstring>& mutable_message_topic() override {
    return instance_->mutable_message_topic();
  }

  void set_message_topic(
    common::optional<std::wstring> value
  ) override {
    instance_->set_message_topic(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& message_broker() const override {
    return instance_->message_broker();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_message_broker() override {
    return instance_->mutable_message_broker();
  }

  void set_message_broker(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_message_broker(value);
  }

  const common::optional<std::wstring>& last_update() const override {
    return instance_->last_update();
  }

  common::optional<std::wstring>& mutable_last_update() override {
    return instance_->mutable_last_update();
  }

  void set_last_update(
    common::optional<std::wstring> value
  ) override {
    instance_->set_last_update(value);
  }

  const common::optional<std::wstring>& min_interval() const override {
    return instance_->min_interval();
  }

  common::optional<std::wstring>& mutable_min_interval() override {
    return instance_->mutable_min_interval();
  }

  void set_min_interval(
    common::optional<std::wstring> value
  ) override {
    instance_->set_min_interval(value);
  }

  const common::optional<std::wstring>& max_interval() const override {
    return instance_->max_interval();
  }

  common::optional<std::wstring>& mutable_max_interval() override {
    return instance_->mutable_max_interval();
  }

  void set_max_interval(
    common::optional<std::wstring> value
  ) override {
    instance_->set_max_interval(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedBasicEventElement(
    std::shared_ptr<types::IBasicEventElement> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedBasicEventElement() = default;

 private:
  std::shared_ptr<types::IBasicEventElement> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedOperation
    : virtual public types::IOperation,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kOperation;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& input_variables() const override {
    return instance_->input_variables();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& mutable_input_variables() override {
    return instance_->mutable_input_variables();
  }

  void set_input_variables(
    common::optional<
      std::vector<
        std::shared_ptr<types::IOperationVariable>
      >
    > value
  ) override {
    instance_->set_input_variables(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& output_variables() const override {
    return instance_->output_variables();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& mutable_output_variables() override {
    return instance_->mutable_output_variables();
  }

  void set_output_variables(
    common::optional<
      std::vector<
        std::shared_ptr<types::IOperationVariable>
      >
    > value
  ) override {
    instance_->set_output_variables(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& inoutput_variables() const override {
    return instance_->inoutput_variables();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& mutable_inoutput_variables() override {
    return instance_->mutable_inoutput_variables();
  }

  void set_inoutput_variables(
    common::optional<
      std::vector<
        std::shared_ptr<types::IOperationVariable>
      >
    > value
  ) override {
    instance_->set_inoutput_variables(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedOperation(
    std::shared_ptr<types::IOperation> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedOperation() = default;

 private:
  std::shared_ptr<types::IOperation> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedOperationVariable
    : virtual public types::IOperationVariable,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kOperationVariable;
  }

  const std::shared_ptr<types::ISubmodelElement>& value() const override {
    return instance_->value();
  }

  std::shared_ptr<types::ISubmodelElement>& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    std::shared_ptr<types::ISubmodelElement> value
  ) override {
    instance_->set_value(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedOperationVariable(
    std::shared_ptr<types::IOperationVariable> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedOperationVariable() = default;

 private:
  std::shared_ptr<types::IOperationVariable> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedCapability
    : virtual public types::ICapability,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kCapability;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& semantic_id() const override {
    return instance_->semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_semantic_id() override {
    return instance_->mutable_semantic_id();
  }

  void set_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_semantic_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& supplemental_semantic_ids() const override {
    return instance_->supplemental_semantic_ids();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_supplemental_semantic_ids() override {
    return instance_->mutable_supplemental_semantic_ids();
  }

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_supplemental_semantic_ids(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& qualifiers() const override {
    return instance_->qualifiers();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IQualifier>
    >
  >& mutable_qualifiers() override {
    return instance_->mutable_qualifiers();
  }

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<types::IQualifier>
      >
    > value
  ) override {
    instance_->set_qualifiers(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedCapability(
    std::shared_ptr<types::ICapability> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedCapability() = default;

 private:
  std::shared_ptr<types::ICapability> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedConceptDescription
    : virtual public types::IConceptDescription,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kConceptDescription;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& extensions() const override {
    return instance_->extensions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IExtension>
    >
  >& mutable_extensions() override {
    return instance_->mutable_extensions();
  }

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IExtension>
      >
    > value
  ) override {
    instance_->set_extensions(value);
  }

  const common::optional<std::wstring>& category() const override {
    return instance_->category();
  }

  common::optional<std::wstring>& mutable_category() override {
    return instance_->mutable_category();
  }

  void set_category(
    common::optional<std::wstring> value
  ) override {
    instance_->set_category(value);
  }

  const common::optional<std::wstring>& id_short() const override {
    return instance_->id_short();
  }

  common::optional<std::wstring>& mutable_id_short() override {
    return instance_->mutable_id_short();
  }

  void set_id_short(
    common::optional<std::wstring> value
  ) override {
    instance_->set_id_short(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& display_name() const override {
    return instance_->display_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    >
  >& mutable_display_name() override {
    return instance_->mutable_display_name();
  }

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >
    > value
  ) override {
    instance_->set_display_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& description() const override {
    return instance_->description();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    >
  >& mutable_description() override {
    return instance_->mutable_description();
  }

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >
    > value
  ) override {
    instance_->set_description(value);
  }

  const common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& administration() const override {
    return instance_->administration();
  }

  common::optional<
    std::shared_ptr<types::IAdministrativeInformation>
  >& mutable_administration() override {
    return instance_->mutable_administration();
  }

  void set_administration(
    common::optional<
      std::shared_ptr<types::IAdministrativeInformation>
    > value
  ) override {
    instance_->set_administration(value);
  }

  const std::wstring& id() const override {
    return instance_->id();
  }

  std::wstring& mutable_id() override {
    return instance_->mutable_id();
  }

  void set_id(
    std::wstring value
  ) override {
    instance_->set_id(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override {
    return instance_->embedded_data_specifications();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override {
    return instance_->mutable_embedded_data_specifications();
  }

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >
    > value
  ) override {
    instance_->set_embedded_data_specifications(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& is_case_of() const override {
    return instance_->is_case_of();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IReference>
    >
  >& mutable_is_case_of() override {
    return instance_->mutable_is_case_of();
  }

  void set_is_case_of(
    common::optional<
      std::vector<
        std::shared_ptr<types::IReference>
      >
    > value
  ) override {
    instance_->set_is_case_of(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedConceptDescription(
    std::shared_ptr<types::IConceptDescription> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedConceptDescription() = default;

 private:
  std::shared_ptr<types::IConceptDescription> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedReference
    : virtual public types::IReference,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kReference;
  }

  types::ReferenceTypes type() const override {
    return instance_->type();
  }

  types::ReferenceTypes& mutable_type() override {
    return instance_->mutable_type();
  }

  void set_type(
    types::ReferenceTypes value
  ) override {
    instance_->set_type(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& referred_semantic_id() const override {
    return instance_->referred_semantic_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_referred_semantic_id() override {
    return instance_->mutable_referred_semantic_id();
  }

  void set_referred_semantic_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_referred_semantic_id(value);
  }

  const std::vector<
    std::shared_ptr<types::IKey>
  >& keys() const override {
    return instance_->keys();
  }

  std::vector<
    std::shared_ptr<types::IKey>
  >& mutable_keys() override {
    return instance_->mutable_keys();
  }

  void set_keys(
    std::vector<
      std::shared_ptr<types::IKey>
    > value
  ) override {
    instance_->set_keys(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedReference(
    std::shared_ptr<types::IReference> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedReference() = default;

 private:
  std::shared_ptr<types::IReference> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedKey
    : virtual public types::IKey,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kKey;
  }

  types::KeyTypes type() const override {
    return instance_->type();
  }

  types::KeyTypes& mutable_type() override {
    return instance_->mutable_type();
  }

  void set_type(
    types::KeyTypes value
  ) override {
    instance_->set_type(value);
  }

  const std::wstring& value() const override {
    return instance_->value();
  }

  std::wstring& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    std::wstring value
  ) override {
    instance_->set_value(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedKey(
    std::shared_ptr<types::IKey> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedKey() = default;

 private:
  std::shared_ptr<types::IKey> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedLangStringNameType
    : virtual public types::ILangStringNameType,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kLangStringNameType;
  }

  const std::wstring& language() const override {
    return instance_->language();
  }

  std::wstring& mutable_language() override {
    return instance_->mutable_language();
  }

  void set_language(
    std::wstring value
  ) override {
    instance_->set_language(value);
  }

  const std::wstring& text() const override {
    return instance_->text();
  }

  std::wstring& mutable_text() override {
    return instance_->mutable_text();
  }

  void set_text(
    std::wstring value
  ) override {
    instance_->set_text(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedLangStringNameType(
    std::shared_ptr<types::ILangStringNameType> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedLangStringNameType() = default;

 private:
  std::shared_ptr<types::ILangStringNameType> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedLangStringTextType
    : virtual public types::ILangStringTextType,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kLangStringTextType;
  }

  const std::wstring& language() const override {
    return instance_->language();
  }

  std::wstring& mutable_language() override {
    return instance_->mutable_language();
  }

  void set_language(
    std::wstring value
  ) override {
    instance_->set_language(value);
  }

  const std::wstring& text() const override {
    return instance_->text();
  }

  std::wstring& mutable_text() override {
    return instance_->mutable_text();
  }

  void set_text(
    std::wstring value
  ) override {
    instance_->set_text(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedLangStringTextType(
    std::shared_ptr<types::ILangStringTextType> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedLangStringTextType() = default;

 private:
  std::shared_ptr<types::ILangStringTextType> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedEnvironment
    : virtual public types::IEnvironment,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kEnvironment;
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IAssetAdministrationShell>
    >
  >& asset_administration_shells() const override {
    return instance_->asset_administration_shells();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IAssetAdministrationShell>
    >
  >& mutable_asset_administration_shells() override {
    return instance_->mutable_asset_administration_shells();
  }

  void set_asset_administration_shells(
    common::optional<
      std::vector<
        std::shared_ptr<types::IAssetAdministrationShell>
      >
    > value
  ) override {
    instance_->set_asset_administration_shells(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodel>
    >
  >& submodels() const override {
    return instance_->submodels();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ISubmodel>
    >
  >& mutable_submodels() override {
    return instance_->mutable_submodels();
  }

  void set_submodels(
    common::optional<
      std::vector<
        std::shared_ptr<types::ISubmodel>
      >
    > value
  ) override {
    instance_->set_submodels(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::IConceptDescription>
    >
  >& concept_descriptions() const override {
    return instance_->concept_descriptions();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::IConceptDescription>
    >
  >& mutable_concept_descriptions() override {
    return instance_->mutable_concept_descriptions();
  }

  void set_concept_descriptions(
    common::optional<
      std::vector<
        std::shared_ptr<types::IConceptDescription>
      >
    > value
  ) override {
    instance_->set_concept_descriptions(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedEnvironment(
    std::shared_ptr<types::IEnvironment> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedEnvironment() = default;

 private:
  std::shared_ptr<types::IEnvironment> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedEmbeddedDataSpecification
    : virtual public types::IEmbeddedDataSpecification,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kEmbeddedDataSpecification;
  }

  const std::shared_ptr<types::IReference>& data_specification() const override {
    return instance_->data_specification();
  }

  std::shared_ptr<types::IReference>& mutable_data_specification() override {
    return instance_->mutable_data_specification();
  }

  void set_data_specification(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_data_specification(value);
  }

  const std::shared_ptr<types::IDataSpecificationContent>& data_specification_content() const override {
    return instance_->data_specification_content();
  }

  std::shared_ptr<types::IDataSpecificationContent>& mutable_data_specification_content() override {
    return instance_->mutable_data_specification_content();
  }

  void set_data_specification_content(
    std::shared_ptr<types::IDataSpecificationContent> value
  ) override {
    instance_->set_data_specification_content(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedEmbeddedDataSpecification(
    std::shared_ptr<types::IEmbeddedDataSpecification> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedEmbeddedDataSpecification() = default;

 private:
  std::shared_ptr<types::IEmbeddedDataSpecification> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedLevelType
    : virtual public types::ILevelType,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kLevelType;
  }

  bool min() const override {
    return instance_->min();
  }

  bool& mutable_min() override {
    return instance_->mutable_min();
  }

  void set_min(
    bool value
  ) override {
    instance_->set_min(value);
  }

  bool nom() const override {
    return instance_->nom();
  }

  bool& mutable_nom() override {
    return instance_->mutable_nom();
  }

  void set_nom(
    bool value
  ) override {
    instance_->set_nom(value);
  }

  bool typ() const override {
    return instance_->typ();
  }

  bool& mutable_typ() override {
    return instance_->mutable_typ();
  }

  void set_typ(
    bool value
  ) override {
    instance_->set_typ(value);
  }

  bool max() const override {
    return instance_->max();
  }

  bool& mutable_max() override {
    return instance_->mutable_max();
  }

  void set_max(
    bool value
  ) override {
    instance_->set_max(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedLevelType(
    std::shared_ptr<types::ILevelType> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedLevelType() = default;

 private:
  std::shared_ptr<types::ILevelType> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedValueReferencePair
    : virtual public types::IValueReferencePair,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kValueReferencePair;
  }

  const std::wstring& value() const override {
    return instance_->value();
  }

  std::wstring& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    std::wstring value
  ) override {
    instance_->set_value(value);
  }

  const std::shared_ptr<types::IReference>& value_id() const override {
    return instance_->value_id();
  }

  std::shared_ptr<types::IReference>& mutable_value_id() override {
    return instance_->mutable_value_id();
  }

  void set_value_id(
    std::shared_ptr<types::IReference> value
  ) override {
    instance_->set_value_id(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedValueReferencePair(
    std::shared_ptr<types::IValueReferencePair> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedValueReferencePair() = default;

 private:
  std::shared_ptr<types::IValueReferencePair> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedValueList
    : virtual public types::IValueList,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kValueList;
  }

  const std::vector<
    std::shared_ptr<types::IValueReferencePair>
  >& value_reference_pairs() const override {
    return instance_->value_reference_pairs();
  }

  std::vector<
    std::shared_ptr<types::IValueReferencePair>
  >& mutable_value_reference_pairs() override {
    return instance_->mutable_value_reference_pairs();
  }

  void set_value_reference_pairs(
    std::vector<
      std::shared_ptr<types::IValueReferencePair>
    > value
  ) override {
    instance_->set_value_reference_pairs(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedValueList(
    std::shared_ptr<types::IValueList> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedValueList() = default;

 private:
  std::shared_ptr<types::IValueList> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedLangStringPreferredNameTypeIec61360
    : virtual public types::ILangStringPreferredNameTypeIec61360,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kLangStringPreferredNameTypeIec61360;
  }

  const std::wstring& language() const override {
    return instance_->language();
  }

  std::wstring& mutable_language() override {
    return instance_->mutable_language();
  }

  void set_language(
    std::wstring value
  ) override {
    instance_->set_language(value);
  }

  const std::wstring& text() const override {
    return instance_->text();
  }

  std::wstring& mutable_text() override {
    return instance_->mutable_text();
  }

  void set_text(
    std::wstring value
  ) override {
    instance_->set_text(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedLangStringPreferredNameTypeIec61360(
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedLangStringPreferredNameTypeIec61360() = default;

 private:
  std::shared_ptr<types::ILangStringPreferredNameTypeIec61360> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedLangStringShortNameTypeIec61360
    : virtual public types::ILangStringShortNameTypeIec61360,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kLangStringShortNameTypeIec61360;
  }

  const std::wstring& language() const override {
    return instance_->language();
  }

  std::wstring& mutable_language() override {
    return instance_->mutable_language();
  }

  void set_language(
    std::wstring value
  ) override {
    instance_->set_language(value);
  }

  const std::wstring& text() const override {
    return instance_->text();
  }

  std::wstring& mutable_text() override {
    return instance_->mutable_text();
  }

  void set_text(
    std::wstring value
  ) override {
    instance_->set_text(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedLangStringShortNameTypeIec61360(
    std::shared_ptr<types::ILangStringShortNameTypeIec61360> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedLangStringShortNameTypeIec61360() = default;

 private:
  std::shared_ptr<types::ILangStringShortNameTypeIec61360> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedLangStringDefinitionTypeIec61360
    : virtual public types::ILangStringDefinitionTypeIec61360,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kLangStringDefinitionTypeIec61360;
  }

  const std::wstring& language() const override {
    return instance_->language();
  }

  std::wstring& mutable_language() override {
    return instance_->mutable_language();
  }

  void set_language(
    std::wstring value
  ) override {
    instance_->set_language(value);
  }

  const std::wstring& text() const override {
    return instance_->text();
  }

  std::wstring& mutable_text() override {
    return instance_->mutable_text();
  }

  void set_text(
    std::wstring value
  ) override {
    instance_->set_text(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedLangStringDefinitionTypeIec61360(
    std::shared_ptr<types::ILangStringDefinitionTypeIec61360> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedLangStringDefinitionTypeIec61360() = default;

 private:
  std::shared_ptr<types::ILangStringDefinitionTypeIec61360> instance_;
  std::shared_ptr<E> enhancement_;
};

template<class E>
class EnhancedDataSpecificationIec61360
    : virtual public types::IDataSpecificationIec61360,
    virtual public IEnhanced<E> {
 public:
  types::ModelType model_type() const override {
    return types::ModelType::kDataSpecificationIec61360;
  }

  const std::vector<
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
  >& preferred_name() const override {
    return instance_->preferred_name();
  }

  std::vector<
    std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
  >& mutable_preferred_name() override {
    return instance_->mutable_preferred_name();
  }

  void set_preferred_name(
    std::vector<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    > value
  ) override {
    instance_->set_preferred_name(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >
  >& short_name() const override {
    return instance_->short_name();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    >
  >& mutable_short_name() override {
    return instance_->mutable_short_name();
  }

  void set_short_name(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringShortNameTypeIec61360>
      >
    > value
  ) override {
    instance_->set_short_name(value);
  }

  const common::optional<std::wstring>& unit() const override {
    return instance_->unit();
  }

  common::optional<std::wstring>& mutable_unit() override {
    return instance_->mutable_unit();
  }

  void set_unit(
    common::optional<std::wstring> value
  ) override {
    instance_->set_unit(value);
  }

  const common::optional<
    std::shared_ptr<types::IReference>
  >& unit_id() const override {
    return instance_->unit_id();
  }

  common::optional<
    std::shared_ptr<types::IReference>
  >& mutable_unit_id() override {
    return instance_->mutable_unit_id();
  }

  void set_unit_id(
    common::optional<
      std::shared_ptr<types::IReference>
    > value
  ) override {
    instance_->set_unit_id(value);
  }

  const common::optional<std::wstring>& source_of_definition() const override {
    return instance_->source_of_definition();
  }

  common::optional<std::wstring>& mutable_source_of_definition() override {
    return instance_->mutable_source_of_definition();
  }

  void set_source_of_definition(
    common::optional<std::wstring> value
  ) override {
    instance_->set_source_of_definition(value);
  }

  const common::optional<std::wstring>& symbol() const override {
    return instance_->symbol();
  }

  common::optional<std::wstring>& mutable_symbol() override {
    return instance_->mutable_symbol();
  }

  void set_symbol(
    common::optional<std::wstring> value
  ) override {
    instance_->set_symbol(value);
  }

  const common::optional<types::DataTypeIec61360>& data_type() const override {
    return instance_->data_type();
  }

  common::optional<types::DataTypeIec61360>& mutable_data_type() override {
    return instance_->mutable_data_type();
  }

  void set_data_type(
    common::optional<types::DataTypeIec61360> value
  ) override {
    instance_->set_data_type(value);
  }

  const common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >
  >& definition() const override {
    return instance_->definition();
  }

  common::optional<
    std::vector<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    >
  >& mutable_definition() override {
    return instance_->mutable_definition();
  }

  void set_definition(
    common::optional<
      std::vector<
        std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
      >
    > value
  ) override {
    instance_->set_definition(value);
  }

  const common::optional<std::wstring>& value_format() const override {
    return instance_->value_format();
  }

  common::optional<std::wstring>& mutable_value_format() override {
    return instance_->mutable_value_format();
  }

  void set_value_format(
    common::optional<std::wstring> value
  ) override {
    instance_->set_value_format(value);
  }

  const common::optional<
    std::shared_ptr<types::IValueList>
  >& value_list() const override {
    return instance_->value_list();
  }

  common::optional<
    std::shared_ptr<types::IValueList>
  >& mutable_value_list() override {
    return instance_->mutable_value_list();
  }

  void set_value_list(
    common::optional<
      std::shared_ptr<types::IValueList>
    > value
  ) override {
    instance_->set_value_list(value);
  }

  const common::optional<std::wstring>& value() const override {
    return instance_->value();
  }

  common::optional<std::wstring>& mutable_value() override {
    return instance_->mutable_value();
  }

  void set_value(
    common::optional<std::wstring> value
  ) override {
    instance_->set_value(value);
  }

  const common::optional<
    std::shared_ptr<types::ILevelType>
  >& level_type() const override {
    return instance_->level_type();
  }

  common::optional<
    std::shared_ptr<types::ILevelType>
  >& mutable_level_type() override {
    return instance_->mutable_level_type();
  }

  void set_level_type(
    common::optional<
      std::shared_ptr<types::ILevelType>
    > value
  ) override {
    instance_->set_level_type(value);
  }

  const std::shared_ptr<E>& enhancement() const {
    return enhancement_;
  }

  std::shared_ptr<E>& mutable_enhancement() {
    return enhancement_;
  }

  void set_enhancement(
    std::shared_ptr<E> value
  ) {
    enhancement_ = std::move(value);
  }

  EnhancedDataSpecificationIec61360(
    std::shared_ptr<types::IDataSpecificationIec61360> instance,
    std::shared_ptr<E> enhancement
  ) :
    instance_(instance),
    enhancement_(enhancement) {
    // Intentionally empty.
  }

  virtual ~EnhancedDataSpecificationIec61360() = default;

 private:
  std::shared_ptr<types::IDataSpecificationIec61360> instance_;
  std::shared_ptr<E> enhancement_;
};

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IExtension> WrapExtension(
  const std::shared_ptr<types::IExtension>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->refers_to().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->refers_to().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_refers_to(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IExtension>(
      new EnhancedExtension<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IAdministrativeInformation> WrapAdministrativeInformation(
  const std::shared_ptr<types::IAdministrativeInformation>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->creator().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->creator().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_creator(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IAdministrativeInformation>(
      new EnhancedAdministrativeInformation<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IQualifier> WrapQualifier(
  const std::shared_ptr<types::IQualifier>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->value_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->value_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_value_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IQualifier>(
      new EnhancedQualifier<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IAssetAdministrationShell> WrapAssetAdministrationShell(
  const std::shared_ptr<types::IAssetAdministrationShell>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->administration().has_value()) {
    const std::shared_ptr<types::IAdministrativeInformation>& value(
      that->administration().value()
    );

    std::shared_ptr<
      types::IAdministrativeInformation
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_administration(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->derived_from().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->derived_from().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_derived_from(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  that->set_asset_information(
    Wrap<E>(
      that->asset_information(),
      factory
    )
  );

  if (that->submodels().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->submodels().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_submodels(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IAssetAdministrationShell>(
      new EnhancedAssetAdministrationShell<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IAssetInformation> WrapAssetInformation(
  const std::shared_ptr<types::IAssetInformation>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->specific_asset_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::ISpecificAssetId>
      >& value(
      that->specific_asset_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ISpecificAssetId>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_specific_asset_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->default_thumbnail().has_value()) {
    const std::shared_ptr<types::IResource>& value(
      that->default_thumbnail().value()
    );

    std::shared_ptr<
      types::IResource
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_default_thumbnail(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IAssetInformation>(
      new EnhancedAssetInformation<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IResource> WrapResource(
  const std::shared_ptr<types::IResource>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IResource>(
      new EnhancedResource<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ISpecificAssetId> WrapSpecificAssetId(
  const std::shared_ptr<types::ISpecificAssetId>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->external_subject_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->external_subject_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_external_subject_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ISpecificAssetId>(
      new EnhancedSpecificAssetId<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ISubmodel> WrapSubmodel(
  const std::shared_ptr<types::ISubmodel>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->administration().has_value()) {
    const std::shared_ptr<types::IAdministrativeInformation>& value(
      that->administration().value()
    );

    std::shared_ptr<
      types::IAdministrativeInformation
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_administration(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->submodel_elements().has_value()) {
    const std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >& value(
      that->submodel_elements().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ISubmodelElement>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_submodel_elements(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ISubmodel>(
      new EnhancedSubmodel<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IRelationshipElement> WrapRelationshipElement(
  const std::shared_ptr<types::IRelationshipElement>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  that->set_first(
    Wrap<E>(
      that->first(),
      factory
    )
  );

  that->set_second(
    Wrap<E>(
      that->second(),
      factory
    )
  );

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IRelationshipElement>(
      new EnhancedRelationshipElement<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ISubmodelElementList> WrapSubmodelElementList(
  const std::shared_ptr<types::ISubmodelElementList>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id_list_element().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id_list_element().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id_list_element(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->value().has_value()) {
    const std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >& value(
      that->value().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ISubmodelElement>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_value(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ISubmodelElementList>(
      new EnhancedSubmodelElementList<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ISubmodelElementCollection> WrapSubmodelElementCollection(
  const std::shared_ptr<types::ISubmodelElementCollection>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->value().has_value()) {
    const std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >& value(
      that->value().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ISubmodelElement>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_value(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ISubmodelElementCollection>(
      new EnhancedSubmodelElementCollection<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IProperty> WrapProperty(
  const std::shared_ptr<types::IProperty>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->value_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->value_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_value_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IProperty>(
      new EnhancedProperty<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IMultiLanguageProperty> WrapMultiLanguageProperty(
  const std::shared_ptr<types::IMultiLanguageProperty>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->value().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->value().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_value(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->value_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->value_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_value_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IMultiLanguageProperty>(
      new EnhancedMultiLanguageProperty<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IRange> WrapRange(
  const std::shared_ptr<types::IRange>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IRange>(
      new EnhancedRange<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IReferenceElement> WrapReferenceElement(
  const std::shared_ptr<types::IReferenceElement>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->value().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->value().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_value(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IReferenceElement>(
      new EnhancedReferenceElement<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IBlob> WrapBlob(
  const std::shared_ptr<types::IBlob>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IBlob>(
      new EnhancedBlob<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IFile> WrapFile(
  const std::shared_ptr<types::IFile>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IFile>(
      new EnhancedFile<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IAnnotatedRelationshipElement> WrapAnnotatedRelationshipElement(
  const std::shared_ptr<types::IAnnotatedRelationshipElement>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  that->set_first(
    Wrap<E>(
      that->first(),
      factory
    )
  );

  that->set_second(
    Wrap<E>(
      that->second(),
      factory
    )
  );

  if (that->annotations().has_value()) {
    const std::vector<
        std::shared_ptr<types::IDataElement>
      >& value(
      that->annotations().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IDataElement>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IDataElement>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_annotations(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IAnnotatedRelationshipElement>(
      new EnhancedAnnotatedRelationshipElement<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IEntity> WrapEntity(
  const std::shared_ptr<types::IEntity>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->statements().has_value()) {
    const std::vector<
        std::shared_ptr<types::ISubmodelElement>
      >& value(
      that->statements().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ISubmodelElement>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ISubmodelElement>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_statements(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->specific_asset_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::ISpecificAssetId>
      >& value(
      that->specific_asset_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ISpecificAssetId>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ISpecificAssetId>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_specific_asset_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IEntity>(
      new EnhancedEntity<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IEventPayload> WrapEventPayload(
  const std::shared_ptr<types::IEventPayload>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  that->set_source(
    Wrap<E>(
      that->source(),
      factory
    )
  );

  if (that->source_semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->source_semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_source_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  that->set_observable_reference(
    Wrap<E>(
      that->observable_reference(),
      factory
    )
  );

  if (that->observable_semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->observable_semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_observable_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->subject_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->subject_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_subject_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IEventPayload>(
      new EnhancedEventPayload<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IBasicEventElement> WrapBasicEventElement(
  const std::shared_ptr<types::IBasicEventElement>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  that->set_observed(
    Wrap<E>(
      that->observed(),
      factory
    )
  );

  if (that->message_broker().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->message_broker().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_message_broker(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IBasicEventElement>(
      new EnhancedBasicEventElement<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IOperation> WrapOperation(
  const std::shared_ptr<types::IOperation>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->input_variables().has_value()) {
    const std::vector<
        std::shared_ptr<types::IOperationVariable>
      >& value(
      that->input_variables().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IOperationVariable>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IOperationVariable>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_input_variables(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->output_variables().has_value()) {
    const std::vector<
        std::shared_ptr<types::IOperationVariable>
      >& value(
      that->output_variables().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IOperationVariable>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IOperationVariable>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_output_variables(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->inoutput_variables().has_value()) {
    const std::vector<
        std::shared_ptr<types::IOperationVariable>
      >& value(
      that->inoutput_variables().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IOperationVariable>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IOperationVariable>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_inoutput_variables(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IOperation>(
      new EnhancedOperation<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IOperationVariable> WrapOperationVariable(
  const std::shared_ptr<types::IOperationVariable>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  that->set_value(
    Wrap<E>(
      that->value(),
      factory
    )
  );

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IOperationVariable>(
      new EnhancedOperationVariable<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ICapability> WrapCapability(
  const std::shared_ptr<types::ICapability>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->supplemental_semantic_ids().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->supplemental_semantic_ids().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_supplemental_semantic_ids(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->qualifiers().has_value()) {
    const std::vector<
        std::shared_ptr<types::IQualifier>
      >& value(
      that->qualifiers().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IQualifier>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IQualifier>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_qualifiers(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ICapability>(
      new EnhancedCapability<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IConceptDescription> WrapConceptDescription(
  const std::shared_ptr<types::IConceptDescription>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->extensions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IExtension>
      >& value(
      that->extensions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IExtension>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IExtension>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_extensions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->display_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringNameType>
      >& value(
      that->display_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringNameType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringNameType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_display_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->description().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringTextType>
      >& value(
      that->description().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringTextType>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringTextType>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_description(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->administration().has_value()) {
    const std::shared_ptr<types::IAdministrativeInformation>& value(
      that->administration().value()
    );

    std::shared_ptr<
      types::IAdministrativeInformation
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_administration(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->embedded_data_specifications().has_value()) {
    const std::vector<
        std::shared_ptr<types::IEmbeddedDataSpecification>
      >& value(
      that->embedded_data_specifications().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IEmbeddedDataSpecification>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IEmbeddedDataSpecification>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_embedded_data_specifications(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->is_case_of().has_value()) {
    const std::vector<
        std::shared_ptr<types::IReference>
      >& value(
      that->is_case_of().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IReference>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IReference>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_is_case_of(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IConceptDescription>(
      new EnhancedConceptDescription<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IReference> WrapReference(
  const std::shared_ptr<types::IReference>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->referred_semantic_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->referred_semantic_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_referred_semantic_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  {
    const std::vector<
      std::shared_ptr<types::IKey>
    >& value(
      that->keys()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IKey>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IKey>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_keys(
      std::move(wrapped)
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IReference>(
      new EnhancedReference<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IKey> WrapKey(
  const std::shared_ptr<types::IKey>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IKey>(
      new EnhancedKey<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ILangStringNameType> WrapLangStringNameType(
  const std::shared_ptr<types::ILangStringNameType>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ILangStringNameType>(
      new EnhancedLangStringNameType<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ILangStringTextType> WrapLangStringTextType(
  const std::shared_ptr<types::ILangStringTextType>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ILangStringTextType>(
      new EnhancedLangStringTextType<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IEnvironment> WrapEnvironment(
  const std::shared_ptr<types::IEnvironment>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  if (that->asset_administration_shells().has_value()) {
    const std::vector<
        std::shared_ptr<types::IAssetAdministrationShell>
      >& value(
      that->asset_administration_shells().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IAssetAdministrationShell>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IAssetAdministrationShell>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_asset_administration_shells(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->submodels().has_value()) {
    const std::vector<
        std::shared_ptr<types::ISubmodel>
      >& value(
      that->submodels().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ISubmodel>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ISubmodel>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_submodels(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->concept_descriptions().has_value()) {
    const std::vector<
        std::shared_ptr<types::IConceptDescription>
      >& value(
      that->concept_descriptions().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IConceptDescription>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IConceptDescription>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_concept_descriptions(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IEnvironment>(
      new EnhancedEnvironment<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IEmbeddedDataSpecification> WrapEmbeddedDataSpecification(
  const std::shared_ptr<types::IEmbeddedDataSpecification>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  that->set_data_specification(
    Wrap<E>(
      that->data_specification(),
      factory
    )
  );

  that->set_data_specification_content(
    Wrap<E>(
      that->data_specification_content(),
      factory
    )
  );

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IEmbeddedDataSpecification>(
      new EnhancedEmbeddedDataSpecification<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ILevelType> WrapLevelType(
  const std::shared_ptr<types::ILevelType>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ILevelType>(
      new EnhancedLevelType<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IValueReferencePair> WrapValueReferencePair(
  const std::shared_ptr<types::IValueReferencePair>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  that->set_value_id(
    Wrap<E>(
      that->value_id(),
      factory
    )
  );

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IValueReferencePair>(
      new EnhancedValueReferencePair<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IValueList> WrapValueList(
  const std::shared_ptr<types::IValueList>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  {
    const std::vector<
      std::shared_ptr<types::IValueReferencePair>
    >& value(
      that->value_reference_pairs()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::IValueReferencePair>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::IValueReferencePair>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_value_reference_pairs(
      std::move(wrapped)
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IValueList>(
      new EnhancedValueList<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ILangStringPreferredNameTypeIec61360> WrapLangStringPreferredNameTypeIec61360(
  const std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>(
      new EnhancedLangStringPreferredNameTypeIec61360<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ILangStringShortNameTypeIec61360> WrapLangStringShortNameTypeIec61360(
  const std::shared_ptr<types::ILangStringShortNameTypeIec61360>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ILangStringShortNameTypeIec61360>(
      new EnhancedLangStringShortNameTypeIec61360<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::ILangStringDefinitionTypeIec61360> WrapLangStringDefinitionTypeIec61360(
  const std::shared_ptr<types::ILangStringDefinitionTypeIec61360>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  // No properties to be recursively enhanced.

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::ILangStringDefinitionTypeIec61360>(
      new EnhancedLangStringDefinitionTypeIec61360<E>(
        that,
        enh
      )
    );
}

/**
 * Wrap \p that with an enhanced instance.
 *
 * \param that instance to be wrapped and enhanced
 * \param factory to produce an enhancement based on an instance
 * \return Enhanced instance, or `that` if no enhancement produced
 *
 * \tparam E type of the enhancement
 */
template<typename E>
std::shared_ptr<types::IDataSpecificationIec61360> WrapDataSpecificationIec61360(
  const std::shared_ptr<types::IDataSpecificationIec61360>& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  // We assume that we already checked whether `that` has been enhanced
  // in the caller.

  {
    const std::vector<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    >& value(
      that->preferred_name()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_preferred_name(
      std::move(wrapped)
    );
  }

  if (that->short_name().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringShortNameTypeIec61360>
      >& value(
      that->short_name().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringShortNameTypeIec61360>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringShortNameTypeIec61360>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_short_name(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->unit_id().has_value()) {
    const std::shared_ptr<types::IReference>& value(
      that->unit_id().value()
    );

    std::shared_ptr<
      types::IReference
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_unit_id(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->definition().has_value()) {
    const std::vector<
        std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
      >& value(
      that->definition().value()
    );
    const std::size_t size = value.size();

    std::vector<
      std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
    > wrapped;
    wrapped.reserve(size);

    for (
      const std::shared_ptr<types::ILangStringDefinitionTypeIec61360>& item
      : value
    ) {
      wrapped.emplace_back(
        Wrap<E>(
          item,
          factory
        )
      );
    }

    that->set_definition(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->value_list().has_value()) {
    const std::shared_ptr<types::IValueList>& value(
      that->value_list().value()
    );

    std::shared_ptr<
      types::IValueList
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_value_list(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  if (that->level_type().has_value()) {
    const std::shared_ptr<types::ILevelType>& value(
      that->level_type().value()
    );

    std::shared_ptr<
      types::ILevelType
    > wrapped(
      Wrap<E>(
        value,
        factory
      )
    );

    that->set_level_type(
      common::make_optional(
        std::move(wrapped)
      )
    );
  }

  std::shared_ptr<E> enh(
    factory(that)
  );
  return (enh == nullptr)
    ? that
    : std::shared_ptr<types::IDataSpecificationIec61360>(
      new EnhancedDataSpecificationIec61360<E>(
        that,
        enh
      )
    );
}

/**
 * Assert that the \p that instance has not been already enhanced.
 *
 * \param that instance to be checked
 * \tparam E type of the enhancement
 * \tparam T interface type of \p that instance
 * \throw std::logic_error if \p that already enhanced
 */
template<
  typename E,
  typename T,
  typename std::enable_if<
    std::is_base_of<types::IClass, T>::value
  >::type* = nullptr
>
void AssertNotEnhanced(
  const std::shared_ptr<T>& that
) {
  std::shared_ptr<impl::IEnhanced<E> > enhanced(
    std::dynamic_pointer_cast<
      impl::IEnhanced<E>
    >(that)
  );
  if (enhanced != nullptr) {
    throw std::logic_error(
      common::Concat(
        "An instance of ",
        stringification::to_string(that->model_type()),
        " has been already wrapped."
      )
    );
  }
}

}  // namespace impl
/// \endcond

/**
 * Wrap \p that instance recursively with the enhancement produced by the \p factory.
 *
 * The factory decides itself whether it will produce an enhancement for
 * \p that instance, or not. Even if no enhancement has been produced for \p that
 * instance, we will still continue to enhance the instances referenced
 * by \p that instance recursively.
 *
 * \param that instance to wrap
 * \param factory to selectively produce an enhancement
 * \return enhanced \p that instance
 * \throw std::logic_error if \p that instance has been already wrapped.
 * \tparam E type of the enhancement
 */
///@{

template <typename E>
std::shared_ptr<
  types::IClass
> Wrap(
  const std::shared_ptr<
    types::IClass
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IClass
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kExtension:
      return impl::WrapExtension<E>(
        std::dynamic_pointer_cast<
          types::IExtension
        >(that),
        factory
      );
      break;
    case types::ModelType::kAdministrativeInformation:
      return impl::WrapAdministrativeInformation<E>(
        std::dynamic_pointer_cast<
          types::IAdministrativeInformation
        >(that),
        factory
      );
      break;
    case types::ModelType::kQualifier:
      return impl::WrapQualifier<E>(
        std::dynamic_pointer_cast<
          types::IQualifier
        >(that),
        factory
      );
      break;
    case types::ModelType::kAssetAdministrationShell:
      return impl::WrapAssetAdministrationShell<E>(
        std::dynamic_pointer_cast<
          types::IAssetAdministrationShell
        >(that),
        factory
      );
      break;
    case types::ModelType::kAssetInformation:
      return impl::WrapAssetInformation<E>(
        std::dynamic_pointer_cast<
          types::IAssetInformation
        >(that),
        factory
      );
      break;
    case types::ModelType::kResource:
      return impl::WrapResource<E>(
        std::dynamic_pointer_cast<
          types::IResource
        >(that),
        factory
      );
      break;
    case types::ModelType::kSpecificAssetId:
      return impl::WrapSpecificAssetId<E>(
        std::dynamic_pointer_cast<
          types::ISpecificAssetId
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        std::dynamic_pointer_cast<
          types::ISubmodel
        >(that),
        factory
      );
      break;
    case types::ModelType::kRelationshipElement:
      return impl::WrapRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementList:
      return impl::WrapSubmodelElementList<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementList
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementCollection:
      return impl::WrapSubmodelElementCollection<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementCollection
        >(that),
        factory
      );
      break;
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        std::dynamic_pointer_cast<
          types::IProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        std::dynamic_pointer_cast<
          types::IMultiLanguageProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        std::dynamic_pointer_cast<
          types::IRange
        >(that),
        factory
      );
      break;
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        std::dynamic_pointer_cast<
          types::IReferenceElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        std::dynamic_pointer_cast<
          types::IBlob
        >(that),
        factory
      );
      break;
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        std::dynamic_pointer_cast<
          types::IFile
        >(that),
        factory
      );
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IAnnotatedRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kEntity:
      return impl::WrapEntity<E>(
        std::dynamic_pointer_cast<
          types::IEntity
        >(that),
        factory
      );
      break;
    case types::ModelType::kEventPayload:
      return impl::WrapEventPayload<E>(
        std::dynamic_pointer_cast<
          types::IEventPayload
        >(that),
        factory
      );
      break;
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        std::dynamic_pointer_cast<
          types::IBasicEventElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kOperation:
      return impl::WrapOperation<E>(
        std::dynamic_pointer_cast<
          types::IOperation
        >(that),
        factory
      );
      break;
    case types::ModelType::kOperationVariable:
      return impl::WrapOperationVariable<E>(
        std::dynamic_pointer_cast<
          types::IOperationVariable
        >(that),
        factory
      );
      break;
    case types::ModelType::kCapability:
      return impl::WrapCapability<E>(
        std::dynamic_pointer_cast<
          types::ICapability
        >(that),
        factory
      );
      break;
    case types::ModelType::kConceptDescription:
      return impl::WrapConceptDescription<E>(
        std::dynamic_pointer_cast<
          types::IConceptDescription
        >(that),
        factory
      );
      break;
    case types::ModelType::kReference:
      return impl::WrapReference<E>(
        std::dynamic_pointer_cast<
          types::IReference
        >(that),
        factory
      );
      break;
    case types::ModelType::kKey:
      return impl::WrapKey<E>(
        std::dynamic_pointer_cast<
          types::IKey
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringNameType:
      return impl::WrapLangStringNameType<E>(
        std::dynamic_pointer_cast<
          types::ILangStringNameType
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringTextType:
      return impl::WrapLangStringTextType<E>(
        std::dynamic_pointer_cast<
          types::ILangStringTextType
        >(that),
        factory
      );
      break;
    case types::ModelType::kEnvironment:
      return impl::WrapEnvironment<E>(
        std::dynamic_pointer_cast<
          types::IEnvironment
        >(that),
        factory
      );
      break;
    case types::ModelType::kEmbeddedDataSpecification:
      return impl::WrapEmbeddedDataSpecification<E>(
        std::dynamic_pointer_cast<
          types::IEmbeddedDataSpecification
        >(that),
        factory
      );
      break;
    case types::ModelType::kLevelType:
      return impl::WrapLevelType<E>(
        std::dynamic_pointer_cast<
          types::ILevelType
        >(that),
        factory
      );
      break;
    case types::ModelType::kValueReferencePair:
      return impl::WrapValueReferencePair<E>(
        std::dynamic_pointer_cast<
          types::IValueReferencePair
        >(that),
        factory
      );
      break;
    case types::ModelType::kValueList:
      return impl::WrapValueList<E>(
        std::dynamic_pointer_cast<
          types::IValueList
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      return impl::WrapLangStringPreferredNameTypeIec61360<E>(
        std::dynamic_pointer_cast<
          types::ILangStringPreferredNameTypeIec61360
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringShortNameTypeIec61360:
      return impl::WrapLangStringShortNameTypeIec61360<E>(
        std::dynamic_pointer_cast<
          types::ILangStringShortNameTypeIec61360
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      return impl::WrapLangStringDefinitionTypeIec61360<E>(
        std::dynamic_pointer_cast<
          types::ILangStringDefinitionTypeIec61360
        >(that),
        factory
      );
      break;
    case types::ModelType::kDataSpecificationIec61360:
      return impl::WrapDataSpecificationIec61360<E>(
        std::dynamic_pointer_cast<
          types::IDataSpecificationIec61360
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IHasSemantics
> Wrap(
  const std::shared_ptr<
    types::IHasSemantics
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IHasSemantics
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kRelationshipElement:
      return impl::WrapRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IAnnotatedRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        std::dynamic_pointer_cast<
          types::IBasicEventElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        std::dynamic_pointer_cast<
          types::IBlob
        >(that),
        factory
      );
      break;
    case types::ModelType::kCapability:
      return impl::WrapCapability<E>(
        std::dynamic_pointer_cast<
          types::ICapability
        >(that),
        factory
      );
      break;
    case types::ModelType::kEntity:
      return impl::WrapEntity<E>(
        std::dynamic_pointer_cast<
          types::IEntity
        >(that),
        factory
      );
      break;
    case types::ModelType::kExtension:
      return impl::WrapExtension<E>(
        std::dynamic_pointer_cast<
          types::IExtension
        >(that),
        factory
      );
      break;
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        std::dynamic_pointer_cast<
          types::IFile
        >(that),
        factory
      );
      break;
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        std::dynamic_pointer_cast<
          types::IMultiLanguageProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kOperation:
      return impl::WrapOperation<E>(
        std::dynamic_pointer_cast<
          types::IOperation
        >(that),
        factory
      );
      break;
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        std::dynamic_pointer_cast<
          types::IProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kQualifier:
      return impl::WrapQualifier<E>(
        std::dynamic_pointer_cast<
          types::IQualifier
        >(that),
        factory
      );
      break;
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        std::dynamic_pointer_cast<
          types::IRange
        >(that),
        factory
      );
      break;
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        std::dynamic_pointer_cast<
          types::IReferenceElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kSpecificAssetId:
      return impl::WrapSpecificAssetId<E>(
        std::dynamic_pointer_cast<
          types::ISpecificAssetId
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        std::dynamic_pointer_cast<
          types::ISubmodel
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementCollection:
      return impl::WrapSubmodelElementCollection<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementCollection
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementList:
      return impl::WrapSubmodelElementList<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementList
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IExtension
> Wrap(
  const std::shared_ptr<
    types::IExtension
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IExtension
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kExtension:
      return impl::WrapExtension<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IHasExtensions
> Wrap(
  const std::shared_ptr<
    types::IHasExtensions
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IHasExtensions
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kRelationshipElement:
      return impl::WrapRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IAnnotatedRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAssetAdministrationShell:
      return impl::WrapAssetAdministrationShell<E>(
        std::dynamic_pointer_cast<
          types::IAssetAdministrationShell
        >(that),
        factory
      );
      break;
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        std::dynamic_pointer_cast<
          types::IBasicEventElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        std::dynamic_pointer_cast<
          types::IBlob
        >(that),
        factory
      );
      break;
    case types::ModelType::kCapability:
      return impl::WrapCapability<E>(
        std::dynamic_pointer_cast<
          types::ICapability
        >(that),
        factory
      );
      break;
    case types::ModelType::kConceptDescription:
      return impl::WrapConceptDescription<E>(
        std::dynamic_pointer_cast<
          types::IConceptDescription
        >(that),
        factory
      );
      break;
    case types::ModelType::kEntity:
      return impl::WrapEntity<E>(
        std::dynamic_pointer_cast<
          types::IEntity
        >(that),
        factory
      );
      break;
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        std::dynamic_pointer_cast<
          types::IFile
        >(that),
        factory
      );
      break;
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        std::dynamic_pointer_cast<
          types::IMultiLanguageProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kOperation:
      return impl::WrapOperation<E>(
        std::dynamic_pointer_cast<
          types::IOperation
        >(that),
        factory
      );
      break;
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        std::dynamic_pointer_cast<
          types::IProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        std::dynamic_pointer_cast<
          types::IRange
        >(that),
        factory
      );
      break;
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        std::dynamic_pointer_cast<
          types::IReferenceElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        std::dynamic_pointer_cast<
          types::ISubmodel
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementCollection:
      return impl::WrapSubmodelElementCollection<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementCollection
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementList:
      return impl::WrapSubmodelElementList<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementList
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IReferable
> Wrap(
  const std::shared_ptr<
    types::IReferable
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IReferable
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kRelationshipElement:
      return impl::WrapRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IAnnotatedRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAssetAdministrationShell:
      return impl::WrapAssetAdministrationShell<E>(
        std::dynamic_pointer_cast<
          types::IAssetAdministrationShell
        >(that),
        factory
      );
      break;
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        std::dynamic_pointer_cast<
          types::IBasicEventElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        std::dynamic_pointer_cast<
          types::IBlob
        >(that),
        factory
      );
      break;
    case types::ModelType::kCapability:
      return impl::WrapCapability<E>(
        std::dynamic_pointer_cast<
          types::ICapability
        >(that),
        factory
      );
      break;
    case types::ModelType::kConceptDescription:
      return impl::WrapConceptDescription<E>(
        std::dynamic_pointer_cast<
          types::IConceptDescription
        >(that),
        factory
      );
      break;
    case types::ModelType::kEntity:
      return impl::WrapEntity<E>(
        std::dynamic_pointer_cast<
          types::IEntity
        >(that),
        factory
      );
      break;
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        std::dynamic_pointer_cast<
          types::IFile
        >(that),
        factory
      );
      break;
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        std::dynamic_pointer_cast<
          types::IMultiLanguageProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kOperation:
      return impl::WrapOperation<E>(
        std::dynamic_pointer_cast<
          types::IOperation
        >(that),
        factory
      );
      break;
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        std::dynamic_pointer_cast<
          types::IProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        std::dynamic_pointer_cast<
          types::IRange
        >(that),
        factory
      );
      break;
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        std::dynamic_pointer_cast<
          types::IReferenceElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        std::dynamic_pointer_cast<
          types::ISubmodel
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementCollection:
      return impl::WrapSubmodelElementCollection<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementCollection
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementList:
      return impl::WrapSubmodelElementList<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementList
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IIdentifiable
> Wrap(
  const std::shared_ptr<
    types::IIdentifiable
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IIdentifiable
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kAssetAdministrationShell:
      return impl::WrapAssetAdministrationShell<E>(
        std::dynamic_pointer_cast<
          types::IAssetAdministrationShell
        >(that),
        factory
      );
      break;
    case types::ModelType::kConceptDescription:
      return impl::WrapConceptDescription<E>(
        std::dynamic_pointer_cast<
          types::IConceptDescription
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        std::dynamic_pointer_cast<
          types::ISubmodel
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IHasKind
> Wrap(
  const std::shared_ptr<
    types::IHasKind
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IHasKind
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        std::dynamic_pointer_cast<
          types::ISubmodel
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IHasDataSpecification
> Wrap(
  const std::shared_ptr<
    types::IHasDataSpecification
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IHasDataSpecification
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kAdministrativeInformation:
      return impl::WrapAdministrativeInformation<E>(
        std::dynamic_pointer_cast<
          types::IAdministrativeInformation
        >(that),
        factory
      );
      break;
    case types::ModelType::kRelationshipElement:
      return impl::WrapRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IAnnotatedRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAssetAdministrationShell:
      return impl::WrapAssetAdministrationShell<E>(
        std::dynamic_pointer_cast<
          types::IAssetAdministrationShell
        >(that),
        factory
      );
      break;
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        std::dynamic_pointer_cast<
          types::IBasicEventElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        std::dynamic_pointer_cast<
          types::IBlob
        >(that),
        factory
      );
      break;
    case types::ModelType::kCapability:
      return impl::WrapCapability<E>(
        std::dynamic_pointer_cast<
          types::ICapability
        >(that),
        factory
      );
      break;
    case types::ModelType::kConceptDescription:
      return impl::WrapConceptDescription<E>(
        std::dynamic_pointer_cast<
          types::IConceptDescription
        >(that),
        factory
      );
      break;
    case types::ModelType::kEntity:
      return impl::WrapEntity<E>(
        std::dynamic_pointer_cast<
          types::IEntity
        >(that),
        factory
      );
      break;
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        std::dynamic_pointer_cast<
          types::IFile
        >(that),
        factory
      );
      break;
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        std::dynamic_pointer_cast<
          types::IMultiLanguageProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kOperation:
      return impl::WrapOperation<E>(
        std::dynamic_pointer_cast<
          types::IOperation
        >(that),
        factory
      );
      break;
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        std::dynamic_pointer_cast<
          types::IProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        std::dynamic_pointer_cast<
          types::IRange
        >(that),
        factory
      );
      break;
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        std::dynamic_pointer_cast<
          types::IReferenceElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        std::dynamic_pointer_cast<
          types::ISubmodel
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementCollection:
      return impl::WrapSubmodelElementCollection<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementCollection
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementList:
      return impl::WrapSubmodelElementList<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementList
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IAdministrativeInformation
> Wrap(
  const std::shared_ptr<
    types::IAdministrativeInformation
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IAdministrativeInformation
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kAdministrativeInformation:
      return impl::WrapAdministrativeInformation<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IQualifiable
> Wrap(
  const std::shared_ptr<
    types::IQualifiable
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IQualifiable
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kRelationshipElement:
      return impl::WrapRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IAnnotatedRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        std::dynamic_pointer_cast<
          types::IBasicEventElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        std::dynamic_pointer_cast<
          types::IBlob
        >(that),
        factory
      );
      break;
    case types::ModelType::kCapability:
      return impl::WrapCapability<E>(
        std::dynamic_pointer_cast<
          types::ICapability
        >(that),
        factory
      );
      break;
    case types::ModelType::kEntity:
      return impl::WrapEntity<E>(
        std::dynamic_pointer_cast<
          types::IEntity
        >(that),
        factory
      );
      break;
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        std::dynamic_pointer_cast<
          types::IFile
        >(that),
        factory
      );
      break;
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        std::dynamic_pointer_cast<
          types::IMultiLanguageProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kOperation:
      return impl::WrapOperation<E>(
        std::dynamic_pointer_cast<
          types::IOperation
        >(that),
        factory
      );
      break;
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        std::dynamic_pointer_cast<
          types::IProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        std::dynamic_pointer_cast<
          types::IRange
        >(that),
        factory
      );
      break;
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        std::dynamic_pointer_cast<
          types::IReferenceElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        std::dynamic_pointer_cast<
          types::ISubmodel
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementCollection:
      return impl::WrapSubmodelElementCollection<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementCollection
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementList:
      return impl::WrapSubmodelElementList<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementList
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IQualifier
> Wrap(
  const std::shared_ptr<
    types::IQualifier
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IQualifier
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kQualifier:
      return impl::WrapQualifier<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IAssetAdministrationShell
> Wrap(
  const std::shared_ptr<
    types::IAssetAdministrationShell
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IAssetAdministrationShell
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kAssetAdministrationShell:
      return impl::WrapAssetAdministrationShell<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IAssetInformation
> Wrap(
  const std::shared_ptr<
    types::IAssetInformation
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IAssetInformation
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kAssetInformation:
      return impl::WrapAssetInformation<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IResource
> Wrap(
  const std::shared_ptr<
    types::IResource
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IResource
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kResource:
      return impl::WrapResource<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ISpecificAssetId
> Wrap(
  const std::shared_ptr<
    types::ISpecificAssetId
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ISpecificAssetId
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kSpecificAssetId:
      return impl::WrapSpecificAssetId<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ISubmodel
> Wrap(
  const std::shared_ptr<
    types::ISubmodel
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ISubmodel
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kSubmodel:
      return impl::WrapSubmodel<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ISubmodelElement
> Wrap(
  const std::shared_ptr<
    types::ISubmodelElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ISubmodelElement
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kRelationshipElement:
      return impl::WrapRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IAnnotatedRelationshipElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        std::dynamic_pointer_cast<
          types::IBasicEventElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        std::dynamic_pointer_cast<
          types::IBlob
        >(that),
        factory
      );
      break;
    case types::ModelType::kCapability:
      return impl::WrapCapability<E>(
        std::dynamic_pointer_cast<
          types::ICapability
        >(that),
        factory
      );
      break;
    case types::ModelType::kEntity:
      return impl::WrapEntity<E>(
        std::dynamic_pointer_cast<
          types::IEntity
        >(that),
        factory
      );
      break;
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        std::dynamic_pointer_cast<
          types::IFile
        >(that),
        factory
      );
      break;
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        std::dynamic_pointer_cast<
          types::IMultiLanguageProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kOperation:
      return impl::WrapOperation<E>(
        std::dynamic_pointer_cast<
          types::IOperation
        >(that),
        factory
      );
      break;
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        std::dynamic_pointer_cast<
          types::IProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        std::dynamic_pointer_cast<
          types::IRange
        >(that),
        factory
      );
      break;
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        std::dynamic_pointer_cast<
          types::IReferenceElement
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementCollection:
      return impl::WrapSubmodelElementCollection<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementCollection
        >(that),
        factory
      );
      break;
    case types::ModelType::kSubmodelElementList:
      return impl::WrapSubmodelElementList<E>(
        std::dynamic_pointer_cast<
          types::ISubmodelElementList
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IRelationshipElement
> Wrap(
  const std::shared_ptr<
    types::IRelationshipElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IRelationshipElement
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kRelationshipElement:
      return impl::WrapRelationshipElement<E>(
        that,
        factory
      );
      break;
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        std::dynamic_pointer_cast<
          types::IAnnotatedRelationshipElement
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ISubmodelElementList
> Wrap(
  const std::shared_ptr<
    types::ISubmodelElementList
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ISubmodelElementList
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kSubmodelElementList:
      return impl::WrapSubmodelElementList<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ISubmodelElementCollection
> Wrap(
  const std::shared_ptr<
    types::ISubmodelElementCollection
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ISubmodelElementCollection
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kSubmodelElementCollection:
      return impl::WrapSubmodelElementCollection<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IDataElement
> Wrap(
  const std::shared_ptr<
    types::IDataElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IDataElement
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        std::dynamic_pointer_cast<
          types::IBlob
        >(that),
        factory
      );
      break;
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        std::dynamic_pointer_cast<
          types::IFile
        >(that),
        factory
      );
      break;
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        std::dynamic_pointer_cast<
          types::IMultiLanguageProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        std::dynamic_pointer_cast<
          types::IProperty
        >(that),
        factory
      );
      break;
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        std::dynamic_pointer_cast<
          types::IRange
        >(that),
        factory
      );
      break;
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        std::dynamic_pointer_cast<
          types::IReferenceElement
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IProperty
> Wrap(
  const std::shared_ptr<
    types::IProperty
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IProperty
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kProperty:
      return impl::WrapProperty<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IMultiLanguageProperty
> Wrap(
  const std::shared_ptr<
    types::IMultiLanguageProperty
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IMultiLanguageProperty
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kMultiLanguageProperty:
      return impl::WrapMultiLanguageProperty<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IRange
> Wrap(
  const std::shared_ptr<
    types::IRange
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IRange
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kRange:
      return impl::WrapRange<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IReferenceElement
> Wrap(
  const std::shared_ptr<
    types::IReferenceElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IReferenceElement
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kReferenceElement:
      return impl::WrapReferenceElement<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IBlob
> Wrap(
  const std::shared_ptr<
    types::IBlob
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IBlob
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kBlob:
      return impl::WrapBlob<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IFile
> Wrap(
  const std::shared_ptr<
    types::IFile
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IFile
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kFile:
      return impl::WrapFile<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IAnnotatedRelationshipElement
> Wrap(
  const std::shared_ptr<
    types::IAnnotatedRelationshipElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IAnnotatedRelationshipElement
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kAnnotatedRelationshipElement:
      return impl::WrapAnnotatedRelationshipElement<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IEntity
> Wrap(
  const std::shared_ptr<
    types::IEntity
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IEntity
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kEntity:
      return impl::WrapEntity<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IEventPayload
> Wrap(
  const std::shared_ptr<
    types::IEventPayload
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IEventPayload
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kEventPayload:
      return impl::WrapEventPayload<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IEventElement
> Wrap(
  const std::shared_ptr<
    types::IEventElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IEventElement
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        std::dynamic_pointer_cast<
          types::IBasicEventElement
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IBasicEventElement
> Wrap(
  const std::shared_ptr<
    types::IBasicEventElement
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IBasicEventElement
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kBasicEventElement:
      return impl::WrapBasicEventElement<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IOperation
> Wrap(
  const std::shared_ptr<
    types::IOperation
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IOperation
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kOperation:
      return impl::WrapOperation<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IOperationVariable
> Wrap(
  const std::shared_ptr<
    types::IOperationVariable
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IOperationVariable
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kOperationVariable:
      return impl::WrapOperationVariable<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ICapability
> Wrap(
  const std::shared_ptr<
    types::ICapability
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ICapability
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kCapability:
      return impl::WrapCapability<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IConceptDescription
> Wrap(
  const std::shared_ptr<
    types::IConceptDescription
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IConceptDescription
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kConceptDescription:
      return impl::WrapConceptDescription<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IReference
> Wrap(
  const std::shared_ptr<
    types::IReference
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IReference
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kReference:
      return impl::WrapReference<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IKey
> Wrap(
  const std::shared_ptr<
    types::IKey
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IKey
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kKey:
      return impl::WrapKey<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IAbstractLangString
> Wrap(
  const std::shared_ptr<
    types::IAbstractLangString
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IAbstractLangString
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      return impl::WrapLangStringDefinitionTypeIec61360<E>(
        std::dynamic_pointer_cast<
          types::ILangStringDefinitionTypeIec61360
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringNameType:
      return impl::WrapLangStringNameType<E>(
        std::dynamic_pointer_cast<
          types::ILangStringNameType
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      return impl::WrapLangStringPreferredNameTypeIec61360<E>(
        std::dynamic_pointer_cast<
          types::ILangStringPreferredNameTypeIec61360
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringShortNameTypeIec61360:
      return impl::WrapLangStringShortNameTypeIec61360<E>(
        std::dynamic_pointer_cast<
          types::ILangStringShortNameTypeIec61360
        >(that),
        factory
      );
      break;
    case types::ModelType::kLangStringTextType:
      return impl::WrapLangStringTextType<E>(
        std::dynamic_pointer_cast<
          types::ILangStringTextType
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ILangStringNameType
> Wrap(
  const std::shared_ptr<
    types::ILangStringNameType
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ILangStringNameType
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kLangStringNameType:
      return impl::WrapLangStringNameType<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ILangStringTextType
> Wrap(
  const std::shared_ptr<
    types::ILangStringTextType
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ILangStringTextType
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kLangStringTextType:
      return impl::WrapLangStringTextType<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IEnvironment
> Wrap(
  const std::shared_ptr<
    types::IEnvironment
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IEnvironment
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kEnvironment:
      return impl::WrapEnvironment<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IDataSpecificationContent
> Wrap(
  const std::shared_ptr<
    types::IDataSpecificationContent
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IDataSpecificationContent
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kDataSpecificationIec61360:
      return impl::WrapDataSpecificationIec61360<E>(
        std::dynamic_pointer_cast<
          types::IDataSpecificationIec61360
        >(that),
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IEmbeddedDataSpecification
> Wrap(
  const std::shared_ptr<
    types::IEmbeddedDataSpecification
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IEmbeddedDataSpecification
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kEmbeddedDataSpecification:
      return impl::WrapEmbeddedDataSpecification<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ILevelType
> Wrap(
  const std::shared_ptr<
    types::ILevelType
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ILevelType
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kLevelType:
      return impl::WrapLevelType<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IValueReferencePair
> Wrap(
  const std::shared_ptr<
    types::IValueReferencePair
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IValueReferencePair
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kValueReferencePair:
      return impl::WrapValueReferencePair<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IValueList
> Wrap(
  const std::shared_ptr<
    types::IValueList
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IValueList
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kValueList:
      return impl::WrapValueList<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ILangStringPreferredNameTypeIec61360
> Wrap(
  const std::shared_ptr<
    types::ILangStringPreferredNameTypeIec61360
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ILangStringPreferredNameTypeIec61360
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      return impl::WrapLangStringPreferredNameTypeIec61360<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ILangStringShortNameTypeIec61360
> Wrap(
  const std::shared_ptr<
    types::ILangStringShortNameTypeIec61360
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ILangStringShortNameTypeIec61360
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kLangStringShortNameTypeIec61360:
      return impl::WrapLangStringShortNameTypeIec61360<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::ILangStringDefinitionTypeIec61360
> Wrap(
  const std::shared_ptr<
    types::ILangStringDefinitionTypeIec61360
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::ILangStringDefinitionTypeIec61360
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      return impl::WrapLangStringDefinitionTypeIec61360<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

template <typename E>
std::shared_ptr<
  types::IDataSpecificationIec61360
> Wrap(
  const std::shared_ptr<
    types::IDataSpecificationIec61360
  >& that,
  const std::function<
    std::shared_ptr<E>(
      const std::shared_ptr<types::IClass>&
    )
  >& factory
) {
  impl::AssertNotEnhanced<
    E,
    types::IDataSpecificationIec61360
  >(that);

  switch (that->model_type()) {
    case types::ModelType::kDataSpecificationIec61360:
      return impl::WrapDataSpecificationIec61360<E>(
        that,
        factory
      );
      break;
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(
              that->model_type()
            )
          )
        )
      );
      break;
  }
}

///@}}

/**
 * Try to unwrap the enhancement from \p that instance.
 *
 * \param that instance possibly wrapped with an enhancement
 * \return the enhancement, or `nullptr` if \p that instance has not been wrapped
 * \tparam E type of the enhancement
 */
template <typename E>
std::shared_ptr<E> Unwrap(
  const std::shared_ptr<types::IClass>& that
) {
  const std::shared_ptr<impl::IEnhanced<E> >& maybe_enhanced(
    std::dynamic_pointer_cast<impl::IEnhanced<E> >(that)
  );

  if (!maybe_enhanced) {
    return nullptr;
  }

  return maybe_enhanced->enhancement();
}

/**
 * Unwrap the enhancement from \p that instance.
 *
 * \remark \p that instance must have been wrapped before.
 *
 * \param that instance expected to be wrapped with an enhancement
 * \return the enhancement
 * \throw std::invalid_argument if \p that instance has not been wrapped
 * \tparam E type of the enhancement
 */
template <typename E>
std::shared_ptr<E> MustUnwrap(
  const std::shared_ptr<types::IClass>& that
) {
  std::shared_ptr<E> enhancement(
    Unwrap<E>(that)
  );
  if (!enhancement) {
    throw std::invalid_argument(
      common::Concat(
        "Expected an instance of ",
        stringification::to_string(that->model_type()),
        " to have been already wrapped with an enhancement, "
        "but it has been not."
      )
    );
  }
  return enhancement;
}

}  // namespace enhancing
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_ENHANCING_GUARD_
