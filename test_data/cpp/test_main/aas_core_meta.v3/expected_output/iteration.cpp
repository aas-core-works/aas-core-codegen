// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/iteration.hpp"

namespace aas_core {
namespace aas_3_0 {
namespace iteration {

// region Pathing

/**
 * Translate the enumeration literal \p property to text.
 *
 * \param property to be converted into text
 * \return text representation of \p property
 * \throw std::invalid_argument if \p property invalid
 */
std::wstring PropertyToWstring(
  Property property
) {
  switch (property) {
    case Property::kAdministration:
      return L"administration";
    case Property::kAnnotations:
      return L"annotations";
    case Property::kAssetAdministrationShells:
      return L"asset_administration_shells";
    case Property::kAssetInformation:
      return L"asset_information";
    case Property::kAssetKind:
      return L"asset_kind";
    case Property::kAssetType:
      return L"asset_type";
    case Property::kCategory:
      return L"category";
    case Property::kConceptDescriptions:
      return L"concept_descriptions";
    case Property::kContentType:
      return L"content_type";
    case Property::kCreator:
      return L"creator";
    case Property::kDataSpecification:
      return L"data_specification";
    case Property::kDataSpecificationContent:
      return L"data_specification_content";
    case Property::kDataType:
      return L"data_type";
    case Property::kDefaultThumbnail:
      return L"default_thumbnail";
    case Property::kDefinition:
      return L"definition";
    case Property::kDerivedFrom:
      return L"derived_from";
    case Property::kDescription:
      return L"description";
    case Property::kDirection:
      return L"direction";
    case Property::kDisplayName:
      return L"display_name";
    case Property::kEmbeddedDataSpecifications:
      return L"embedded_data_specifications";
    case Property::kEntityType:
      return L"entity_type";
    case Property::kExtensions:
      return L"extensions";
    case Property::kExternalSubjectId:
      return L"external_subject_id";
    case Property::kFirst:
      return L"first";
    case Property::kGlobalAssetId:
      return L"global_asset_id";
    case Property::kId:
      return L"id";
    case Property::kIdShort:
      return L"id_short";
    case Property::kInoutputVariables:
      return L"inoutput_variables";
    case Property::kInputVariables:
      return L"input_variables";
    case Property::kIsCaseOf:
      return L"is_case_of";
    case Property::kKeys:
      return L"keys";
    case Property::kKind:
      return L"kind";
    case Property::kLanguage:
      return L"language";
    case Property::kLastUpdate:
      return L"last_update";
    case Property::kLevelType:
      return L"level_type";
    case Property::kMax:
      return L"max";
    case Property::kMaxInterval:
      return L"max_interval";
    case Property::kMessageBroker:
      return L"message_broker";
    case Property::kMessageTopic:
      return L"message_topic";
    case Property::kMin:
      return L"min";
    case Property::kMinInterval:
      return L"min_interval";
    case Property::kName:
      return L"name";
    case Property::kNom:
      return L"nom";
    case Property::kObservableReference:
      return L"observable_reference";
    case Property::kObservableSemanticId:
      return L"observable_semantic_id";
    case Property::kObserved:
      return L"observed";
    case Property::kOrderRelevant:
      return L"order_relevant";
    case Property::kOutputVariables:
      return L"output_variables";
    case Property::kPath:
      return L"path";
    case Property::kPayload:
      return L"payload";
    case Property::kPreferredName:
      return L"preferred_name";
    case Property::kQualifiers:
      return L"qualifiers";
    case Property::kReferredSemanticId:
      return L"referred_semantic_id";
    case Property::kRefersTo:
      return L"refers_to";
    case Property::kRevision:
      return L"revision";
    case Property::kSecond:
      return L"second";
    case Property::kSemanticId:
      return L"semantic_id";
    case Property::kSemanticIdListElement:
      return L"semantic_id_list_element";
    case Property::kShortName:
      return L"short_name";
    case Property::kSource:
      return L"source";
    case Property::kSourceOfDefinition:
      return L"source_of_definition";
    case Property::kSourceSemanticId:
      return L"source_semantic_id";
    case Property::kSpecificAssetIds:
      return L"specific_asset_ids";
    case Property::kState:
      return L"state";
    case Property::kStatements:
      return L"statements";
    case Property::kSubjectId:
      return L"subject_id";
    case Property::kSubmodelElements:
      return L"submodel_elements";
    case Property::kSubmodels:
      return L"submodels";
    case Property::kSupplementalSemanticIds:
      return L"supplemental_semantic_ids";
    case Property::kSymbol:
      return L"symbol";
    case Property::kTemplateId:
      return L"template_id";
    case Property::kText:
      return L"text";
    case Property::kTimeStamp:
      return L"time_stamp";
    case Property::kTopic:
      return L"topic";
    case Property::kTyp:
      return L"typ";
    case Property::kType:
      return L"type";
    case Property::kTypeValueListElement:
      return L"type_value_list_element";
    case Property::kUnit:
      return L"unit";
    case Property::kUnitId:
      return L"unit_id";
    case Property::kValue:
      return L"value";
    case Property::kValueFormat:
      return L"value_format";
    case Property::kValueId:
      return L"value_id";
    case Property::kValueList:
      return L"value_list";
    case Property::kValueReferencePairs:
      return L"value_reference_pairs";
    case Property::kValueType:
      return L"value_type";
    case Property::kValueTypeListElement:
      return L"value_type_list_element";
    case Property::kVersion:
      return L"version";
    default:
      throw std::invalid_argument(
        common::Concat(
          "Unexpected property literal: ",
          std::to_string(
            static_cast<std::uint32_t>(property)
          )
        )
      );
  }
}  // function to_wstring

// region struct PropertySegment

PropertySegment::PropertySegment(Property a_property) {
  property = a_property;
}

std::wstring PropertySegment::ToWstring() const {
  return common::Concat(
    L".",
    PropertyToWstring(property)
  );
}

std::unique_ptr<ISegment> PropertySegment::Clone() const {
  return common::make_unique<PropertySegment>(*this);
}

// endregion struct PropertySegment

// region struct IndexSegment

IndexSegment::IndexSegment(size_t an_index) {
  index = an_index;
}

std::wstring IndexSegment::ToWstring() const {
  return common::Concat(
    L"[",
    std::to_wstring(index),
    L"]"
  );
}

std::unique_ptr<ISegment> IndexSegment::Clone() const {
  return common::make_unique<IndexSegment>(*this);
}

// endregion struct IndexSegment

// region struct Path

Path::Path() {
  // Intentionally empty.
}

Path::Path(const Path& other) {
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
}

Path::Path(Path&& other) {
  segments = std::move(other.segments);
}

Path& Path::operator=(const Path& other) {
  segments.clear();
  for (const std::unique_ptr<ISegment>& segment : other.segments) {
    segments.emplace_back(segment->Clone());
  }
  return *this;
}

Path& Path::operator=(Path&& other) {
  if (this != &other) {
    segments = std::move(other.segments);
  }
  return *this;
}

std::wstring Path::ToWstring() const {
  std::vector<std::wstring> parts;
  parts.reserve(segments.size());

  for (const std::unique_ptr<ISegment>& segment : segments ) {
    parts.emplace_back(segment->ToWstring());
  }

  size_t size = 0;
  for (const std::wstring& part : parts) {
    size += part.size();
  }

  std::wstring result;
  result.reserve(size);
  for (const std::wstring& part : parts) {
    result.append(part);
  }

  return result;
}

// endregion struct Path

// endregion Pathing

// region Non-recursive iteration

// region Non-recursive iteration over IExtension

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverExtension : public impl::IIterator {
 public:
  IteratorOverExtension(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverExtension() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IExtension* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverExtension

IteratorOverExtension::IteratorOverExtension(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IExtension*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverExtension::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverExtension::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverExtension, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverExtension::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverExtension::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverExtension, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverExtension::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverExtension, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverExtension::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverExtension, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverExtension, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverExtension::Clone() const {
  return common::make_unique<IteratorOverExtension>(*this);
}

void IteratorOverExtension::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->semantic_id().has_value())) {
          state_ = 1;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 5;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 2: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 4;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        ++(*cursor_);

        state_ = 2;
        continue;
      }

      case 4: {
        cursor_.reset();
      }

      case 5: {
        if (!(casted_->refers_to().has_value())) {
          state_ = 9;
          continue;
        }

        property_ = Property::kRefersTo;

        cursor_ = 0;
      }

      case 6: {
        if (!(*cursor_ < casted_->refers_to()->size())) {
          state_ = 8;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_refers_to(
          *(casted_->refers_to())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_refers_to[*cursor_]
          )
        );
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        ++(*cursor_);

        state_ = 6;
        continue;
      }

      case 8: {
        cursor_.reset();
      }

      case 9: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 10;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IAdministrativeInformation

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverAdministrativeInformation : public impl::IIterator {
 public:
  IteratorOverAdministrativeInformation(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverAdministrativeInformation() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IAdministrativeInformation* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverAdministrativeInformation

IteratorOverAdministrativeInformation::IteratorOverAdministrativeInformation(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IAdministrativeInformation*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverAdministrativeInformation::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverAdministrativeInformation::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverAdministrativeInformation, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverAdministrativeInformation::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverAdministrativeInformation::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverAdministrativeInformation, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverAdministrativeInformation::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverAdministrativeInformation, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverAdministrativeInformation::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverAdministrativeInformation, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverAdministrativeInformation, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverAdministrativeInformation::Clone() const {
  return common::make_unique<IteratorOverAdministrativeInformation>(*this);
}

void IteratorOverAdministrativeInformation::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 4;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 1: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->creator().has_value())) {
          state_ = 5;
          continue;
        }

        property_ = Property::kCreator;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->creator())
          )
        );
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 6;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IQualifier

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverQualifier : public impl::IIterator {
 public:
  IteratorOverQualifier(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverQualifier() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IQualifier* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverQualifier

IteratorOverQualifier::IteratorOverQualifier(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IQualifier*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverQualifier::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverQualifier::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverQualifier, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverQualifier::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverQualifier::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverQualifier, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverQualifier::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverQualifier, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverQualifier::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverQualifier, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverQualifier, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverQualifier::Clone() const {
  return common::make_unique<IteratorOverQualifier>(*this);
}

void IteratorOverQualifier::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->semantic_id().has_value())) {
          state_ = 1;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 5;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 2: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 4;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        ++(*cursor_);

        state_ = 2;
        continue;
      }

      case 4: {
        cursor_.reset();
      }

      case 5: {
        if (!(casted_->value_id().has_value())) {
          state_ = 6;
          continue;
        }

        property_ = Property::kValueId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->value_id())
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 7;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IAssetAdministrationShell

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverAssetAdministrationShell : public impl::IIterator {
 public:
  IteratorOverAssetAdministrationShell(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverAssetAdministrationShell() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IAssetAdministrationShell* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverAssetAdministrationShell

IteratorOverAssetAdministrationShell::IteratorOverAssetAdministrationShell(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IAssetAdministrationShell*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverAssetAdministrationShell::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverAssetAdministrationShell::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverAssetAdministrationShell, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverAssetAdministrationShell::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverAssetAdministrationShell::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverAssetAdministrationShell, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverAssetAdministrationShell::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverAssetAdministrationShell, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverAssetAdministrationShell::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverAssetAdministrationShell, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverAssetAdministrationShell, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverAssetAdministrationShell::Clone() const {
  return common::make_unique<IteratorOverAssetAdministrationShell>(*this);
}

void IteratorOverAssetAdministrationShell::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->administration().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kAdministration;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->administration())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 17;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->derived_from().has_value())) {
          state_ = 18;
          continue;
        }

        property_ = Property::kDerivedFrom;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->derived_from())
          )
        );
        ++index_;

        state_ = 18;
        return;
      }

      case 18: {
        property_ = Property::kAssetInformation;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->asset_information()
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        if (!(casted_->submodels().has_value())) {
          state_ = 23;
          continue;
        }

        property_ = Property::kSubmodels;

        cursor_ = 0;
      }

      case 20: {
        if (!(*cursor_ < casted_->submodels()->size())) {
          state_ = 22;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_submodels(
          *(casted_->submodels())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_submodels[*cursor_]
          )
        );
        ++index_;

        state_ = 21;
        return;
      }

      case 21: {
        ++(*cursor_);

        state_ = 20;
        continue;
      }

      case 22: {
        cursor_.reset();
      }

      case 23: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 24;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IAssetInformation

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverAssetInformation : public impl::IIterator {
 public:
  IteratorOverAssetInformation(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverAssetInformation() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IAssetInformation* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverAssetInformation

IteratorOverAssetInformation::IteratorOverAssetInformation(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IAssetInformation*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverAssetInformation::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverAssetInformation::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverAssetInformation, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverAssetInformation::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverAssetInformation::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverAssetInformation, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverAssetInformation::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverAssetInformation, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverAssetInformation::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverAssetInformation, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverAssetInformation, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverAssetInformation::Clone() const {
  return common::make_unique<IteratorOverAssetInformation>(*this);
}

void IteratorOverAssetInformation::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->specific_asset_ids().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kSpecificAssetIds;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->specific_asset_ids()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ISpecificAssetId>
        >& the_specific_asset_ids(
          *(casted_->specific_asset_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_specific_asset_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->default_thumbnail().has_value())) {
          state_ = 5;
          continue;
        }

        property_ = Property::kDefaultThumbnail;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->default_thumbnail())
          )
        );
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 6;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

/**
 * This iterator is always done as IResource
 * references no other instances.
 */
class IteratorOverResource : public impl::IIterator {
 public:
  IteratorOverResource(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverResource, "
      "but the iterator is always done as "
      "IResource "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverResource, "
      "but the iterator is always done as "
      "IResource references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverResource>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverResource, "
      "but the iterator is always done as "
      "IResource references "
      "no other instances."
    );
  }

  ~IteratorOverResource() override = default;
};  // class IteratorOverResource

// region Non-recursive iteration over ISpecificAssetId

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverSpecificAssetId : public impl::IIterator {
 public:
  IteratorOverSpecificAssetId(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverSpecificAssetId() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::ISpecificAssetId* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverSpecificAssetId

IteratorOverSpecificAssetId::IteratorOverSpecificAssetId(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::ISpecificAssetId*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverSpecificAssetId::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverSpecificAssetId::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverSpecificAssetId, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverSpecificAssetId::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverSpecificAssetId::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverSpecificAssetId, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverSpecificAssetId::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverSpecificAssetId, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverSpecificAssetId::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverSpecificAssetId, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverSpecificAssetId, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverSpecificAssetId::Clone() const {
  return common::make_unique<IteratorOverSpecificAssetId>(*this);
}

void IteratorOverSpecificAssetId::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->semantic_id().has_value())) {
          state_ = 1;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 5;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 2: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 4;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        ++(*cursor_);

        state_ = 2;
        continue;
      }

      case 4: {
        cursor_.reset();
      }

      case 5: {
        if (!(casted_->external_subject_id().has_value())) {
          state_ = 6;
          continue;
        }

        property_ = Property::kExternalSubjectId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->external_subject_id())
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 7;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over ISubmodel

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverSubmodel : public impl::IIterator {
 public:
  IteratorOverSubmodel(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverSubmodel() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::ISubmodel* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverSubmodel

IteratorOverSubmodel::IteratorOverSubmodel(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::ISubmodel*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverSubmodel::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverSubmodel::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverSubmodel, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverSubmodel::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverSubmodel::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverSubmodel, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverSubmodel::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverSubmodel, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverSubmodel::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverSubmodel, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverSubmodel, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverSubmodel::Clone() const {
  return common::make_unique<IteratorOverSubmodel>(*this);
}

void IteratorOverSubmodel::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->administration().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kAdministration;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->administration())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 14;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 18;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 15: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 17;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 16;
        return;
      }

      case 16: {
        ++(*cursor_);

        state_ = 15;
        continue;
      }

      case 17: {
        cursor_.reset();
      }

      case 18: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 22;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 19: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 21;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 20;
        return;
      }

      case 20: {
        ++(*cursor_);

        state_ = 19;
        continue;
      }

      case 21: {
        cursor_.reset();
      }

      case 22: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 26;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 23: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 25;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 24;
        return;
      }

      case 24: {
        ++(*cursor_);

        state_ = 23;
        continue;
      }

      case 25: {
        cursor_.reset();
      }

      case 26: {
        if (!(casted_->submodel_elements().has_value())) {
          state_ = 30;
          continue;
        }

        property_ = Property::kSubmodelElements;

        cursor_ = 0;
      }

      case 27: {
        if (!(*cursor_ < casted_->submodel_elements()->size())) {
          state_ = 29;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ISubmodelElement>
        >& the_submodel_elements(
          *(casted_->submodel_elements())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_submodel_elements[*cursor_]
          )
        );
        ++index_;

        state_ = 28;
        return;
      }

      case 28: {
        ++(*cursor_);

        state_ = 27;
        continue;
      }

      case 29: {
        cursor_.reset();
      }

      case 30: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 31;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IRelationshipElement

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverRelationshipElement : public impl::IIterator {
 public:
  IteratorOverRelationshipElement(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverRelationshipElement() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IRelationshipElement* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverRelationshipElement

IteratorOverRelationshipElement::IteratorOverRelationshipElement(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IRelationshipElement*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverRelationshipElement::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverRelationshipElement::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverRelationshipElement, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverRelationshipElement::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverRelationshipElement::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverRelationshipElement, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverRelationshipElement::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverRelationshipElement, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverRelationshipElement::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverRelationshipElement, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverRelationshipElement, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverRelationshipElement::Clone() const {
  return common::make_unique<IteratorOverRelationshipElement>(*this);
}

void IteratorOverRelationshipElement::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        property_ = Property::kFirst;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->first()
          )
        );
        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        property_ = Property::kSecond;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->second()
          )
        );
        ++index_;

        state_ = 27;
        return;
      }

      case 27: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 28;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over ISubmodelElementList

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverSubmodelElementList : public impl::IIterator {
 public:
  IteratorOverSubmodelElementList(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverSubmodelElementList() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::ISubmodelElementList* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverSubmodelElementList

IteratorOverSubmodelElementList::IteratorOverSubmodelElementList(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::ISubmodelElementList*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverSubmodelElementList::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverSubmodelElementList::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverSubmodelElementList, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverSubmodelElementList::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverSubmodelElementList::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverSubmodelElementList, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverSubmodelElementList::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverSubmodelElementList, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverSubmodelElementList::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverSubmodelElementList, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverSubmodelElementList, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverSubmodelElementList::Clone() const {
  return common::make_unique<IteratorOverSubmodelElementList>(*this);
}

void IteratorOverSubmodelElementList::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        if (!(casted_->semantic_id_list_element().has_value())) {
          state_ = 26;
          continue;
        }

        property_ = Property::kSemanticIdListElement;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id_list_element())
          )
        );
        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        if (!(casted_->value().has_value())) {
          state_ = 30;
          continue;
        }

        property_ = Property::kValue;

        cursor_ = 0;
      }

      case 27: {
        if (!(*cursor_ < casted_->value()->size())) {
          state_ = 29;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ISubmodelElement>
        >& the_value(
          *(casted_->value())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_value[*cursor_]
          )
        );
        ++index_;

        state_ = 28;
        return;
      }

      case 28: {
        ++(*cursor_);

        state_ = 27;
        continue;
      }

      case 29: {
        cursor_.reset();
      }

      case 30: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 31;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over ISubmodelElementCollection

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverSubmodelElementCollection : public impl::IIterator {
 public:
  IteratorOverSubmodelElementCollection(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverSubmodelElementCollection() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::ISubmodelElementCollection* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverSubmodelElementCollection

IteratorOverSubmodelElementCollection::IteratorOverSubmodelElementCollection(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::ISubmodelElementCollection*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverSubmodelElementCollection::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverSubmodelElementCollection::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverSubmodelElementCollection, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverSubmodelElementCollection::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverSubmodelElementCollection::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverSubmodelElementCollection, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverSubmodelElementCollection::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverSubmodelElementCollection, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverSubmodelElementCollection::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverSubmodelElementCollection, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverSubmodelElementCollection, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverSubmodelElementCollection::Clone() const {
  return common::make_unique<IteratorOverSubmodelElementCollection>(*this);
}

void IteratorOverSubmodelElementCollection::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        if (!(casted_->value().has_value())) {
          state_ = 29;
          continue;
        }

        property_ = Property::kValue;

        cursor_ = 0;
      }

      case 26: {
        if (!(*cursor_ < casted_->value()->size())) {
          state_ = 28;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ISubmodelElement>
        >& the_value(
          *(casted_->value())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_value[*cursor_]
          )
        );
        ++index_;

        state_ = 27;
        return;
      }

      case 27: {
        ++(*cursor_);

        state_ = 26;
        continue;
      }

      case 28: {
        cursor_.reset();
      }

      case 29: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 30;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IProperty

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverProperty : public impl::IIterator {
 public:
  IteratorOverProperty(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverProperty() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IProperty* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverProperty

IteratorOverProperty::IteratorOverProperty(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IProperty*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverProperty::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverProperty::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverProperty, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverProperty::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverProperty::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverProperty, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverProperty::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverProperty, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverProperty::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverProperty, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverProperty, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverProperty::Clone() const {
  return common::make_unique<IteratorOverProperty>(*this);
}

void IteratorOverProperty::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        if (!(casted_->value_id().has_value())) {
          state_ = 26;
          continue;
        }

        property_ = Property::kValueId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->value_id())
          )
        );
        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 27;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IMultiLanguageProperty

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverMultiLanguageProperty : public impl::IIterator {
 public:
  IteratorOverMultiLanguageProperty(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverMultiLanguageProperty() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IMultiLanguageProperty* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverMultiLanguageProperty

IteratorOverMultiLanguageProperty::IteratorOverMultiLanguageProperty(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IMultiLanguageProperty*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverMultiLanguageProperty::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverMultiLanguageProperty::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverMultiLanguageProperty, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverMultiLanguageProperty::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverMultiLanguageProperty::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverMultiLanguageProperty, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverMultiLanguageProperty::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverMultiLanguageProperty, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverMultiLanguageProperty::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverMultiLanguageProperty, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverMultiLanguageProperty, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverMultiLanguageProperty::Clone() const {
  return common::make_unique<IteratorOverMultiLanguageProperty>(*this);
}

void IteratorOverMultiLanguageProperty::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        if (!(casted_->value().has_value())) {
          state_ = 29;
          continue;
        }

        property_ = Property::kValue;

        cursor_ = 0;
      }

      case 26: {
        if (!(*cursor_ < casted_->value()->size())) {
          state_ = 28;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_value(
          *(casted_->value())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_value[*cursor_]
          )
        );
        ++index_;

        state_ = 27;
        return;
      }

      case 27: {
        ++(*cursor_);

        state_ = 26;
        continue;
      }

      case 28: {
        cursor_.reset();
      }

      case 29: {
        if (!(casted_->value_id().has_value())) {
          state_ = 30;
          continue;
        }

        property_ = Property::kValueId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->value_id())
          )
        );
        ++index_;

        state_ = 30;
        return;
      }

      case 30: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 31;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IRange

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverRange : public impl::IIterator {
 public:
  IteratorOverRange(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverRange() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IRange* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverRange

IteratorOverRange::IteratorOverRange(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IRange*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverRange::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverRange::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverRange, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverRange::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverRange::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverRange, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverRange::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverRange, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverRange::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverRange, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverRange, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverRange::Clone() const {
  return common::make_unique<IteratorOverRange>(*this);
}

void IteratorOverRange::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 26;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IReferenceElement

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverReferenceElement : public impl::IIterator {
 public:
  IteratorOverReferenceElement(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverReferenceElement() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IReferenceElement* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverReferenceElement

IteratorOverReferenceElement::IteratorOverReferenceElement(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IReferenceElement*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverReferenceElement::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverReferenceElement::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverReferenceElement, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverReferenceElement::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverReferenceElement::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverReferenceElement, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverReferenceElement::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverReferenceElement, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverReferenceElement::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverReferenceElement, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverReferenceElement, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverReferenceElement::Clone() const {
  return common::make_unique<IteratorOverReferenceElement>(*this);
}

void IteratorOverReferenceElement::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        if (!(casted_->value().has_value())) {
          state_ = 26;
          continue;
        }

        property_ = Property::kValue;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->value())
          )
        );
        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 27;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IBlob

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverBlob : public impl::IIterator {
 public:
  IteratorOverBlob(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverBlob() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IBlob* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverBlob

IteratorOverBlob::IteratorOverBlob(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IBlob*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverBlob::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverBlob::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverBlob, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverBlob::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverBlob::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverBlob, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverBlob::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverBlob, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverBlob::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverBlob, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverBlob, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverBlob::Clone() const {
  return common::make_unique<IteratorOverBlob>(*this);
}

void IteratorOverBlob::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 26;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IFile

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverFile : public impl::IIterator {
 public:
  IteratorOverFile(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverFile() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IFile* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverFile

IteratorOverFile::IteratorOverFile(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IFile*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverFile::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverFile::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverFile, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverFile::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverFile::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverFile, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverFile::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverFile, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverFile::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverFile, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverFile, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverFile::Clone() const {
  return common::make_unique<IteratorOverFile>(*this);
}

void IteratorOverFile::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 26;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IAnnotatedRelationshipElement

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverAnnotatedRelationshipElement : public impl::IIterator {
 public:
  IteratorOverAnnotatedRelationshipElement(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverAnnotatedRelationshipElement() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IAnnotatedRelationshipElement* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverAnnotatedRelationshipElement

IteratorOverAnnotatedRelationshipElement::IteratorOverAnnotatedRelationshipElement(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IAnnotatedRelationshipElement*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverAnnotatedRelationshipElement::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverAnnotatedRelationshipElement::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverAnnotatedRelationshipElement, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverAnnotatedRelationshipElement::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverAnnotatedRelationshipElement::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverAnnotatedRelationshipElement, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverAnnotatedRelationshipElement::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverAnnotatedRelationshipElement, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverAnnotatedRelationshipElement::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverAnnotatedRelationshipElement, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverAnnotatedRelationshipElement, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverAnnotatedRelationshipElement::Clone() const {
  return common::make_unique<IteratorOverAnnotatedRelationshipElement>(*this);
}

void IteratorOverAnnotatedRelationshipElement::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        property_ = Property::kFirst;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->first()
          )
        );
        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        property_ = Property::kSecond;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->second()
          )
        );
        ++index_;

        state_ = 27;
        return;
      }

      case 27: {
        if (!(casted_->annotations().has_value())) {
          state_ = 31;
          continue;
        }

        property_ = Property::kAnnotations;

        cursor_ = 0;
      }

      case 28: {
        if (!(*cursor_ < casted_->annotations()->size())) {
          state_ = 30;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IDataElement>
        >& the_annotations(
          *(casted_->annotations())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_annotations[*cursor_]
          )
        );
        ++index_;

        state_ = 29;
        return;
      }

      case 29: {
        ++(*cursor_);

        state_ = 28;
        continue;
      }

      case 30: {
        cursor_.reset();
      }

      case 31: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 32;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IEntity

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverEntity : public impl::IIterator {
 public:
  IteratorOverEntity(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverEntity() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IEntity* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverEntity

IteratorOverEntity::IteratorOverEntity(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IEntity*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverEntity::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverEntity::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverEntity, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverEntity::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverEntity::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverEntity, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverEntity::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverEntity, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverEntity::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverEntity, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverEntity, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverEntity::Clone() const {
  return common::make_unique<IteratorOverEntity>(*this);
}

void IteratorOverEntity::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        if (!(casted_->statements().has_value())) {
          state_ = 29;
          continue;
        }

        property_ = Property::kStatements;

        cursor_ = 0;
      }

      case 26: {
        if (!(*cursor_ < casted_->statements()->size())) {
          state_ = 28;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ISubmodelElement>
        >& the_statements(
          *(casted_->statements())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_statements[*cursor_]
          )
        );
        ++index_;

        state_ = 27;
        return;
      }

      case 27: {
        ++(*cursor_);

        state_ = 26;
        continue;
      }

      case 28: {
        cursor_.reset();
      }

      case 29: {
        if (!(casted_->specific_asset_ids().has_value())) {
          state_ = 33;
          continue;
        }

        property_ = Property::kSpecificAssetIds;

        cursor_ = 0;
      }

      case 30: {
        if (!(*cursor_ < casted_->specific_asset_ids()->size())) {
          state_ = 32;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ISpecificAssetId>
        >& the_specific_asset_ids(
          *(casted_->specific_asset_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_specific_asset_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 31;
        return;
      }

      case 31: {
        ++(*cursor_);

        state_ = 30;
        continue;
      }

      case 32: {
        cursor_.reset();
      }

      case 33: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 34;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IEventPayload

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverEventPayload : public impl::IIterator {
 public:
  IteratorOverEventPayload(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverEventPayload() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IEventPayload* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverEventPayload

IteratorOverEventPayload::IteratorOverEventPayload(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IEventPayload*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverEventPayload::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverEventPayload::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverEventPayload, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverEventPayload::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverEventPayload::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverEventPayload, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverEventPayload::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverEventPayload, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverEventPayload::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverEventPayload, "
      "but the iterator was done."
    );
  }

  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverEventPayload, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverEventPayload::Clone() const {
  return common::make_unique<IteratorOverEventPayload>(*this);
}

void IteratorOverEventPayload::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        property_ = Property::kSource;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->source()
          )
        );
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (!(casted_->source_semantic_id().has_value())) {
          state_ = 2;
          continue;
        }

        property_ = Property::kSourceSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->source_semantic_id())
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        property_ = Property::kObservableReference;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->observable_reference()
          )
        );
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (!(casted_->observable_semantic_id().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kObservableSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->observable_semantic_id())
          )
        );
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (!(casted_->subject_id().has_value())) {
          state_ = 5;
          continue;
        }

        property_ = Property::kSubjectId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->subject_id())
          )
        );
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 6;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IBasicEventElement

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverBasicEventElement : public impl::IIterator {
 public:
  IteratorOverBasicEventElement(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverBasicEventElement() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IBasicEventElement* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverBasicEventElement

IteratorOverBasicEventElement::IteratorOverBasicEventElement(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IBasicEventElement*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverBasicEventElement::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverBasicEventElement::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverBasicEventElement, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverBasicEventElement::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverBasicEventElement::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverBasicEventElement, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverBasicEventElement::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverBasicEventElement, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverBasicEventElement::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverBasicEventElement, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverBasicEventElement, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverBasicEventElement::Clone() const {
  return common::make_unique<IteratorOverBasicEventElement>(*this);
}

void IteratorOverBasicEventElement::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        property_ = Property::kObserved;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->observed()
          )
        );
        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        if (!(casted_->message_broker().has_value())) {
          state_ = 27;
          continue;
        }

        property_ = Property::kMessageBroker;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->message_broker())
          )
        );
        ++index_;

        state_ = 27;
        return;
      }

      case 27: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 28;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IOperation

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverOperation : public impl::IIterator {
 public:
  IteratorOverOperation(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverOperation() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IOperation* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverOperation

IteratorOverOperation::IteratorOverOperation(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IOperation*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverOperation::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverOperation::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverOperation, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverOperation::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverOperation::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverOperation, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverOperation::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverOperation, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverOperation::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverOperation, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverOperation, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverOperation::Clone() const {
  return common::make_unique<IteratorOverOperation>(*this);
}

void IteratorOverOperation::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        if (!(casted_->input_variables().has_value())) {
          state_ = 29;
          continue;
        }

        property_ = Property::kInputVariables;

        cursor_ = 0;
      }

      case 26: {
        if (!(*cursor_ < casted_->input_variables()->size())) {
          state_ = 28;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IOperationVariable>
        >& the_input_variables(
          *(casted_->input_variables())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_input_variables[*cursor_]
          )
        );
        ++index_;

        state_ = 27;
        return;
      }

      case 27: {
        ++(*cursor_);

        state_ = 26;
        continue;
      }

      case 28: {
        cursor_.reset();
      }

      case 29: {
        if (!(casted_->output_variables().has_value())) {
          state_ = 33;
          continue;
        }

        property_ = Property::kOutputVariables;

        cursor_ = 0;
      }

      case 30: {
        if (!(*cursor_ < casted_->output_variables()->size())) {
          state_ = 32;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IOperationVariable>
        >& the_output_variables(
          *(casted_->output_variables())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_output_variables[*cursor_]
          )
        );
        ++index_;

        state_ = 31;
        return;
      }

      case 31: {
        ++(*cursor_);

        state_ = 30;
        continue;
      }

      case 32: {
        cursor_.reset();
      }

      case 33: {
        if (!(casted_->inoutput_variables().has_value())) {
          state_ = 37;
          continue;
        }

        property_ = Property::kInoutputVariables;

        cursor_ = 0;
      }

      case 34: {
        if (!(*cursor_ < casted_->inoutput_variables()->size())) {
          state_ = 36;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IOperationVariable>
        >& the_inoutput_variables(
          *(casted_->inoutput_variables())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_inoutput_variables[*cursor_]
          )
        );
        ++index_;

        state_ = 35;
        return;
      }

      case 35: {
        ++(*cursor_);

        state_ = 34;
        continue;
      }

      case 36: {
        cursor_.reset();
      }

      case 37: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 38;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IOperationVariable

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverOperationVariable : public impl::IIterator {
 public:
  IteratorOverOperationVariable(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverOperationVariable() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IOperationVariable* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverOperationVariable

IteratorOverOperationVariable::IteratorOverOperationVariable(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IOperationVariable*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverOperationVariable::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverOperationVariable::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverOperationVariable, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverOperationVariable::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverOperationVariable::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverOperationVariable, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverOperationVariable::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverOperationVariable, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverOperationVariable::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverOperationVariable, "
      "but the iterator was done."
    );
  }

  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverOperationVariable, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverOperationVariable::Clone() const {
  return common::make_unique<IteratorOverOperationVariable>(*this);
}

void IteratorOverOperationVariable::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        property_ = Property::kValue;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->value()
          )
        );
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 2;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over ICapability

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverCapability : public impl::IIterator {
 public:
  IteratorOverCapability(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverCapability() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::ICapability* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverCapability

IteratorOverCapability::IteratorOverCapability(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::ICapability*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverCapability::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverCapability::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverCapability, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverCapability::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverCapability::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverCapability, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverCapability::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverCapability, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverCapability::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverCapability, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverCapability, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverCapability::Clone() const {
  return common::make_unique<IteratorOverCapability>(*this);
}

void IteratorOverCapability::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->semantic_id().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->semantic_id())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->supplemental_semantic_ids().has_value())) {
          state_ = 17;
          continue;
        }

        property_ = Property::kSupplementalSemanticIds;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->supplemental_semantic_ids()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_supplemental_semantic_ids(
          *(casted_->supplemental_semantic_ids())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_supplemental_semantic_ids[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->qualifiers().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kQualifiers;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->qualifiers()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IQualifier>
        >& the_qualifiers(
          *(casted_->qualifiers())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_qualifiers[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 25;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 22: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 24;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        ++(*cursor_);

        state_ = 22;
        continue;
      }

      case 24: {
        cursor_.reset();
      }

      case 25: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 26;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IConceptDescription

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverConceptDescription : public impl::IIterator {
 public:
  IteratorOverConceptDescription(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverConceptDescription() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IConceptDescription* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverConceptDescription

IteratorOverConceptDescription::IteratorOverConceptDescription(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IConceptDescription*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverConceptDescription::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverConceptDescription::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverConceptDescription, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverConceptDescription::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverConceptDescription::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverConceptDescription, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverConceptDescription::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverConceptDescription, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverConceptDescription::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverConceptDescription, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverConceptDescription, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverConceptDescription::Clone() const {
  return common::make_unique<IteratorOverConceptDescription>(*this);
}

void IteratorOverConceptDescription::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->extensions().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kExtensions;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->extensions()->size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IExtension>
        >& the_extensions(
          *(casted_->extensions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_extensions[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->display_name().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kDisplayName;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->display_name()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringNameType>
        >& the_display_name(
          *(casted_->display_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_display_name[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->description().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDescription;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->description()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringTextType>
        >& the_description(
          *(casted_->description())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_description[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->administration().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kAdministration;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->administration())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(casted_->embedded_data_specifications().has_value())
        ) {
          state_ = 17;
          continue;
        }

        property_ = Property::kEmbeddedDataSpecifications;

        cursor_ = 0;
      }

      case 14: {
        if (
          !(*cursor_ < casted_->embedded_data_specifications()->size())
        ) {
          state_ = 16;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IEmbeddedDataSpecification>
        >& the_embedded_data_specifications(
          *(casted_->embedded_data_specifications())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_embedded_data_specifications[*cursor_]
          )
        );
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        ++(*cursor_);

        state_ = 14;
        continue;
      }

      case 16: {
        cursor_.reset();
      }

      case 17: {
        if (!(casted_->is_case_of().has_value())) {
          state_ = 21;
          continue;
        }

        property_ = Property::kIsCaseOf;

        cursor_ = 0;
      }

      case 18: {
        if (!(*cursor_ < casted_->is_case_of()->size())) {
          state_ = 20;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IReference>
        >& the_is_case_of(
          *(casted_->is_case_of())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_is_case_of[*cursor_]
          )
        );
        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        ++(*cursor_);

        state_ = 18;
        continue;
      }

      case 20: {
        cursor_.reset();
      }

      case 21: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 22;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IReference

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverReference : public impl::IIterator {
 public:
  IteratorOverReference(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverReference() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IReference* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverReference

IteratorOverReference::IteratorOverReference(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IReference*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverReference::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverReference::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverReference, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverReference::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverReference::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverReference, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverReference::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverReference, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverReference::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverReference, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverReference, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverReference::Clone() const {
  return common::make_unique<IteratorOverReference>(*this);
}

void IteratorOverReference::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->referred_semantic_id().has_value())) {
          state_ = 1;
          continue;
        }

        property_ = Property::kReferredSemanticId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->referred_semantic_id())
          )
        );
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        property_ = Property::kKeys;

        cursor_ = 0;
      }

      case 2: {
        if (!(*cursor_ < casted_->keys().size())) {
          state_ = 4;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IKey>
        >& the_keys(
          casted_->keys()
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_keys[*cursor_]
          )
        );
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        ++(*cursor_);

        state_ = 2;
        continue;
      }

      case 4: {
        cursor_.reset();

        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 5;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

/**
 * This iterator is always done as IKey
 * references no other instances.
 */
class IteratorOverKey : public impl::IIterator {
 public:
  IteratorOverKey(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverKey, "
      "but the iterator is always done as "
      "IKey "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverKey, "
      "but the iterator is always done as "
      "IKey references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverKey>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverKey, "
      "but the iterator is always done as "
      "IKey references "
      "no other instances."
    );
  }

  ~IteratorOverKey() override = default;
};  // class IteratorOverKey

/**
 * This iterator is always done as ILangStringNameType
 * references no other instances.
 */
class IteratorOverLangStringNameType : public impl::IIterator {
 public:
  IteratorOverLangStringNameType(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverLangStringNameType, "
      "but the iterator is always done as "
      "ILangStringNameType "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverLangStringNameType, "
      "but the iterator is always done as "
      "ILangStringNameType references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverLangStringNameType>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverLangStringNameType, "
      "but the iterator is always done as "
      "ILangStringNameType references "
      "no other instances."
    );
  }

  ~IteratorOverLangStringNameType() override = default;
};  // class IteratorOverLangStringNameType

/**
 * This iterator is always done as ILangStringTextType
 * references no other instances.
 */
class IteratorOverLangStringTextType : public impl::IIterator {
 public:
  IteratorOverLangStringTextType(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverLangStringTextType, "
      "but the iterator is always done as "
      "ILangStringTextType "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverLangStringTextType, "
      "but the iterator is always done as "
      "ILangStringTextType references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverLangStringTextType>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverLangStringTextType, "
      "but the iterator is always done as "
      "ILangStringTextType references "
      "no other instances."
    );
  }

  ~IteratorOverLangStringTextType() override = default;
};  // class IteratorOverLangStringTextType

// region Non-recursive iteration over IEnvironment

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverEnvironment : public impl::IIterator {
 public:
  IteratorOverEnvironment(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverEnvironment() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IEnvironment* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverEnvironment

IteratorOverEnvironment::IteratorOverEnvironment(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IEnvironment*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverEnvironment::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverEnvironment::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverEnvironment, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverEnvironment::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverEnvironment::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverEnvironment, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverEnvironment::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverEnvironment, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverEnvironment::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverEnvironment, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverEnvironment, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverEnvironment::Clone() const {
  return common::make_unique<IteratorOverEnvironment>(*this);
}

void IteratorOverEnvironment::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        if (!(casted_->asset_administration_shells().has_value())) {
          state_ = 4;
          continue;
        }

        property_ = Property::kAssetAdministrationShells;

        cursor_ = 0;
      }

      case 1: {
        if (
          !(*cursor_ < casted_->asset_administration_shells()->size())
        ) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IAssetAdministrationShell>
        >& the_asset_administration_shells(
          *(casted_->asset_administration_shells())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_asset_administration_shells[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();
      }

      case 4: {
        if (!(casted_->submodels().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kSubmodels;

        cursor_ = 0;
      }

      case 5: {
        if (!(*cursor_ < casted_->submodels()->size())) {
          state_ = 7;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ISubmodel>
        >& the_submodels(
          *(casted_->submodels())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_submodels[*cursor_]
          )
        );
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        ++(*cursor_);

        state_ = 5;
        continue;
      }

      case 7: {
        cursor_.reset();
      }

      case 8: {
        if (!(casted_->concept_descriptions().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kConceptDescriptions;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->concept_descriptions()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IConceptDescription>
        >& the_concept_descriptions(
          *(casted_->concept_descriptions())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_concept_descriptions[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 13;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IEmbeddedDataSpecification

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverEmbeddedDataSpecification : public impl::IIterator {
 public:
  IteratorOverEmbeddedDataSpecification(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverEmbeddedDataSpecification() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IEmbeddedDataSpecification* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverEmbeddedDataSpecification

IteratorOverEmbeddedDataSpecification::IteratorOverEmbeddedDataSpecification(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IEmbeddedDataSpecification*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverEmbeddedDataSpecification::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverEmbeddedDataSpecification::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverEmbeddedDataSpecification, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverEmbeddedDataSpecification::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverEmbeddedDataSpecification::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverEmbeddedDataSpecification, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverEmbeddedDataSpecification::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverEmbeddedDataSpecification, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverEmbeddedDataSpecification::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverEmbeddedDataSpecification, "
      "but the iterator was done."
    );
  }

  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverEmbeddedDataSpecification, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverEmbeddedDataSpecification::Clone() const {
  return common::make_unique<IteratorOverEmbeddedDataSpecification>(*this);
}

void IteratorOverEmbeddedDataSpecification::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        property_ = Property::kDataSpecification;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->data_specification()
          )
        );
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        property_ = Property::kDataSpecificationContent;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->data_specification_content()
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 3;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

/**
 * This iterator is always done as ILevelType
 * references no other instances.
 */
class IteratorOverLevelType : public impl::IIterator {
 public:
  IteratorOverLevelType(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverLevelType, "
      "but the iterator is always done as "
      "ILevelType "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverLevelType, "
      "but the iterator is always done as "
      "ILevelType references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverLevelType>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverLevelType, "
      "but the iterator is always done as "
      "ILevelType references "
      "no other instances."
    );
  }

  ~IteratorOverLevelType() override = default;
};  // class IteratorOverLevelType

// region Non-recursive iteration over IValueReferencePair

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverValueReferencePair : public impl::IIterator {
 public:
  IteratorOverValueReferencePair(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverValueReferencePair() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IValueReferencePair* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverValueReferencePair

IteratorOverValueReferencePair::IteratorOverValueReferencePair(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IValueReferencePair*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverValueReferencePair::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverValueReferencePair::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverValueReferencePair, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverValueReferencePair::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverValueReferencePair::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverValueReferencePair, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverValueReferencePair::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverValueReferencePair, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverValueReferencePair::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverValueReferencePair, "
      "but the iterator was done."
    );
  }

  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverValueReferencePair, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverValueReferencePair::Clone() const {
  return common::make_unique<IteratorOverValueReferencePair>(*this);
}

void IteratorOverValueReferencePair::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        property_ = Property::kValueId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            casted_->value_id()
          )
        );
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 2;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

// region Non-recursive iteration over IValueList

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverValueList : public impl::IIterator {
 public:
  IteratorOverValueList(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverValueList() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IValueList* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverValueList

IteratorOverValueList::IteratorOverValueList(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IValueList*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverValueList::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverValueList::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverValueList, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverValueList::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverValueList::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverValueList, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverValueList::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverValueList, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverValueList::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverValueList, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverValueList, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverValueList::Clone() const {
  return common::make_unique<IteratorOverValueList>(*this);
}

void IteratorOverValueList::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        property_ = Property::kValueReferencePairs;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->value_reference_pairs().size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::IValueReferencePair>
        >& the_value_reference_pairs(
          casted_->value_reference_pairs()
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_value_reference_pairs[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();

        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

/**
 * This iterator is always done as ILangStringPreferredNameTypeIec61360
 * references no other instances.
 */
class IteratorOverLangStringPreferredNameTypeIec61360 : public impl::IIterator {
 public:
  IteratorOverLangStringPreferredNameTypeIec61360(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverLangStringPreferredNameTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringPreferredNameTypeIec61360 "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverLangStringPreferredNameTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringPreferredNameTypeIec61360 references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverLangStringPreferredNameTypeIec61360>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverLangStringPreferredNameTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringPreferredNameTypeIec61360 references "
      "no other instances."
    );
  }

  ~IteratorOverLangStringPreferredNameTypeIec61360() override = default;
};  // class IteratorOverLangStringPreferredNameTypeIec61360

/**
 * This iterator is always done as ILangStringShortNameTypeIec61360
 * references no other instances.
 */
class IteratorOverLangStringShortNameTypeIec61360 : public impl::IIterator {
 public:
  IteratorOverLangStringShortNameTypeIec61360(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverLangStringShortNameTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringShortNameTypeIec61360 "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverLangStringShortNameTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringShortNameTypeIec61360 references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverLangStringShortNameTypeIec61360>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverLangStringShortNameTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringShortNameTypeIec61360 references "
      "no other instances."
    );
  }

  ~IteratorOverLangStringShortNameTypeIec61360() override = default;
};  // class IteratorOverLangStringShortNameTypeIec61360

/**
 * This iterator is always done as ILangStringDefinitionTypeIec61360
 * references no other instances.
 */
class IteratorOverLangStringDefinitionTypeIec61360 : public impl::IIterator {
 public:
  IteratorOverLangStringDefinitionTypeIec61360(
    const std::shared_ptr<types::IClass>&
  ) {
    // Intentionally empty.
  }

  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move "
      "an IteratorOverLangStringDefinitionTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringDefinitionTypeIec61360 "
      "references no other instances."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an IteratorOverLangStringDefinitionTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringDefinitionTypeIec61360 references "
      "no other instances."
    );
  }

  long Index() const override {
    return -1;
  }

  std::unique_ptr<impl::IIterator> Clone() const override {
    return common::make_unique<IteratorOverLangStringDefinitionTypeIec61360>(*this);
  }

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an IteratorOverLangStringDefinitionTypeIec61360, "
      "but the iterator is always done as "
      "ILangStringDefinitionTypeIec61360 references "
      "no other instances."
    );
  }

  ~IteratorOverLangStringDefinitionTypeIec61360() override = default;
};  // class IteratorOverLangStringDefinitionTypeIec61360

// region Non-recursive iteration over IDataSpecificationIec61360

/**
 * Iterate non-recursively over the instances referenced from an instance.
 */
class IteratorOverDataSpecificationIec61360 : public impl::IIterator {
 public:
  IteratorOverDataSpecificationIec61360(
    const std::shared_ptr<types::IClass>& instance
  );
  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~IteratorOverDataSpecificationIec61360() override = default;

 private:
  // We make instance_ a pointer, so that we can follow the rule-of-zero.
  const std::shared_ptr<types::IClass>* instance_;
  // We make casted_ a pointer, so that we can follow the rule-of-zero.
  const types::IDataSpecificationIec61360* casted_;
  std::uint32_t state_;
  common::optional<Property> property_;
  common::optional<size_t> cursor_;  // in yield-from loops
  std::shared_ptr<types::IClass> item_;
  long index_;  // in total iteration
  bool done_;

  void Execute();
};  // class IteratorOverDataSpecificationIec61360

IteratorOverDataSpecificationIec61360::IteratorOverDataSpecificationIec61360(
  const std::shared_ptr<types::IClass>& instance
) :
  instance_(&instance),
  // NOTE (mristin):
  // The dynamic cast is necessary due to virtual inheritance. Otherwise,
  // we would have used static cast.
  casted_(
    dynamic_cast<types::IDataSpecificationIec61360*>(
      instance.get()
    )
  ) {
  // Intentionally empty.
}

void IteratorOverDataSpecificationIec61360::Start() {
  state_ = 0;
  Execute();
}

void IteratorOverDataSpecificationIec61360::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move IteratorOverDataSpecificationIec61360, "
      "but it was done."
    );
  }
  #endif

  Execute();
}

bool IteratorOverDataSpecificationIec61360::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& IteratorOverDataSpecificationIec61360::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from IteratorOverDataSpecificationIec61360, "
      "but the iterator was done."
    );
  }
  #endif

  return item_;
}

long IteratorOverDataSpecificationIec61360::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done IteratorOverDataSpecificationIec61360, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void IteratorOverDataSpecificationIec61360::PrependToPath(
  Path* path
) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverDataSpecificationIec61360, "
      "but the iterator was done."
    );
  }
  #endif

  if (cursor_.has_value()) {
    path->segments.emplace_front(
      common::make_unique<IndexSegment>(*cursor_)
    );
  }

  #ifdef DEBUG
  if (!property_.has_value()) {
    throw std::logic_error(
      "You want to prepend to path from IteratorOverDataSpecificationIec61360, "
      "but the property_ has not been set to a value."
    );
  }
  #endif

  path->segments.emplace_front(
    common::make_unique<PropertySegment>(*property_)
  );
}

std::unique_ptr<impl::IIterator> IteratorOverDataSpecificationIec61360::Clone() const {
  return common::make_unique<IteratorOverDataSpecificationIec61360>(*this);
}

void IteratorOverDataSpecificationIec61360::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        property_.reset();
        item_ = nullptr;
        index_ = -1;
        done_ = false;

        cursor_.reset();

        property_ = Property::kPreferredName;

        cursor_ = 0;
      }

      case 1: {
        if (!(*cursor_ < casted_->preferred_name().size())) {
          state_ = 3;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>
        >& the_preferred_name(
          casted_->preferred_name()
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_preferred_name[*cursor_]
          )
        );
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        ++(*cursor_);

        state_ = 1;
        continue;
      }

      case 3: {
        cursor_.reset();

        if (!(casted_->short_name().has_value())) {
          state_ = 7;
          continue;
        }

        property_ = Property::kShortName;

        cursor_ = 0;
      }

      case 4: {
        if (!(*cursor_ < casted_->short_name()->size())) {
          state_ = 6;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringShortNameTypeIec61360>
        >& the_short_name(
          *(casted_->short_name())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_short_name[*cursor_]
          )
        );
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        ++(*cursor_);

        state_ = 4;
        continue;
      }

      case 6: {
        cursor_.reset();
      }

      case 7: {
        if (!(casted_->unit_id().has_value())) {
          state_ = 8;
          continue;
        }

        property_ = Property::kUnitId;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->unit_id())
          )
        );
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (!(casted_->definition().has_value())) {
          state_ = 12;
          continue;
        }

        property_ = Property::kDefinition;

        cursor_ = 0;
      }

      case 9: {
        if (!(*cursor_ < casted_->definition()->size())) {
          state_ = 11;
          continue;
        }

        const std::vector<
          std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
        >& the_definition(
          *(casted_->definition())
        );

        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            the_definition[*cursor_]
          )
        );
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        ++(*cursor_);

        state_ = 9;
        continue;
      }

      case 11: {
        cursor_.reset();
      }

      case 12: {
        if (!(casted_->value_list().has_value())) {
          state_ = 13;
          continue;
        }

        property_ = Property::kValueList;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->value_list())
          )
        );
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(casted_->level_type().has_value())) {
          state_ = 14;
          continue;
        }

        property_ = Property::kLevelType;
        item_ = std::move(
          std::static_pointer_cast<types::IClass>(
            *(casted_->level_type())
          )
        );
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 15;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion

/**
 * This iterator is always done.
 *
 * It is used for efficient comparisons against end-of-descent.
 */
class AlwaysDoneIterator : public impl::IIterator {
 public:
  void Start() override {
    // Intentionally empty.
  }

  void Next() override {
    throw std::logic_error(
      "You want to move an AlwaysDoneIterator, "
      "but the iterator is always done, as its name suggests."
    );
  }

  bool Done() const override {
    return true;
  }

  const std::shared_ptr<types::IClass>& Get() const override {
    throw std::logic_error(
      "You want to get from an AlwaysDoneIterator, "
      "but the iterator is always done, as its name suggests."
    );
  }

  std::unique_ptr<IIterator> Clone() const override {
    return common::make_unique<AlwaysDoneIterator>(*this);
  };

  void PrependToPath(Path*) const override {
    throw std::logic_error(
      "You want to prepend to path from an AlwaysDoneIterator, "
      "but the iterator is always done, as its name suggests."
    );
  }

  long Index() const override {
    return -1;
  }

  ~AlwaysDoneIterator() override = default;
};  // class AlwaysDoneIterator

/**
 * Produce a non-recursive iterator over the instance given its runtime model type.
 */
std::unique_ptr<impl::IIterator> NewNonRecursiveIterator(
  const std::shared_ptr<types::IClass>& instance
) {
  switch (instance->model_type()) {
    case types::ModelType::kExtension:
      return common::make_unique<IteratorOverExtension>(
        instance
      );
    case types::ModelType::kAdministrativeInformation:
      return common::make_unique<IteratorOverAdministrativeInformation>(
        instance
      );
    case types::ModelType::kQualifier:
      return common::make_unique<IteratorOverQualifier>(
        instance
      );
    case types::ModelType::kAssetAdministrationShell:
      return common::make_unique<IteratorOverAssetAdministrationShell>(
        instance
      );
    case types::ModelType::kAssetInformation:
      return common::make_unique<IteratorOverAssetInformation>(
        instance
      );
    case types::ModelType::kResource:
      return common::make_unique<IteratorOverResource>(
        instance
      );
    case types::ModelType::kSpecificAssetId:
      return common::make_unique<IteratorOverSpecificAssetId>(
        instance
      );
    case types::ModelType::kSubmodel:
      return common::make_unique<IteratorOverSubmodel>(
        instance
      );
    case types::ModelType::kRelationshipElement:
      return common::make_unique<IteratorOverRelationshipElement>(
        instance
      );
    case types::ModelType::kSubmodelElementList:
      return common::make_unique<IteratorOverSubmodelElementList>(
        instance
      );
    case types::ModelType::kSubmodelElementCollection:
      return common::make_unique<IteratorOverSubmodelElementCollection>(
        instance
      );
    case types::ModelType::kProperty:
      return common::make_unique<IteratorOverProperty>(
        instance
      );
    case types::ModelType::kMultiLanguageProperty:
      return common::make_unique<IteratorOverMultiLanguageProperty>(
        instance
      );
    case types::ModelType::kRange:
      return common::make_unique<IteratorOverRange>(
        instance
      );
    case types::ModelType::kReferenceElement:
      return common::make_unique<IteratorOverReferenceElement>(
        instance
      );
    case types::ModelType::kBlob:
      return common::make_unique<IteratorOverBlob>(
        instance
      );
    case types::ModelType::kFile:
      return common::make_unique<IteratorOverFile>(
        instance
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return common::make_unique<IteratorOverAnnotatedRelationshipElement>(
        instance
      );
    case types::ModelType::kEntity:
      return common::make_unique<IteratorOverEntity>(
        instance
      );
    case types::ModelType::kEventPayload:
      return common::make_unique<IteratorOverEventPayload>(
        instance
      );
    case types::ModelType::kBasicEventElement:
      return common::make_unique<IteratorOverBasicEventElement>(
        instance
      );
    case types::ModelType::kOperation:
      return common::make_unique<IteratorOverOperation>(
        instance
      );
    case types::ModelType::kOperationVariable:
      return common::make_unique<IteratorOverOperationVariable>(
        instance
      );
    case types::ModelType::kCapability:
      return common::make_unique<IteratorOverCapability>(
        instance
      );
    case types::ModelType::kConceptDescription:
      return common::make_unique<IteratorOverConceptDescription>(
        instance
      );
    case types::ModelType::kReference:
      return common::make_unique<IteratorOverReference>(
        instance
      );
    case types::ModelType::kKey:
      return common::make_unique<IteratorOverKey>(
        instance
      );
    case types::ModelType::kLangStringNameType:
      return common::make_unique<IteratorOverLangStringNameType>(
        instance
      );
    case types::ModelType::kLangStringTextType:
      return common::make_unique<IteratorOverLangStringTextType>(
        instance
      );
    case types::ModelType::kEnvironment:
      return common::make_unique<IteratorOverEnvironment>(
        instance
      );
    case types::ModelType::kEmbeddedDataSpecification:
      return common::make_unique<IteratorOverEmbeddedDataSpecification>(
        instance
      );
    case types::ModelType::kLevelType:
      return common::make_unique<IteratorOverLevelType>(
        instance
      );
    case types::ModelType::kValueReferencePair:
      return common::make_unique<IteratorOverValueReferencePair>(
        instance
      );
    case types::ModelType::kValueList:
      return common::make_unique<IteratorOverValueList>(
        instance
      );
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      return common::make_unique<IteratorOverLangStringPreferredNameTypeIec61360>(
        instance
      );
    case types::ModelType::kLangStringShortNameTypeIec61360:
      return common::make_unique<IteratorOverLangStringShortNameTypeIec61360>(
        instance
      );
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      return common::make_unique<IteratorOverLangStringDefinitionTypeIec61360>(
        instance
      );
    case types::ModelType::kDataSpecificationIec61360:
      return common::make_unique<IteratorOverDataSpecificationIec61360>(
        instance
      );
    default:
      throw std::logic_error(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(instance->model_type())
          )
        )
      );
  }
}

// endregion Non-recursive iteration

// region Recursive iteration

/**
 * Iterate recursively over the instance, including the instance in the iteration.
 *
 * This is a realisation of the following pseudo-code:
 * \code
 * stack = new Stack();
 * stack.push(instance);
 * while not stack.empty():
 *     instance = stack.pop()
 *     yield instance
 *
 *     it = new_non_recursive_iterator(instance)
 *     while not it.done():
 *         yield recursively from it.get()
 *         it.next()
 * \endcode
 */
class RecursiveInclusiveIterator : public impl::IIterator {
 public:
  RecursiveInclusiveIterator(
    const std::shared_ptr<types::IClass>& instance
  );

  RecursiveInclusiveIterator(
    const RecursiveInclusiveIterator& other
  );
  RecursiveInclusiveIterator(
    RecursiveInclusiveIterator&& other
  );
  RecursiveInclusiveIterator& operator=(
    const RecursiveInclusiveIterator& other
  );
  RecursiveInclusiveIterator& operator=(
    RecursiveInclusiveIterator&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~RecursiveInclusiveIterator() override = default;

 private:
  // The instance_ needs to be a pointer so that we can re-assign it in
  // the constructors and assignment operations.
  const std::shared_ptr<types::IClass>* instance_;

  // Iterator over the instances referenced from this instance
  // in the outer loop
  std::unique_ptr<impl::IIterator> non_recursive_iterator_;

  // Iterator for recursion into the reference referenced from this instance
  // in the inner loop
  std::unique_ptr<impl::IIterator> recursive_iterator_;

  const std::shared_ptr<types::IClass>* item_;

  bool done_;
  long index_;
  size_t state_;

  void Execute();
};  // class RecursiveInclusiveIterator

/**
 * Iterate recursively over the instance, excluding the instance in the iteration.
 *
 * This is a realisation of the following pseudo-code:
 * \code
 * stack = new Stack();
 * stack.push(instance);
 * while not stack.empty():
 *     some_instance = stack.pop()
 *     if some_instance is not instance:
 *         yield some_instance
 *
 *     it = new_non_recursive_iterator(some_instance)
 *     while not it.done():
 *         yield recursively from it.get()
 *         it.next()
 * \endcode
 */
class RecursiveExclusiveIterator : public impl::IIterator {
 public:
  RecursiveExclusiveIterator(
    const std::shared_ptr<types::IClass>& instance
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const std::shared_ptr<types::IClass>& Get() const override;
  long Index() const override;
  void PrependToPath(Path* path) const override;
  std::unique_ptr<impl::IIterator> Clone() const override;
  ~RecursiveExclusiveIterator() override = default;

 private:
  RecursiveInclusiveIterator inclusive_iterator_;
};  // class RecursiveExclusiveIterator

// region RecursiveInclusiveIterator implementation

RecursiveInclusiveIterator::RecursiveInclusiveIterator(
  const std::shared_ptr<types::IClass>& instance
) : instance_(&instance), item_(nullptr), index_(-1) {
  // Intentionally empty.
}

RecursiveInclusiveIterator::RecursiveInclusiveIterator(
  const RecursiveInclusiveIterator& other
) {
  instance_ = other.instance_;
  non_recursive_iterator_ = (other.non_recursive_iterator_ == nullptr)
    ? nullptr
    : other.non_recursive_iterator_->Clone();
  recursive_iterator_ = (other.recursive_iterator_ == nullptr)
    ? nullptr
    : other.recursive_iterator_->Clone();
  item_ = other.item_;
  done_ = other.done_;
  index_ = other.index_;
  state_ = other.state_;
}

RecursiveInclusiveIterator::RecursiveInclusiveIterator(
  RecursiveInclusiveIterator&& other
) {
  instance_ = other.instance_;
  non_recursive_iterator_ = std::move(other.non_recursive_iterator_);
  recursive_iterator_ = std::move(other.recursive_iterator_);
  item_ = other.item_;
  done_ = other.done_;
  index_ = other.index_;
  state_ = other.state_;
}

RecursiveInclusiveIterator& RecursiveInclusiveIterator::operator=(
  const RecursiveInclusiveIterator& other
) {
  return *this = RecursiveInclusiveIterator(other);
}

RecursiveInclusiveIterator& RecursiveInclusiveIterator::operator=(
  RecursiveInclusiveIterator&& other
) {
  if (this != &other) {
    instance_ = other.instance_;
    non_recursive_iterator_ = std::move(other.non_recursive_iterator_);
    recursive_iterator_ = std::move(other.recursive_iterator_);
    item_ = other.item_;
    done_ = other.done_;
    index_ = other.index_;
    state_ = other.state_;
  }

  return *this;
}

void RecursiveInclusiveIterator::Start() {
  state_ = 0;
  Execute();

  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "Expected RecursiveInclusiveIterator not to be done at start, but it was."
    );
  }

  if (Index() !== 0) {
    throw std::logic_error(
      common::Concat(
        "Expected RecursiveInclusiveIterator::Index() to be 0 on Start()"
        ", but got ",
        std::to_string(Index())
      )
    );
  }

  const std::shared_ptr<IClass>& current_item(Get());
  if (current_item == nullptr) {
    throw std::logic_error(
      "Unexpected null pointer from Get() at the end of "
      "RecursiveInclusiveIterator::Start"
    );
  }

  if (current_item.get() != instance_.get()) {
    throw std::logic_error(
      common::Concat(
        "Expected the current item to point to the instance "
        "at the end of RecursiveInclusiveIterator::Start, "
        "but got ",
        std::to_string(current_item.get()),
        " from Get() instead of ",
        std::to_string(instance_.get())
      )
    );
  }
  #endif
}

void RecursiveInclusiveIterator::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a RecursiveInclusiveIterator, but it was done."
    );
  }
  #endif

  Execute();
}

bool RecursiveInclusiveIterator::Done() const {
  return done_;
}

const std::shared_ptr<types::IClass>& RecursiveInclusiveIterator::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from RecursiveInclusiveIterator, but it was done."
    );
  }

  if (item_ == nullptr) {
    throw std::logic_error(
      "You want to get from a RecursiveInclusiveIterator, "
      "but item_ has not been set."
    );
  }
  #endif

  return *item_;
}

long RecursiveInclusiveIterator::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 on a done RecursiveInclusiveIterator, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

void RecursiveInclusiveIterator::PrependToPath(Path* path) const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to prepend to path from RecursiveInclusiveIterator, "
      "but the iterator was done."
    );
  }
  #endif

  if (Index() == 0) {
    // Index set to 0 indicates that the iterator points to the instance itself.
    // Therefore, there is nothing to prepend to the path.
    return;
  }

  if (recursive_iterator_ != nullptr) {
    recursive_iterator_->PrependToPath(path);
  }

  if (non_recursive_iterator_ != nullptr) {
    non_recursive_iterator_->PrependToPath(path);
  }
}

std::unique_ptr<impl::IIterator> RecursiveInclusiveIterator::Clone() const {
  return common::make_unique<RecursiveInclusiveIterator>(*this);
}

void RecursiveInclusiveIterator::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        item_ = instance_;
        index_ = 0;
        done_ = false;
        non_recursive_iterator_.reset(nullptr);
        recursive_iterator_.reset(nullptr);

        state_ = 1;
        return;
      }

      case 1: {
        non_recursive_iterator_ = NewNonRecursiveIterator(
          *instance_
        );

        non_recursive_iterator_->Start();
      }

      case 2: {
        if (!(!non_recursive_iterator_->Done())) {
          state_ = 7;
          continue;
        }

        item_ = &(non_recursive_iterator_->Get());
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        recursive_iterator_ = std::move(
          common::make_unique<RecursiveExclusiveIterator>(
            *item_
          )
        );

        recursive_iterator_->Start();
      }

      case 4: {
        if (!(!recursive_iterator_->Done())) {
          state_ = 6;
          continue;
        }

        item_ = &(recursive_iterator_->Get());
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        recursive_iterator_->Next();

        state_ = 4;
        continue;
      }

      case 6: {
        recursive_iterator_.reset(nullptr);

        non_recursive_iterator_->Next();

        state_ = 2;
        continue;
      }

      case 7: {
        non_recursive_iterator_.reset(nullptr);
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 8;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion RecursiveInclusiveIterator implementation

// region RecursiveExclusiveIterator implementation

RecursiveExclusiveIterator::RecursiveExclusiveIterator(
  const std::shared_ptr<types::IClass>& instance
) : inclusive_iterator_(instance) {
  // Intentionally empty.
}

void RecursiveExclusiveIterator::Start() {
  inclusive_iterator_.Start();

  #ifdef DEBUG
  if (inclusive_iterator_.Done()) {
    throw std::logic_error(
      "Expected the inclusive iterator to be not-done immediately after start, "
      "as the first item is expected to point to the instance itself, "
      "but the inclusive iterator was done."
    );
  }
  #endif

  // Simply skip the instance in the very first yield.
  inclusive_iterator_.Next();
}

void RecursiveExclusiveIterator::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a RecursiveExclusiveIterator, but it was done."
    );
  }
  #endif

  inclusive_iterator_.Next();
}

bool RecursiveExclusiveIterator::Done() const {
  return inclusive_iterator_.Done();
}

const std::shared_ptr<types::IClass>& RecursiveExclusiveIterator::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from RecursiveExclusiveIterator, but it was done."
    );
  }
  #endif

  return inclusive_iterator_.Get();
}

long RecursiveExclusiveIterator::Index() const {
  if (inclusive_iterator_.Done()) {
    return -1;
  }

  return inclusive_iterator_.Index() - 1;
}

void RecursiveExclusiveIterator::PrependToPath(Path* path) const {
  inclusive_iterator_.PrependToPath(path);
}

std::unique_ptr<impl::IIterator> RecursiveExclusiveIterator::Clone() const {
  return common::make_unique<RecursiveExclusiveIterator>(*this);
}

// endregion RecursiveExclusiveIterator implementation

// endregion Recursive iteration

// region Iterator facade

Iterator::Iterator(
  const Iterator& other
) : implementation_(other.implementation_->Clone()) {
  // Intentionally empty.
}

Iterator::Iterator(
  Iterator&& other
) : implementation_(std::move(other.implementation_)) {
  // Intentionally empty.
}

Iterator& Iterator::operator=(const Iterator& other) {
  return *this = Iterator(other);
}

Iterator& Iterator::operator=(Iterator&& other) {
  if (this != &other) {
    this->implementation_ = std::move(other.implementation_);
  }

  return *this;
}

const std::shared_ptr<types::IClass>& Iterator::operator*() const {
  if (implementation_->Done()) {
    throw std::logic_error(
      "You want to dereference a completed iterator."
    );
  }

  return implementation_->Get();
}

const std::shared_ptr<types::IClass>* Iterator::operator->() {
  if (implementation_->Done()) {
    throw std::logic_error(
      "You want to dereference a completed iterator."
    );
  }

  return &(implementation_->Get());
}

// Prefix increment
Iterator& Iterator::operator++() {
  if (implementation_->Done()) {
    throw std::logic_error(
      "You want to move a completed iterator."
    );
  }

  implementation_->Next();
  return *this;
}

// Postfix increment
Iterator Iterator::operator++(int) {
  Iterator result(*this);
  ++(*this);
  return result;
}

bool operator==(const Iterator& a, const Iterator& b) {
  return a.implementation_->Index() == b.implementation_->Index();
}

bool operator!=(const Iterator& a, const Iterator& b) {
  return a.implementation_->Index() != b.implementation_->Index();
}

Path MaterializePath(const Iterator& iterator) {
  if (iterator.implementation_->Done()) {
    throw std::logic_error(
      "You want to materialize path of a completed iterator."
    );
  }

  Path path;
  iterator.implementation_->PrependToPath(&path);
  return path;
}

void PrependToPath(const Iterator& iterator, Path* path) {
  if (iterator.implementation_->Done()) {
    throw std::logic_error(
      "You want to prepend a path of a completed iterator."
    );
  }

  iterator.implementation_->PrependToPath(path);
}

// endregion Iterator facade

// region Descents

// region Descent

// NOTE (mristin):
// We have to make a copy of the pointer since we would lose otherwise
// in range-based `for` loops,
// see: https://stackoverflow.com/questions/29990045/temporary-lifetime-in-range-for-expression
Descent::Descent(
  std::shared_ptr<types::IClass> instance
) : instance_(std::move(instance)) {
  // Intentionally empty.
}

Iterator Descent::begin() const {
  std::unique_ptr<impl::IIterator> it_impl(
    std::move(
      common::make_unique<RecursiveExclusiveIterator>(instance_)
    )
  );

  it_impl->Start();

  // NOTE(mristin):
  // We short-circuit here for memory frugality,
  // as we can immediately dispose it_impl.
  if (it_impl->Done()) {
    return end();
  }

  return Iterator(std::move(it_impl));
}

const Iterator& Descent::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneIterator>());
  return iterator;
}

// endregion Descent

// region DescentOnce

// NOTE (mristin):
// We have to make a copy of the pointer since we would lose otherwise
// in range-based `for` loops,
// see: https://stackoverflow.com/questions/29990045/temporary-lifetime-in-range-for-expression
DescentOnce::DescentOnce(
  std::shared_ptr<types::IClass> instance
) : instance_(std::move(instance)) {
  // Intentionally empty.
}

Iterator DescentOnce::begin() const {
  std::unique_ptr<impl::IIterator> it_impl(
    NewNonRecursiveIterator(instance_)
  );

  it_impl->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose it_impl.
  if (it_impl->Done()) {
    return Iterator(std::move(common::make_unique<AlwaysDoneIterator>()));
  }

  return Iterator(std::move(it_impl));
}

const Iterator& DescentOnce::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneIterator>());
  return iterator;
}

// endregion DescentOnce

// endregion Descents

// region Over enumerations

const std::vector<types::ModellingKind> kOverModellingKind = {
  types::ModellingKind::kTemplate,
  types::ModellingKind::kInstance
};

const std::vector<types::QualifierKind> kOverQualifierKind = {
  types::QualifierKind::kValueQualifier,
  types::QualifierKind::kConceptQualifier,
  types::QualifierKind::kTemplateQualifier
};

const std::vector<types::AssetKind> kOverAssetKind = {
  types::AssetKind::kType,
  types::AssetKind::kInstance,
  types::AssetKind::kNotApplicable
};

const std::vector<types::AasSubmodelElements> kOverAasSubmodelElements = {
  types::AasSubmodelElements::kAnnotatedRelationshipElement,
  types::AasSubmodelElements::kBasicEventElement,
  types::AasSubmodelElements::kBlob,
  types::AasSubmodelElements::kCapability,
  types::AasSubmodelElements::kDataElement,
  types::AasSubmodelElements::kEntity,
  types::AasSubmodelElements::kEventElement,
  types::AasSubmodelElements::kFile,
  types::AasSubmodelElements::kMultiLanguageProperty,
  types::AasSubmodelElements::kOperation,
  types::AasSubmodelElements::kProperty,
  types::AasSubmodelElements::kRange,
  types::AasSubmodelElements::kReferenceElement,
  types::AasSubmodelElements::kRelationshipElement,
  types::AasSubmodelElements::kSubmodelElement,
  types::AasSubmodelElements::kSubmodelElementList,
  types::AasSubmodelElements::kSubmodelElementCollection
};

const std::vector<types::EntityType> kOverEntityType = {
  types::EntityType::kCoManagedEntity,
  types::EntityType::kSelfManagedEntity
};

const std::vector<types::Direction> kOverDirection = {
  types::Direction::kInput,
  types::Direction::kOutput
};

const std::vector<types::StateOfEvent> kOverStateOfEvent = {
  types::StateOfEvent::kOn,
  types::StateOfEvent::kOff
};

const std::vector<types::ReferenceTypes> kOverReferenceTypes = {
  types::ReferenceTypes::kExternalReference,
  types::ReferenceTypes::kModelReference
};

const std::vector<types::KeyTypes> kOverKeyTypes = {
  types::KeyTypes::kAnnotatedRelationshipElement,
  types::KeyTypes::kAssetAdministrationShell,
  types::KeyTypes::kBasicEventElement,
  types::KeyTypes::kBlob,
  types::KeyTypes::kCapability,
  types::KeyTypes::kConceptDescription,
  types::KeyTypes::kDataElement,
  types::KeyTypes::kEntity,
  types::KeyTypes::kEventElement,
  types::KeyTypes::kFile,
  types::KeyTypes::kFragmentReference,
  types::KeyTypes::kGlobalReference,
  types::KeyTypes::kIdentifiable,
  types::KeyTypes::kMultiLanguageProperty,
  types::KeyTypes::kOperation,
  types::KeyTypes::kProperty,
  types::KeyTypes::kRange,
  types::KeyTypes::kReferable,
  types::KeyTypes::kReferenceElement,
  types::KeyTypes::kRelationshipElement,
  types::KeyTypes::kSubmodel,
  types::KeyTypes::kSubmodelElement,
  types::KeyTypes::kSubmodelElementCollection,
  types::KeyTypes::kSubmodelElementList
};

const std::vector<types::DataTypeDefXsd> kOverDataTypeDefXsd = {
  types::DataTypeDefXsd::kAnyUri,
  types::DataTypeDefXsd::kBase64Binary,
  types::DataTypeDefXsd::kBoolean,
  types::DataTypeDefXsd::kByte,
  types::DataTypeDefXsd::kDate,
  types::DataTypeDefXsd::kDateTime,
  types::DataTypeDefXsd::kDecimal,
  types::DataTypeDefXsd::kDouble,
  types::DataTypeDefXsd::kDuration,
  types::DataTypeDefXsd::kFloat,
  types::DataTypeDefXsd::kGDay,
  types::DataTypeDefXsd::kGMonth,
  types::DataTypeDefXsd::kGMonthDay,
  types::DataTypeDefXsd::kGYear,
  types::DataTypeDefXsd::kGYearMonth,
  types::DataTypeDefXsd::kHexBinary,
  types::DataTypeDefXsd::kInt,
  types::DataTypeDefXsd::kInteger,
  types::DataTypeDefXsd::kLong,
  types::DataTypeDefXsd::kNegativeInteger,
  types::DataTypeDefXsd::kNonNegativeInteger,
  types::DataTypeDefXsd::kNonPositiveInteger,
  types::DataTypeDefXsd::kPositiveInteger,
  types::DataTypeDefXsd::kShort,
  types::DataTypeDefXsd::kString,
  types::DataTypeDefXsd::kTime,
  types::DataTypeDefXsd::kUnsignedByte,
  types::DataTypeDefXsd::kUnsignedInt,
  types::DataTypeDefXsd::kUnsignedLong,
  types::DataTypeDefXsd::kUnsignedShort
};

const std::vector<types::DataTypeIec61360> kOverDataTypeIec61360 = {
  types::DataTypeIec61360::kDate,
  types::DataTypeIec61360::kString,
  types::DataTypeIec61360::kStringTranslatable,
  types::DataTypeIec61360::kIntegerMeasure,
  types::DataTypeIec61360::kIntegerCount,
  types::DataTypeIec61360::kIntegerCurrency,
  types::DataTypeIec61360::kRealMeasure,
  types::DataTypeIec61360::kRealCount,
  types::DataTypeIec61360::kRealCurrency,
  types::DataTypeIec61360::kBoolean,
  types::DataTypeIec61360::kIri,
  types::DataTypeIec61360::kIrdi,
  types::DataTypeIec61360::kRational,
  types::DataTypeIec61360::kRationalMeasure,
  types::DataTypeIec61360::kTime,
  types::DataTypeIec61360::kTimestamp,
  types::DataTypeIec61360::kFile,
  types::DataTypeIec61360::kHtml,
  types::DataTypeIec61360::kBlob
};

// endregion Over enumerations

}  // namespace iteration
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
