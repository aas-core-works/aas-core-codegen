// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/constants.hpp"
#include "aas_core/aas_3_0/pattern.hpp"
#include "aas_core/aas_3_0/revm.hpp"
#include "aas_core/aas_3_0/verification.hpp"

#pragma warning(push, 0)
#include <map>
#include <set>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {
namespace verification {

// region struct Error

Error::Error(
  std::wstring a_cause
) :
  cause(std::move(a_cause)) {
  // Intentionally empty.
}

Error::Error(
  std::wstring a_cause,
  iteration::Path a_path
) :
  cause(std::move(a_cause)),
  path(std::move(a_path)) {
  // Intentionally empty.
}

// endregion struct Error

// region class AlwaysDoneVerificator

class AlwaysDoneVerificator : public impl::IVerificator {
 public:
  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;
  std::unique_ptr<impl::IVerificator> Clone() const override;

  virtual ~AlwaysDoneVerificator() = default;
};  // class AlwaysDoneVerificator

void AlwaysDoneVerificator::Start() {
  // Intentionally empty.
}

void AlwaysDoneVerificator::Next() {
  throw std::logic_error(
    "You want to move an AlwaysDoneVerificator, "
    "but the verificator is always done, as its name suggests."
  );
}

bool AlwaysDoneVerificator::Done() const {
  return true;
}

const Error& AlwaysDoneVerificator::Get() const {
    throw std::logic_error(
      "You want to get from an AlwaysDoneVerificator, "
      "but the verificator is always done, as its name suggests."
    );
}

Error& AlwaysDoneVerificator::GetMutable() {
    throw std::logic_error(
      "You want to get mutable from an AlwaysDoneVerificator, "
      "but the verificator is always done, as its name suggests."
    );
}

long AlwaysDoneVerificator::Index() const {
  return -1;
}

std::unique_ptr<impl::IVerificator> AlwaysDoneVerificator::Clone() const {
  return common::make_unique<AlwaysDoneVerificator>(*this);
}

// endregion class AlwaysDoneVerificator

// region Verification functions

bool MatchesIdShort(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesIdShortProgram,
    text
  );
}

bool MatchesVersionType(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesVersionTypeProgram,
    text
  );
}

bool MatchesRevisionType(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesRevisionTypeProgram,
    text
  );
}

bool MatchesXsDateTimeUtc(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsDateTimeUtcProgram,
    text
  );
}

std::vector<
  std::unique_ptr<revm::Instruction>
> ConstructMatchesXsDatePrefixProgram() {
  std::vector<std::unique_ptr<revm::Instruction> > program;
  
  {  // ^(-?[0-9]+)-(0[1-9]|1[0-2])-(0[0-9]|1[0-9]|2[0-9]|30|31).*$
    {  // -?[0-9]+
      {  // -?
        program.emplace_back(
          std::make_unique<revm::InstructionSplit>(1, 2)
        );
        // -
        program.emplace_back(  // 1
          std::make_unique<revm::InstructionChar>(L'-')
        );
      }  // -?
      {  // [0-9]+
        // [0-9]
        program.emplace_back(  // 2
          std::make_unique<revm::InstructionSet>(
            std::vector<revm::Range>{
              revm::Range(L'0', L'9')
            }
          )
        );
        program.emplace_back(
          std::make_unique<revm::InstructionSplit>(2, 4)
        );
      }  // [0-9]+
    }  // -?[0-9]+
    // -
    program.emplace_back(  // 4
      std::make_unique<revm::InstructionChar>(L'-')
    );
    {  // 0[1-9]|1[0-2]
      program.emplace_back(
        std::make_unique<revm::InstructionSplit>(6, 9)
      );
      {  // 0[1-9]
        // 0
        program.emplace_back(  // 6
          std::make_unique<revm::InstructionChar>(L'0')
        );
        // [1-9]
        program.emplace_back(
          std::make_unique<revm::InstructionSet>(
            std::vector<revm::Range>{
              revm::Range(L'1', L'9')
            }
          )
        );
      }  // 0[1-9]
      program.emplace_back(
        std::make_unique<revm::InstructionJump>(11)
      );
      {  // 1[0-2]
        // 1
        program.emplace_back(  // 9
          std::make_unique<revm::InstructionChar>(L'1')
        );
        // [0-2]
        program.emplace_back(
          std::make_unique<revm::InstructionSet>(
            std::vector<revm::Range>{
              revm::Range(L'0', L'2')
            }
          )
        );
      }  // 1[0-2]
    }  // 0[1-9]|1[0-2]
    // -
    program.emplace_back(  // 11
      std::make_unique<revm::InstructionChar>(L'-')
    );
    {  // 0[0-9]|1[0-9]|2[0-9]|30|31
      program.emplace_back(
        std::make_unique<revm::InstructionSplit>(13, 16)
      );
      {  // 0[0-9]
        // 0
        program.emplace_back(  // 13
          std::make_unique<revm::InstructionChar>(L'0')
        );
        // [0-9]
        program.emplace_back(
          std::make_unique<revm::InstructionSet>(
            std::vector<revm::Range>{
              revm::Range(L'0', L'9')
            }
          )
        );
      }  // 0[0-9]
      program.emplace_back(
        std::make_unique<revm::InstructionJump>(30)
      );
      program.emplace_back(  // 16
        std::make_unique<revm::InstructionSplit>(17, 20)
      );
      {  // 1[0-9]
        // 1
        program.emplace_back(  // 17
          std::make_unique<revm::InstructionChar>(L'1')
        );
        // [0-9]
        program.emplace_back(
          std::make_unique<revm::InstructionSet>(
            std::vector<revm::Range>{
              revm::Range(L'0', L'9')
            }
          )
        );
      }  // 1[0-9]
      program.emplace_back(
        std::make_unique<revm::InstructionJump>(30)
      );
      program.emplace_back(  // 20
        std::make_unique<revm::InstructionSplit>(21, 24)
      );
      {  // 2[0-9]
        // 2
        program.emplace_back(  // 21
          std::make_unique<revm::InstructionChar>(L'2')
        );
        // [0-9]
        program.emplace_back(
          std::make_unique<revm::InstructionSet>(
            std::vector<revm::Range>{
              revm::Range(L'0', L'9')
            }
          )
        );
      }  // 2[0-9]
      program.emplace_back(
        std::make_unique<revm::InstructionJump>(30)
      );
      program.emplace_back(  // 24
        std::make_unique<revm::InstructionSplit>(25, 28)
      );
      {  // 30
        // 3
        program.emplace_back(  // 25
          std::make_unique<revm::InstructionChar>(L'3')
        );
        // 0
        program.emplace_back(
          std::make_unique<revm::InstructionChar>(L'0')
        );
      }  // 30
      program.emplace_back(
        std::make_unique<revm::InstructionJump>(30)
      );
      {  // 31
        // 3
        program.emplace_back(  // 28
          std::make_unique<revm::InstructionChar>(L'3')
        );
        // 1
        program.emplace_back(
          std::make_unique<revm::InstructionChar>(L'1')
        );
      }  // 31
    }  // 0[0-9]|1[0-9]|2[0-9]|30|31
    program.emplace_back(  // 30
      std::make_unique<revm::InstructionMatch>()
    );
  }  // ^(-?[0-9]+)-(0[1-9]|1[0-2])-(0[0-9]|1[0-9]|2[0-9]|30|31).*$

  return program;
}

const std::vector<
  std::unique_ptr<revm::Instruction>
> kMatchesXsDatePrefixProgram = ConstructMatchesXsDatePrefixProgram();

bool MatchesXsDatePrefix(
  const std::wstring& text
) {
  return revm::Match(
    kMatchesXsDatePrefixProgram,
    text
  );
}

/**
 * Represent a parsed date from a date string where we ignore the offset.
 */
struct MatchedDatePrefix {
  std::wstring year;
  std::wstring month;
  std::wstring day;

  MatchedDatePrefix(
    std::wstring a_year,
  	std::wstring a_month,
  	std::wstring a_day
  ) :
    year(std::move(a_year)),
    month(std::move(a_month)),
    day(std::move(a_day)) {
    // Intentionally empty.
  }
};  // MatchedDatePrefix

/**
 * Parse the date from the given text where the text is supposed to be an xs:date or
 * an xs:dateTime.
 */
MatchedDatePrefix ParseXsDatePrefix(const std::wstring& text) {
  size_t year_end = 0;
  if (text.size() < 5) {
    throw std::logic_error(
      common::WstringToUtf8(
        common::Concat(
          L"Expected text to be prefixed with a valid xs:date, but it was not: ",
          text
	    )
	  )
	);
  }

  if (text[0] == L'-') {
    ++year_end;
  }

  while (true) {
    if (year_end >= text.size()) {
      throw std::logic_error(
        common::WstringToUtf8(
          common::Concat(
            L"Expected text to be prefixed with a valid xs:date, but it was not: ",
            text
	      )
	    )
	  );
    }

    if (std::isdigit(text[year_end])) {
      ++year_end;
    } else if (text[year_end] == '-') {
      break;
    } else {
      throw std::logic_error(
        common::WstringToUtf8(
          common::Concat(
            L"Expected text to be prefixed with a valid xs:date, but it was not. ",
            L"We encountered an unexpected character while parsing the year: ",
            std::wstring(text[year_end], 1),
            L"; the text was: ",
            text
	      )
	    )
	  );
    }
  }

  const std::wstring year_str = text.substr(0, year_end);

  size_t month_end = year_end + 1;
  while (true) {
    if (month_end >= text.size()) {
      throw std::logic_error(
        common::WstringToUtf8(
          common::Concat(
            L"Expected text to be prefixed with a valid xs:date, but it was not: ",
            text
	      )
	    )
	  );
    }

    if (std::isdigit(text[month_end])) {
      ++month_end;
    } else if (text[month_end] == '-') {
      break;
    } else {
      throw std::logic_error(
        common::WstringToUtf8(
          common::Concat(
            L"Expected text to be prefixed with a valid xs:date, but it was not. ",
			L"We encountered an unexpected character while parsing the month: ",
            std::wstring(text[month_end], 1),
            L"; the text was: ",
            text
	      )
	    )
	  );
    }
  }

  std::wstring month_str = text.substr(year_end + 1, month_end - year_end - 1);

  size_t day_end = month_end + 1;

  while (true) {
    if (day_end == text.size()) {
      break;
    }

    if (std::isdigit(text[day_end])) {
      ++day_end;
    } else if(
      text[day_end] == L'-'
      || text[day_end] == L'+'
      || text[day_end] == L'Z'
      || text[day_end] == L'T'
    ) {
      // We encountered a valid suffix for xs:date offset or time in xs::dateTime.
      break;
    } else {
      throw std::logic_error(
        common::WstringToUtf8(
          common::Concat(
            L"Expected text to be prefixed with a valid xs:date, but it was not. ",
            L"We encountered an unexpected character while parsing the day: ",
            std::wstring(text[day_end], 1),
            L"; the text was: ",
            text
	      )
	    )
	  );
    }
  }

  std::wstring day_str = text.substr(month_end + 1, day_end - month_end - 1);

  return MatchedDatePrefix(year_str, month_str, day_str);
}

/**
 * Determine the sign of the given year as text.
 *
 * @param year_str year as text
 * @return -1, 0 or 1; -1 means BC, 1 means AD. 0 means a zero year,
 * even if specified as -0.
 */
int DetermineEra(const std::wstring& year_str) {
  #ifdef DEBUG
  if (year_str.empty()) {
    throw std::invalid_argument(
      "Expected a valid year string, but got an empty string"
    );
  }
  #endif

  const int sign = (year_str[0] == L'-') ? -1 : 1;

  size_t cursor = 0;
  if (sign < 0) {
    // NOTE (mristin):
    // We skip the minus sign as prefix, including the edge case "-0".
    ++cursor;
  }

  bool is_zero = true;
  for (; cursor < year_str.size(); ++cursor) {
    if (year_str[cursor] != L'0') {
      is_zero = false;
      break;
    }
  }

  if (is_zero) {
    return 0;
  }

  return sign;
}

const std::map<int, int> kDaysInMonth = {
  {1, 31},
  // Please use IsLeapYear if you need to check
  // whether a concrete February has 28 or 29 days.
  {2, 29},
  {3, 31},
  {4, 30},
  {5, 31},
  {6, 30},
  {7, 31},
  {8, 31},
  {9, 30},
  {10, 31},
  {11, 30},
  {12, 31}
};

/**
 * \brief Check that \p value is a valid `xs:date` without the offset.
 *
 * Year 1 BCE is the last leap BCE year.
 * See: https://www.w3.org/TR/xmlschema-2/#dateTime.
 *
 * \param value to be checked
 * \return true if \p value is a valid `xs:date`
 */
bool IsXsDateWithoutOffset(const std::wstring& text) {
  // NOTE (mristin):
  // We can not use date functions from the operation system as they do not
  // handle years BCE (*e.g.*, `-0003-01-02`).

  if (!MatchesXsDatePrefix(text)) {
    return false;
  }

  // NOTE (mristin):
  // We need to match the prefix as zone offsets are allowed in the dates. Optimally,
  // we would re-use the pattern matching from `MatchesXsDatePrefix`, but this
  // would make the code generation and constraint inference for schemas much more
  // difficult. Hence, we sacrifice the efficiency a bit for the clearer code & code
  // generation.

  // NOTE (mristin):
  // The year can be arbitrarily large in `xs:date` and `xs:dateTime`. Instead of
  // using a BigInt implementation -- and having to maintain another dependency --
  // we simply clip the year to the last four relevant digits for the computation of
  // leap years.

  const MatchedDatePrefix match = ParseXsDatePrefix(text);

  const int era = DetermineEra(match.year);

  // NOTE (mristin):
  // We do not accept year zero, see the note at:
  // https://www.w3.org/TR/xmlschema-2/#dateTime
  if (era == 0) {
    return false;
  }

  std::wstring last_four_year_digits;

  const size_t year_start = (era < 0) ? 1 : 0;
  const size_t end = match.year.size();
  size_t start = end - 4;
  if (start < year_start) {
    start = year_start;
  }

  const std::wstring at_most_last_four_year_digits(
    match.year.substr(start, 4)
  );

  int year_suffix = era * std::stoi(at_most_last_four_year_digits);

  // NOTE (mristin):
  // We consider the years B.C. to be one-off.
  // See the note at: https://www.w3.org/TR/xmlschema-2/#dateTime:
  // "'-0001' is the lexical representation of the year 1 Before Common Era
  // (1 BCE, sometimes written "1 BC")."
  //
  // Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.
  if (year_suffix < 0) {
    year_suffix = -year_suffix - 1;
  }

  bool is_leap_year = true;

  if (year_suffix % 4 > 0) {
    is_leap_year = false;
  } else if (year_suffix % 100 > 0) {
    is_leap_year = true;
  } else if (year_suffix % 400 > 0) {
    is_leap_year = false;
  }

  const int month = std::stoi(match.month);
  const int day = std::stoi(match.day);

  if (day <= 0) {
    return false;
  }

  if (month <= 0 || month >= 13) {
    return false;
  }

  const int max_days(
  	(month == 2)
	  ? (is_leap_year ? 29 : 28)
      : kDaysInMonth.at(month)
  );

  if (day > max_days) {
    return false;
  }

  return true;
}

bool IsXsDateTimeUtc(
  const std::wstring& text
) {
  if (!MatchesXsDateTimeUtc(text)) {
    return false;
  }

  const size_t pos = text.find(L'T');
  if (pos == std::wstring::npos) {
    std::wstringstream wss;
    wss
      << L"Expected 'T' in the date-time if it matches the expected regex, "
      << L"but got: "
      << text;

    throw std::logic_error(
      common::WstringToUtf8(wss.str())
    );
  }

  // NOTE (mristin):
  // We make a copy here to be compatible with C++11. Optimally, a string view
  // should be used here.
  std::wstring date = text.substr(0, pos);

  return IsXsDateWithoutOffset(date);
}

bool MatchesMimeType(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesMimeTypeProgram,
    text
  );
}

bool MatchesRfc8089Path(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesRfc8089PathProgram,
    text
  );
}

bool MatchesBcp47(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesBcp47Program,
    text
  );
}

bool QualifierTypesAreUnique(
  const std::vector<
    std::shared_ptr<types::IQualifier>
  >& qualifiers
) {
  std::set<std::wstring> type_set;
  for (const std::shared_ptr<types::IQualifier>& qualifier : qualifiers) {
    const std::wstring& type = qualifier->type();

    if (type_set.find(type) != type_set.end()) {
      return false;
    }

    type_set.insert(type);
  }

  return true;
}

bool MatchesXmlSerializableString(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXmlSerializableStringProgram,
    text
  );
}

bool MatchesXsAnyUri(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsAnyUriProgram,
    text
  );
}

bool MatchesXsBase64Binary(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsBase64BinaryProgram,
    text
  );
}

bool MatchesXsBoolean(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsBooleanProgram,
    text
  );
}

bool MatchesXsDate(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsDateProgram,
    text
  );
}

bool MatchesXsDateTime(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsDateTimeProgram,
    text
  );
}

bool IsXsDateTime(
  const std::wstring& text
) {
  if (!MatchesXsDateTime(text)) {
    return false;
  }

  const size_t pos = text.find(L'T');
  if (pos == std::wstring::npos) {
    std::wstringstream wss;
    wss
      << L"Expected 'T' in the date-time if it matches the expected regex, "
      << L"but got: "
      << text;

    throw std::logic_error(
      common::WstringToUtf8(wss.str())
    );
  }

  // NOTE (mristin):
  // We make a copy here to be compatible with C++11. Optimally, a string view
  // should be used here.
  std::wstring date = text.substr(0, pos);

  return IsXsDateWithoutOffset(date);
}

bool MatchesXsDecimal(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsDecimalProgram,
    text
  );
}

bool MatchesXsDouble(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsDoubleProgram,
    text
  );
}

bool MatchesXsDuration(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsDurationProgram,
    text
  );
}

bool MatchesXsFloat(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsFloatProgram,
    text
  );
}

bool MatchesXsGDay(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsGDayProgram,
    text
  );
}

bool MatchesXsGMonth(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsGMonthProgram,
    text
  );
}

bool MatchesXsGMonthDay(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsGMonthDayProgram,
    text
  );
}

bool MatchesXsGYear(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsGYearProgram,
    text
  );
}

bool MatchesXsGYearMonth(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsGYearMonthProgram,
    text
  );
}

bool MatchesXsHexBinary(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsHexBinaryProgram,
    text
  );
}

bool MatchesXsTime(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsTimeProgram,
    text
  );
}

bool MatchesXsInteger(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsIntegerProgram,
    text
  );
}

bool MatchesXsLong(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsLongProgram,
    text
  );
}

bool MatchesXsInt(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsIntProgram,
    text
  );
}

bool MatchesXsShort(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsShortProgram,
    text
  );
}

bool MatchesXsByte(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsByteProgram,
    text
  );
}

bool MatchesXsNonNegativeInteger(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsNonNegativeIntegerProgram,
    text
  );
}

bool MatchesXsPositiveInteger(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsPositiveIntegerProgram,
    text
  );
}

bool MatchesXsUnsignedLong(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsUnsignedLongProgram,
    text
  );
}

bool MatchesXsUnsignedInt(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsUnsignedIntProgram,
    text
  );
}

bool MatchesXsUnsignedShort(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsUnsignedShortProgram,
    text
  );
}

bool MatchesXsUnsignedByte(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsUnsignedByteProgram,
    text
  );
}

bool MatchesXsNonPositiveInteger(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsNonPositiveIntegerProgram,
    text
  );
}

bool MatchesXsNegativeInteger(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsNegativeIntegerProgram,
    text
  );
}

bool MatchesXsString(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kMatchesXsStringProgram,
    text
  );
}

bool IsXsDate(const std::wstring& text) {
  // NOTE (mristin):
  // Optimally, we would re-use the parts of `MatchesXsDate` program and
  // `IsXsDateWithoutOffset`, but this would make the implementation much more
  // difficult to read and maintain. Hence, we opt here for simplicity of implementation
  // to computational performance.

  if (!MatchesXsDate(text)) {
    return false;
  }

  return IsXsDateWithoutOffset(text);
}

bool IsXsDouble(const std::wstring& value) {
  // NOTE (mristin):
  // We need to check explicitly for the regular expression since
  // `stod` allows `nan`, `infinity` and `inf` case-insensitive, while
  // XSD accepts only case-sensitive literals, see:
  // https://en.cppreference.com/w/cpp/string/basic_string/stof,
  // https://www.w3.org/TR/xmlschema-2/#double
  if (!MatchesXsDouble(value)) {
    return false;
  }

  try {
  // NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
    const bool sizeof_double_is_8 = sizeof(double) == 8;
    const bool sizeof_long_double_is_8 = sizeof(long double) == 8;

    if (sizeof_double_is_8) {
      static_cast<void>(
        std::stod(value)
      );
    } else if (sizeof_long_double_is_8) {
      static_cast<void>(
        std::stold(value)
      );
    } else {
      std::stringstream ss;
      ss
        << "The size of long double was not 8 (it was "
        << sizeof(long double) << "), nor was the size of double 8 ("
        << "it was " << sizeof(double) << "). Hence, we do not know "
        << "how to check for string parsing of a 64-bit floating-point number.";
      throw std::logic_error(ss.str());
    }
  } catch (const std::invalid_argument&) {
  std::wstringstream wss;
    wss
      << "Unexpected unparsable floating-point number from "
      << "the value matching the regex: " << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }

  return true;
}

bool IsXsFloat(const std::wstring& value) {
  // NOTE (mristin):
  // We need to check explicitly for the regular expression since
  // `stof` allows `nan`, `infinity` and `inf` case-insensitive, while
  // XSD accepts only case-sensitive literals, see:
  // https://en.cppreference.com/w/cpp/string/basic_string/stof,
  // https://www.w3.org/TR/xmlschema-2/#float
  if (!MatchesXsFloat(value)) {
    return false;
  }

  try {
    // NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
    const bool sizeof_float_is_4 = sizeof(float) == 4;
    const bool sizeof_double_is_4 = sizeof(double) == 4;

    if (sizeof_float_is_4) {
      static_cast<void>(
        std::stof(value)
      );
    } else if(sizeof_double_is_4) {
      static_cast<void>(
        std::stod(value)
      );
    } else {
      std::stringstream ss;
      ss
        << "The size of float was not 4 (it was "
        << sizeof(float) << "), nor was the size of double 4 ("
        << "it was " << sizeof(double) << "). Hence, we do not know "
        << "how to check for string parsing of a 32-bit floating-point number.";
      throw std::logic_error(ss.str());
    }
  } catch (const std::invalid_argument&) {
  std::wstringstream wss;
    wss
      << "Unexpected unparsable floating-point number from "
      << "the value matching the regex: " << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }

  return true;
}

bool IsXsGMonthDay(const std::wstring& value) {
  if (!MatchesXsGMonthDay(value)) {
    return false;
  }

  const std::wstring month_str = value.substr(2, 2);

  const int month = std::stoi(value.substr(2, 2));
  const int day = std::stoi(value.substr(5, 2));

  // We know by regular expression that the month will be 1-12.
  return day <= kDaysInMonth.at(month);
}

bool IsXsLong(const std::wstring& value) {
  if (!MatchesXsLong(value)) {
    return false;
  }

  try {
	// NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
    const bool sizeof_long_is_8 = sizeof(long) == 8;
    const bool sizeof_long_long_is_8 = sizeof(long long) == 8;

    if (sizeof_long_is_8) {
      static_cast<void>(
        std::stol(value)
      );
    } else if (sizeof_long_long_is_8) {
      static_cast<void>(
        std::stoll(value)
      );
    } else {
      std::stringstream ss;
      ss
        << "The size of long was not 8 (it was "
        << sizeof(long) << "), nor was the size of long long 8 ("
        << "it was " << sizeof(long long) << "). Hence, we do not know "
        << "how to check for string parsing of a 64-bit integer number.";
      throw std::logic_error(ss.str());
    }
  } catch (const std::invalid_argument&) {
  std::wstringstream wss;
    wss
      << "Unexpected unparsable integer number from the value matching the regex: "
      << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }

  return true;
}

bool IsXsInt(const std::wstring& value) {
  if (!MatchesXsInt(value)) {
    return false;
  }

  try {
	// NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
  	const bool sizeof_int_is_4 = sizeof(int) == 4;
  	const bool sizeof_long_is_4 = sizeof(long) == 4;

    if (sizeof_int_is_4) {
      static_cast<void>(
        std::stoi(value)
      );
    } else if (sizeof_long_is_4) {
      static_cast<void>(
        std::stol(value)
      );
    } else {
      std::stringstream ss;
      ss
        << "The size of int was not 4 (it was "
        << sizeof(int) << "), nor was the size of long 4 ("
        << "it was " << sizeof(long) << "). Hence, we do not know "
        << "how to check for string parsing of a 32-bit integer number.";
      throw std::logic_error(ss.str());
    }
  } catch (const std::invalid_argument&) {
  std::wstringstream wss;
    wss
      << "Unexpected unparsable integer number from "
      << "the value matching the regex: " << value;

    throw std::invalid_argument(
    common::WstringToUtf8(wss.str())
  );
  } catch (const std::out_of_range&) {
    return false;
  }

  return true;
}

bool IsXsShort(const std::wstring& value) {
  if (!MatchesXsShort(value)) {
    return false;
  }

  int converted;
  try {
    converted = std::stoi(value);
  } catch (const std::invalid_argument&) {
  std::wstringstream wss;
    wss
      << "Unexpected unparsable integer number from "
      << "the value matching the regex: " << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }

  return -32768 <= converted && converted <= 32767;
}

bool IsXsByte(const std::wstring& value) {
  if (!MatchesXsByte(value)) {
    return false;
  }

  int converted;
  try {
    converted = std::stoi(value);
  } catch (const std::invalid_argument&) {
  std::wstringstream wss;
    wss
      << "Unexpected unparsable integer number from "
      << "the value matching the regex: " << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }

  return -128 <= converted && converted <= 127;
}

bool IsXsUnsignedLong(const std::wstring& value) {
  if (!MatchesXsUnsignedLong(value)) {
    return false;
  }

  try {
  	// NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
	const bool sizeof_unsigned_long_is_8 = sizeof(unsigned long) == 8;
	const bool sizeof_unsigned_long_long_is_8 = sizeof(unsigned long long) == 8;

    if (sizeof_unsigned_long_is_8) {
      static_cast<void>(
        std::stoul(value)
      );
    } else if (sizeof_unsigned_long_long_is_8) {
      static_cast<void>(
        std::stoull(value)
      );
    } else {
      std::stringstream ss;
      ss
        << "The size of unsigned long was not 8 (it was "
        << sizeof(unsigned long) << "), nor was the size of unsigned long long 8 ("
        << "it was " << sizeof(unsigned long long) << "). Hence, we do not know "
        << "how to check for string parsing of an unsigned 64-bit integer number.";
      throw std::logic_error(ss.str());
    }
  } catch (const std::invalid_argument&) {
  std::wstringstream wss;
    wss
      << "Unexpected unparsable integer number from "
      << "the value matching the regex: " << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }

  return true;
}

bool IsXsUnsignedInt(const std::wstring& value) {
  if (!MatchesXsUnsignedInt(value)) {
    return false;
  }

  // NOTE (mristin):
  // There exist no std::stoui or std::stou, see:
  // https://stackoverflow.com/questions/8715213/why-is-there-no-stdstou,
  // so we have to work with std::stoul.

  try {
	// NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
	const bool sizeof_unsigned_long_ge_4 = sizeof(unsigned long) >= 4;
	const bool sizeof_unsigned_long_long_ge_4 = sizeof(unsigned long long) >= 4;

    if (sizeof_unsigned_long_ge_4) {
      const unsigned long number = std::stoul(value);
      return number <= 4294967295ul;
    } else if (sizeof_unsigned_long_long_ge_4) {
      const unsigned long long number = std::stoull(value);
      return number <= 4294967295ull;
    } else {
      std::stringstream ss;
      ss
        << "The size of unsigned long was less than 4 (it was "
        << sizeof(unsigned long) << "), and the size of "
        << "unsigned long long was also less than 4 ("
        << "it was " << sizeof(unsigned long long) << "). Hence, we do not "
        << "know how to check for string parsing of "
        << "an unsigned 32-bit integer number.";
      throw std::logic_error(ss.str());
    }
  } catch (const std::invalid_argument&) {
    std::wstringstream wss;
      wss
        << "Unexpected unparsable integer number from "
        << "the value matching the regex: " << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }
}

bool IsXsUnsignedShort(const std::wstring& value) {
  if (!MatchesXsUnsignedShort(value)) {
    return false;
  }

  // NOTE (mristin):
  // There exist no std::stoui or std::stou, see:
  // https://stackoverflow.com/questions/8715213/why-is-there-no-stdstou,
  // so we have to work with std::stoul.

  try {
	// NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
    const bool sizeof_unsigned_long_ge_4(
    	sizeof(unsigned long) >= 4
    );
    const bool sizeof_unsigned_long_long_ge_4(
    	sizeof(unsigned long long) >= 4
    );

    if (sizeof_unsigned_long_ge_4) {
      const unsigned long number = std::stoul(value);
      return number <= 65535ul;
    } else if (sizeof_unsigned_long_long_ge_4) {
      const unsigned long long number = std::stoull(value);
      return number <= 65535ull;
    } else {
      std::stringstream ss;
      ss
        << "The size of unsigned long was less than 4 (it was "
        << sizeof(unsigned long) << "), and the size of "
        << "unsigned long long was also less than 4 ("
        << "it was " << sizeof(unsigned long long) << "). Hence, we do not "
        << "know how to check for string parsing of "
        << "an unsigned 16-bit integer number.";
      throw std::logic_error(ss.str());
    }
  } catch (const std::invalid_argument&) {
    std::wstringstream wss;
      wss
        << "Unexpected unparsable integer number from "
        << "the value matching the regex: " << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }
}

bool IsXsUnsignedByte(const std::wstring& value) {
  if (!MatchesXsUnsignedByte(value)) {
    return false;
  }

  // NOTE (mristin):
  // There exist no std::stoui or std::stou, see:
  // https://stackoverflow.com/questions/8715213/why-is-there-no-stdstou,
  // so we have to work with std::stoul.

  try {
	// NOTE (mristin):
    // We remove the warning C4101 in MSVC with constants.
    // See: https://stackoverflow.com/questions/25573996/c4127-conditional-expression-is-constant
  	const bool sizeof_unsigned_long_ge_4(
	  sizeof(unsigned long) >= 4
  	);
  	const bool sizeof_unsigned_long_long_ge_4(
  	  sizeof(unsigned long long) >= 4
  	);

    if (sizeof_unsigned_long_ge_4) {
      const unsigned long number = std::stoul(value);
      return number <= 255ul;
    } else if (sizeof_unsigned_long_long_ge_4) {
      const unsigned long long number = std::stoull(value);
      return number <= 255ull;
    } else {
      std::stringstream ss;
      ss
        << "The size of unsigned long was less than 4 (it was "
        << sizeof(unsigned long) << "), and the size of "
        << "unsigned long long was also less than 4 ("
        << "it was " << sizeof(unsigned long long) << "). Hence, we do not "
        << "know how to check for string parsing of "
        << "an unsigned 8-bit integer number.";
      throw std::logic_error(ss.str());
    }
  } catch (const std::invalid_argument&) {
  std::wstringstream wss;
    wss
      << "Unexpected unparsable integer number from "
      << "the value matching the regex: " << value;

    throw std::invalid_argument(
      common::WstringToUtf8(wss.str())
    );
  } catch (const std::out_of_range&) {
    return false;
  }
}

// NOTE (mristin):
// We use a map instead of a switch statement to check for exhaustiveness.

std::map<
  types::DataTypeDefXsd,
  std::function<bool(const std::wstring&)>
> ConstructDataTypeDefXsdToValueConsistency() {
  std::map<
    types::DataTypeDefXsd,
    std::function<bool(const std::wstring&)>
  > result = {
    {
      types::DataTypeDefXsd::kAnyUri,
      MatchesXsAnyUri
    },
  {
      types::DataTypeDefXsd::kBase64Binary,
      MatchesXsBase64Binary
    },
    {
      types::DataTypeDefXsd::kBoolean,
      MatchesXsBoolean
    },
    {
      types::DataTypeDefXsd::kByte,
      IsXsByte
    },
    {
      types::DataTypeDefXsd::kDate,
      IsXsDate
    },
    {
      types::DataTypeDefXsd::kDateTime,
      IsXsDateTime
    },
    {
      types::DataTypeDefXsd::kDecimal,
      MatchesXsDecimal
    },
    {
      types::DataTypeDefXsd::kDouble,
      IsXsDouble
    },
    {
      types::DataTypeDefXsd::kDuration,
      MatchesXsDuration
    },
    {
      types::DataTypeDefXsd::kFloat,
      IsXsFloat
    },
    {
      types::DataTypeDefXsd::kGDay,
      MatchesXsGDay
    },
    {
      types::DataTypeDefXsd::kGMonth,
      MatchesXsGMonth
    },
    {
      types::DataTypeDefXsd::kGMonthDay,
      IsXsGMonthDay
    },
    {
      types::DataTypeDefXsd::kGYear,
      MatchesXsGYear
    },
    {
      types::DataTypeDefXsd::kGYearMonth,
      MatchesXsGYearMonth
    },
    {
      types::DataTypeDefXsd::kHexBinary,
      MatchesXsHexBinary
    },
    {
      types::DataTypeDefXsd::kInt,
      IsXsInt
    },
    {
      types::DataTypeDefXsd::kInteger,
      MatchesXsInteger
    },
    {
      types::DataTypeDefXsd::kLong,
      IsXsLong
    },
    {
      types::DataTypeDefXsd::kNegativeInteger,
      MatchesXsNegativeInteger
    },
    {
      types::DataTypeDefXsd::kNonNegativeInteger,
      MatchesXsNonNegativeInteger
    },
    {
      types::DataTypeDefXsd::kNonPositiveInteger,
      MatchesXsNonPositiveInteger
    },
    {
      types::DataTypeDefXsd::kPositiveInteger,
      MatchesXsPositiveInteger
    },
    {
      types::DataTypeDefXsd::kShort,
      IsXsShort
    },
    {
      types::DataTypeDefXsd::kString,
      MatchesXsString
    },
    {
      types::DataTypeDefXsd::kTime,
      MatchesXsTime
    },
    {
      types::DataTypeDefXsd::kUnsignedByte,
      IsXsUnsignedByte
    },
    {
      types::DataTypeDefXsd::kUnsignedInt,
      IsXsUnsignedInt
    },
    {
      types::DataTypeDefXsd::kUnsignedLong,
      IsXsUnsignedLong
    },
    {
      types::DataTypeDefXsd::kUnsignedShort,
      IsXsUnsignedShort
    }
  };

  #ifdef DEBUG
  for (types::DataTypeDefXsd literal : iteration::kOverDataTypeDefXsd) {
    const auto it = result.find(literal);
    if (it == result.end()) {
      std::stringstream ss;
      ss
        << "The enumeration literal "
        << stringification::to_string(literal)
        << " of types::DataTypeDefXsd "
        << " is not covered in ConstructDataTypeDefXsdToValueConsistency";
      throw std::logic_error(ss.str());
    }
  }
  #endif

  return result;
}

const std::map<
  types::DataTypeDefXsd,
  std::function<bool(const std::wstring&)>
> kDataTypeDefXsdToValueConsistency(
  ConstructDataTypeDefXsdToValueConsistency()
);


bool ValueConsistentWithXsdType(
  const std::wstring& value,
  types::DataTypeDefXsd value_type
) {
  const auto it = kDataTypeDefXsdToValueConsistency.find(
    value_type
  );

  if (it == kDataTypeDefXsdToValueConsistency.end()) {
    std::ostringstream ss;
    ss
      << "The value type is invalid. Expected a literal of "
      << "types::DataTypeDefXsd, but got: "
      << static_cast<std::uint32_t>(value_type);
    throw std::invalid_argument(ss.str());
  }

  const std::function<bool(const std::wstring&)>& func(
    it->second
  );

  return func(value);
}

bool IsModelReferenceTo(
  const std::shared_ptr<types::IReference>& reference,
  types::KeyTypes expected_type
) {
  return (
    (
      reference->type() == types::ReferenceTypes::kModelReference
      && reference->keys().size() != 0
      && reference->keys().back()->type() == expected_type
    )
  );
}

bool IsModelReferenceToReferable(
  const std::shared_ptr<types::IReference>& reference
) {
  return (
    (
      reference->type() == types::ReferenceTypes::kModelReference
      && reference->keys().size() != 0
      && common::Contains(
        constants::kAasReferables,
        reference->keys().back()->type()
      )
    )
  );
}

bool IdShortsOfVariablesAreUnique(
  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& input_variables,
  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& output_variables,
  const common::optional<
    std::vector<
      std::shared_ptr<types::IOperationVariable>
    >
  >& inoutput_variables
) {
  std::set<std::wstring> id_short_set;
  
  if (input_variables.has_value()) {
    const std::vector<
      std::shared_ptr<types::IOperationVariable>
    >& variables = *input_variables;
    
    for (const std::shared_ptr<types::IOperationVariable>& variable : variables) {
      const common::optional<std::wstring>& id_short(
        variable->value()->id_short()
      );
      
      if (id_short.has_value()) {
        if (id_short_set.find(*id_short) != id_short_set.end()) {
          return false;
        }
        
        id_short_set.insert(*id_short);
      }
    }
  }
  
  if (output_variables.has_value()) {
    const std::vector<
      std::shared_ptr<types::IOperationVariable>
    >& variables = *output_variables;
    
    for (const std::shared_ptr<types::IOperationVariable>& variable : variables) {
      const common::optional<std::wstring>& id_short(
        variable->value()->id_short()
      );
      
      if (id_short.has_value()) {
        if (id_short_set.find(*id_short) != id_short_set.end()) {
          return false;
        }
        
        id_short_set.insert(*id_short);
      }
    }
  }
  
  if (inoutput_variables.has_value()) {
    const std::vector<
      std::shared_ptr<types::IOperationVariable>
    >& variables = *inoutput_variables;
    
    for (const std::shared_ptr<types::IOperationVariable>& variable : variables) {
      const common::optional<std::wstring>& id_short(
        variable->value()->id_short()
      );
      
      if (id_short.has_value()) {
        if (id_short_set.find(*id_short) != id_short_set.end()) {
          return false;
        }
        
        id_short_set.insert(*id_short);
      }
    }
  }

  return true;
}

bool ExtensionNamesAreUnique(
  const std::vector<
    std::shared_ptr<types::IExtension>
  >& extensions
) {
  std::set<std::wstring> name_set;

  for (const std::shared_ptr<types::IExtension>& extension : extensions) {
    const std::wstring& name = extension->name();

    if (name_set.find(name) != name_set.end()) {
      return false;
    }

    name_set.insert(name);
  }

  return true;
}

bool SubmodelElementsHaveIdenticalSemanticIds(
  const std::vector<
    std::shared_ptr<types::ISubmodelElement>
  >& elements
) {
  types::IReference* that_semantic_id = nullptr;

  for (const std::shared_ptr<types::ISubmodelElement>& element : elements) {
    const common::optional<
      std::shared_ptr<types::IReference>
    >& this_semantic_id(
      element->semantic_id()
    );

    if (!this_semantic_id.has_value()) {
      continue;
    }

    if (that_semantic_id == nullptr) {
      that_semantic_id = (*this_semantic_id).get();
      continue;
    }

    const std::vector<
      std::shared_ptr<types::IKey>
    >& this_keys = (*this_semantic_id)->keys();

    const std::vector<
      std::shared_ptr<types::IKey>
    >& that_keys = that_semantic_id->keys();

    if (this_keys.size() != that_keys.size()) {
      return false;
    }

    for (size_t i = 0; i < that_keys.size(); ++i) {
      if (this_keys[i]->value() != that_keys[i]->value()) {
        return false;
      }
    }
  }

  return true;
}

std::map<
  types::AasSubmodelElements,
  std::function<bool(const std::shared_ptr<types::ISubmodelElement>&)>
> ConstructAasSubmodelElementToIs() {
  std::map<
    types::AasSubmodelElements,
    std::function<bool(const std::shared_ptr<types::ISubmodelElement>&)>
  > result = {
    {
      types::AasSubmodelElements::kAnnotatedRelationshipElement,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsAnnotatedRelationshipElement(*element);
      }
    },
    {
      types::AasSubmodelElements::kBasicEventElement,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsBasicEventElement(*element);
      }
    },
    {
      types::AasSubmodelElements::kBlob,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsBlob(*element);
      }
    },
    {
      types::AasSubmodelElements::kCapability,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsCapability(*element);
      }
    },
    {
      types::AasSubmodelElements::kDataElement,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsDataElement(*element);
      }
    },
    {
      types::AasSubmodelElements::kEntity,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsEntity(*element);
      }
    },
    {
      types::AasSubmodelElements::kEventElement,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsEventElement(*element);
      }
    },
    {
      types::AasSubmodelElements::kFile,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsFile(*element);
      }
    },
    {
      types::AasSubmodelElements::kMultiLanguageProperty,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsMultiLanguageProperty(*element);
      }
    },
    {
      types::AasSubmodelElements::kOperation,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsOperation(*element);
      }
    },
    {
      types::AasSubmodelElements::kProperty,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsProperty(*element);
      }
    },
    {
      types::AasSubmodelElements::kRange,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsRange(*element);
      }
    },
    {
      types::AasSubmodelElements::kReferenceElement,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsReferenceElement(*element);
      }
    },
    {
      types::AasSubmodelElements::kRelationshipElement,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsRelationshipElement(*element);
      }
    },
    {
      types::AasSubmodelElements::kSubmodelElement,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsSubmodelElement(*element);
      }
    },
    {
      types::AasSubmodelElements::kSubmodelElementList,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsSubmodelElementList(*element);
      }
    },
    {
      types::AasSubmodelElements::kSubmodelElementCollection,
      [](const std::shared_ptr<types::ISubmodelElement>& element) {
        return types::IsSubmodelElementCollection(*element);
      }
    }
  };

  #ifdef DEBUG
  for (types::AasSubmodelElements literal : iteration::kOverAasSubmodelElements) {
    const auto it = result.find(literal);
    if (it == result.end()) {
      throw std::logic_error(
        common::Concat(
          "The enumeration literal ",
          std::to_string(static_cast<std::uint32_t>(literal)),
          " of types::AasSubmodelElements "
          " is not covered in ConstructAasSubmodelElementToIs"
        )
      );
    }
  }
  #endif

  return result;
}

const std::map<
  types::AasSubmodelElements,
  std::function<bool(const std::shared_ptr<types::ISubmodelElement>&)>
> kAasSubmodelElementToIs = ConstructAasSubmodelElementToIs();

bool SubmodelElementIsOfType(
  const std::shared_ptr<types::ISubmodelElement>& element,
  types::AasSubmodelElements element_type
) {
  const auto it = kAasSubmodelElementToIs.find(element_type);
  if (it == kAasSubmodelElementToIs.end()) {
    throw std::invalid_argument(
      common::Concat(
        "Unexpected element type: ",
        std::to_string(static_cast<uint32_t>(element_type))
      )
    );
  }

  const std::function<
    bool(const std::shared_ptr<types::ISubmodelElement>&)
  >& is_function(
    it->second
  );

  return is_function(element);
}

bool PropertiesOrRangesHaveValueType(
  const std::vector<
    std::shared_ptr<types::ISubmodelElement>
  >& elements,
  types::DataTypeDefXsd value_type
) {
  for (const std::shared_ptr<types::ISubmodelElement>& element : elements) {
    // NOTE (mristin):
    // Dynamic casts are necessary here due to virtual inheritance.

    switch (element->model_type()) {
      case types::ModelType::kProperty: {
        types::IProperty* casted = dynamic_cast<types::IProperty*>(
          element.get()
        );

        if (casted->value_type() != value_type) {
          return false;
        }
        break;
      }
      case types::ModelType::kRange: {
        types::IRange* casted = dynamic_cast<types::IRange*>(
          element.get()
        );

        if (casted->value_type() != value_type) {
          return false;
        }
        break;
      }
    }
  }

  return true;
}

bool ReferenceKeyValuesEqual(
  const std::shared_ptr<types::IReference>& that,
  const std::shared_ptr<types::IReference>& other
) {
  if (that->keys().size() != other->keys().size()) {
    return false;
  }

  const std::vector<
    std::shared_ptr<types::IKey>
  >& that_keys = that->keys();

  const std::vector<
    std::shared_ptr<types::IKey>
  >& other_keys = other->keys();

  for (size_t i = 0; i < that_keys.size(); ++i) {
    if (that_keys[i]->value() != other_keys[i]->value()) {
      return false;
    }
  }

  return true;
}

bool DataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(
  const std::vector<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >& embedded_data_specifications
) {
  for (const auto& embedded_data_specification : embedded_data_specifications) {
    const std::shared_ptr<
      types::IDataSpecificationContent
    >& content(
      embedded_data_specification->data_specification_content()
    );

	// NOTE (mristin):
	// We need to use dynamic cast due to virtual inheritance. Otherwise,
    // we would have used the model_type followed by a static cast.
	const types::IDataSpecificationIec61360* iec61360 = dynamic_cast<
	  const types::IDataSpecificationIec61360*
	>(content.get());

    if (iec61360 != nullptr) {
      const common::optional<
        types::DataTypeIec61360
      >& data_type(
        iec61360->data_type()
      );

      if (
        !data_type.has_value()
        || (
          constants::kDataTypeIec61360ForPropertyOrValue.find(*data_type)
          == constants::kDataTypeIec61360ForPropertyOrValue.end()
        )
      ) {
        return false;
      }
    }
  }

  return true;
}

bool DataSpecificationIec61360sForReferenceHaveAppropriateDataType(
  const std::vector<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >& embedded_data_specifications
) {
  for (const auto& embedded_data_specification : embedded_data_specifications) {
    const std::shared_ptr<
      types::IDataSpecificationContent
    >& content(
      embedded_data_specification->data_specification_content()
    );

    // NOTE (mristin):
	// We need to use dynamic cast due to virtual inheritance. Otherwise,
    // we would have used the model_type followed by a static cast.
	const types::IDataSpecificationIec61360* iec61360 = dynamic_cast<
	  const types::IDataSpecificationIec61360*
	>(content.get());

    if (iec61360 != nullptr) {
	  const common::optional<
	    types::DataTypeIec61360
	  >& data_type(
        iec61360->data_type()
      );

      if (
        !data_type.has_value()
        || (
          constants::kDataTypeIec61360ForReference.find(*data_type) ==
          constants::kDataTypeIec61360ForReference.end()
        )
      ) {
        return false;
      }
    }
  }

  return true;
}

bool DataSpecificationIec61360sForDocumentHaveAppropriateDataType(
  const std::vector<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >& embedded_data_specifications
) {
  for (const auto& embedded_data_specification : embedded_data_specifications) {
    const std::shared_ptr<
      types::IDataSpecificationContent
    >& content(
      embedded_data_specification->data_specification_content()
    );

	// NOTE (mristin):
    // We need to use dynamic cast due to virtual inheritance. Otherwise,
    // we would have used the model_type followed by a static cast.
	const types::IDataSpecificationIec61360* iec61360 = dynamic_cast<
	  const types::IDataSpecificationIec61360*
	>(content.get());

    if (iec61360 != nullptr) {
	  const common::optional<
	    types::DataTypeIec61360
	  >& data_type(
        iec61360->data_type()
      );

      if (
        !data_type.has_value()
        || (
          constants::kDataTypeIec61360ForDocument.find(*data_type)
          == constants::kDataTypeIec61360ForDocument.end()
        )
      ) {
        return false;
      }
    }
  }

  return true;
}

bool DataSpecificationIec61360sHaveDataType(
  const std::vector<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >& embedded_data_specifications
) {
  for (const auto& embedded_data_specification : embedded_data_specifications) {
    const std::shared_ptr<
      types::IDataSpecificationContent
    >& content(
      embedded_data_specification->data_specification_content()
    );

    // NOTE (mristin):
	// We need to use dynamic cast due to virtual inheritance. Otherwise,
    // we would have used the model_type followed by a static cast.
	const types::IDataSpecificationIec61360* iec61360 = dynamic_cast<
	  const types::IDataSpecificationIec61360*
	>(content.get());

    if (iec61360 != nullptr) {
	  const common::optional<
	    types::DataTypeIec61360
	  >& data_type(
        iec61360->data_type()
      );

      if (!data_type.has_value()) {
        return false;
      }
    }
  }

  return true;
}

bool DataSpecificationIec61360sHaveValue(
  const std::vector<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >& embedded_data_specifications
) {
  for (const auto& embedded_data_specification : embedded_data_specifications) {
    const std::shared_ptr<
      types::IDataSpecificationContent
    >& content(
      embedded_data_specification->data_specification_content()
    );

    // NOTE (mristin):
	// We need to use dynamic cast due to virtual inheritance. Otherwise,
    // we would have used the model_type followed by a static cast.
	const types::IDataSpecificationIec61360* iec61360 = dynamic_cast<
	  const types::IDataSpecificationIec61360*
	>(content.get());

    if (iec61360 != nullptr) {
	  const common::optional<std::wstring>& maybe_value(
        iec61360->value()
      );

      if (!maybe_value.has_value()) {
        return false;
      }
    }
  }

  return true;
}

bool DataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(
  const std::vector<
    std::shared_ptr<types::IEmbeddedDataSpecification>
  >& embedded_data_specifications
) {
  for (const auto& embedded_data_specification : embedded_data_specifications) {
    const std::shared_ptr<
      types::IDataSpecificationContent
    >& content(
      embedded_data_specification->data_specification_content()
    );

    // NOTE (mristin):
	// We need to use dynamic cast due to virtual inheritance. Otherwise,
    // we would have used the model_type followed by a static cast.
	const types::IDataSpecificationIec61360* iec61360 = dynamic_cast<
	  const types::IDataSpecificationIec61360*
	>(content.get());

    if (iec61360 != nullptr) {
      const common::optional<
        std::vector<
          std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
        >
      >& maybe_definition = iec61360->definition();

      if (!maybe_definition.has_value()) {
        return false;
      }

      const std::vector<
        std::shared_ptr<types::ILangStringDefinitionTypeIec61360>
      >& definition = *maybe_definition;

      bool no_definition_in_english = true;
      for (const auto& lang_string : definition) {
        if (IsBcp47ForEnglish(lang_string->language())) {
          no_definition_in_english = false;
          break;
        }
      }

      if (no_definition_in_english) {
      	return false;
      }
    }
  }

  return true;
}

bool IsBcp47ForEnglish(
  const std::wstring& text
) {
  return revm::Match(
    pattern::kIsBcp47ForEnglishProgram,
    text
  );
}

// endregion Verification functions

// region Verification of constrained primitives

namespace constrained_primitive_verificator {

class OfNonEmptyXmlSerializableString : public impl::IVerificator {
 public:
  OfNonEmptyXmlSerializableString(
    const std::wstring& value
  );

  OfNonEmptyXmlSerializableString(
    const OfNonEmptyXmlSerializableString& other
  );
  OfNonEmptyXmlSerializableString(
    OfNonEmptyXmlSerializableString&& other
  );
  OfNonEmptyXmlSerializableString& operator=(
    const OfNonEmptyXmlSerializableString& other
  );
  OfNonEmptyXmlSerializableString& operator=(
    OfNonEmptyXmlSerializableString&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfNonEmptyXmlSerializableString() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfNonEmptyXmlSerializableString

OfNonEmptyXmlSerializableString::OfNonEmptyXmlSerializableString(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfNonEmptyXmlSerializableString::OfNonEmptyXmlSerializableString(
  const OfNonEmptyXmlSerializableString& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfNonEmptyXmlSerializableString::OfNonEmptyXmlSerializableString(
  OfNonEmptyXmlSerializableString&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfNonEmptyXmlSerializableString& OfNonEmptyXmlSerializableString::operator=(
  const OfNonEmptyXmlSerializableString& other
) {
  return *this = OfNonEmptyXmlSerializableString(other);
}

OfNonEmptyXmlSerializableString& OfNonEmptyXmlSerializableString::operator=(
  OfNonEmptyXmlSerializableString&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfNonEmptyXmlSerializableString::Start() {
  state_ = 0;
  Execute();
}

void OfNonEmptyXmlSerializableString::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfNonEmptyXmlSerializableString, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfNonEmptyXmlSerializableString::Done() const {
  return done_;
}

const Error& OfNonEmptyXmlSerializableString::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfNonEmptyXmlSerializableString, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfNonEmptyXmlSerializableString::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfNonEmptyXmlSerializableString, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfNonEmptyXmlSerializableString::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfNonEmptyXmlSerializableString, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfNonEmptyXmlSerializableString::Clone() const {
  return common::make_unique<
    OfNonEmptyXmlSerializableString
  >(*this);
}

void OfNonEmptyXmlSerializableString::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 3;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfDateTimeUtc : public impl::IVerificator {
 public:
  OfDateTimeUtc(
    const std::wstring& value
  );

  OfDateTimeUtc(
    const OfDateTimeUtc& other
  );
  OfDateTimeUtc(
    OfDateTimeUtc&& other
  );
  OfDateTimeUtc& operator=(
    const OfDateTimeUtc& other
  );
  OfDateTimeUtc& operator=(
    OfDateTimeUtc&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfDateTimeUtc() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfDateTimeUtc

OfDateTimeUtc::OfDateTimeUtc(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfDateTimeUtc::OfDateTimeUtc(
  const OfDateTimeUtc& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfDateTimeUtc::OfDateTimeUtc(
  OfDateTimeUtc&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfDateTimeUtc& OfDateTimeUtc::operator=(
  const OfDateTimeUtc& other
) {
  return *this = OfDateTimeUtc(other);
}

OfDateTimeUtc& OfDateTimeUtc::operator=(
  OfDateTimeUtc&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfDateTimeUtc::Start() {
  state_ = 0;
  Execute();
}

void OfDateTimeUtc::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfDateTimeUtc, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfDateTimeUtc::Done() const {
  return done_;
}

const Error& OfDateTimeUtc::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfDateTimeUtc, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfDateTimeUtc::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfDateTimeUtc, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfDateTimeUtc::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfDateTimeUtc, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfDateTimeUtc::Clone() const {
  return common::make_unique<
    OfDateTimeUtc
  >(*this);
}

void OfDateTimeUtc::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXsDateTimeUtc(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must match the pattern of xs:dateTime with "
          L"the time zone fixed to UTC."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          IsXsDateTimeUtc(
            (*value_)
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must represent a valid xs:dateTime with the time "
          L"zone fixed to UTC."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 3;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfDuration : public impl::IVerificator {
 public:
  OfDuration(
    const std::wstring& value
  );

  OfDuration(
    const OfDuration& other
  );
  OfDuration(
    OfDuration&& other
  );
  OfDuration& operator=(
    const OfDuration& other
  );
  OfDuration& operator=(
    OfDuration&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfDuration() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfDuration

OfDuration::OfDuration(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfDuration::OfDuration(
  const OfDuration& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfDuration::OfDuration(
  OfDuration&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfDuration& OfDuration::operator=(
  const OfDuration& other
) {
  return *this = OfDuration(other);
}

OfDuration& OfDuration::operator=(
  OfDuration&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfDuration::Start() {
  state_ = 0;
  Execute();
}

void OfDuration::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfDuration, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfDuration::Done() const {
  return done_;
}

const Error& OfDuration::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfDuration, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfDuration::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfDuration, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfDuration::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfDuration, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfDuration::Clone() const {
  return common::make_unique<
    OfDuration
  >(*this);
}

void OfDuration::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXsDuration(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must match the pattern of xs:duration."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 2;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfBlobType : public impl::IVerificator {
 public:
  OfBlobType(
    const std::vector<std::uint8_t>& value
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  virtual ~OfBlobType() = default;
};  // class OfBlobType

OfBlobType::OfBlobType(
  const std::vector<std::uint8_t>&
) {
  // Intentionally empty.
}

void OfBlobType::Start() {
  // Intentionally empty.
}

void OfBlobType::Next() {
  throw std::logic_error(
    "You want to move "
    "a verificator OfBlobType, "
    "but the verificator is always done as "
    "there are no invariants defined for this constrained primitive."
  );
}

bool OfBlobType::Done() const {
  return true;
}

const Error& OfBlobType::Get() const {
  throw std::logic_error(
    "You want to get from "
    "a verificator OfBlobType, "
    "but the verificator is always done as "
    "there are no invariants defined for this constrained primitive."
  );
}

Error& OfBlobType::GetMutable() {
  throw std::logic_error(
    "You want to get mutable from "
    "a verificator OfBlobType, "
    "but the verificator is always done as "
    "there are no invariants defined for this constrained primitive."
  );
}

long OfBlobType::Index() const {
  return -1;
}

std::unique_ptr<impl::IVerificator> OfBlobType::Clone() const {
  return common::make_unique<
    OfBlobType
  >(*this);
}

class OfIdentifier : public impl::IVerificator {
 public:
  OfIdentifier(
    const std::wstring& value
  );

  OfIdentifier(
    const OfIdentifier& other
  );
  OfIdentifier(
    OfIdentifier&& other
  );
  OfIdentifier& operator=(
    const OfIdentifier& other
  );
  OfIdentifier& operator=(
    OfIdentifier&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfIdentifier() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfIdentifier

OfIdentifier::OfIdentifier(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfIdentifier::OfIdentifier(
  const OfIdentifier& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfIdentifier::OfIdentifier(
  OfIdentifier&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfIdentifier& OfIdentifier::operator=(
  const OfIdentifier& other
) {
  return *this = OfIdentifier(other);
}

OfIdentifier& OfIdentifier::operator=(
  OfIdentifier&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfIdentifier::Start() {
  state_ = 0;
  Execute();
}

void OfIdentifier::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfIdentifier, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfIdentifier::Done() const {
  return done_;
}

const Error& OfIdentifier::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfIdentifier, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfIdentifier::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfIdentifier, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfIdentifier::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfIdentifier, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfIdentifier::Clone() const {
  return common::make_unique<
    OfIdentifier
  >(*this);
}

void OfIdentifier::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 2000) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Identifier shall have a maximum length of 2000 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfValueTypeIec61360 : public impl::IVerificator {
 public:
  OfValueTypeIec61360(
    const std::wstring& value
  );

  OfValueTypeIec61360(
    const OfValueTypeIec61360& other
  );
  OfValueTypeIec61360(
    OfValueTypeIec61360&& other
  );
  OfValueTypeIec61360& operator=(
    const OfValueTypeIec61360& other
  );
  OfValueTypeIec61360& operator=(
    OfValueTypeIec61360&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfValueTypeIec61360() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfValueTypeIec61360

OfValueTypeIec61360::OfValueTypeIec61360(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfValueTypeIec61360::OfValueTypeIec61360(
  const OfValueTypeIec61360& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfValueTypeIec61360::OfValueTypeIec61360(
  OfValueTypeIec61360&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfValueTypeIec61360& OfValueTypeIec61360::operator=(
  const OfValueTypeIec61360& other
) {
  return *this = OfValueTypeIec61360(other);
}

OfValueTypeIec61360& OfValueTypeIec61360::operator=(
  OfValueTypeIec61360&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfValueTypeIec61360::Start() {
  state_ = 0;
  Execute();
}

void OfValueTypeIec61360::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfValueTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfValueTypeIec61360::Done() const {
  return done_;
}

const Error& OfValueTypeIec61360::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfValueTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfValueTypeIec61360::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfValueTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfValueTypeIec61360::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfValueTypeIec61360, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfValueTypeIec61360::Clone() const {
  return common::make_unique<
    OfValueTypeIec61360
  >(*this);
}

void OfValueTypeIec61360::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 2000) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Value type IEC 61360 shall have a maximum length of 2000 "
          L"characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfNameType : public impl::IVerificator {
 public:
  OfNameType(
    const std::wstring& value
  );

  OfNameType(
    const OfNameType& other
  );
  OfNameType(
    OfNameType&& other
  );
  OfNameType& operator=(
    const OfNameType& other
  );
  OfNameType& operator=(
    OfNameType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfNameType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfNameType

OfNameType::OfNameType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfNameType::OfNameType(
  const OfNameType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfNameType::OfNameType(
  OfNameType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfNameType& OfNameType::operator=(
  const OfNameType& other
) {
  return *this = OfNameType(other);
}

OfNameType& OfNameType::operator=(
  OfNameType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfNameType::Start() {
  state_ = 0;
  Execute();
}

void OfNameType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfNameType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfNameType::Done() const {
  return done_;
}

const Error& OfNameType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfNameType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfNameType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfNameType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfNameType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfNameType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfNameType::Clone() const {
  return common::make_unique<
    OfNameType
  >(*this);
}

void OfNameType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 128) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Name type shall have a maximum length of 128 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfVersionType : public impl::IVerificator {
 public:
  OfVersionType(
    const std::wstring& value
  );

  OfVersionType(
    const OfVersionType& other
  );
  OfVersionType(
    OfVersionType&& other
  );
  OfVersionType& operator=(
    const OfVersionType& other
  );
  OfVersionType& operator=(
    OfVersionType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfVersionType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfVersionType

OfVersionType::OfVersionType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfVersionType::OfVersionType(
  const OfVersionType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfVersionType::OfVersionType(
  OfVersionType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfVersionType& OfVersionType::operator=(
  const OfVersionType& other
) {
  return *this = OfVersionType(other);
}

OfVersionType& OfVersionType::operator=(
  OfVersionType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfVersionType::Start() {
  state_ = 0;
  Execute();
}

void OfVersionType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfVersionType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfVersionType::Done() const {
  return done_;
}

const Error& OfVersionType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfVersionType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfVersionType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfVersionType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfVersionType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfVersionType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfVersionType::Clone() const {
  return common::make_unique<
    OfVersionType
  >(*this);
}

void OfVersionType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          MatchesVersionType(
            (*value_)
          )
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Version type shall match the version pattern."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if ((*value_).size() <= 4) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Version type shall have a maximum length of 4 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 5;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfRevisionType : public impl::IVerificator {
 public:
  OfRevisionType(
    const std::wstring& value
  );

  OfRevisionType(
    const OfRevisionType& other
  );
  OfRevisionType(
    OfRevisionType&& other
  );
  OfRevisionType& operator=(
    const OfRevisionType& other
  );
  OfRevisionType& operator=(
    OfRevisionType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfRevisionType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfRevisionType

OfRevisionType::OfRevisionType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfRevisionType::OfRevisionType(
  const OfRevisionType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfRevisionType::OfRevisionType(
  OfRevisionType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfRevisionType& OfRevisionType::operator=(
  const OfRevisionType& other
) {
  return *this = OfRevisionType(other);
}

OfRevisionType& OfRevisionType::operator=(
  OfRevisionType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfRevisionType::Start() {
  state_ = 0;
  Execute();
}

void OfRevisionType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfRevisionType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfRevisionType::Done() const {
  return done_;
}

const Error& OfRevisionType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfRevisionType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfRevisionType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfRevisionType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfRevisionType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfRevisionType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfRevisionType::Clone() const {
  return common::make_unique<
    OfRevisionType
  >(*this);
}

void OfRevisionType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          MatchesRevisionType(
            (*value_)
          )
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Revision type shall match the revision pattern."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if ((*value_).size() <= 4) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Revision type shall have a maximum length of 4 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 5;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfLabelType : public impl::IVerificator {
 public:
  OfLabelType(
    const std::wstring& value
  );

  OfLabelType(
    const OfLabelType& other
  );
  OfLabelType(
    OfLabelType&& other
  );
  OfLabelType& operator=(
    const OfLabelType& other
  );
  OfLabelType& operator=(
    OfLabelType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfLabelType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfLabelType

OfLabelType::OfLabelType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfLabelType::OfLabelType(
  const OfLabelType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfLabelType::OfLabelType(
  OfLabelType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfLabelType& OfLabelType::operator=(
  const OfLabelType& other
) {
  return *this = OfLabelType(other);
}

OfLabelType& OfLabelType::operator=(
  OfLabelType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfLabelType::Start() {
  state_ = 0;
  Execute();
}

void OfLabelType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfLabelType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfLabelType::Done() const {
  return done_;
}

const Error& OfLabelType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfLabelType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfLabelType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfLabelType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfLabelType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfLabelType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfLabelType::Clone() const {
  return common::make_unique<
    OfLabelType
  >(*this);
}

void OfLabelType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 64) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Label type shall have a maximum length of 64 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfMessageTopicType : public impl::IVerificator {
 public:
  OfMessageTopicType(
    const std::wstring& value
  );

  OfMessageTopicType(
    const OfMessageTopicType& other
  );
  OfMessageTopicType(
    OfMessageTopicType&& other
  );
  OfMessageTopicType& operator=(
    const OfMessageTopicType& other
  );
  OfMessageTopicType& operator=(
    OfMessageTopicType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfMessageTopicType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfMessageTopicType

OfMessageTopicType::OfMessageTopicType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfMessageTopicType::OfMessageTopicType(
  const OfMessageTopicType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfMessageTopicType::OfMessageTopicType(
  OfMessageTopicType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfMessageTopicType& OfMessageTopicType::operator=(
  const OfMessageTopicType& other
) {
  return *this = OfMessageTopicType(other);
}

OfMessageTopicType& OfMessageTopicType::operator=(
  OfMessageTopicType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfMessageTopicType::Start() {
  state_ = 0;
  Execute();
}

void OfMessageTopicType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfMessageTopicType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfMessageTopicType::Done() const {
  return done_;
}

const Error& OfMessageTopicType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfMessageTopicType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfMessageTopicType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfMessageTopicType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfMessageTopicType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfMessageTopicType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfMessageTopicType::Clone() const {
  return common::make_unique<
    OfMessageTopicType
  >(*this);
}

void OfMessageTopicType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 255) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Message topic type shall have a maximum length of 255 "
          L"characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfBcp47LanguageTag : public impl::IVerificator {
 public:
  OfBcp47LanguageTag(
    const std::wstring& value
  );

  OfBcp47LanguageTag(
    const OfBcp47LanguageTag& other
  );
  OfBcp47LanguageTag(
    OfBcp47LanguageTag&& other
  );
  OfBcp47LanguageTag& operator=(
    const OfBcp47LanguageTag& other
  );
  OfBcp47LanguageTag& operator=(
    OfBcp47LanguageTag&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfBcp47LanguageTag() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfBcp47LanguageTag

OfBcp47LanguageTag::OfBcp47LanguageTag(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfBcp47LanguageTag::OfBcp47LanguageTag(
  const OfBcp47LanguageTag& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfBcp47LanguageTag::OfBcp47LanguageTag(
  OfBcp47LanguageTag&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfBcp47LanguageTag& OfBcp47LanguageTag::operator=(
  const OfBcp47LanguageTag& other
) {
  return *this = OfBcp47LanguageTag(other);
}

OfBcp47LanguageTag& OfBcp47LanguageTag::operator=(
  OfBcp47LanguageTag&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfBcp47LanguageTag::Start() {
  state_ = 0;
  Execute();
}

void OfBcp47LanguageTag::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfBcp47LanguageTag, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfBcp47LanguageTag::Done() const {
  return done_;
}

const Error& OfBcp47LanguageTag::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfBcp47LanguageTag, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfBcp47LanguageTag::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfBcp47LanguageTag, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfBcp47LanguageTag::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfBcp47LanguageTag, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfBcp47LanguageTag::Clone() const {
  return common::make_unique<
    OfBcp47LanguageTag
  >(*this);
}

void OfBcp47LanguageTag::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesBcp47(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must represent a value language tag conformant to "
          L"BCP 47."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 2;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfContentType : public impl::IVerificator {
 public:
  OfContentType(
    const std::wstring& value
  );

  OfContentType(
    const OfContentType& other
  );
  OfContentType(
    OfContentType&& other
  );
  OfContentType& operator=(
    const OfContentType& other
  );
  OfContentType& operator=(
    OfContentType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfContentType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfContentType

OfContentType::OfContentType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfContentType::OfContentType(
  const OfContentType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfContentType::OfContentType(
  OfContentType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfContentType& OfContentType::operator=(
  const OfContentType& other
) {
  return *this = OfContentType(other);
}

OfContentType& OfContentType::operator=(
  OfContentType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfContentType::Start() {
  state_ = 0;
  Execute();
}

void OfContentType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfContentType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfContentType::Done() const {
  return done_;
}

const Error& OfContentType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfContentType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfContentType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfContentType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfContentType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfContentType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfContentType::Clone() const {
  return common::make_unique<
    OfContentType
  >(*this);
}

void OfContentType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 100) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Content type shall have a maximum length of 100 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          MatchesMimeType(
            (*value_)
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must represent a valid content MIME type "
          L"according to RFC 2046."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 5;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfPathType : public impl::IVerificator {
 public:
  OfPathType(
    const std::wstring& value
  );

  OfPathType(
    const OfPathType& other
  );
  OfPathType(
    OfPathType&& other
  );
  OfPathType& operator=(
    const OfPathType& other
  );
  OfPathType& operator=(
    OfPathType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfPathType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfPathType

OfPathType::OfPathType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfPathType::OfPathType(
  const OfPathType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfPathType::OfPathType(
  OfPathType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfPathType& OfPathType::operator=(
  const OfPathType& other
) {
  return *this = OfPathType(other);
}

OfPathType& OfPathType::operator=(
  OfPathType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfPathType::Start() {
  state_ = 0;
  Execute();
}

void OfPathType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfPathType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfPathType::Done() const {
  return done_;
}

const Error& OfPathType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfPathType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfPathType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfPathType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfPathType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfPathType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfPathType::Clone() const {
  return common::make_unique<
    OfPathType
  >(*this);
}

void OfPathType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 2000) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Identifier shall have a maximum length of 2000 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfQualifierType : public impl::IVerificator {
 public:
  OfQualifierType(
    const std::wstring& value
  );

  OfQualifierType(
    const OfQualifierType& other
  );
  OfQualifierType(
    OfQualifierType&& other
  );
  OfQualifierType& operator=(
    const OfQualifierType& other
  );
  OfQualifierType& operator=(
    OfQualifierType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfQualifierType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfQualifierType

OfQualifierType::OfQualifierType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfQualifierType::OfQualifierType(
  const OfQualifierType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfQualifierType::OfQualifierType(
  OfQualifierType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfQualifierType& OfQualifierType::operator=(
  const OfQualifierType& other
) {
  return *this = OfQualifierType(other);
}

OfQualifierType& OfQualifierType::operator=(
  OfQualifierType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfQualifierType::Start() {
  state_ = 0;
  Execute();
}

void OfQualifierType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfQualifierType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfQualifierType::Done() const {
  return done_;
}

const Error& OfQualifierType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfQualifierType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfQualifierType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfQualifierType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfQualifierType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfQualifierType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfQualifierType::Clone() const {
  return common::make_unique<
    OfQualifierType
  >(*this);
}

void OfQualifierType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 128) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Name type shall have a maximum length of 128 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfValueDataType : public impl::IVerificator {
 public:
  OfValueDataType(
    const std::wstring& value
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  virtual ~OfValueDataType() = default;
};  // class OfValueDataType

OfValueDataType::OfValueDataType(
  const std::wstring&
) {
  // Intentionally empty.
}

void OfValueDataType::Start() {
  // Intentionally empty.
}

void OfValueDataType::Next() {
  throw std::logic_error(
    "You want to move "
    "a verificator OfValueDataType, "
    "but the verificator is always done as "
    "there are no invariants defined for this constrained primitive."
  );
}

bool OfValueDataType::Done() const {
  return true;
}

const Error& OfValueDataType::Get() const {
  throw std::logic_error(
    "You want to get from "
    "a verificator OfValueDataType, "
    "but the verificator is always done as "
    "there are no invariants defined for this constrained primitive."
  );
}

Error& OfValueDataType::GetMutable() {
  throw std::logic_error(
    "You want to get mutable from "
    "a verificator OfValueDataType, "
    "but the verificator is always done as "
    "there are no invariants defined for this constrained primitive."
  );
}

long OfValueDataType::Index() const {
  return -1;
}

std::unique_ptr<impl::IVerificator> OfValueDataType::Clone() const {
  return common::make_unique<
    OfValueDataType
  >(*this);
}

class OfIdShortType : public impl::IVerificator {
 public:
  OfIdShortType(
    const std::wstring& value
  );

  OfIdShortType(
    const OfIdShortType& other
  );
  OfIdShortType(
    OfIdShortType&& other
  );
  OfIdShortType& operator=(
    const OfIdShortType& other
  );
  OfIdShortType& operator=(
    OfIdShortType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfIdShortType() override = default;

 private:
  const std::wstring* value_;
  long index_;
  std::unique_ptr<Error> error_;
  bool done_;
  std::uint32_t state_;

  void Execute();
};  // class OfIdShortType

OfIdShortType::OfIdShortType(
  const std::wstring& value
) : value_(&value) {
  // Intentionally empty.
}

OfIdShortType::OfIdShortType(
  const OfIdShortType& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfIdShortType::OfIdShortType(
  OfIdShortType&& other
) {
  value_ = other.value_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  done_ = other.done_;
  state_ = other.state_;
}

OfIdShortType& OfIdShortType::operator=(
  const OfIdShortType& other
) {
  return *this = OfIdShortType(other);
}

OfIdShortType& OfIdShortType::operator=(
  OfIdShortType&& other
) {
  if (this != &other) {
    value_ = other.value_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    done_ = other.done_;
    state_ = other.state_;
  }

  return *this;
}

void OfIdShortType::Start() {
  state_ = 0;
  Execute();
}

void OfIdShortType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfIdShortType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfIdShortType::Done() const {
  return done_;
}

const Error& OfIdShortType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfIdShortType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfIdShortType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfIdShortType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfIdShortType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfIdShortType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfIdShortType::Clone() const {
  return common::make_unique<
    OfIdShortType
  >(*this);
}

void OfIdShortType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          MatchesXmlSerializableString(
            (*value_)
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-130: An attribute with data type 'string' "
          L"shall consist of these characters only: "
          L"^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if ((*value_).size() >= 1) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must not be empty."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if ((*value_).size() <= 128) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Name type shall have a maximum length of 128 characters."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          MatchesIdShort(
            (*value_)
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"ID-short of Referables shall only feature letters, digits, "
          L"underscore (``_``); starting mandatory with a letter. "
          L"*I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``."
        );
        // No path is prepended as the error refers to the value itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 5;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

}  // namespace constrained_primitive_verificator

namespace constrained_primitive_verification {

// region OfNonEmptyXmlSerializableString

class OfNonEmptyXmlSerializableString : public IVerification {
 public:
  OfNonEmptyXmlSerializableString(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfNonEmptyXmlSerializableString() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfNonEmptyXmlSerializableString::OfNonEmptyXmlSerializableString(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfNonEmptyXmlSerializableString::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfNonEmptyXmlSerializableString
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfNonEmptyXmlSerializableString::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfNonEmptyXmlSerializableString

// region OfDateTimeUtc

class OfDateTimeUtc : public IVerification {
 public:
  OfDateTimeUtc(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfDateTimeUtc() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfDateTimeUtc::OfDateTimeUtc(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfDateTimeUtc::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfDateTimeUtc
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfDateTimeUtc::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfDateTimeUtc

// region OfDuration

class OfDuration : public IVerification {
 public:
  OfDuration(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfDuration() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfDuration::OfDuration(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfDuration::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfDuration
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfDuration::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfDuration

// region OfBlobType

class OfBlobType : public IVerification {
 public:
  OfBlobType(
    const std::vector<std::uint8_t>& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfBlobType() override = default;
 private:
  const std::vector<std::uint8_t>& value_;
};  // class ConstrainedPrimitiveVerification

OfBlobType::OfBlobType(
  const std::vector<std::uint8_t>& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfBlobType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfBlobType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfBlobType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfBlobType

// region OfIdentifier

class OfIdentifier : public IVerification {
 public:
  OfIdentifier(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfIdentifier() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfIdentifier::OfIdentifier(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfIdentifier::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfIdentifier
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfIdentifier::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfIdentifier

// region OfValueTypeIec61360

class OfValueTypeIec61360 : public IVerification {
 public:
  OfValueTypeIec61360(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfValueTypeIec61360() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfValueTypeIec61360::OfValueTypeIec61360(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfValueTypeIec61360::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfValueTypeIec61360
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfValueTypeIec61360::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfValueTypeIec61360

// region OfNameType

class OfNameType : public IVerification {
 public:
  OfNameType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfNameType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfNameType::OfNameType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfNameType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfNameType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfNameType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfNameType

// region OfVersionType

class OfVersionType : public IVerification {
 public:
  OfVersionType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfVersionType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfVersionType::OfVersionType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfVersionType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfVersionType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfVersionType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfVersionType

// region OfRevisionType

class OfRevisionType : public IVerification {
 public:
  OfRevisionType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfRevisionType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfRevisionType::OfRevisionType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfRevisionType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfRevisionType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfRevisionType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfRevisionType

// region OfLabelType

class OfLabelType : public IVerification {
 public:
  OfLabelType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfLabelType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfLabelType::OfLabelType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfLabelType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfLabelType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfLabelType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfLabelType

// region OfMessageTopicType

class OfMessageTopicType : public IVerification {
 public:
  OfMessageTopicType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfMessageTopicType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfMessageTopicType::OfMessageTopicType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfMessageTopicType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfMessageTopicType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfMessageTopicType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfMessageTopicType

// region OfBcp47LanguageTag

class OfBcp47LanguageTag : public IVerification {
 public:
  OfBcp47LanguageTag(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfBcp47LanguageTag() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfBcp47LanguageTag::OfBcp47LanguageTag(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfBcp47LanguageTag::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfBcp47LanguageTag
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfBcp47LanguageTag::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfBcp47LanguageTag

// region OfContentType

class OfContentType : public IVerification {
 public:
  OfContentType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfContentType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfContentType::OfContentType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfContentType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfContentType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfContentType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfContentType

// region OfPathType

class OfPathType : public IVerification {
 public:
  OfPathType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfPathType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfPathType::OfPathType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfPathType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfPathType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfPathType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfPathType

// region OfQualifierType

class OfQualifierType : public IVerification {
 public:
  OfQualifierType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfQualifierType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfQualifierType::OfQualifierType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfQualifierType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfQualifierType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfQualifierType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfQualifierType

// region OfValueDataType

class OfValueDataType : public IVerification {
 public:
  OfValueDataType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfValueDataType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfValueDataType::OfValueDataType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfValueDataType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfValueDataType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfValueDataType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfValueDataType

// region OfIdShortType

class OfIdShortType : public IVerification {
 public:
  OfIdShortType(
    const std::wstring& value
  );

  Iterator begin() const override;
  const Iterator& end() const override;

  ~OfIdShortType() override = default;
 private:
  const std::wstring& value_;
};  // class ConstrainedPrimitiveVerification

OfIdShortType::OfIdShortType(
  const std::wstring& value
) : value_(value) {
  // Intentionally empty.
}

Iterator OfIdShortType::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<
      constrained_primitive_verificator::OfIdShortType
    >(value_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& OfIdShortType::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion OfIdShortType

}  // namespace constrained_primitive_verification

std::unique_ptr<IVerification> VerifyNonEmptyXmlSerializableString(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfNonEmptyXmlSerializableString
  >(that);
}

std::unique_ptr<IVerification> VerifyDateTimeUtc(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfDateTimeUtc
  >(that);
}

std::unique_ptr<IVerification> VerifyDuration(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfDuration
  >(that);
}

std::unique_ptr<IVerification> VerifyBlobType(
  const std::vector<std::uint8_t>& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfBlobType
  >(that);
}

std::unique_ptr<IVerification> VerifyIdentifier(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfIdentifier
  >(that);
}

std::unique_ptr<IVerification> VerifyValueTypeIec61360(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfValueTypeIec61360
  >(that);
}

std::unique_ptr<IVerification> VerifyNameType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfNameType
  >(that);
}

std::unique_ptr<IVerification> VerifyVersionType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfVersionType
  >(that);
}

std::unique_ptr<IVerification> VerifyRevisionType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfRevisionType
  >(that);
}

std::unique_ptr<IVerification> VerifyLabelType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfLabelType
  >(that);
}

std::unique_ptr<IVerification> VerifyMessageTopicType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfMessageTopicType
  >(that);
}

std::unique_ptr<IVerification> VerifyBcp47LanguageTag(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfBcp47LanguageTag
  >(that);
}

std::unique_ptr<IVerification> VerifyContentType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfContentType
  >(that);
}

std::unique_ptr<IVerification> VerifyPathType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfPathType
  >(that);
}

std::unique_ptr<IVerification> VerifyQualifierType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfQualifierType
  >(that);
}

std::unique_ptr<IVerification> VerifyValueDataType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfValueDataType
  >(that);
}

std::unique_ptr<IVerification> VerifyIdShortType(
  const std::wstring& that
) {
  return common::make_unique<
    constrained_primitive_verification::OfIdShortType
  >(that);
}

// endregion Verification of constrained primitives

/**
 * Produce a non-recursive verificator of the instance given its runtime model type.
 */
std::unique_ptr<impl::IVerificator> NewNonRecursiveVerificator(
  const std::shared_ptr<types::IClass>& instance
);

// region Non-recursive verificators

namespace non_recursive_verificator {

class OfExtension : public impl::IVerificator {
 public:
  OfExtension(
    const std::shared_ptr<types::IClass>& instance
  );

  OfExtension(
    const OfExtension& other
  );
  OfExtension(
    OfExtension&& other
  );
  OfExtension& operator=(
    const OfExtension& other
  );
  OfExtension& operator=(
    OfExtension&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfExtension() override = default;

 private:
  std::shared_ptr<types::IExtension> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfExtension

OfExtension::OfExtension(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IExtension
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfExtension::OfExtension(
  const OfExtension& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfExtension::OfExtension(
  OfExtension&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfExtension& OfExtension::operator=(
  const OfExtension& other
) {
  return *this = OfExtension(other);
}

OfExtension& OfExtension::operator=(
  OfExtension&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfExtension::Start() {
  state_ = 0;
  Execute();
}

void OfExtension::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfExtension, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfExtension::Done() const {
  return done_;
}

const Error& OfExtension::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfExtension, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfExtension::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfExtension, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfExtension::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfExtension, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfExtension::Clone() const {
  return common::make_unique<
    OfExtension
  >(*this);
}

void OfExtension::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->refers_to().has_value())
          || ((*(instance_->refers_to())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Refers-to must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->value().has_value())
          || ValueConsistentWithXsdType(
            (*(instance_->value())),
            instance_->ValueTypeOrDefault()
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"The value must match the value type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            instance_->name()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 5: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 7;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kName
          )
        );

        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        constrained_primitive_verificator_->Next();

        state_ = 5;
        continue;
      }

      case 7: {
        constrained_primitive_verificator_ = nullptr;

        if (!(instance_->value().has_value())) {
          state_ = 11;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfValueDataType
          >(
            *(instance_->value())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 8: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 10;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        constrained_primitive_verificator_->Next();

        state_ = 8;
        continue;
      }

      case 10: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 11: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 12;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfAdministrativeInformation : public impl::IVerificator {
 public:
  OfAdministrativeInformation(
    const std::shared_ptr<types::IClass>& instance
  );

  OfAdministrativeInformation(
    const OfAdministrativeInformation& other
  );
  OfAdministrativeInformation(
    OfAdministrativeInformation&& other
  );
  OfAdministrativeInformation& operator=(
    const OfAdministrativeInformation& other
  );
  OfAdministrativeInformation& operator=(
    OfAdministrativeInformation&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfAdministrativeInformation() override = default;

 private:
  std::shared_ptr<types::IAdministrativeInformation> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfAdministrativeInformation

OfAdministrativeInformation::OfAdministrativeInformation(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IAdministrativeInformation
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfAdministrativeInformation::OfAdministrativeInformation(
  const OfAdministrativeInformation& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfAdministrativeInformation::OfAdministrativeInformation(
  OfAdministrativeInformation&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfAdministrativeInformation& OfAdministrativeInformation::operator=(
  const OfAdministrativeInformation& other
) {
  return *this = OfAdministrativeInformation(other);
}

OfAdministrativeInformation& OfAdministrativeInformation::operator=(
  OfAdministrativeInformation&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfAdministrativeInformation::Start() {
  state_ = 0;
  Execute();
}

void OfAdministrativeInformation::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfAdministrativeInformation, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfAdministrativeInformation::Done() const {
  return done_;
}

const Error& OfAdministrativeInformation::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfAdministrativeInformation, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfAdministrativeInformation::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfAdministrativeInformation, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfAdministrativeInformation::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfAdministrativeInformation, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfAdministrativeInformation::Clone() const {
  return common::make_unique<
    OfAdministrativeInformation
  >(*this);
}

void OfAdministrativeInformation::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->revision().has_value())
          || (instance_->version().has_value())
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-005: If version is not specified then also "
          L"revision shall be unspecified. This means, a revision "
          L"requires a version. If there is no version there is no "
          L"revision either. Revision is optional."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (!(instance_->version().has_value())) {
          state_ = 6;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfVersionType
          >(
            *(instance_->version())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 3: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 5;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kVersion
          )
        );

        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        constrained_primitive_verificator_->Next();

        state_ = 3;
        continue;
      }

      case 5: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 6: {
        if (!(instance_->revision().has_value())) {
          state_ = 10;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfRevisionType
          >(
            *(instance_->revision())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 7: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 9;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kRevision
          )
        );

        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        constrained_primitive_verificator_->Next();

        state_ = 7;
        continue;
      }

      case 9: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 10: {
        if (!(instance_->template_id().has_value())) {
          state_ = 14;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            *(instance_->template_id())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 11: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 13;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kTemplateId
          )
        );

        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        constrained_primitive_verificator_->Next();

        state_ = 11;
        continue;
      }

      case 13: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 14: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 15;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfQualifier : public impl::IVerificator {
 public:
  OfQualifier(
    const std::shared_ptr<types::IClass>& instance
  );

  OfQualifier(
    const OfQualifier& other
  );
  OfQualifier(
    OfQualifier&& other
  );
  OfQualifier& operator=(
    const OfQualifier& other
  );
  OfQualifier& operator=(
    OfQualifier&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfQualifier() override = default;

 private:
  std::shared_ptr<types::IQualifier> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfQualifier

OfQualifier::OfQualifier(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IQualifier
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfQualifier::OfQualifier(
  const OfQualifier& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfQualifier::OfQualifier(
  OfQualifier&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfQualifier& OfQualifier::operator=(
  const OfQualifier& other
) {
  return *this = OfQualifier(other);
}

OfQualifier& OfQualifier::operator=(
  OfQualifier&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfQualifier::Start() {
  state_ = 0;
  Execute();
}

void OfQualifier::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfQualifier, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfQualifier::Done() const {
  return done_;
}

const Error& OfQualifier::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfQualifier, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfQualifier::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfQualifier, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfQualifier::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfQualifier, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfQualifier::Clone() const {
  return common::make_unique<
    OfQualifier
  >(*this);
}

void OfQualifier::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->value().has_value())
          || ValueConsistentWithXsdType(
            (*(instance_->value())),
            instance_->value_type()
          )
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-020: The value shall be consistent to "
          L"the data type as defined in value type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfQualifierType
          >(
            instance_->type()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 4: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 6;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kType
          )
        );

        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        constrained_primitive_verificator_->Next();

        state_ = 4;
        continue;
      }

      case 6: {
        constrained_primitive_verificator_ = nullptr;

        if (!(instance_->value().has_value())) {
          state_ = 10;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfValueDataType
          >(
            *(instance_->value())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 7: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 9;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        constrained_primitive_verificator_->Next();

        state_ = 7;
        continue;
      }

      case 9: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 10: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 11;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfAssetAdministrationShell : public impl::IVerificator {
 public:
  OfAssetAdministrationShell(
    const std::shared_ptr<types::IClass>& instance
  );

  OfAssetAdministrationShell(
    const OfAssetAdministrationShell& other
  );
  OfAssetAdministrationShell(
    OfAssetAdministrationShell&& other
  );
  OfAssetAdministrationShell& operator=(
    const OfAssetAdministrationShell& other
  );
  OfAssetAdministrationShell& operator=(
    OfAssetAdministrationShell&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfAssetAdministrationShell() override = default;

 private:
  std::shared_ptr<types::IAssetAdministrationShell> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfAssetAdministrationShell

OfAssetAdministrationShell::OfAssetAdministrationShell(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IAssetAdministrationShell
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfAssetAdministrationShell::OfAssetAdministrationShell(
  const OfAssetAdministrationShell& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfAssetAdministrationShell::OfAssetAdministrationShell(
  OfAssetAdministrationShell&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfAssetAdministrationShell& OfAssetAdministrationShell::operator=(
  const OfAssetAdministrationShell& other
) {
  return *this = OfAssetAdministrationShell(other);
}

OfAssetAdministrationShell& OfAssetAdministrationShell::operator=(
  OfAssetAdministrationShell&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfAssetAdministrationShell::Start() {
  state_ = 0;
  Execute();
}

void OfAssetAdministrationShell::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfAssetAdministrationShell, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfAssetAdministrationShell::Done() const {
  return done_;
}

const Error& OfAssetAdministrationShell::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfAssetAdministrationShell, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfAssetAdministrationShell::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfAssetAdministrationShell, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfAssetAdministrationShell::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfAssetAdministrationShell, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfAssetAdministrationShell::Clone() const {
  return common::make_unique<
    OfAssetAdministrationShell
  >(*this);
}

void OfAssetAdministrationShell::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->submodels().has_value())
          || ((*(instance_->submodels())).size() >= 1)
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Submodels must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->derived_from().has_value())
          || IsModelReferenceTo(
            (*(instance_->derived_from())),
            types::KeyTypes::kAssetAdministrationShell
          )
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Derived-from must be a model reference to an asset "
          L"administration shell."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->submodels().has_value())
          || common::All(
            [&](const std::shared_ptr<types::IReference>& reference) -> bool {
              return IsModelReferenceTo(
                reference,
                types::KeyTypes::kSubmodel
              );
            },
            (*(instance_->submodels()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"All submodels must be model references to a submodel."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (!(instance_->category().has_value())) {
          state_ = 14;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 11: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 13;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        constrained_primitive_verificator_->Next();

        state_ = 11;
        continue;
      }

      case 13: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 14: {
        if (!(instance_->id_short().has_value())) {
          state_ = 18;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 15: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 17;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 16;
        return;
      }

      case 16: {
        constrained_primitive_verificator_->Next();

        state_ = 15;
        continue;
      }

      case 17: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 18: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            instance_->id()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 19: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 21;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kId
          )
        );

        ++index_;

        state_ = 20;
        return;
      }

      case 20: {
        constrained_primitive_verificator_->Next();

        state_ = 19;
        continue;
      }

      case 21: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 22;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfAssetInformation : public impl::IVerificator {
 public:
  OfAssetInformation(
    const std::shared_ptr<types::IClass>& instance
  );

  OfAssetInformation(
    const OfAssetInformation& other
  );
  OfAssetInformation(
    OfAssetInformation&& other
  );
  OfAssetInformation& operator=(
    const OfAssetInformation& other
  );
  OfAssetInformation& operator=(
    OfAssetInformation&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfAssetInformation() override = default;

 private:
  std::shared_ptr<types::IAssetInformation> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfAssetInformation

OfAssetInformation::OfAssetInformation(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IAssetInformation
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfAssetInformation::OfAssetInformation(
  const OfAssetInformation& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfAssetInformation::OfAssetInformation(
  OfAssetInformation&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfAssetInformation& OfAssetInformation::operator=(
  const OfAssetInformation& other
) {
  return *this = OfAssetInformation(other);
}

OfAssetInformation& OfAssetInformation::operator=(
  OfAssetInformation&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfAssetInformation::Start() {
  state_ = 0;
  Execute();
}

void OfAssetInformation::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfAssetInformation, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfAssetInformation::Done() const {
  return done_;
}

const Error& OfAssetInformation::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfAssetInformation, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfAssetInformation::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfAssetInformation, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfAssetInformation::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfAssetInformation, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfAssetInformation::Clone() const {
  return common::make_unique<
    OfAssetInformation
  >(*this);
}

void OfAssetInformation::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->specific_asset_ids().has_value())
          || common::All(
            [&](const std::shared_ptr<types::ISpecificAssetId>& specific_asset_id) -> bool {
              return (
                specific_asset_id->name() != L"globalAssetId"
                || (
                  (
                    (instance_->global_asset_id().has_value())
                    && specific_asset_id->name() == L"globalAssetId"
                    && specific_asset_id->value() == (*(instance_->global_asset_id()))
                  )
                )
              );
            },
            (*(instance_->specific_asset_ids()))
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-116: ``globalAssetId`` is a reserved key. "
          L"If used as value for the name of specific asset ID then "
          L"the value of specific asset ID shall be identical to "
          L"the global asset ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          (
            (
              (
                (instance_->global_asset_id().has_value())
                || (instance_->specific_asset_ids().has_value())
              )
            )
            && (
              !(instance_->specific_asset_ids().has_value())
              || ((*(instance_->specific_asset_ids())).size() >= 1)
            )
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-131: Either the global asset ID shall be "
          L"defined or at least one specific asset ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->specific_asset_ids().has_value())
          || ((*(instance_->specific_asset_ids())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Specific asset IDs must be either not set or have at least "
          L"one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (!(instance_->global_asset_id().has_value())) {
          state_ = 7;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            *(instance_->global_asset_id())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 4: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 6;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kGlobalAssetId
          )
        );

        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        constrained_primitive_verificator_->Next();

        state_ = 4;
        continue;
      }

      case 6: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 7: {
        if (!(instance_->asset_type().has_value())) {
          state_ = 11;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            *(instance_->asset_type())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 8: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 10;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kAssetType
          )
        );

        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        constrained_primitive_verificator_->Next();

        state_ = 8;
        continue;
      }

      case 10: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 11: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 12;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfResource : public impl::IVerificator {
 public:
  OfResource(
    const std::shared_ptr<types::IClass>& instance
  );

  OfResource(
    const OfResource& other
  );
  OfResource(
    OfResource&& other
  );
  OfResource& operator=(
    const OfResource& other
  );
  OfResource& operator=(
    OfResource&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfResource() override = default;

 private:
  std::shared_ptr<types::IResource> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfResource

OfResource::OfResource(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IResource
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfResource::OfResource(
  const OfResource& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfResource::OfResource(
  OfResource&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfResource& OfResource::operator=(
  const OfResource& other
) {
  return *this = OfResource(other);
}

OfResource& OfResource::operator=(
  OfResource&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfResource::Start() {
  state_ = 0;
  Execute();
}

void OfResource::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfResource, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfResource::Done() const {
  return done_;
}

const Error& OfResource::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfResource, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfResource::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfResource, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfResource::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfResource, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfResource::Clone() const {
  return common::make_unique<
    OfResource
  >(*this);
}

void OfResource::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfPathType
          >(
            instance_->path()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 1: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 3;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kPath
          )
        );

        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        constrained_primitive_verificator_->Next();

        state_ = 1;
        continue;
      }

      case 3: {
        constrained_primitive_verificator_ = nullptr;

        if (!(instance_->content_type().has_value())) {
          state_ = 7;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfContentType
          >(
            *(instance_->content_type())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 4: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 6;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kContentType
          )
        );

        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        constrained_primitive_verificator_->Next();

        state_ = 4;
        continue;
      }

      case 6: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 7: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 8;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfSpecificAssetId : public impl::IVerificator {
 public:
  OfSpecificAssetId(
    const std::shared_ptr<types::IClass>& instance
  );

  OfSpecificAssetId(
    const OfSpecificAssetId& other
  );
  OfSpecificAssetId(
    OfSpecificAssetId&& other
  );
  OfSpecificAssetId& operator=(
    const OfSpecificAssetId& other
  );
  OfSpecificAssetId& operator=(
    OfSpecificAssetId&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfSpecificAssetId() override = default;

 private:
  std::shared_ptr<types::ISpecificAssetId> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfSpecificAssetId

OfSpecificAssetId::OfSpecificAssetId(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ISpecificAssetId
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfSpecificAssetId::OfSpecificAssetId(
  const OfSpecificAssetId& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfSpecificAssetId::OfSpecificAssetId(
  OfSpecificAssetId&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfSpecificAssetId& OfSpecificAssetId::operator=(
  const OfSpecificAssetId& other
) {
  return *this = OfSpecificAssetId(other);
}

OfSpecificAssetId& OfSpecificAssetId::operator=(
  OfSpecificAssetId&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfSpecificAssetId::Start() {
  state_ = 0;
  Execute();
}

void OfSpecificAssetId::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfSpecificAssetId, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfSpecificAssetId::Done() const {
  return done_;
}

const Error& OfSpecificAssetId::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfSpecificAssetId, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfSpecificAssetId::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfSpecificAssetId, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfSpecificAssetId::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfSpecificAssetId, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfSpecificAssetId::Clone() const {
  return common::make_unique<
    OfSpecificAssetId
  >(*this);
}

void OfSpecificAssetId::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->external_subject_id().has_value())
          || ((*(instance_->external_subject_id()))->type() == types::ReferenceTypes::kExternalReference)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-133: External subject ID shall be "
          L"an external reference."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfLabelType
          >(
            instance_->name()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 4: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 6;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kName
          )
        );

        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        constrained_primitive_verificator_->Next();

        state_ = 4;
        continue;
      }

      case 6: {
        constrained_primitive_verificator_ = nullptr;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            instance_->value()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 7: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 9;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        constrained_primitive_verificator_->Next();

        state_ = 7;
        continue;
      }

      case 9: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 10;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfSubmodel : public impl::IVerificator {
 public:
  OfSubmodel(
    const std::shared_ptr<types::IClass>& instance
  );

  OfSubmodel(
    const OfSubmodel& other
  );
  OfSubmodel(
    OfSubmodel&& other
  );
  OfSubmodel& operator=(
    const OfSubmodel& other
  );
  OfSubmodel& operator=(
    OfSubmodel&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfSubmodel() override = default;

 private:
  std::shared_ptr<types::ISubmodel> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfSubmodel

OfSubmodel::OfSubmodel(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ISubmodel
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfSubmodel::OfSubmodel(
  const OfSubmodel& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfSubmodel::OfSubmodel(
  OfSubmodel&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfSubmodel& OfSubmodel::operator=(
  const OfSubmodel& other
) {
  return *this = OfSubmodel(other);
}

OfSubmodel& OfSubmodel::operator=(
  OfSubmodel&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfSubmodel::Start() {
  state_ = 0;
  Execute();
}

void OfSubmodel::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfSubmodel, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfSubmodel::Done() const {
  return done_;
}

const Error& OfSubmodel::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfSubmodel, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfSubmodel::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfSubmodel, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfSubmodel::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfSubmodel, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfSubmodel::Clone() const {
  return common::make_unique<
    OfSubmodel
  >(*this);
}

void OfSubmodel::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->submodel_elements().has_value())
          || ((*(instance_->submodel_elements())).size() >= 1)
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Submodel elements must be either not set or have at least "
          L"one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !(instance_->submodel_elements().has_value())
          || common::All(
            [&](const std::shared_ptr<types::ISubmodelElement>& item) -> bool {
              return item->id_short().has_value();
            },
            (*(instance_->submodel_elements()))
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"ID-shorts need to be defined for all the items of submodel "
          L"elements according to AASd-117 (ID-short of Referables not "
          L"being a direct child of a Submodel element list shall be "
          L"specified)."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(instance_->submodel_elements().has_value())
          || IdShortsAreUnique(
            (*(instance_->submodel_elements()))
          )
        ) {
          state_ = 14;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-022: ID-short of non-identifiable "
          L"referables within the same name space shall be unique "
          L"(case-sensitive)."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (
          !(instance_->submodel_elements().has_value())
          || (!(instance_->KindOrDefault() != types::ModellingKind::kTemplate)
          || common::All(
            [&](const std::shared_ptr<types::ISubmodelElement>& submodel_element) -> bool {
              return !(submodel_element->qualifiers().has_value())
              || common::All(
                [&](const std::shared_ptr<types::IQualifier>& qualifier) -> bool {
                  return qualifier->KindOrDefault() != types::QualifierKind::kTemplateQualifier;
                },
                (*(submodel_element->qualifiers()))
              );
            },
            (*(instance_->submodel_elements()))
          ))
        ) {
          state_ = 15;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-129: If any qualifier kind value of "
          L"a Submodel element qualifier (attribute qualifier inherited "
          L"via Qualifiable) is equal to Template Qualifier then "
          L"the submodel element shall be part of a submodel template, "
          L"i.e. a Submodel with submodel kind (attribute kind "
          L"inherited via Has-Kind) value is equal to Template."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        if (
          !(instance_->qualifiers().has_value())
          || (!common::Some(
            [&](const std::shared_ptr<types::IQualifier>& qualifier) -> bool {
              return qualifier->KindOrDefault() == types::QualifierKind::kTemplateQualifier;
            },
            (*(instance_->qualifiers()))
          )
          || (instance_->KindOrDefault() == types::ModellingKind::kTemplate))
        ) {
          state_ = 16;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-119: If any qualifier kind value of "
          L"a qualifiable qualifier is equal to template qualifier and "
          L"the qualified element has kind then the qualified element "
          L"shall be of kind template."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 16;
        return;
      }

      case 16: {
        if (!(instance_->category().has_value())) {
          state_ = 20;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 17: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 19;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 18;
        return;
      }

      case 18: {
        constrained_primitive_verificator_->Next();

        state_ = 17;
        continue;
      }

      case 19: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 20: {
        if (!(instance_->id_short().has_value())) {
          state_ = 24;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 21: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 23;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 22;
        return;
      }

      case 22: {
        constrained_primitive_verificator_->Next();

        state_ = 21;
        continue;
      }

      case 23: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 24: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            instance_->id()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 25: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 27;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kId
          )
        );

        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        constrained_primitive_verificator_->Next();

        state_ = 25;
        continue;
      }

      case 27: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 28;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfRelationshipElement : public impl::IVerificator {
 public:
  OfRelationshipElement(
    const std::shared_ptr<types::IClass>& instance
  );

  OfRelationshipElement(
    const OfRelationshipElement& other
  );
  OfRelationshipElement(
    OfRelationshipElement&& other
  );
  OfRelationshipElement& operator=(
    const OfRelationshipElement& other
  );
  OfRelationshipElement& operator=(
    OfRelationshipElement&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfRelationshipElement() override = default;

 private:
  std::shared_ptr<types::IRelationshipElement> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfRelationshipElement

OfRelationshipElement::OfRelationshipElement(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IRelationshipElement
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfRelationshipElement::OfRelationshipElement(
  const OfRelationshipElement& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfRelationshipElement::OfRelationshipElement(
  OfRelationshipElement&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfRelationshipElement& OfRelationshipElement::operator=(
  const OfRelationshipElement& other
) {
  return *this = OfRelationshipElement(other);
}

OfRelationshipElement& OfRelationshipElement::operator=(
  OfRelationshipElement&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfRelationshipElement::Start() {
  state_ = 0;
  Execute();
}

void OfRelationshipElement::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfRelationshipElement, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfRelationshipElement::Done() const {
  return done_;
}

const Error& OfRelationshipElement::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfRelationshipElement, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfRelationshipElement::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfRelationshipElement, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfRelationshipElement::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfRelationshipElement, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfRelationshipElement::Clone() const {
  return common::make_unique<
    OfRelationshipElement
  >(*this);
}

void OfRelationshipElement::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (!(instance_->category().has_value())) {
          state_ = 15;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 12: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 14;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        constrained_primitive_verificator_->Next();

        state_ = 12;
        continue;
      }

      case 14: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 15: {
        if (!(instance_->id_short().has_value())) {
          state_ = 19;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 16: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 18;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 17;
        return;
      }

      case 17: {
        constrained_primitive_verificator_->Next();

        state_ = 16;
        continue;
      }

      case 18: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 19: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 20;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfSubmodelElementList : public impl::IVerificator {
 public:
  OfSubmodelElementList(
    const std::shared_ptr<types::IClass>& instance
  );

  OfSubmodelElementList(
    const OfSubmodelElementList& other
  );
  OfSubmodelElementList(
    OfSubmodelElementList&& other
  );
  OfSubmodelElementList& operator=(
    const OfSubmodelElementList& other
  );
  OfSubmodelElementList& operator=(
    OfSubmodelElementList&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfSubmodelElementList() override = default;

 private:
  std::shared_ptr<types::ISubmodelElementList> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfSubmodelElementList

OfSubmodelElementList::OfSubmodelElementList(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ISubmodelElementList
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfSubmodelElementList::OfSubmodelElementList(
  const OfSubmodelElementList& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfSubmodelElementList::OfSubmodelElementList(
  OfSubmodelElementList&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfSubmodelElementList& OfSubmodelElementList::operator=(
  const OfSubmodelElementList& other
) {
  return *this = OfSubmodelElementList(other);
}

OfSubmodelElementList& OfSubmodelElementList::operator=(
  OfSubmodelElementList&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfSubmodelElementList::Start() {
  state_ = 0;
  Execute();
}

void OfSubmodelElementList::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfSubmodelElementList, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfSubmodelElementList::Done() const {
  return done_;
}

const Error& OfSubmodelElementList::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfSubmodelElementList, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfSubmodelElementList::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfSubmodelElementList, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfSubmodelElementList::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfSubmodelElementList, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfSubmodelElementList::Clone() const {
  return common::make_unique<
    OfSubmodelElementList
  >(*this);
}

void OfSubmodelElementList::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->value().has_value())
          || ((*(instance_->value())).size() >= 1)
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Value must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !((
            (instance_->value().has_value())
            && (instance_->semantic_id_list_element().has_value())
          ))
          || common::All(
            [&](const std::shared_ptr<types::ISubmodelElement>& child) -> bool {
              return !(child->semantic_id().has_value())
              || ReferenceKeyValuesEqual(
                (*(child->semantic_id())),
                (*(instance_->semantic_id_list_element()))
              );
            },
            (*(instance_->value()))
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-107: If a first level child element has "
          L"a semantic ID it shall be identical to semantic ID list "
          L"element."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(instance_->value().has_value())
          || SubmodelElementsHaveIdenticalSemanticIds(
            (*(instance_->value()))
          )
        ) {
          state_ = 14;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-114: If two first level child elements have "
          L"a semantic ID then they shall be identical."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (
          !(instance_->value().has_value())
          || common::All(
            [&](const std::shared_ptr<types::ISubmodelElement>& element) -> bool {
              return SubmodelElementIsOfType(
                element,
                instance_->type_value_list_element()
              );
            },
            (*(instance_->value()))
          )
        ) {
          state_ = 15;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-108: All first level child elements shall "
          L"have the same submodel element type as specified in type "
          L"value list element."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        if (
          !((
            (instance_->type_value_list_element().has_value())
            && (
              (
                instance_->type_value_list_element() == types::AasSubmodelElements::kProperty
                || instance_->type_value_list_element() == types::AasSubmodelElements::kRange
              )
            )
          ))
          || ((
            (instance_->value_type_list_element().has_value())
            && (
              (
                (!(instance_->value().has_value()))
                || PropertiesOrRangesHaveValueType(
                  instance_->value(),
                  (*(instance_->value_type_list_element()))
                )
              )
            )
          ))
        ) {
          state_ = 16;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-109: If type value list element is equal to "
          L"Property or Range value type list element shall be set and "
          L"all first level child elements shall have the value type as "
          L"specified in value type list element."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 16;
        return;
      }

      case 16: {
        if (
          !(instance_->value().has_value())
          || common::All(
            [&](const std::shared_ptr<types::ISubmodelElement>& element) -> bool {
              return !(element->id_short().has_value());
            },
            (*(instance_->value()))
          )
        ) {
          state_ = 17;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-120: ID-short of submodel elements being "
          L"a direct child of a  Submodel element list shall not be "
          L"specified."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 17;
        return;
      }

      case 17: {
        if (!(instance_->category().has_value())) {
          state_ = 21;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 18: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 20;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        constrained_primitive_verificator_->Next();

        state_ = 18;
        continue;
      }

      case 20: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 21: {
        if (!(instance_->id_short().has_value())) {
          state_ = 25;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 22: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 24;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        constrained_primitive_verificator_->Next();

        state_ = 22;
        continue;
      }

      case 24: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 25: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 26;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfSubmodelElementCollection : public impl::IVerificator {
 public:
  OfSubmodelElementCollection(
    const std::shared_ptr<types::IClass>& instance
  );

  OfSubmodelElementCollection(
    const OfSubmodelElementCollection& other
  );
  OfSubmodelElementCollection(
    OfSubmodelElementCollection&& other
  );
  OfSubmodelElementCollection& operator=(
    const OfSubmodelElementCollection& other
  );
  OfSubmodelElementCollection& operator=(
    OfSubmodelElementCollection&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfSubmodelElementCollection() override = default;

 private:
  std::shared_ptr<types::ISubmodelElementCollection> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfSubmodelElementCollection

OfSubmodelElementCollection::OfSubmodelElementCollection(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ISubmodelElementCollection
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfSubmodelElementCollection::OfSubmodelElementCollection(
  const OfSubmodelElementCollection& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfSubmodelElementCollection::OfSubmodelElementCollection(
  OfSubmodelElementCollection&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfSubmodelElementCollection& OfSubmodelElementCollection::operator=(
  const OfSubmodelElementCollection& other
) {
  return *this = OfSubmodelElementCollection(other);
}

OfSubmodelElementCollection& OfSubmodelElementCollection::operator=(
  OfSubmodelElementCollection&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfSubmodelElementCollection::Start() {
  state_ = 0;
  Execute();
}

void OfSubmodelElementCollection::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfSubmodelElementCollection, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfSubmodelElementCollection::Done() const {
  return done_;
}

const Error& OfSubmodelElementCollection::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfSubmodelElementCollection, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfSubmodelElementCollection::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfSubmodelElementCollection, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfSubmodelElementCollection::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfSubmodelElementCollection, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfSubmodelElementCollection::Clone() const {
  return common::make_unique<
    OfSubmodelElementCollection
  >(*this);
}

void OfSubmodelElementCollection::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->value().has_value())
          || ((*(instance_->value())).size() >= 1)
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Value must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !(instance_->value().has_value())
          || common::All(
            [&](const std::shared_ptr<types::ISubmodelElement>& item) -> bool {
              return item->id_short().has_value();
            },
            (*(instance_->value()))
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"ID-shorts need to be defined for all the items of value "
          L"according to AASd-117 (ID-short of Referables not being "
          L"a direct child of a Submodel element list shall be "
          L"specified)."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(instance_->value().has_value())
          || IdShortsAreUnique(
            (*(instance_->value()))
          )
        ) {
          state_ = 14;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"ID-shorts of the value must be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (!(instance_->category().has_value())) {
          state_ = 18;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 15: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 17;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 16;
        return;
      }

      case 16: {
        constrained_primitive_verificator_->Next();

        state_ = 15;
        continue;
      }

      case 17: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 18: {
        if (!(instance_->id_short().has_value())) {
          state_ = 22;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 19: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 21;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 20;
        return;
      }

      case 20: {
        constrained_primitive_verificator_->Next();

        state_ = 19;
        continue;
      }

      case 21: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 22: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 23;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfProperty : public impl::IVerificator {
 public:
  OfProperty(
    const std::shared_ptr<types::IClass>& instance
  );

  OfProperty(
    const OfProperty& other
  );
  OfProperty(
    OfProperty&& other
  );
  OfProperty& operator=(
    const OfProperty& other
  );
  OfProperty& operator=(
    OfProperty&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfProperty() override = default;

 private:
  std::shared_ptr<types::IProperty> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfProperty

OfProperty::OfProperty(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IProperty
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfProperty::OfProperty(
  const OfProperty& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfProperty::OfProperty(
  OfProperty&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfProperty& OfProperty::operator=(
  const OfProperty& other
) {
  return *this = OfProperty(other);
}

OfProperty& OfProperty::operator=(
  OfProperty&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfProperty::Start() {
  state_ = 0;
  Execute();
}

void OfProperty::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfProperty, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfProperty::Done() const {
  return done_;
}

const Error& OfProperty::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfProperty, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfProperty::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfProperty, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfProperty::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfProperty, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfProperty::Clone() const {
  return common::make_unique<
    OfProperty
  >(*this);
}

void OfProperty::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->category().has_value())
          || common::Contains(
            constants::kValidCategoriesForDataElement,
            (*(instance_->category()))
          )
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-090: For data elements category shall be "
          L"one of the following values: CONSTANT, PARAMETER or "
          L"VARIABLE."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !(instance_->value().has_value())
          || ValueConsistentWithXsdType(
            (*(instance_->value())),
            instance_->value_type()
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Value must be consistent with the value type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(instance_->category().has_value())) {
          state_ = 17;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 14: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 16;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        constrained_primitive_verificator_->Next();

        state_ = 14;
        continue;
      }

      case 16: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 17: {
        if (!(instance_->id_short().has_value())) {
          state_ = 21;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 18: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 20;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        constrained_primitive_verificator_->Next();

        state_ = 18;
        continue;
      }

      case 20: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 21: {
        if (!(instance_->value().has_value())) {
          state_ = 25;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfValueDataType
          >(
            *(instance_->value())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 22: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 24;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        constrained_primitive_verificator_->Next();

        state_ = 22;
        continue;
      }

      case 24: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 25: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 26;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfMultiLanguageProperty : public impl::IVerificator {
 public:
  OfMultiLanguageProperty(
    const std::shared_ptr<types::IClass>& instance
  );

  OfMultiLanguageProperty(
    const OfMultiLanguageProperty& other
  );
  OfMultiLanguageProperty(
    OfMultiLanguageProperty&& other
  );
  OfMultiLanguageProperty& operator=(
    const OfMultiLanguageProperty& other
  );
  OfMultiLanguageProperty& operator=(
    OfMultiLanguageProperty&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfMultiLanguageProperty() override = default;

 private:
  std::shared_ptr<types::IMultiLanguageProperty> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfMultiLanguageProperty

OfMultiLanguageProperty::OfMultiLanguageProperty(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IMultiLanguageProperty
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfMultiLanguageProperty::OfMultiLanguageProperty(
  const OfMultiLanguageProperty& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfMultiLanguageProperty::OfMultiLanguageProperty(
  OfMultiLanguageProperty&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfMultiLanguageProperty& OfMultiLanguageProperty::operator=(
  const OfMultiLanguageProperty& other
) {
  return *this = OfMultiLanguageProperty(other);
}

OfMultiLanguageProperty& OfMultiLanguageProperty::operator=(
  OfMultiLanguageProperty&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfMultiLanguageProperty::Start() {
  state_ = 0;
  Execute();
}

void OfMultiLanguageProperty::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfMultiLanguageProperty, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfMultiLanguageProperty::Done() const {
  return done_;
}

const Error& OfMultiLanguageProperty::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfMultiLanguageProperty, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfMultiLanguageProperty::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfMultiLanguageProperty, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfMultiLanguageProperty::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfMultiLanguageProperty, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfMultiLanguageProperty::Clone() const {
  return common::make_unique<
    OfMultiLanguageProperty
  >(*this);
}

void OfMultiLanguageProperty::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->category().has_value())
          || common::Contains(
            constants::kValidCategoriesForDataElement,
            (*(instance_->category()))
          )
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-090: For data elements category shall be "
          L"one of the following values: CONSTANT, PARAMETER or "
          L"VARIABLE."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !(instance_->value().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->value()))
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Value must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(instance_->value().has_value())
          || ((*(instance_->value())).size() >= 1)
        ) {
          state_ = 14;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Value must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (!(instance_->category().has_value())) {
          state_ = 18;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 15: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 17;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 16;
        return;
      }

      case 16: {
        constrained_primitive_verificator_->Next();

        state_ = 15;
        continue;
      }

      case 17: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 18: {
        if (!(instance_->id_short().has_value())) {
          state_ = 22;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 19: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 21;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 20;
        return;
      }

      case 20: {
        constrained_primitive_verificator_->Next();

        state_ = 19;
        continue;
      }

      case 21: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 22: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 23;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfRange : public impl::IVerificator {
 public:
  OfRange(
    const std::shared_ptr<types::IClass>& instance
  );

  OfRange(
    const OfRange& other
  );
  OfRange(
    OfRange&& other
  );
  OfRange& operator=(
    const OfRange& other
  );
  OfRange& operator=(
    OfRange&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfRange() override = default;

 private:
  std::shared_ptr<types::IRange> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfRange

OfRange::OfRange(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IRange
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfRange::OfRange(
  const OfRange& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfRange::OfRange(
  OfRange&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfRange& OfRange::operator=(
  const OfRange& other
) {
  return *this = OfRange(other);
}

OfRange& OfRange::operator=(
  OfRange&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfRange::Start() {
  state_ = 0;
  Execute();
}

void OfRange::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfRange, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfRange::Done() const {
  return done_;
}

const Error& OfRange::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfRange, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfRange::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfRange, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfRange::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfRange, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfRange::Clone() const {
  return common::make_unique<
    OfRange
  >(*this);
}

void OfRange::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->category().has_value())
          || common::Contains(
            constants::kValidCategoriesForDataElement,
            (*(instance_->category()))
          )
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-090: For data elements category shall be "
          L"one of the following values: CONSTANT, PARAMETER or "
          L"VARIABLE."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !(instance_->max().has_value())
          || ValueConsistentWithXsdType(
            (*(instance_->max())),
            instance_->value_type()
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Max must be consistent with the value type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(instance_->min().has_value())
          || ValueConsistentWithXsdType(
            (*(instance_->min())),
            instance_->value_type()
          )
        ) {
          state_ = 14;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Min must be consistent with the value type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (!(instance_->category().has_value())) {
          state_ = 18;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 15: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 17;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 16;
        return;
      }

      case 16: {
        constrained_primitive_verificator_->Next();

        state_ = 15;
        continue;
      }

      case 17: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 18: {
        if (!(instance_->id_short().has_value())) {
          state_ = 22;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 19: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 21;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 20;
        return;
      }

      case 20: {
        constrained_primitive_verificator_->Next();

        state_ = 19;
        continue;
      }

      case 21: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 22: {
        if (!(instance_->min().has_value())) {
          state_ = 26;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfValueDataType
          >(
            *(instance_->min())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 23: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 25;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kMin
          )
        );

        ++index_;

        state_ = 24;
        return;
      }

      case 24: {
        constrained_primitive_verificator_->Next();

        state_ = 23;
        continue;
      }

      case 25: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 26: {
        if (!(instance_->max().has_value())) {
          state_ = 30;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfValueDataType
          >(
            *(instance_->max())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 27: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 29;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kMax
          )
        );

        ++index_;

        state_ = 28;
        return;
      }

      case 28: {
        constrained_primitive_verificator_->Next();

        state_ = 27;
        continue;
      }

      case 29: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 30: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 31;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfReferenceElement : public impl::IVerificator {
 public:
  OfReferenceElement(
    const std::shared_ptr<types::IClass>& instance
  );

  OfReferenceElement(
    const OfReferenceElement& other
  );
  OfReferenceElement(
    OfReferenceElement&& other
  );
  OfReferenceElement& operator=(
    const OfReferenceElement& other
  );
  OfReferenceElement& operator=(
    OfReferenceElement&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfReferenceElement() override = default;

 private:
  std::shared_ptr<types::IReferenceElement> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfReferenceElement

OfReferenceElement::OfReferenceElement(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IReferenceElement
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfReferenceElement::OfReferenceElement(
  const OfReferenceElement& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfReferenceElement::OfReferenceElement(
  OfReferenceElement&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfReferenceElement& OfReferenceElement::operator=(
  const OfReferenceElement& other
) {
  return *this = OfReferenceElement(other);
}

OfReferenceElement& OfReferenceElement::operator=(
  OfReferenceElement&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfReferenceElement::Start() {
  state_ = 0;
  Execute();
}

void OfReferenceElement::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfReferenceElement, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfReferenceElement::Done() const {
  return done_;
}

const Error& OfReferenceElement::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfReferenceElement, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfReferenceElement::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfReferenceElement, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfReferenceElement::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfReferenceElement, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfReferenceElement::Clone() const {
  return common::make_unique<
    OfReferenceElement
  >(*this);
}

void OfReferenceElement::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->category().has_value())
          || common::Contains(
            constants::kValidCategoriesForDataElement,
            (*(instance_->category()))
          )
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-090: For data elements category shall be "
          L"one of the following values: CONSTANT, PARAMETER or "
          L"VARIABLE."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (!(instance_->category().has_value())) {
          state_ = 16;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 13: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 15;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        constrained_primitive_verificator_->Next();

        state_ = 13;
        continue;
      }

      case 15: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 16: {
        if (!(instance_->id_short().has_value())) {
          state_ = 20;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 17: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 19;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 18;
        return;
      }

      case 18: {
        constrained_primitive_verificator_->Next();

        state_ = 17;
        continue;
      }

      case 19: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 20: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 21;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfBlob : public impl::IVerificator {
 public:
  OfBlob(
    const std::shared_ptr<types::IClass>& instance
  );

  OfBlob(
    const OfBlob& other
  );
  OfBlob(
    OfBlob&& other
  );
  OfBlob& operator=(
    const OfBlob& other
  );
  OfBlob& operator=(
    OfBlob&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfBlob() override = default;

 private:
  std::shared_ptr<types::IBlob> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfBlob

OfBlob::OfBlob(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IBlob
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfBlob::OfBlob(
  const OfBlob& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfBlob::OfBlob(
  OfBlob&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfBlob& OfBlob::operator=(
  const OfBlob& other
) {
  return *this = OfBlob(other);
}

OfBlob& OfBlob::operator=(
  OfBlob&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfBlob::Start() {
  state_ = 0;
  Execute();
}

void OfBlob::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfBlob, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfBlob::Done() const {
  return done_;
}

const Error& OfBlob::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfBlob, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfBlob::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfBlob, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfBlob::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfBlob, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfBlob::Clone() const {
  return common::make_unique<
    OfBlob
  >(*this);
}

void OfBlob::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->category().has_value())
          || common::Contains(
            constants::kValidCategoriesForDataElement,
            (*(instance_->category()))
          )
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-090: For data elements category shall be "
          L"one of the following values: CONSTANT, PARAMETER or "
          L"VARIABLE."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (!(instance_->category().has_value())) {
          state_ = 16;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 13: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 15;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        constrained_primitive_verificator_->Next();

        state_ = 13;
        continue;
      }

      case 15: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 16: {
        if (!(instance_->id_short().has_value())) {
          state_ = 20;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 17: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 19;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 18;
        return;
      }

      case 18: {
        constrained_primitive_verificator_->Next();

        state_ = 17;
        continue;
      }

      case 19: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 20: {
        if (!(instance_->value().has_value())) {
          state_ = 24;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfBlobType
          >(
            *(instance_->value())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 21: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 23;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 22;
        return;
      }

      case 22: {
        constrained_primitive_verificator_->Next();

        state_ = 21;
        continue;
      }

      case 23: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 24: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfContentType
          >(
            instance_->content_type()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 25: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 27;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kContentType
          )
        );

        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        constrained_primitive_verificator_->Next();

        state_ = 25;
        continue;
      }

      case 27: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 28;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfFile : public impl::IVerificator {
 public:
  OfFile(
    const std::shared_ptr<types::IClass>& instance
  );

  OfFile(
    const OfFile& other
  );
  OfFile(
    OfFile&& other
  );
  OfFile& operator=(
    const OfFile& other
  );
  OfFile& operator=(
    OfFile&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfFile() override = default;

 private:
  std::shared_ptr<types::IFile> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfFile

OfFile::OfFile(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IFile
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfFile::OfFile(
  const OfFile& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfFile::OfFile(
  OfFile&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfFile& OfFile::operator=(
  const OfFile& other
) {
  return *this = OfFile(other);
}

OfFile& OfFile::operator=(
  OfFile&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfFile::Start() {
  state_ = 0;
  Execute();
}

void OfFile::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfFile, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfFile::Done() const {
  return done_;
}

const Error& OfFile::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfFile, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfFile::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfFile, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfFile::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfFile, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfFile::Clone() const {
  return common::make_unique<
    OfFile
  >(*this);
}

void OfFile::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->category().has_value())
          || common::Contains(
            constants::kValidCategoriesForDataElement,
            (*(instance_->category()))
          )
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-090: For data elements category shall be "
          L"one of the following values: CONSTANT, PARAMETER or "
          L"VARIABLE."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (!(instance_->category().has_value())) {
          state_ = 16;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 13: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 15;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        constrained_primitive_verificator_->Next();

        state_ = 13;
        continue;
      }

      case 15: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 16: {
        if (!(instance_->id_short().has_value())) {
          state_ = 20;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 17: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 19;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 18;
        return;
      }

      case 18: {
        constrained_primitive_verificator_->Next();

        state_ = 17;
        continue;
      }

      case 19: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 20: {
        if (!(instance_->value().has_value())) {
          state_ = 24;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfPathType
          >(
            *(instance_->value())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 21: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 23;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 22;
        return;
      }

      case 22: {
        constrained_primitive_verificator_->Next();

        state_ = 21;
        continue;
      }

      case 23: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 24: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfContentType
          >(
            instance_->content_type()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 25: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 27;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kContentType
          )
        );

        ++index_;

        state_ = 26;
        return;
      }

      case 26: {
        constrained_primitive_verificator_->Next();

        state_ = 25;
        continue;
      }

      case 27: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 28;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfAnnotatedRelationshipElement : public impl::IVerificator {
 public:
  OfAnnotatedRelationshipElement(
    const std::shared_ptr<types::IClass>& instance
  );

  OfAnnotatedRelationshipElement(
    const OfAnnotatedRelationshipElement& other
  );
  OfAnnotatedRelationshipElement(
    OfAnnotatedRelationshipElement&& other
  );
  OfAnnotatedRelationshipElement& operator=(
    const OfAnnotatedRelationshipElement& other
  );
  OfAnnotatedRelationshipElement& operator=(
    OfAnnotatedRelationshipElement&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfAnnotatedRelationshipElement() override = default;

 private:
  std::shared_ptr<types::IAnnotatedRelationshipElement> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfAnnotatedRelationshipElement

OfAnnotatedRelationshipElement::OfAnnotatedRelationshipElement(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IAnnotatedRelationshipElement
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfAnnotatedRelationshipElement::OfAnnotatedRelationshipElement(
  const OfAnnotatedRelationshipElement& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfAnnotatedRelationshipElement::OfAnnotatedRelationshipElement(
  OfAnnotatedRelationshipElement&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfAnnotatedRelationshipElement& OfAnnotatedRelationshipElement::operator=(
  const OfAnnotatedRelationshipElement& other
) {
  return *this = OfAnnotatedRelationshipElement(other);
}

OfAnnotatedRelationshipElement& OfAnnotatedRelationshipElement::operator=(
  OfAnnotatedRelationshipElement&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfAnnotatedRelationshipElement::Start() {
  state_ = 0;
  Execute();
}

void OfAnnotatedRelationshipElement::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfAnnotatedRelationshipElement, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfAnnotatedRelationshipElement::Done() const {
  return done_;
}

const Error& OfAnnotatedRelationshipElement::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfAnnotatedRelationshipElement, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfAnnotatedRelationshipElement::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfAnnotatedRelationshipElement, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfAnnotatedRelationshipElement::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfAnnotatedRelationshipElement, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfAnnotatedRelationshipElement::Clone() const {
  return common::make_unique<
    OfAnnotatedRelationshipElement
  >(*this);
}

void OfAnnotatedRelationshipElement::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->annotations().has_value())
          || ((*(instance_->annotations())).size() >= 1)
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Annotations must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !(instance_->annotations().has_value())
          || common::All(
            [&](const std::shared_ptr<types::IDataElement>& item) -> bool {
              return item->id_short().has_value();
            },
            (*(instance_->annotations()))
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"ID-shorts need to be defined for all the items of "
          L"annotations according to AASd-117 (ID-short of Referables "
          L"not being a direct child of a Submodel element list shall "
          L"be specified)."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(instance_->category().has_value())) {
          state_ = 17;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 14: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 16;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        constrained_primitive_verificator_->Next();

        state_ = 14;
        continue;
      }

      case 16: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 17: {
        if (!(instance_->id_short().has_value())) {
          state_ = 21;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 18: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 20;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        constrained_primitive_verificator_->Next();

        state_ = 18;
        continue;
      }

      case 20: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 21: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 22;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfEntity : public impl::IVerificator {
 public:
  OfEntity(
    const std::shared_ptr<types::IClass>& instance
  );

  OfEntity(
    const OfEntity& other
  );
  OfEntity(
    OfEntity&& other
  );
  OfEntity& operator=(
    const OfEntity& other
  );
  OfEntity& operator=(
    OfEntity&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfEntity() override = default;

 private:
  std::shared_ptr<types::IEntity> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfEntity

OfEntity::OfEntity(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IEntity
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfEntity::OfEntity(
  const OfEntity& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfEntity::OfEntity(
  OfEntity&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfEntity& OfEntity::operator=(
  const OfEntity& other
) {
  return *this = OfEntity(other);
}

OfEntity& OfEntity::operator=(
  OfEntity&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfEntity::Start() {
  state_ = 0;
  Execute();
}

void OfEntity::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfEntity, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfEntity::Done() const {
  return done_;
}

const Error& OfEntity::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfEntity, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfEntity::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfEntity, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfEntity::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfEntity, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfEntity::Clone() const {
  return common::make_unique<
    OfEntity
  >(*this);
}

void OfEntity::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->statements().has_value())
          || ((*(instance_->statements())).size() >= 1)
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Statements must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !(instance_->statements().has_value())
          || common::All(
            [&](const std::shared_ptr<types::ISubmodelElement>& item) -> bool {
              return item->id_short().has_value();
            },
            (*(instance_->statements()))
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"ID-shorts need to be defined for all the items of "
          L"statements according to AASd-117 (ID-short of Referables "
          L"not being a direct child of a Submodel element list shall "
          L"be specified)."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          (
            (
              (
                instance_->entity_type() == types::EntityType::kSelfManagedEntity
                && (
                  (
                    (
                      (
                        (instance_->global_asset_id().has_value())
                        && (!(instance_->specific_asset_ids().has_value()))
                      )
                    )
                    || (
                      (
                        (!(instance_->global_asset_id().has_value()))
                        && (instance_->specific_asset_ids().has_value())
                        && (*(instance_->specific_asset_ids())).size() >= 1
                      )
                    )
                  )
                )
              )
            )
            || (
              (
                instance_->entity_type() != types::EntityType::kSelfManagedEntity
                && (!(instance_->global_asset_id().has_value()))
                && (!(instance_->specific_asset_ids().has_value()))
              )
            )
          )
        ) {
          state_ = 14;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-014: Either the attribute global asset ID "
          L"or specific asset ID must be set if entity type is set to "
          L"self-managed entity. They are not existing otherwise."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (
          !(instance_->specific_asset_ids().has_value())
          || ((*(instance_->specific_asset_ids())).size() >= 1)
        ) {
          state_ = 15;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Specific asset IDs must be either not set or have at least "
          L"one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        if (!(instance_->category().has_value())) {
          state_ = 19;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 16: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 18;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 17;
        return;
      }

      case 17: {
        constrained_primitive_verificator_->Next();

        state_ = 16;
        continue;
      }

      case 18: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 19: {
        if (!(instance_->id_short().has_value())) {
          state_ = 23;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 20: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 22;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 21;
        return;
      }

      case 21: {
        constrained_primitive_verificator_->Next();

        state_ = 20;
        continue;
      }

      case 22: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 23: {
        if (!(instance_->global_asset_id().has_value())) {
          state_ = 27;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            *(instance_->global_asset_id())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 24: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 26;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kGlobalAssetId
          )
        );

        ++index_;

        state_ = 25;
        return;
      }

      case 25: {
        constrained_primitive_verificator_->Next();

        state_ = 24;
        continue;
      }

      case 26: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 27: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 28;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfEventPayload : public impl::IVerificator {
 public:
  OfEventPayload(
    const std::shared_ptr<types::IClass>& instance
  );

  OfEventPayload(
    const OfEventPayload& other
  );
  OfEventPayload(
    OfEventPayload&& other
  );
  OfEventPayload& operator=(
    const OfEventPayload& other
  );
  OfEventPayload& operator=(
    OfEventPayload&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfEventPayload() override = default;

 private:
  std::shared_ptr<types::IEventPayload> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfEventPayload

OfEventPayload::OfEventPayload(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IEventPayload
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfEventPayload::OfEventPayload(
  const OfEventPayload& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfEventPayload::OfEventPayload(
  OfEventPayload&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfEventPayload& OfEventPayload::operator=(
  const OfEventPayload& other
) {
  return *this = OfEventPayload(other);
}

OfEventPayload& OfEventPayload::operator=(
  OfEventPayload&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfEventPayload::Start() {
  state_ = 0;
  Execute();
}

void OfEventPayload::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfEventPayload, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfEventPayload::Done() const {
  return done_;
}

const Error& OfEventPayload::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfEventPayload, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfEventPayload::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfEventPayload, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfEventPayload::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfEventPayload, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfEventPayload::Clone() const {
  return common::make_unique<
    OfEventPayload
  >(*this);
}

void OfEventPayload::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          (
            IsModelReferenceTo(
              instance_->source(),
              types::KeyTypes::kEventElement
            )
            || IsModelReferenceTo(
              instance_->source(),
              types::KeyTypes::kBasicEventElement
            )
          )
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Source must be a model reference to an Event element."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          IsModelReferenceToReferable(
            instance_->observable_reference()
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Observable reference must be a model reference to "
          L"a referable."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (!(instance_->topic().has_value())) {
          state_ = 6;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfMessageTopicType
          >(
            *(instance_->topic())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 3: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 5;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kTopic
          )
        );

        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        constrained_primitive_verificator_->Next();

        state_ = 3;
        continue;
      }

      case 5: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 6: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfDateTimeUtc
          >(
            instance_->time_stamp()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 7: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 9;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kTimeStamp
          )
        );

        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        constrained_primitive_verificator_->Next();

        state_ = 7;
        continue;
      }

      case 9: {
        constrained_primitive_verificator_ = nullptr;

        if (!(instance_->payload().has_value())) {
          state_ = 13;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfBlobType
          >(
            *(instance_->payload())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 10: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 12;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kPayload
          )
        );

        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        constrained_primitive_verificator_->Next();

        state_ = 10;
        continue;
      }

      case 12: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 13: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 14;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfBasicEventElement : public impl::IVerificator {
 public:
  OfBasicEventElement(
    const std::shared_ptr<types::IClass>& instance
  );

  OfBasicEventElement(
    const OfBasicEventElement& other
  );
  OfBasicEventElement(
    OfBasicEventElement&& other
  );
  OfBasicEventElement& operator=(
    const OfBasicEventElement& other
  );
  OfBasicEventElement& operator=(
    OfBasicEventElement&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfBasicEventElement() override = default;

 private:
  std::shared_ptr<types::IBasicEventElement> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfBasicEventElement

OfBasicEventElement::OfBasicEventElement(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IBasicEventElement
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfBasicEventElement::OfBasicEventElement(
  const OfBasicEventElement& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfBasicEventElement::OfBasicEventElement(
  OfBasicEventElement&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfBasicEventElement& OfBasicEventElement::operator=(
  const OfBasicEventElement& other
) {
  return *this = OfBasicEventElement(other);
}

OfBasicEventElement& OfBasicEventElement::operator=(
  OfBasicEventElement&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfBasicEventElement::Start() {
  state_ = 0;
  Execute();
}

void OfBasicEventElement::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfBasicEventElement, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfBasicEventElement::Done() const {
  return done_;
}

const Error& OfBasicEventElement::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfBasicEventElement, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfBasicEventElement::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfBasicEventElement, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfBasicEventElement::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfBasicEventElement, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfBasicEventElement::Clone() const {
  return common::make_unique<
    OfBasicEventElement
  >(*this);
}

void OfBasicEventElement::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !(instance_->direction() == types::Direction::kInput)
          || (!(instance_->max_interval().has_value()))
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Max. interval is not applicable for input direction."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          IsModelReferenceToReferable(
            instance_->observed()
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Observed must be a model reference to a referable."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(instance_->message_broker().has_value())
          || IsModelReferenceToReferable(
            (*(instance_->message_broker()))
          )
        ) {
          state_ = 14;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Message broker must be a model reference to a referable."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (!(instance_->category().has_value())) {
          state_ = 18;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 15: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 17;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 16;
        return;
      }

      case 16: {
        constrained_primitive_verificator_->Next();

        state_ = 15;
        continue;
      }

      case 17: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 18: {
        if (!(instance_->id_short().has_value())) {
          state_ = 22;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 19: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 21;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 20;
        return;
      }

      case 20: {
        constrained_primitive_verificator_->Next();

        state_ = 19;
        continue;
      }

      case 21: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 22: {
        if (!(instance_->message_topic().has_value())) {
          state_ = 26;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfMessageTopicType
          >(
            *(instance_->message_topic())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 23: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 25;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kMessageTopic
          )
        );

        ++index_;

        state_ = 24;
        return;
      }

      case 24: {
        constrained_primitive_verificator_->Next();

        state_ = 23;
        continue;
      }

      case 25: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 26: {
        if (!(instance_->last_update().has_value())) {
          state_ = 30;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfDateTimeUtc
          >(
            *(instance_->last_update())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 27: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 29;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kLastUpdate
          )
        );

        ++index_;

        state_ = 28;
        return;
      }

      case 28: {
        constrained_primitive_verificator_->Next();

        state_ = 27;
        continue;
      }

      case 29: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 30: {
        if (!(instance_->min_interval().has_value())) {
          state_ = 34;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfDuration
          >(
            *(instance_->min_interval())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 31: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 33;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kMinInterval
          )
        );

        ++index_;

        state_ = 32;
        return;
      }

      case 32: {
        constrained_primitive_verificator_->Next();

        state_ = 31;
        continue;
      }

      case 33: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 34: {
        if (!(instance_->max_interval().has_value())) {
          state_ = 38;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfDuration
          >(
            *(instance_->max_interval())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 35: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 37;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kMaxInterval
          )
        );

        ++index_;

        state_ = 36;
        return;
      }

      case 36: {
        constrained_primitive_verificator_->Next();

        state_ = 35;
        continue;
      }

      case 37: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 38: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 39;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfOperation : public impl::IVerificator {
 public:
  OfOperation(
    const std::shared_ptr<types::IClass>& instance
  );

  OfOperation(
    const OfOperation& other
  );
  OfOperation(
    OfOperation&& other
  );
  OfOperation& operator=(
    const OfOperation& other
  );
  OfOperation& operator=(
    OfOperation&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfOperation() override = default;

 private:
  std::shared_ptr<types::IOperation> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfOperation

OfOperation::OfOperation(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IOperation
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfOperation::OfOperation(
  const OfOperation& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfOperation::OfOperation(
  OfOperation&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfOperation& OfOperation::operator=(
  const OfOperation& other
) {
  return *this = OfOperation(other);
}

OfOperation& OfOperation::operator=(
  OfOperation&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfOperation::Start() {
  state_ = 0;
  Execute();
}

void OfOperation::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfOperation, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfOperation::Done() const {
  return done_;
}

const Error& OfOperation::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfOperation, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfOperation::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfOperation, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfOperation::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfOperation, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfOperation::Clone() const {
  return common::make_unique<
    OfOperation
  >(*this);
}

void OfOperation::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          IdShortsOfVariablesAreUnique(
            instance_->input_variables(),
            instance_->output_variables(),
            instance_->inoutput_variables()
          )
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-134: For an Operation the ID-short of all "
          L"values of input, output and in/output variables."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !(instance_->input_variables().has_value())
          || ((*(instance_->input_variables())).size() >= 1)
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Input variables must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (
          !(instance_->output_variables().has_value())
          || ((*(instance_->output_variables())).size() >= 1)
        ) {
          state_ = 14;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Output variables must be either not set or have at least "
          L"one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 14;
        return;
      }

      case 14: {
        if (
          !(instance_->inoutput_variables().has_value())
          || ((*(instance_->inoutput_variables())).size() >= 1)
        ) {
          state_ = 15;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Inoutput variables must be either not set or have at least "
          L"one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        if (!(instance_->category().has_value())) {
          state_ = 19;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 16: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 18;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 17;
        return;
      }

      case 17: {
        constrained_primitive_verificator_->Next();

        state_ = 16;
        continue;
      }

      case 18: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 19: {
        if (!(instance_->id_short().has_value())) {
          state_ = 23;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 20: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 22;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 21;
        return;
      }

      case 21: {
        constrained_primitive_verificator_->Next();

        state_ = 20;
        continue;
      }

      case 22: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 23: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 24;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfOperationVariable : public impl::IVerificator {
 public:
  OfOperationVariable(
    const std::shared_ptr<types::IClass>& instance
  );

  OfOperationVariable(
    const OfOperationVariable& other
  );
  OfOperationVariable(
    OfOperationVariable&& other
  );
  OfOperationVariable& operator=(
    const OfOperationVariable& other
  );
  OfOperationVariable& operator=(
    OfOperationVariable&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfOperationVariable() override = default;

 private:
  std::shared_ptr<types::IOperationVariable> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;

  void Execute();
};  // class OfOperationVariable

OfOperationVariable::OfOperationVariable(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IOperationVariable
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfOperationVariable::OfOperationVariable(
  const OfOperationVariable& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
}

OfOperationVariable::OfOperationVariable(
  OfOperationVariable&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
}

OfOperationVariable& OfOperationVariable::operator=(
  const OfOperationVariable& other
) {
  return *this = OfOperationVariable(other);
}

OfOperationVariable& OfOperationVariable::operator=(
  OfOperationVariable&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
  }
  return *this;
}

void OfOperationVariable::Start() {
  state_ = 0;
  Execute();
}

void OfOperationVariable::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfOperationVariable, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfOperationVariable::Done() const {
  return done_;
}

const Error& OfOperationVariable::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfOperationVariable, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfOperationVariable::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfOperationVariable, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfOperationVariable::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfOperationVariable, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfOperationVariable::Clone() const {
  return common::make_unique<
    OfOperationVariable
  >(*this);
}

void OfOperationVariable::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (instance_->value()->id_short().has_value()) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Value must have the ID-short specified according to "
          L"Constraint AASd-117 (ID-short of Referables not being "
          L"a direct child of a Submodel element list shall be "
          L"specified)."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 2;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfCapability : public impl::IVerificator {
 public:
  OfCapability(
    const std::shared_ptr<types::IClass>& instance
  );

  OfCapability(
    const OfCapability& other
  );
  OfCapability(
    OfCapability&& other
  );
  OfCapability& operator=(
    const OfCapability& other
  );
  OfCapability& operator=(
    OfCapability&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfCapability() override = default;

 private:
  std::shared_ptr<types::ICapability> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfCapability

OfCapability::OfCapability(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ICapability
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfCapability::OfCapability(
  const OfCapability& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfCapability::OfCapability(
  OfCapability&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfCapability& OfCapability::operator=(
  const OfCapability& other
) {
  return *this = OfCapability(other);
}

OfCapability& OfCapability::operator=(
  OfCapability&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfCapability::Start() {
  state_ = 0;
  Execute();
}

void OfCapability::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfCapability, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfCapability::Done() const {
  return done_;
}

const Error& OfCapability::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfCapability, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfCapability::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfCapability, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfCapability::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfCapability, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfCapability::Clone() const {
  return common::make_unique<
    OfCapability
  >(*this);
}

void OfCapability::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || ((*(instance_->supplemental_semantic_ids())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Supplemental semantic IDs must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->supplemental_semantic_ids().has_value())
          || (instance_->semantic_id().has_value())
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-118: If there are supplemental semantic IDs "
          L"defined then there shall be also a main semantic ID."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->qualifiers().has_value())
          || ((*(instance_->qualifiers())).size() >= 1)
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Qualifiers must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !(instance_->qualifiers().has_value())
          || QualifierTypesAreUnique(
            (*(instance_->qualifiers()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-021: Every qualifiable can only have one "
          L"qualifier with the same type."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (!(instance_->category().has_value())) {
          state_ = 15;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 12: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 14;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        constrained_primitive_verificator_->Next();

        state_ = 12;
        continue;
      }

      case 14: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 15: {
        if (!(instance_->id_short().has_value())) {
          state_ = 19;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 16: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 18;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 17;
        return;
      }

      case 17: {
        constrained_primitive_verificator_->Next();

        state_ = 16;
        continue;
      }

      case 18: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 19: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 20;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfConceptDescription : public impl::IVerificator {
 public:
  OfConceptDescription(
    const std::shared_ptr<types::IClass>& instance
  );

  OfConceptDescription(
    const OfConceptDescription& other
  );
  OfConceptDescription(
    OfConceptDescription&& other
  );
  OfConceptDescription& operator=(
    const OfConceptDescription& other
  );
  OfConceptDescription& operator=(
    OfConceptDescription&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfConceptDescription() override = default;

 private:
  std::shared_ptr<types::IConceptDescription> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfConceptDescription

OfConceptDescription::OfConceptDescription(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IConceptDescription
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfConceptDescription::OfConceptDescription(
  const OfConceptDescription& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfConceptDescription::OfConceptDescription(
  OfConceptDescription&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfConceptDescription& OfConceptDescription::operator=(
  const OfConceptDescription& other
) {
  return *this = OfConceptDescription(other);
}

OfConceptDescription& OfConceptDescription::operator=(
  OfConceptDescription&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfConceptDescription::Start() {
  state_ = 0;
  Execute();
}

void OfConceptDescription::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfConceptDescription, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfConceptDescription::Done() const {
  return done_;
}

const Error& OfConceptDescription::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfConceptDescription, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfConceptDescription::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfConceptDescription, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfConceptDescription::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfConceptDescription, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfConceptDescription::Clone() const {
  return common::make_unique<
    OfConceptDescription
  >(*this);
}

void OfConceptDescription::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->extensions().has_value())
          || ((*(instance_->extensions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Extensions must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->extensions().has_value())
          || ExtensionNamesAreUnique(
            (*(instance_->extensions()))
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-077: The name of an extension within "
          L"Has-Extensions needs to be unique."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->description().has_value())
          || ((*(instance_->description())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->description().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->description()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Description must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->display_name().has_value())
          || ((*(instance_->display_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must be either not set or have at least one "
          L"item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->display_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->display_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Display name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((*(instance_->embedded_data_specifications())).size() >= 1)
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Embedded data specifications must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !(instance_->is_case_of().has_value())
          || ((*(instance_->is_case_of())).size() >= 1)
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Is-case-of must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !(instance_->embedded_data_specifications().has_value())
          || ((
            DataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(
              (*(instance_->embedded_data_specifications()))
            )
            || DataSpecificationIec61360sHaveValue(
              (*(instance_->embedded_data_specifications()))
            )
          ))
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASc-3a-008: For a concept description using "
          L"data specification template IEC 61360, the definition is "
          L"mandatory and shall be defined at least in English. "
          L"Exception: The concept description describes a value."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (
          !((
            (instance_->category().has_value())
            && (*(instance_->category())) == L"QUALIFIER_TYPE"
            && (instance_->embedded_data_specifications().has_value())
          ))
          || DataSpecificationIec61360sHaveDataType(
            (*(instance_->embedded_data_specifications()))
          )
        ) {
          state_ = 10;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASc-3a-007: For a concept description with "
          L"category QUALIFIER_TYPE using data specification IEC 61360, "
          L"the data type of the data specification is mandatory and "
          L"shall be defined."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 10;
        return;
      }

      case 10: {
        if (
          !((
            (instance_->category().has_value())
            && (*(instance_->category())) == L"DOCUMENT"
            && (instance_->embedded_data_specifications().has_value())
          ))
          || DataSpecificationIec61360sForDocumentHaveAppropriateDataType(
            (*(instance_->embedded_data_specifications()))
          )
        ) {
          state_ = 11;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASc-3a-006: For a concept description with "
          L"category DOCUMENT using data specification IEC 61360, "
          L"the data type of the data specification shall be one of: "
          L"FILE, BLOB, HTML."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        if (
          !((
            (instance_->category().has_value())
            && (*(instance_->category())) == L"REFERENCE"
            && (instance_->embedded_data_specifications().has_value())
          ))
          || DataSpecificationIec61360sForReferenceHaveAppropriateDataType(
            (*(instance_->embedded_data_specifications()))
          )
        ) {
          state_ = 12;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASc-3a-005: For a concept description with "
          L"category REFERENCE using data specification IEC 61360, "
          L"the data type of the data specification shall be one of: "
          L"STRING, IRI, IRDI."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 12;
        return;
      }

      case 12: {
        if (
          !((
            (instance_->category().has_value())
            && (
              (
                (*(instance_->category())) == L"PROPERTY"
                || (*(instance_->category())) == L"VALUE"
              )
            )
            && (instance_->embedded_data_specifications().has_value())
          ))
          || DataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(
            (*(instance_->embedded_data_specifications()))
          )
        ) {
          state_ = 13;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASc-3a-004: For a concept description with "
          L"category PROPERTY or VALUE using data specification IEC "
          L"61360, the data type of the data specification is mandatory "
          L"and shall be one of: DATE, STRING, STRING_TRANSLATABLE, "
          L"INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, "
          L"REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, "
          L"RATIONAL_MEASURE, TIME, TIMESTAMP."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 13;
        return;
      }

      case 13: {
        if (!(instance_->category().has_value())) {
          state_ = 17;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNameType
          >(
            *(instance_->category())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 14: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 16;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kCategory
          )
        );

        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        constrained_primitive_verificator_->Next();

        state_ = 14;
        continue;
      }

      case 16: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 17: {
        if (!(instance_->id_short().has_value())) {
          state_ = 21;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdShortType
          >(
            *(instance_->id_short())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 18: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 20;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kIdShort
          )
        );

        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        constrained_primitive_verificator_->Next();

        state_ = 18;
        continue;
      }

      case 20: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 21: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            instance_->id()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 22: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 24;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kId
          )
        );

        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        constrained_primitive_verificator_->Next();

        state_ = 22;
        continue;
      }

      case 24: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 25;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfReference : public impl::IVerificator {
 public:
  OfReference(
    const std::shared_ptr<types::IClass>& instance
  );

  OfReference(
    const OfReference& other
  );
  OfReference(
    OfReference&& other
  );
  OfReference& operator=(
    const OfReference& other
  );
  OfReference& operator=(
    OfReference&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfReference() override = default;

 private:
  std::shared_ptr<types::IReference> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;

  void Execute();
};  // class OfReference

OfReference::OfReference(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IReference
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfReference::OfReference(
  const OfReference& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
}

OfReference::OfReference(
  OfReference&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
}

OfReference& OfReference::operator=(
  const OfReference& other
) {
  return *this = OfReference(other);
}

OfReference& OfReference::operator=(
  OfReference&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
  }
  return *this;
}

void OfReference::Start() {
  state_ = 0;
  Execute();
}

void OfReference::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfReference, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfReference::Done() const {
  return done_;
}

const Error& OfReference::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfReference, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfReference::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfReference, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfReference::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfReference, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfReference::Clone() const {
  return common::make_unique<
    OfReference
  >(*this);
}

void OfReference::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (instance_->keys().size() >= 1) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Keys must contain at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->keys().size() >= 1)
          || common::Contains(
            constants::kGloballyIdentifiables,
            instance_->keys().at(0)->type()
          )
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-121: For References the value of type of "
          L"the first key of keys shall be one of Globally "
          L"Identifiables."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !((
            instance_->type() == types::ReferenceTypes::kExternalReference
            && instance_->keys().size() >= 1
          ))
          || common::Contains(
            constants::kGenericGloballyIdentifiables,
            instance_->keys().at(0)->type()
          )
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-122: For external references the value of "
          L"type of the first key of keys shall be one of Generic "
          L"Globally Identifiables."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !((
            instance_->type() == types::ReferenceTypes::kModelReference
            && instance_->keys().size() >= 1
          ))
          || common::Contains(
            constants::kAasIdentifiables,
            instance_->keys().at(0)->type()
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-123: For model references the value of type "
          L"of the first key of keys shall be one of AAS identifiables."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !((
            instance_->type() == types::ReferenceTypes::kExternalReference
            && instance_->keys().size() >= 1
          ))
          || ((
            common::Contains(
              constants::kGenericGloballyIdentifiables,
              instance_->keys().back()->type()
            )
            || common::Contains(
              constants::kGenericFragmentKeys,
              instance_->keys().back()->type()
            )
          ))
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-124: For external references the last key "
          L"of keys shall be either one of Generic Globally "
          L"Identifiables or one of Generic Fragment Keys."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !((
            instance_->type() == types::ReferenceTypes::kModelReference
            && instance_->keys().size() > 1
          ))
          || common::AllRange(
            [&](size_t i) -> bool {
              return common::Contains(
                constants::kFragmentKeys,
                instance_->keys().at(i)->type()
              );
            },
            1,
            instance_->keys().size()
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-125: For model references with more than "
          L"one key in keys the value of type of each of the keys "
          L"following the first key of keys shall be one of Fragment "
          L"Keys."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (
          !((
            instance_->type() == types::ReferenceTypes::kModelReference
            && instance_->keys().size() > 1
          ))
          || common::AllRange(
            [&](size_t i) -> bool {
              return !common::Contains(
                constants::kGenericFragmentKeys,
                instance_->keys().at(i)->type()
              );
            },
            0,
            instance_->keys().size() - (1)
          )
        ) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-126: For model references with more than "
          L"one key in keys the value of type of the last key in "
          L"the reference key chain may be one of Generic Fragment Keys "
          L"or no key at all shall have a value out of Generic Fragment "
          L"Keys."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          !((
            instance_->type() == types::ReferenceTypes::kModelReference
            && instance_->keys().size() > 1
            && instance_->keys().back()->type() == types::KeyTypes::kFragmentReference
          ))
          || ((
            instance_->keys().at(instance_->keys().size() - 2)->type() == types::KeyTypes::kFile
            || instance_->keys().at(instance_->keys().size() - 2)->type() == types::KeyTypes::kBlob
          ))
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-127: For model references, with more than "
          L"one key in keys a key with type Fragment Reference shall be "
          L"preceded by a key with type File or Blob."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          !((
            instance_->type() == types::ReferenceTypes::kModelReference
            && instance_->keys().size() > 2
          ))
          || common::AllRange(
            [&](size_t i) -> bool {
              return !(instance_->keys().at(i)->type() == types::KeyTypes::kSubmodelElementList)
              || MatchesXsPositiveInteger(
                instance_->keys().at(i + (1))->value()
              );
            },
            0,
            instance_->keys().size() - (1)
          )
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASd-128: For model references, the value of "
          L"a key preceded by a key with type Submodel element list is "
          L"an integer number denoting the position in the array of "
          L"the submodel element list."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 10;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfKey : public impl::IVerificator {
 public:
  OfKey(
    const std::shared_ptr<types::IClass>& instance
  );

  OfKey(
    const OfKey& other
  );
  OfKey(
    OfKey&& other
  );
  OfKey& operator=(
    const OfKey& other
  );
  OfKey& operator=(
    OfKey&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfKey() override = default;

 private:
  std::shared_ptr<types::IKey> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfKey

OfKey::OfKey(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IKey
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfKey::OfKey(
  const OfKey& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfKey::OfKey(
  OfKey&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfKey& OfKey::operator=(
  const OfKey& other
) {
  return *this = OfKey(other);
}

OfKey& OfKey::operator=(
  OfKey&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfKey::Start() {
  state_ = 0;
  Execute();
}

void OfKey::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfKey, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfKey::Done() const {
  return done_;
}

const Error& OfKey::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfKey, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfKey::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfKey, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfKey::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfKey, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfKey::Clone() const {
  return common::make_unique<
    OfKey
  >(*this);
}

void OfKey::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfIdentifier
          >(
            instance_->value()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 1: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 3;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        constrained_primitive_verificator_->Next();

        state_ = 1;
        continue;
      }

      case 3: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfLangStringNameType : public impl::IVerificator {
 public:
  OfLangStringNameType(
    const std::shared_ptr<types::IClass>& instance
  );

  OfLangStringNameType(
    const OfLangStringNameType& other
  );
  OfLangStringNameType(
    OfLangStringNameType&& other
  );
  OfLangStringNameType& operator=(
    const OfLangStringNameType& other
  );
  OfLangStringNameType& operator=(
    OfLangStringNameType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfLangStringNameType() override = default;

 private:
  std::shared_ptr<types::ILangStringNameType> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfLangStringNameType

OfLangStringNameType::OfLangStringNameType(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ILangStringNameType
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfLangStringNameType::OfLangStringNameType(
  const OfLangStringNameType& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfLangStringNameType::OfLangStringNameType(
  OfLangStringNameType&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfLangStringNameType& OfLangStringNameType::operator=(
  const OfLangStringNameType& other
) {
  return *this = OfLangStringNameType(other);
}

OfLangStringNameType& OfLangStringNameType::operator=(
  OfLangStringNameType&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfLangStringNameType::Start() {
  state_ = 0;
  Execute();
}

void OfLangStringNameType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfLangStringNameType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfLangStringNameType::Done() const {
  return done_;
}

const Error& OfLangStringNameType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfLangStringNameType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfLangStringNameType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfLangStringNameType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfLangStringNameType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfLangStringNameType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfLangStringNameType::Clone() const {
  return common::make_unique<
    OfLangStringNameType
  >(*this);
}

void OfLangStringNameType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (instance_->text().size() <= 128) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"String shall have a maximum length of 128 characters."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfBcp47LanguageTag
          >(
            instance_->language()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 2: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 4;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kLanguage
          )
        );

        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        constrained_primitive_verificator_->Next();

        state_ = 2;
        continue;
      }

      case 4: {
        constrained_primitive_verificator_ = nullptr;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            instance_->text()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 5: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 7;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kText
          )
        );

        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        constrained_primitive_verificator_->Next();

        state_ = 5;
        continue;
      }

      case 7: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 8;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfLangStringTextType : public impl::IVerificator {
 public:
  OfLangStringTextType(
    const std::shared_ptr<types::IClass>& instance
  );

  OfLangStringTextType(
    const OfLangStringTextType& other
  );
  OfLangStringTextType(
    OfLangStringTextType&& other
  );
  OfLangStringTextType& operator=(
    const OfLangStringTextType& other
  );
  OfLangStringTextType& operator=(
    OfLangStringTextType&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfLangStringTextType() override = default;

 private:
  std::shared_ptr<types::ILangStringTextType> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfLangStringTextType

OfLangStringTextType::OfLangStringTextType(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ILangStringTextType
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfLangStringTextType::OfLangStringTextType(
  const OfLangStringTextType& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfLangStringTextType::OfLangStringTextType(
  OfLangStringTextType&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfLangStringTextType& OfLangStringTextType::operator=(
  const OfLangStringTextType& other
) {
  return *this = OfLangStringTextType(other);
}

OfLangStringTextType& OfLangStringTextType::operator=(
  OfLangStringTextType&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfLangStringTextType::Start() {
  state_ = 0;
  Execute();
}

void OfLangStringTextType::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfLangStringTextType, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfLangStringTextType::Done() const {
  return done_;
}

const Error& OfLangStringTextType::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfLangStringTextType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfLangStringTextType::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfLangStringTextType, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfLangStringTextType::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfLangStringTextType, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfLangStringTextType::Clone() const {
  return common::make_unique<
    OfLangStringTextType
  >(*this);
}

void OfLangStringTextType::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (instance_->text().size() <= 1023) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"String shall have a maximum length of 1023 characters."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfBcp47LanguageTag
          >(
            instance_->language()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 2: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 4;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kLanguage
          )
        );

        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        constrained_primitive_verificator_->Next();

        state_ = 2;
        continue;
      }

      case 4: {
        constrained_primitive_verificator_ = nullptr;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            instance_->text()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 5: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 7;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kText
          )
        );

        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        constrained_primitive_verificator_->Next();

        state_ = 5;
        continue;
      }

      case 7: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 8;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfEnvironment : public impl::IVerificator {
 public:
  OfEnvironment(
    const std::shared_ptr<types::IClass>& instance
  );

  OfEnvironment(
    const OfEnvironment& other
  );
  OfEnvironment(
    OfEnvironment&& other
  );
  OfEnvironment& operator=(
    const OfEnvironment& other
  );
  OfEnvironment& operator=(
    OfEnvironment&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfEnvironment() override = default;

 private:
  std::shared_ptr<types::IEnvironment> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;

  void Execute();
};  // class OfEnvironment

OfEnvironment::OfEnvironment(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IEnvironment
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfEnvironment::OfEnvironment(
  const OfEnvironment& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
}

OfEnvironment::OfEnvironment(
  OfEnvironment&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
}

OfEnvironment& OfEnvironment::operator=(
  const OfEnvironment& other
) {
  return *this = OfEnvironment(other);
}

OfEnvironment& OfEnvironment::operator=(
  OfEnvironment&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
  }
  return *this;
}

void OfEnvironment::Start() {
  state_ = 0;
  Execute();
}

void OfEnvironment::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfEnvironment, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfEnvironment::Done() const {
  return done_;
}

const Error& OfEnvironment::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfEnvironment, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfEnvironment::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfEnvironment, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfEnvironment::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfEnvironment, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfEnvironment::Clone() const {
  return common::make_unique<
    OfEnvironment
  >(*this);
}

void OfEnvironment::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !(instance_->concept_descriptions().has_value())
          || ((*(instance_->concept_descriptions())).size() >= 1)
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Concept descriptions must be either not set or have at "
          L"least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !(instance_->submodels().has_value())
          || ((*(instance_->submodels())).size() >= 1)
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Submodels must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->asset_administration_shells().has_value())
          || ((*(instance_->asset_administration_shells())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Asset administration shells must be either not set or have "
          L"at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfEmbeddedDataSpecification : public impl::IVerificator {
 public:
  OfEmbeddedDataSpecification(
    const std::shared_ptr<types::IClass>& instance
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfEmbeddedDataSpecification() override = default;
};  // class OfEmbeddedDataSpecification

OfEmbeddedDataSpecification::OfEmbeddedDataSpecification(
  const std::shared_ptr<types::IClass>&
) {
  // Intentionally empty.
}

void OfEmbeddedDataSpecification::Start() {
  // Intentionally empty.
}

void OfEmbeddedDataSpecification::Next() {
  throw std::logic_error(
    "You want to move "
    "a verificator OfEmbeddedDataSpecification, "
    "but the verificator is always done as "
    "IEmbeddedDataSpecification "
    "has no invariants defined."
  );
}

bool OfEmbeddedDataSpecification::Done() const {
  return true;
}

const Error& OfEmbeddedDataSpecification::Get() const {
  throw std::logic_error(
    "You want to get from "
    "a verificator OfEmbeddedDataSpecification, "
    "but the verificator is always done as "
    "IEmbeddedDataSpecification "
    "has no invariants defined."
  );
}

Error& OfEmbeddedDataSpecification::GetMutable() {
  throw std::logic_error(
    "You want to get mutable from "
    "a verificator OfEmbeddedDataSpecification, "
    "but the verificator is always done as "
    "IEmbeddedDataSpecification "
    "has no invariants defined."
  );
}

long OfEmbeddedDataSpecification::Index() const {
  return -1;
}

std::unique_ptr<impl::IVerificator> OfEmbeddedDataSpecification::Clone() const {
  return common::make_unique<
    OfEmbeddedDataSpecification
  >(*this);
}

class OfLevelType : public impl::IVerificator {
 public:
  OfLevelType(
    const std::shared_ptr<types::IClass>& instance
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfLevelType() override = default;
};  // class OfLevelType

OfLevelType::OfLevelType(
  const std::shared_ptr<types::IClass>&
) {
  // Intentionally empty.
}

void OfLevelType::Start() {
  // Intentionally empty.
}

void OfLevelType::Next() {
  throw std::logic_error(
    "You want to move "
    "a verificator OfLevelType, "
    "but the verificator is always done as "
    "ILevelType "
    "has no invariants defined."
  );
}

bool OfLevelType::Done() const {
  return true;
}

const Error& OfLevelType::Get() const {
  throw std::logic_error(
    "You want to get from "
    "a verificator OfLevelType, "
    "but the verificator is always done as "
    "ILevelType "
    "has no invariants defined."
  );
}

Error& OfLevelType::GetMutable() {
  throw std::logic_error(
    "You want to get mutable from "
    "a verificator OfLevelType, "
    "but the verificator is always done as "
    "ILevelType "
    "has no invariants defined."
  );
}

long OfLevelType::Index() const {
  return -1;
}

std::unique_ptr<impl::IVerificator> OfLevelType::Clone() const {
  return common::make_unique<
    OfLevelType
  >(*this);
}

class OfValueReferencePair : public impl::IVerificator {
 public:
  OfValueReferencePair(
    const std::shared_ptr<types::IClass>& instance
  );

  OfValueReferencePair(
    const OfValueReferencePair& other
  );
  OfValueReferencePair(
    OfValueReferencePair&& other
  );
  OfValueReferencePair& operator=(
    const OfValueReferencePair& other
  );
  OfValueReferencePair& operator=(
    OfValueReferencePair&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfValueReferencePair() override = default;

 private:
  std::shared_ptr<types::IValueReferencePair> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfValueReferencePair

OfValueReferencePair::OfValueReferencePair(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IValueReferencePair
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfValueReferencePair::OfValueReferencePair(
  const OfValueReferencePair& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfValueReferencePair::OfValueReferencePair(
  OfValueReferencePair&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfValueReferencePair& OfValueReferencePair::operator=(
  const OfValueReferencePair& other
) {
  return *this = OfValueReferencePair(other);
}

OfValueReferencePair& OfValueReferencePair::operator=(
  OfValueReferencePair&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfValueReferencePair::Start() {
  state_ = 0;
  Execute();
}

void OfValueReferencePair::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfValueReferencePair, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfValueReferencePair::Done() const {
  return done_;
}

const Error& OfValueReferencePair::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfValueReferencePair, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfValueReferencePair::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfValueReferencePair, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfValueReferencePair::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfValueReferencePair, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfValueReferencePair::Clone() const {
  return common::make_unique<
    OfValueReferencePair
  >(*this);
}

void OfValueReferencePair::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfValueTypeIec61360
          >(
            instance_->value()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 1: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 3;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        constrained_primitive_verificator_->Next();

        state_ = 1;
        continue;
      }

      case 3: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 4;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfValueList : public impl::IVerificator {
 public:
  OfValueList(
    const std::shared_ptr<types::IClass>& instance
  );

  OfValueList(
    const OfValueList& other
  );
  OfValueList(
    OfValueList&& other
  );
  OfValueList& operator=(
    const OfValueList& other
  );
  OfValueList& operator=(
    OfValueList&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfValueList() override = default;

 private:
  std::shared_ptr<types::IValueList> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;

  void Execute();
};  // class OfValueList

OfValueList::OfValueList(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IValueList
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfValueList::OfValueList(
  const OfValueList& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
}

OfValueList::OfValueList(
  OfValueList&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
}

OfValueList& OfValueList::operator=(
  const OfValueList& other
) {
  return *this = OfValueList(other);
}

OfValueList& OfValueList::operator=(
  OfValueList&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
  }
  return *this;
}

void OfValueList::Start() {
  state_ = 0;
  Execute();
}

void OfValueList::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfValueList, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfValueList::Done() const {
  return done_;
}

const Error& OfValueList::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfValueList, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfValueList::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfValueList, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfValueList::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfValueList, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfValueList::Clone() const {
  return common::make_unique<
    OfValueList
  >(*this);
}

void OfValueList::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (instance_->value_reference_pairs().size() >= 1) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Value reference pair types must contain at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 2;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfLangStringPreferredNameTypeIec61360 : public impl::IVerificator {
 public:
  OfLangStringPreferredNameTypeIec61360(
    const std::shared_ptr<types::IClass>& instance
  );

  OfLangStringPreferredNameTypeIec61360(
    const OfLangStringPreferredNameTypeIec61360& other
  );
  OfLangStringPreferredNameTypeIec61360(
    OfLangStringPreferredNameTypeIec61360&& other
  );
  OfLangStringPreferredNameTypeIec61360& operator=(
    const OfLangStringPreferredNameTypeIec61360& other
  );
  OfLangStringPreferredNameTypeIec61360& operator=(
    OfLangStringPreferredNameTypeIec61360&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfLangStringPreferredNameTypeIec61360() override = default;

 private:
  std::shared_ptr<types::ILangStringPreferredNameTypeIec61360> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfLangStringPreferredNameTypeIec61360

OfLangStringPreferredNameTypeIec61360::OfLangStringPreferredNameTypeIec61360(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ILangStringPreferredNameTypeIec61360
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfLangStringPreferredNameTypeIec61360::OfLangStringPreferredNameTypeIec61360(
  const OfLangStringPreferredNameTypeIec61360& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfLangStringPreferredNameTypeIec61360::OfLangStringPreferredNameTypeIec61360(
  OfLangStringPreferredNameTypeIec61360&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfLangStringPreferredNameTypeIec61360& OfLangStringPreferredNameTypeIec61360::operator=(
  const OfLangStringPreferredNameTypeIec61360& other
) {
  return *this = OfLangStringPreferredNameTypeIec61360(other);
}

OfLangStringPreferredNameTypeIec61360& OfLangStringPreferredNameTypeIec61360::operator=(
  OfLangStringPreferredNameTypeIec61360&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfLangStringPreferredNameTypeIec61360::Start() {
  state_ = 0;
  Execute();
}

void OfLangStringPreferredNameTypeIec61360::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfLangStringPreferredNameTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfLangStringPreferredNameTypeIec61360::Done() const {
  return done_;
}

const Error& OfLangStringPreferredNameTypeIec61360::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfLangStringPreferredNameTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfLangStringPreferredNameTypeIec61360::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfLangStringPreferredNameTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfLangStringPreferredNameTypeIec61360::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfLangStringPreferredNameTypeIec61360, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfLangStringPreferredNameTypeIec61360::Clone() const {
  return common::make_unique<
    OfLangStringPreferredNameTypeIec61360
  >(*this);
}

void OfLangStringPreferredNameTypeIec61360::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (instance_->text().size() <= 255) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"String shall have a maximum length of 255 characters."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfBcp47LanguageTag
          >(
            instance_->language()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 2: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 4;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kLanguage
          )
        );

        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        constrained_primitive_verificator_->Next();

        state_ = 2;
        continue;
      }

      case 4: {
        constrained_primitive_verificator_ = nullptr;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            instance_->text()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 5: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 7;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kText
          )
        );

        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        constrained_primitive_verificator_->Next();

        state_ = 5;
        continue;
      }

      case 7: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 8;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfLangStringShortNameTypeIec61360 : public impl::IVerificator {
 public:
  OfLangStringShortNameTypeIec61360(
    const std::shared_ptr<types::IClass>& instance
  );

  OfLangStringShortNameTypeIec61360(
    const OfLangStringShortNameTypeIec61360& other
  );
  OfLangStringShortNameTypeIec61360(
    OfLangStringShortNameTypeIec61360&& other
  );
  OfLangStringShortNameTypeIec61360& operator=(
    const OfLangStringShortNameTypeIec61360& other
  );
  OfLangStringShortNameTypeIec61360& operator=(
    OfLangStringShortNameTypeIec61360&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfLangStringShortNameTypeIec61360() override = default;

 private:
  std::shared_ptr<types::ILangStringShortNameTypeIec61360> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfLangStringShortNameTypeIec61360

OfLangStringShortNameTypeIec61360::OfLangStringShortNameTypeIec61360(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ILangStringShortNameTypeIec61360
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfLangStringShortNameTypeIec61360::OfLangStringShortNameTypeIec61360(
  const OfLangStringShortNameTypeIec61360& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfLangStringShortNameTypeIec61360::OfLangStringShortNameTypeIec61360(
  OfLangStringShortNameTypeIec61360&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfLangStringShortNameTypeIec61360& OfLangStringShortNameTypeIec61360::operator=(
  const OfLangStringShortNameTypeIec61360& other
) {
  return *this = OfLangStringShortNameTypeIec61360(other);
}

OfLangStringShortNameTypeIec61360& OfLangStringShortNameTypeIec61360::operator=(
  OfLangStringShortNameTypeIec61360&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfLangStringShortNameTypeIec61360::Start() {
  state_ = 0;
  Execute();
}

void OfLangStringShortNameTypeIec61360::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfLangStringShortNameTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfLangStringShortNameTypeIec61360::Done() const {
  return done_;
}

const Error& OfLangStringShortNameTypeIec61360::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfLangStringShortNameTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfLangStringShortNameTypeIec61360::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfLangStringShortNameTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfLangStringShortNameTypeIec61360::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfLangStringShortNameTypeIec61360, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfLangStringShortNameTypeIec61360::Clone() const {
  return common::make_unique<
    OfLangStringShortNameTypeIec61360
  >(*this);
}

void OfLangStringShortNameTypeIec61360::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (instance_->text().size() <= 18) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"String shall have a maximum length of 18 characters."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfBcp47LanguageTag
          >(
            instance_->language()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 2: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 4;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kLanguage
          )
        );

        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        constrained_primitive_verificator_->Next();

        state_ = 2;
        continue;
      }

      case 4: {
        constrained_primitive_verificator_ = nullptr;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            instance_->text()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 5: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 7;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kText
          )
        );

        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        constrained_primitive_verificator_->Next();

        state_ = 5;
        continue;
      }

      case 7: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 8;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfLangStringDefinitionTypeIec61360 : public impl::IVerificator {
 public:
  OfLangStringDefinitionTypeIec61360(
    const std::shared_ptr<types::IClass>& instance
  );

  OfLangStringDefinitionTypeIec61360(
    const OfLangStringDefinitionTypeIec61360& other
  );
  OfLangStringDefinitionTypeIec61360(
    OfLangStringDefinitionTypeIec61360&& other
  );
  OfLangStringDefinitionTypeIec61360& operator=(
    const OfLangStringDefinitionTypeIec61360& other
  );
  OfLangStringDefinitionTypeIec61360& operator=(
    OfLangStringDefinitionTypeIec61360&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfLangStringDefinitionTypeIec61360() override = default;

 private:
  std::shared_ptr<types::ILangStringDefinitionTypeIec61360> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfLangStringDefinitionTypeIec61360

OfLangStringDefinitionTypeIec61360::OfLangStringDefinitionTypeIec61360(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::ILangStringDefinitionTypeIec61360
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfLangStringDefinitionTypeIec61360::OfLangStringDefinitionTypeIec61360(
  const OfLangStringDefinitionTypeIec61360& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfLangStringDefinitionTypeIec61360::OfLangStringDefinitionTypeIec61360(
  OfLangStringDefinitionTypeIec61360&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfLangStringDefinitionTypeIec61360& OfLangStringDefinitionTypeIec61360::operator=(
  const OfLangStringDefinitionTypeIec61360& other
) {
  return *this = OfLangStringDefinitionTypeIec61360(other);
}

OfLangStringDefinitionTypeIec61360& OfLangStringDefinitionTypeIec61360::operator=(
  OfLangStringDefinitionTypeIec61360&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfLangStringDefinitionTypeIec61360::Start() {
  state_ = 0;
  Execute();
}

void OfLangStringDefinitionTypeIec61360::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfLangStringDefinitionTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfLangStringDefinitionTypeIec61360::Done() const {
  return done_;
}

const Error& OfLangStringDefinitionTypeIec61360::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfLangStringDefinitionTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfLangStringDefinitionTypeIec61360::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfLangStringDefinitionTypeIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfLangStringDefinitionTypeIec61360::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfLangStringDefinitionTypeIec61360, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfLangStringDefinitionTypeIec61360::Clone() const {
  return common::make_unique<
    OfLangStringDefinitionTypeIec61360
  >(*this);
}

void OfLangStringDefinitionTypeIec61360::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (instance_->text().size() <= 1023) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"String shall have a maximum length of 1023 characters."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfBcp47LanguageTag
          >(
            instance_->language()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 2: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 4;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kLanguage
          )
        );

        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        constrained_primitive_verificator_->Next();

        state_ = 2;
        continue;
      }

      case 4: {
        constrained_primitive_verificator_ = nullptr;

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            instance_->text()
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 5: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 7;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kText
          )
        );

        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        constrained_primitive_verificator_->Next();

        state_ = 5;
        continue;
      }

      case 7: {
        constrained_primitive_verificator_ = nullptr;

        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 8;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

class OfDataSpecificationIec61360 : public impl::IVerificator {
 public:
  OfDataSpecificationIec61360(
    const std::shared_ptr<types::IClass>& instance
  );

  OfDataSpecificationIec61360(
    const OfDataSpecificationIec61360& other
  );
  OfDataSpecificationIec61360(
    OfDataSpecificationIec61360&& other
  );
  OfDataSpecificationIec61360& operator=(
    const OfDataSpecificationIec61360& other
  );
  OfDataSpecificationIec61360& operator=(
    OfDataSpecificationIec61360&& other
  );

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~OfDataSpecificationIec61360() override = default;

 private:
  std::shared_ptr<types::IDataSpecificationIec61360> instance_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> constrained_primitive_verificator_;

  void Execute();
};  // class OfDataSpecificationIec61360

OfDataSpecificationIec61360::OfDataSpecificationIec61360(
  const std::shared_ptr<types::IClass>& instance
) :
  // NOTE (mristin)
  // We cast here despite the cost of increasing the use count of the shared pointer.
  // Otherwise, if we didn't cast, we would not be able to have a uniform interface
  // for the verification functions based on the shared pointer.
  instance_(
    std::dynamic_pointer_cast<
      types::IDataSpecificationIec61360
    >(
      instance
    )
  ) {
  // Intentionally empty.
}

OfDataSpecificationIec61360::OfDataSpecificationIec61360(
  const OfDataSpecificationIec61360& other
) {
  instance_ = other.instance_;
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = (
    other.constrained_primitive_verificator_->Clone()
  );
}

OfDataSpecificationIec61360::OfDataSpecificationIec61360(
  OfDataSpecificationIec61360&& other
) {
  instance_ = std::move(other.instance_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  state_ = other.state_;
  constrained_primitive_verificator_ = std::move(
    other.constrained_primitive_verificator_
  );
}

OfDataSpecificationIec61360& OfDataSpecificationIec61360::operator=(
  const OfDataSpecificationIec61360& other
) {
  return *this = OfDataSpecificationIec61360(other);
}

OfDataSpecificationIec61360& OfDataSpecificationIec61360::operator=(
  OfDataSpecificationIec61360&& other
) {
  if (this != &other) {
    instance_ = std::move(other.instance_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    state_ = other.state_;
    constrained_primitive_verificator_ = std::move(
      other.constrained_primitive_verificator_
    );
  }
  return *this;
}

void OfDataSpecificationIec61360::Start() {
  state_ = 0;
  Execute();
}

void OfDataSpecificationIec61360::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to move a verificator OfDataSpecificationIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool OfDataSpecificationIec61360::Done() const {
  return done_;
}

const Error& OfDataSpecificationIec61360::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a verificator OfDataSpecificationIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

Error& OfDataSpecificationIec61360::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a verificator OfDataSpecificationIec61360, "
      "but the verificator was done."
    );
  }
  #endif

  return *error_;
}

long OfDataSpecificationIec61360::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done verificator OfDataSpecificationIec61360, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> OfDataSpecificationIec61360::Clone() const {
  return common::make_unique<
    OfDataSpecificationIec61360
  >(*this);
}

void OfDataSpecificationIec61360::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        done_ = false;
        error_ = nullptr;
        index_ = -1;

        if (
          !((
            (instance_->value().has_value())
            && (instance_->value_list().has_value())
          ))
        ) {
          state_ = 1;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASc-3a-010: If value is not empty then value "
          L"list shall be empty and vice versa."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 1;
        return;
      }

      case 1: {
        if (
          !((
            (instance_->data_type().has_value())
            && common::Contains(
              constants::kIec61360DataTypesWithUnit,
              (*(instance_->data_type()))
            )
          ))
          || ((
            (instance_->unit().has_value())
            || (instance_->unit_id().has_value())
          ))
        ) {
          state_ = 2;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASc-3a-009: If data type is a an integer, real "
          L"or rational with a measure or currency, unit or unit ID "
          L"shall be defined."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        if (
          !(instance_->definition().has_value())
          || ((*(instance_->definition())).size() >= 1)
        ) {
          state_ = 3;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Definition must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 3;
        return;
      }

      case 3: {
        if (
          !(instance_->definition().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->definition()))
          )
        ) {
          state_ = 4;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Definition must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 4;
        return;
      }

      case 4: {
        if (
          !(instance_->short_name().has_value())
          || ((*(instance_->short_name())).size() >= 1)
        ) {
          state_ = 5;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Short name must be either not set or have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 5;
        return;
      }

      case 5: {
        if (
          !(instance_->short_name().has_value())
          || LangStringsHaveUniqueLanguages(
            (*(instance_->short_name()))
          )
        ) {
          state_ = 6;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Short name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        if (instance_->preferred_name().size() >= 1) {
          state_ = 7;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Preferred name must have at least one item."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 7;
        return;
      }

      case 7: {
        if (
          LangStringsHaveUniqueLanguages(
            instance_->preferred_name()
          )
        ) {
          state_ = 8;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Preferred name must specify unique languages."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 8;
        return;
      }

      case 8: {
        if (
          common::Some(
            [&](const std::shared_ptr<types::ILangStringPreferredNameTypeIec61360>& lang_string) -> bool {
              return IsBcp47ForEnglish(
                lang_string->language()
              );
            },
            instance_->preferred_name()
          )
        ) {
          state_ = 9;
          continue;
        }

        error_ = common::make_unique<Error>(
          L"Constraint AASc-3a-002: preferred name shall be provided at "
          L"least in English."
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 9;
        return;
      }

      case 9: {
        if (!(instance_->unit().has_value())) {
          state_ = 13;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            *(instance_->unit())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 10: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 12;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kUnit
          )
        );

        ++index_;

        state_ = 11;
        return;
      }

      case 11: {
        constrained_primitive_verificator_->Next();

        state_ = 10;
        continue;
      }

      case 12: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 13: {
        if (!(instance_->source_of_definition().has_value())) {
          state_ = 17;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            *(instance_->source_of_definition())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 14: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 16;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSourceOfDefinition
          )
        );

        ++index_;

        state_ = 15;
        return;
      }

      case 15: {
        constrained_primitive_verificator_->Next();

        state_ = 14;
        continue;
      }

      case 16: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 17: {
        if (!(instance_->symbol().has_value())) {
          state_ = 21;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            *(instance_->symbol())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 18: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 20;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kSymbol
          )
        );

        ++index_;

        state_ = 19;
        return;
      }

      case 19: {
        constrained_primitive_verificator_->Next();

        state_ = 18;
        continue;
      }

      case 20: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 21: {
        if (!(instance_->value_format().has_value())) {
          state_ = 25;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfNonEmptyXmlSerializableString
          >(
            *(instance_->value_format())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 22: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 24;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValueFormat
          )
        );

        ++index_;

        state_ = 23;
        return;
      }

      case 23: {
        constrained_primitive_verificator_->Next();

        state_ = 22;
        continue;
      }

      case 24: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 25: {
        if (!(instance_->value().has_value())) {
          state_ = 29;
          continue;
        }

        constrained_primitive_verificator_ = (
          common::make_unique<
            constrained_primitive_verificator::OfValueTypeIec61360
          >(
            *(instance_->value())
          )
        );
        constrained_primitive_verificator_->Start();
      }

      case 26: {
        if (!(!constrained_primitive_verificator_->Done())) {
          state_ = 28;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            constrained_primitive_verificator_->GetMutable()
          )
        );

        error_->path.segments.emplace_back(
          common::make_unique<iteration::PropertySegment>(
            iteration::Property::kValue
          )
        );

        ++index_;

        state_ = 27;
        return;
      }

      case 27: {
        constrained_primitive_verificator_->Next();

        state_ = 26;
        continue;
      }

      case 28: {
        constrained_primitive_verificator_ = nullptr;
      }

      case 29: {
        done_ = true;
        error_ = nullptr;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 30;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

}  // namespace non_recursive_verificator

std::unique_ptr<impl::IVerificator> NewNonRecursiveVerificator(
  const std::shared_ptr<types::IClass>& instance
) {
  switch (instance->model_type()) {
    case types::ModelType::kExtension:
      return common::make_unique<
        non_recursive_verificator::OfExtension
      >(
        instance
      );
    case types::ModelType::kAdministrativeInformation:
      return common::make_unique<
        non_recursive_verificator::OfAdministrativeInformation
      >(
        instance
      );
    case types::ModelType::kQualifier:
      return common::make_unique<
        non_recursive_verificator::OfQualifier
      >(
        instance
      );
    case types::ModelType::kAssetAdministrationShell:
      return common::make_unique<
        non_recursive_verificator::OfAssetAdministrationShell
      >(
        instance
      );
    case types::ModelType::kAssetInformation:
      return common::make_unique<
        non_recursive_verificator::OfAssetInformation
      >(
        instance
      );
    case types::ModelType::kResource:
      return common::make_unique<
        non_recursive_verificator::OfResource
      >(
        instance
      );
    case types::ModelType::kSpecificAssetId:
      return common::make_unique<
        non_recursive_verificator::OfSpecificAssetId
      >(
        instance
      );
    case types::ModelType::kSubmodel:
      return common::make_unique<
        non_recursive_verificator::OfSubmodel
      >(
        instance
      );
    case types::ModelType::kRelationshipElement:
      return common::make_unique<
        non_recursive_verificator::OfRelationshipElement
      >(
        instance
      );
    case types::ModelType::kSubmodelElementList:
      return common::make_unique<
        non_recursive_verificator::OfSubmodelElementList
      >(
        instance
      );
    case types::ModelType::kSubmodelElementCollection:
      return common::make_unique<
        non_recursive_verificator::OfSubmodelElementCollection
      >(
        instance
      );
    case types::ModelType::kProperty:
      return common::make_unique<
        non_recursive_verificator::OfProperty
      >(
        instance
      );
    case types::ModelType::kMultiLanguageProperty:
      return common::make_unique<
        non_recursive_verificator::OfMultiLanguageProperty
      >(
        instance
      );
    case types::ModelType::kRange:
      return common::make_unique<
        non_recursive_verificator::OfRange
      >(
        instance
      );
    case types::ModelType::kReferenceElement:
      return common::make_unique<
        non_recursive_verificator::OfReferenceElement
      >(
        instance
      );
    case types::ModelType::kBlob:
      return common::make_unique<
        non_recursive_verificator::OfBlob
      >(
        instance
      );
    case types::ModelType::kFile:
      return common::make_unique<
        non_recursive_verificator::OfFile
      >(
        instance
      );
    case types::ModelType::kAnnotatedRelationshipElement:
      return common::make_unique<
        non_recursive_verificator::OfAnnotatedRelationshipElement
      >(
        instance
      );
    case types::ModelType::kEntity:
      return common::make_unique<
        non_recursive_verificator::OfEntity
      >(
        instance
      );
    case types::ModelType::kEventPayload:
      return common::make_unique<
        non_recursive_verificator::OfEventPayload
      >(
        instance
      );
    case types::ModelType::kBasicEventElement:
      return common::make_unique<
        non_recursive_verificator::OfBasicEventElement
      >(
        instance
      );
    case types::ModelType::kOperation:
      return common::make_unique<
        non_recursive_verificator::OfOperation
      >(
        instance
      );
    case types::ModelType::kOperationVariable:
      return common::make_unique<
        non_recursive_verificator::OfOperationVariable
      >(
        instance
      );
    case types::ModelType::kCapability:
      return common::make_unique<
        non_recursive_verificator::OfCapability
      >(
        instance
      );
    case types::ModelType::kConceptDescription:
      return common::make_unique<
        non_recursive_verificator::OfConceptDescription
      >(
        instance
      );
    case types::ModelType::kReference:
      return common::make_unique<
        non_recursive_verificator::OfReference
      >(
        instance
      );
    case types::ModelType::kKey:
      return common::make_unique<
        non_recursive_verificator::OfKey
      >(
        instance
      );
    case types::ModelType::kLangStringNameType:
      return common::make_unique<
        non_recursive_verificator::OfLangStringNameType
      >(
        instance
      );
    case types::ModelType::kLangStringTextType:
      return common::make_unique<
        non_recursive_verificator::OfLangStringTextType
      >(
        instance
      );
    case types::ModelType::kEnvironment:
      return common::make_unique<
        non_recursive_verificator::OfEnvironment
      >(
        instance
      );
    case types::ModelType::kEmbeddedDataSpecification:
      return common::make_unique<
        non_recursive_verificator::OfEmbeddedDataSpecification
      >(
        instance
      );
    case types::ModelType::kLevelType:
      return common::make_unique<
        non_recursive_verificator::OfLevelType
      >(
        instance
      );
    case types::ModelType::kValueReferencePair:
      return common::make_unique<
        non_recursive_verificator::OfValueReferencePair
      >(
        instance
      );
    case types::ModelType::kValueList:
      return common::make_unique<
        non_recursive_verificator::OfValueList
      >(
        instance
      );
    case types::ModelType::kLangStringPreferredNameTypeIec61360:
      return common::make_unique<
        non_recursive_verificator::OfLangStringPreferredNameTypeIec61360
      >(
        instance
      );
    case types::ModelType::kLangStringShortNameTypeIec61360:
      return common::make_unique<
        non_recursive_verificator::OfLangStringShortNameTypeIec61360
      >(
        instance
      );
    case types::ModelType::kLangStringDefinitionTypeIec61360:
      return common::make_unique<
        non_recursive_verificator::OfLangStringDefinitionTypeIec61360
      >(
        instance
      );
    case types::ModelType::kDataSpecificationIec61360:
      return common::make_unique<
        non_recursive_verificator::OfDataSpecificationIec61360
      >(
        instance
      );
    default:
      throw std::logic_error(
        common::Concat(
          "Unexpected model type: ",
          std::to_string(
            static_cast<std::uint32_t>(instance->model_type())
          )
        )
      );
  }
}

// endregion Non-recursive verificators

// region Recursive verificators

class RecursiveVerificator : public impl::IVerificator {
 public:
  RecursiveVerificator(
    const std::shared_ptr<types::IClass>& instance
  );

  RecursiveVerificator(const RecursiveVerificator& other);
  RecursiveVerificator(RecursiveVerificator&& other);
  RecursiveVerificator& operator=(const RecursiveVerificator& other);
  RecursiveVerificator& operator=(RecursiveVerificator&& other);

  void Start() override;
  void Next() override;
  bool Done() const override;
  const Error& Get() const override;
  Error& GetMutable() override;
  long Index() const override;

  std::unique_ptr<impl::IVerificator> Clone() const override;

  ~RecursiveVerificator() override = default;

 private:
  // NOTE(mristin):
  // We use a pointer to a shared pointer here so that we can implement
  // copy-assignment and move-assignment. Otherwise, if we used a constant
  // reference here, the assignments could not be implemented as C++ does not
  // allow re-binding of constant references.
  const std::shared_ptr<types::IClass>* instance_;

  std::uint32_t state_;
  std::unique_ptr<impl::IVerificator> verificator_;
  bool done_;
  long index_;
  std::unique_ptr<Error> error_;
  common::optional<iteration::Iterator> iterator_;
  common::optional<iteration::Iterator> iterator_end_;

  void Execute();
};  // class RecursiveVerificator

RecursiveVerificator::RecursiveVerificator(
  const std::shared_ptr<types::IClass>& instance
) : instance_(&instance) {
  // Intentionally empty.
}

RecursiveVerificator::RecursiveVerificator(const RecursiveVerificator& other) {
  instance_ = other.instance_;
  state_ = other.state_;
  verificator_ = other.verificator_->Clone();
  done_ = other.done_;
  index_ = other.index_;
  error_ = common::make_unique<Error>(*(other.error_));
  iterator_ = other.iterator_;
  iterator_end_ = other.iterator_end_;
}

RecursiveVerificator::RecursiveVerificator(RecursiveVerificator&& other) {
  instance_ = other.instance_;
  state_ = other.state_;
  verificator_ = std::move(other.verificator_);
  done_ = other.done_;
  index_ = other.index_;
  error_ = std::move(other.error_);
  iterator_ = std::move(other.iterator_);
  iterator_end_ = std::move(other.iterator_end_);
}

RecursiveVerificator& RecursiveVerificator::operator=(
  const RecursiveVerificator& other
) {
  return *this = RecursiveVerificator(other);
}

RecursiveVerificator& RecursiveVerificator::operator=(RecursiveVerificator&& other) {
  if (this != &other) {
    instance_ = other.instance_;
    state_ = other.state_;
    verificator_ = std::move(other.verificator_);
    done_ = other.done_;
    index_ = other.index_;
    error_ = std::move(other.error_);
    iterator_ = std::move(other.iterator_);
    iterator_end_ = std::move(other.iterator_end_);
  }

  return *this;
}

void RecursiveVerificator::Start() {
  state_ = 0;
  Execute();
}

void RecursiveVerificator::Next() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a RecursiveVerificator, "
      "but the verificator was done."
    );
  }
  #endif

  Execute();
}

bool RecursiveVerificator::Done() const {
  return done_;
}

const Error& RecursiveVerificator::Get() const {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get from a RecursiveVerificator, "
      "but the verificator is done."
    );
  }
  #endif

  return *error_;
}

Error& RecursiveVerificator::GetMutable() {
  #ifdef DEBUG
  if (Done()) {
    throw std::logic_error(
      "You want to get mutable from a RecursiveVerificator, "
      "but the verificator is done."
    );
  }
  #endif

  return *error_;
}

long RecursiveVerificator::Index() const {
  #ifdef DEBUG
  if (Done() && index_ != -1) {
    throw std::logic_error(
      common::Concat(
        "Expected index to be -1 "
        "from a done RecursiveVerificator, "
        "but got: ",
        std::to_string(index_)
      )
    );
  }
  #endif

  return index_;
}

std::unique_ptr<impl::IVerificator> RecursiveVerificator::Clone() const {
  return common::make_unique<RecursiveVerificator>(*this);
}

void RecursiveVerificator::Execute() {
  while (true) {
    switch (state_) {
      case 0: {
        error_ = nullptr;
        index_ = -1;
        done_ = false;

        verificator_ = NewNonRecursiveVerificator(*instance_);
        verificator_->Start();
      }

      case 1: {
        if (!(!verificator_->Done())) {
          state_ = 3;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            verificator_->GetMutable()
          )
        );
        // No path is prepended as the error refers to the instance itself.
        ++index_;

        state_ = 2;
        return;
      }

      case 2: {
        verificator_->Next();

        state_ = 1;
        continue;
      }

      case 3: {
        verificator_ = nullptr;

        {
          // NOTE (mristin):
          // We will not need descent, so we introduce it in the scope.
          iteration::Descent descent(
            *instance_
          );
          iterator_ = std::move(descent.begin());

          // NOTE (mristin):
          // descent.end() is a constant reference, so we make an explicit
          // copy here.
          iterator_end_ = descent.end();
        }
      }

      case 4: {
        if (!(*iterator_ != *iterator_end_)) {
          state_ = 8;
          continue;
        }

        verificator_ = NewNonRecursiveVerificator(
          *(*iterator_)
        );
        verificator_->Start();
      }

      case 5: {
        if (!(!verificator_->Done())) {
          state_ = 7;
          continue;
        }

        // We intentionally take over the ownership of the errors' data members,
        // as we know the implementation in all the detail, and want to avoid a costly
        // copy.
        error_ = common::make_unique<Error>(
          std::move(
            verificator_->GetMutable()
          )
        );

        error_->path = std::move(
          iteration::MaterializePath(
            *iterator_
          )
        );

        ++index_;

        state_ = 6;
        return;
      }

      case 6: {
        verificator_->Next();

        state_ = 5;
        continue;
      }

      case 7: {
        verificator_ = nullptr;

        ++(*iterator_);

        state_ = 4;
        continue;
      }

      case 8: {
        iterator_.reset();
        iterator_end_.reset();
        done_ = true;
        index_ = -1;

        // We invalidate the state since we reached the end of the routine.
        state_ = 9;
        return;
      }

      default:
        throw std::logic_error(
          common::Concat(
            "Invalid state_: ",
            std::to_string(state_)
          )
        );
    }
  }
}

// endregion Recursive verificators

// region NonRecursiveVerification

NonRecursiveVerification::NonRecursiveVerification(
  const std::shared_ptr<types::IClass>& instance
) : instance_(instance) {
  // Intentionally empty.
}

Iterator NonRecursiveVerification::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    NewNonRecursiveVerificator(instance_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& NonRecursiveVerification::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion NonRecursiveVerification

// region RecursiveVerification

RecursiveVerification::RecursiveVerification(
  const std::shared_ptr<types::IClass>& instance
) : instance_(instance) {
  // Intentionally empty.
}

Iterator RecursiveVerification::begin() const {
  std::unique_ptr<impl::IVerificator> verificator(
    common::make_unique<RecursiveVerificator>(instance_)
  );

  verificator->Start();

  // NOTE(mristin):
  // We short-circuit here for efficiency, as we can immediately dispose
  // of the verificator.
  if (verificator->Done()) {
    return Iterator(common::make_unique<AlwaysDoneVerificator>());
  }

  return Iterator(std::move(verificator));
}

const Iterator& RecursiveVerification::end() const {
  static Iterator iterator(common::make_unique<AlwaysDoneVerificator>());
  return iterator;
}

// endregion RecursiveVerification

// region struct Iterator

Iterator::Iterator(
  const Iterator& other
) :
  verificator_(other.verificator_->Clone()) {
  // Intentionally empty.
}

Iterator::Iterator(
  Iterator&& other
) :
  verificator_(std::move(other.verificator_)) {
  // Intentionally empty.
}

Iterator& Iterator::operator=(const Iterator& other) {
  return *this = Iterator(other);
}

Iterator& Iterator::operator=(Iterator&& other) {
  if (this != &other) {
    verificator_ = std::move(other.verificator_);
  }

  return *this;
}

const Error& Iterator::operator*() const {
  if (verificator_->Done()) {
    throw std::logic_error(
      "You want to de-reference from a completed iterator "
      "over verification errors."
    );
  }

  return verificator_->Get();
}

const Error* Iterator::operator->() const {
  if (verificator_->Done()) {
    throw std::logic_error(
      "You want to de-reference from a completed iterator "
      "over verification errors."
    );
  }

  return &(verificator_->Get());
}

// Prefix increment
Iterator& Iterator::operator++() {
  if (verificator_->Done()) {
    throw std::logic_error(
      "You want to move a completed iterator "
      "over verification errors."
    );
  }

  verificator_->Next();
  return *this;
}

// Postfix increment
Iterator Iterator::operator++(int) {
  Iterator result(*this);
  ++(*this);
  return result;
}

bool operator==(const Iterator& a, const Iterator& b) {
  return a.verificator_->Index() == b.verificator_->Index();
}

bool operator!=(const Iterator& a, const Iterator& b) {
  return a.verificator_->Index() != b.verificator_->Index();
}

// endregion struct Iterator

}  // namespace verification
}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.
