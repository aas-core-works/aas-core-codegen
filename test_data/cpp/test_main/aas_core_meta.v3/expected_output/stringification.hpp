#ifndef AAS_CORE_AAS_3_0_STRINGIFICATION_GUARD_
#define AAS_CORE_AAS_3_0_STRINGIFICATION_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"
#include "aas_core/aas_3_0/types.hpp"

#pragma warning(push, 0)
#include <string>
#include <vector>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup stringification Translate to strings, and, where applicable, from strings.
 * @{
 */
namespace stringification {

/**
 * Try to parse the \p text as a model type literal.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::ModelType> ModelTypeFromString(
  const std::string& text
);

/**
 * Parse the \p text as a model type literal.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::ModelType MustModelTypeFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p model_type to text.
 *
 * \param model_type to be converted into text
 * \return text representation of \p model_type
 * \throw std::invalid_argument if \p model_type invalid
 */
std::string to_string(
  types::ModelType model_type
);

/**
 * Try to parse the \p text as a literal of
 * types::ModellingKind.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::ModellingKind> ModellingKindFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::ModellingKind.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::ModellingKind MustModellingKindFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::ModellingKind to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::ModellingKind literal
);

/**
 * Try to parse the \p text as a literal of
 * types::QualifierKind.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::QualifierKind> QualifierKindFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::QualifierKind.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::QualifierKind MustQualifierKindFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::QualifierKind to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::QualifierKind literal
);

/**
 * Try to parse the \p text as a literal of
 * types::AssetKind.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::AssetKind> AssetKindFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::AssetKind.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::AssetKind MustAssetKindFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::AssetKind to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::AssetKind literal
);

/**
 * Try to parse the \p text as a literal of
 * types::AasSubmodelElements.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::AasSubmodelElements> AasSubmodelElementsFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::AasSubmodelElements.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::AasSubmodelElements MustAasSubmodelElementsFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::AasSubmodelElements to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::AasSubmodelElements literal
);

/**
 * Try to parse the \p text as a literal of
 * types::EntityType.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::EntityType> EntityTypeFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::EntityType.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::EntityType MustEntityTypeFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::EntityType to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::EntityType literal
);

/**
 * Try to parse the \p text as a literal of
 * types::Direction.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::Direction> DirectionFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::Direction.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::Direction MustDirectionFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::Direction to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::Direction literal
);

/**
 * Try to parse the \p text as a literal of
 * types::StateOfEvent.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::StateOfEvent> StateOfEventFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::StateOfEvent.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::StateOfEvent MustStateOfEventFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::StateOfEvent to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::StateOfEvent literal
);

/**
 * Try to parse the \p text as a literal of
 * types::ReferenceTypes.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::ReferenceTypes> ReferenceTypesFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::ReferenceTypes.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::ReferenceTypes MustReferenceTypesFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::ReferenceTypes to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::ReferenceTypes literal
);

/**
 * Try to parse the \p text as a literal of
 * types::KeyTypes.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::KeyTypes> KeyTypesFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::KeyTypes.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::KeyTypes MustKeyTypesFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::KeyTypes to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::KeyTypes literal
);

/**
 * Try to parse the \p text as a literal of
 * types::DataTypeDefXsd.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::DataTypeDefXsd> DataTypeDefXsdFromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::DataTypeDefXsd.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::DataTypeDefXsd MustDataTypeDefXsdFromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::DataTypeDefXsd to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::DataTypeDefXsd literal
);

/**
 * Try to parse the \p text as a literal of
 * types::DataTypeIec61360.
 *
 * \param text to be parsed
 * \return literal, or nothing, if \p text invalid
 */ 
common::optional<types::DataTypeIec61360> DataTypeIec61360FromString(
  const std::string& text
);

/**
 * Parse the \p text as a literal of
 * types::DataTypeIec61360.
 *
 * \param text to be parsed
 * \return literal
 * \throw std::invalid_argument if \p text invalid
 */
types::DataTypeIec61360 MustDataTypeIec61360FromString(
  const std::string& text
);

/**
 * Translate the enumeration literal \p literal
 * of types::DataTypeIec61360 to text.
 *
 * \param literal to be converted into text
 * \return text representation of \p literal
 * \throw std::invalid_argument if \p literal invalid
 */
std::string to_string(
  types::DataTypeIec61360 literal
);

/**
 * Encode the \p bytes with base64 to a std::string.
 *
 * \param bytes to be encoded
 * \return base64-encoding of \p bytes
 */
std::string Base64Encode(
  const std::vector<std::uint8_t>& bytes
);

/**
 * Decode the \p the text with base64 to bytes. 
 *
 * \remark \parblock
 * We intentionally decode from std::string and *not* from std::wstring as
 * the de/serialization libraries currently work only with UTF-8 encoded strings.
 * \endparblock
 *
 * \param text to be decoded
 * \return decoded bytes, or error message, if any.
 */
common::expected<
  std::vector<std::uint8_t>,
  std::string
> Base64Decode(
  const std::string& text
);

}  // namespace stringification
}  // namespace aas_3_0
}  // namespace aas_core

/**@}*/

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_STRINGIFICATION_GUARD_
