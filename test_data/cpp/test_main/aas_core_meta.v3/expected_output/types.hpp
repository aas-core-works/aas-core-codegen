#ifndef AAS_CORE_AAS_3_0_TYPES_GUARD_
#define AAS_CORE_AAS_3_0_TYPES_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#include "aas_core/aas_3_0/common.hpp"

#pragma warning(push, 0)
#include <cstddef>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup types Define data structures corresponding to the meta-model.
 * @{
 */
namespace types {

// region Enumerations

/**
 * Enumerate the model types for faster type switches.
 *
 * For example, switch statements can be implemented as jump tables.
 */
enum class ModelType : std::uint32_t {
  kExtension = 0,
  kAdministrativeInformation = 1,
  kQualifier = 2,
  kAssetAdministrationShell = 3,
  kAssetInformation = 4,
  kResource = 5,
  kSpecificAssetId = 6,
  kSubmodel = 7,
  kRelationshipElement = 8,
  kSubmodelElementList = 9,
  kSubmodelElementCollection = 10,
  kProperty = 11,
  kMultiLanguageProperty = 12,
  kRange = 13,
  kReferenceElement = 14,
  kBlob = 15,
  kFile = 16,
  kAnnotatedRelationshipElement = 17,
  kEntity = 18,
  kEventPayload = 19,
  kBasicEventElement = 20,
  kOperation = 21,
  kOperationVariable = 22,
  kCapability = 23,
  kConceptDescription = 24,
  kReference = 25,
  kKey = 26,
  kLangStringNameType = 27,
  kLangStringTextType = 28,
  kEnvironment = 29,
  kEmbeddedDataSpecification = 30,
  kLevelType = 31,
  kValueReferencePair = 32,
  kValueList = 33,
  kLangStringPreferredNameTypeIec61360 = 34,
  kLangStringShortNameTypeIec61360 = 35,
  kLangStringDefinitionTypeIec61360 = 36,
  kDataSpecificationIec61360 = 37
};

/// \brief Enumeration for denoting whether an element is a template or an instance.
enum class ModellingKind : std::uint32_t {
  /// \brief Specification of the common features of a structured element in sufficient detail
  /// that such a instance can be instantiated using it
  kTemplate = 0,
  /// \brief Concrete, clearly identifiable element instance. Its creation and validation
  /// may be guided by a corresponding element template.
  kInstance = 1,
};  // enum class ModellingKind

/// \brief Enumeration for kinds of qualifiers.
///
/// \note This element is experimental and therefore may be subject to change or may be
/// removed completely in future versions of the meta-model.
enum class QualifierKind : std::uint32_t {
  /// \brief qualifies the value of the element and can change during run-time.
  ///
  /// Value qualifiers are only applicable to elements with kind
  /// ModellingKind::kInstance.
  kValueQualifier = 0,
  /// \brief qualifies the semantic definition the element is referring to
  /// (IHasSemantics::semantic_id)
  kConceptQualifier = 1,
  /// \brief qualifies the elements within a specific submodel on concept level.
  ///
  /// Template qualifiers are only applicable to elements with kind
  /// ModellingKind::kTemplate.
  kTemplateQualifier = 2,
};  // enum class QualifierKind

/// \brief Enumeration for denoting whether an asset is a type asset or an instance asset.
enum class AssetKind : std::uint32_t {
  /// \brief Type asset
  kType = 0,
  /// \brief Instance asset
  kInstance = 1,
  /// \brief Neither a type asset nor an instance asset
  kNotApplicable = 2,
};  // enum class AssetKind

/// \brief Enumeration of all possible elements of a ISubmodelElementList.
enum class AasSubmodelElements : std::uint32_t {
  kAnnotatedRelationshipElement = 0,
  kBasicEventElement = 1,
  kBlob = 2,
  kCapability = 3,
  kDataElement = 4,
  kEntity = 5,
  kEventElement = 6,
  kFile = 7,
  kMultiLanguageProperty = 8,
  kOperation = 9,
  kProperty = 10,
  kRange = 11,
  kReferenceElement = 12,
  kRelationshipElement = 13,
  kSubmodelElement = 14,
  kSubmodelElementList = 15,
  kSubmodelElementCollection = 16,
};  // enum class AasSubmodelElements

/// \brief Enumeration for denoting whether an entity is a self-managed entity or a co-managed
/// entity.
enum class EntityType : std::uint32_t {
  /// \brief For co-managed entities there is no separate AAS. Co-managed entities need to be
  /// part of a self-managed entity.
  kCoManagedEntity = 0,
  /// \brief Self-Managed Entities have their own AAS but can be part of the bill of material of
  /// a composite self-managed entity.
  ///
  /// The asset of an I4.0 Component is a self-managed entity per definition.
  kSelfManagedEntity = 1,
};  // enum class EntityType

/// \brief Direction
///
/// \note This element is experimental and therefore may be subject to change or may be
/// removed completely in future versions of the meta-model.
enum class Direction : std::uint32_t {
  /// \brief Input direction.
  kInput = 0,
  /// \brief Output direction
  kOutput = 1,
};  // enum class Direction

/// \brief State of an event
///
/// \note This element is experimental and therefore may be subject to change or may be
/// removed completely in future versions of the meta-model.
enum class StateOfEvent : std::uint32_t {
  /// \brief Event is on
  kOn = 0,
  /// \brief Event is off.
  kOff = 1,
};  // enum class StateOfEvent

/// \brief Reference types
enum class ReferenceTypes : std::uint32_t {
  /// \brief External reference.
  kExternalReference = 0,
  /// \brief Model reference.
  kModelReference = 1,
};  // enum class ReferenceTypes

/// \brief Enumeration of different key value types within a key.
enum class KeyTypes : std::uint32_t {
  kAnnotatedRelationshipElement = 0,
  kAssetAdministrationShell = 1,
  kBasicEventElement = 2,
  kBlob = 3,
  kCapability = 4,
  kConceptDescription = 5,
  /// \brief Data element.
  ///
  /// \note Data Element is abstract, *i.e.* if a key uses KeyTypes::kDataElement
  /// the reference may be a Property, a File etc.
  kDataElement = 6,
  kEntity = 7,
  /// \brief Event.
  ///
  /// \note IEventElement is abstract.
  kEventElement = 8,
  kFile = 9,
  /// \brief Bookmark or a similar local identifier of a subordinate part of
  /// a primary resource
  kFragmentReference = 10,
  kGlobalReference = 11,
  /// \brief Identifiable.
  ///
  /// \note Identifiable is abstract, i.e. if a key uses “Identifiable” the reference
  /// may be an Asset Administration Shell, a Submodel or a Concept Description.
  kIdentifiable = 12,
  /// \brief Property with a value that can be provided in multiple languages
  kMultiLanguageProperty = 13,
  kOperation = 14,
  kProperty = 15,
  /// \brief Range with min and max
  kRange = 16,
  kReferable = 17,
  /// \brief Reference
  kReferenceElement = 18,
  /// \brief Relationship
  kRelationshipElement = 19,
  kSubmodel = 20,
  /// \brief Submodel Element
  ///
  /// \note Submodel Element is abstract, *i.e.* if a key uses KeyTypes::kSubmodelElement
  /// the reference may be a IProperty, an IOperation etc.
  kSubmodelElement = 21,
  /// \brief Struct of Submodel Elements
  kSubmodelElementCollection = 22,
  /// \brief List of Submodel Elements
  kSubmodelElementList = 23,
};  // enum class KeyTypes

/// \brief Enumeration listing all XSD anySimpleTypes
enum class DataTypeDefXsd : std::uint32_t {
  kAnyUri = 0,
  kBase64Binary = 1,
  kBoolean = 2,
  kByte = 3,
  kDate = 4,
  kDateTime = 5,
  kDecimal = 6,
  kDouble = 7,
  kDuration = 8,
  kFloat = 9,
  kGDay = 10,
  kGMonth = 11,
  kGMonthDay = 12,
  kGYear = 13,
  kGYearMonth = 14,
  kHexBinary = 15,
  kInt = 16,
  kInteger = 17,
  kLong = 18,
  kNegativeInteger = 19,
  kNonNegativeInteger = 20,
  kNonPositiveInteger = 21,
  kPositiveInteger = 22,
  kShort = 23,
  kString = 24,
  kTime = 25,
  kUnsignedByte = 26,
  kUnsignedInt = 27,
  kUnsignedLong = 28,
  kUnsignedShort = 29,
};  // enum class DataTypeDefXsd

enum class DataTypeIec61360 : std::uint32_t {
  /// \brief values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
  /// Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
  /// "31 May 1999".
  kDate = 0,
  /// \brief values consisting of sequence of characters but cannot be translated into other
  /// languages
  kString = 1,
  /// \brief values containing string but shall be represented as different string in different
  /// languages
  kStringTranslatable = 2,
  /// \brief values containing values that are measure of type INTEGER. In addition such a value
  /// comes with a physical unit.
  kIntegerMeasure = 3,
  /// \brief values containing values of type INTEGER but are no currencies or measures
  kIntegerCount = 4,
  /// \brief values containing values of type INTEGER that are currencies
  kIntegerCurrency = 5,
  /// \brief values containing values that are measures of type REAL. In addition such a value
  /// comes with a physical unit.
  kRealMeasure = 6,
  /// \brief values containing numbers that can be written as a terminating or non-terminating
  /// decimal; a rational or irrational number but are no currencies or measures
  kRealCount = 7,
  /// \brief values containing values of type REAL that are currencies
  kRealCurrency = 8,
  /// \brief values representing truth of logic or Boolean algebra (TRUE, FALSE)
  kBoolean = 9,
  /// \brief values containing values of type STRING conformant to Rfc 3987
  ///
  /// \note In IEC61360-1 (2017) only URI is supported.
  /// An IRI type allows in particular to express an URL or an URI.
  kIri = 10,
  /// \brief values conforming to ISO/IEC 11179 series global identifier sequences
  ///
  /// IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.
  ///
  /// ICID values are value conformant to an IRDI, where the delimiter between RAI and ID
  /// is “#” while the delimiter between DI and VI is confined to “##”
  ///
  /// ISO29002_IRDI values are values containing a global identifier that identifies an
  /// administrated item in a registry. The structure of this identifier complies with
  /// identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the
  /// requirements specified in ISO/TS 29002-5 for an "international registration data
  /// identifier" (IRDI).
  kIrdi = 11,
  /// \brief values containing values of type rational
  kRational = 12,
  /// \brief values containing values of type rational. In addition such a value comes with a
  /// physical unit.
  kRationalMeasure = 13,
  /// \brief values containing a time, conformant to ISO 8601:2004 but restricted to what is
  /// allowed in the corresponding type in xml.
  ///
  /// Format hh:mm (ECLASS)
  ///
  /// Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME] representation of:
  /// 1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated
  /// Universal Time (UTC).
  kTime = 14,
  /// \brief values containing a time, conformant to ISO 8601:2004 but restricted to what is
  /// allowed in the corresponding type in xml.
  ///
  /// Format yyyy-mm-dd hh:mm (ECLASS)
  kTimestamp = 15,
  /// \brief values containing an address to a file. The values are of type URI and can represent
  /// an absolute or relative path.
  ///
  /// \note IEC61360 does not support the file type.
  kFile = 16,
  /// \brief Values containing string with any sequence of characters, using the syntax of HTML5
  /// (see W3C Recommendation 28:2014)
  kHtml = 17,
  /// \brief values containing the content of a file. Values may be binaries.
  ///
  /// HTML conformant to HTML5 is a special blob.
  ///
  /// In IEC61360 binary is for a sequence of bits, each bit being represented by “0” and
  /// “1” only. A binary is a blob but a blob may also contain other source code.
  kBlob = 18,
};  // enum class DataTypeIec61360

// endregion Enumerations

// region Forward declaration of interfaces

// endregion Forward declaration of interfaces

class IHasSemantics;

class IExtension;

class IHasExtensions;

class IReferable;

class IIdentifiable;

class IHasKind;

class IHasDataSpecification;

class IAdministrativeInformation;

class IQualifiable;

class IQualifier;

class IAssetAdministrationShell;

class IAssetInformation;

class IResource;

class ISpecificAssetId;

class ISubmodel;

class ISubmodelElement;

class IRelationshipElement;

class ISubmodelElementList;

class ISubmodelElementCollection;

class IDataElement;

class IProperty;

class IMultiLanguageProperty;

class IRange;

class IReferenceElement;

class IBlob;

class IFile;

class IAnnotatedRelationshipElement;

class IEntity;

class IEventPayload;

class IEventElement;

class IBasicEventElement;

class IOperation;

class IOperationVariable;

class ICapability;

class IConceptDescription;

class IReference;

class IKey;

class IAbstractLangString;

class ILangStringNameType;

class ILangStringTextType;

class IEnvironment;

class IDataSpecificationContent;

class IEmbeddedDataSpecification;

class ILevelType;

class IValueReferencePair;

class IValueList;

class ILangStringPreferredNameTypeIec61360;

class ILangStringShortNameTypeIec61360;

class ILangStringDefinitionTypeIec61360;

class IDataSpecificationIec61360;

// region Class interfaces

/**
 * Model the most general instance of the model.
 */
class IClass {
 public:
  /**
   * Indicate the runtime model type.
   */
  virtual ModelType model_type() const = 0;
  virtual ~IClass() = default;
};

/// \brief Element that can have a semantic definition plus some supplemental semantic
/// definitions.
///
/// Constraint AASd-118:\n
/// If there are ID IHasSemantics::supplemental_semantic_ids defined
/// then there shall be also a main semantic ID IHasSemantics::semantic_id.
class IHasSemantics
    : virtual public IClass {
 public:
  ///@{
  /// \brief Identifier of the semantic definition of the element. It is called semantic ID
  /// of the element or also main semantic ID of the element.
  ///
  /// \note It is recommended to use a global reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() = 0;

  virtual void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Identifier of a supplemental semantic definition of the element.
  /// It is called supplemental semantic ID of the element.
  ///
  /// \note It is recommended to use a global reference.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() = 0;

  virtual void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IHasSemantics() = default;
};

/// \brief Single extension of an element.
class IExtension
    : virtual public IHasSemantics {
 public:
  ///@{
  /// \brief Name of the extension.

  virtual const std::wstring& name() const = 0;

  virtual std::wstring& mutable_name() = 0;

  virtual void set_name(
    std::wstring value
  ) = 0;

  ///@}

  ///@{
  /// \brief Type of the value of the extension.
  ///
  /// Default: DataTypeDefXsd::kString

  virtual const common::optional<DataTypeDefXsd>& value_type() const = 0;

  virtual common::optional<DataTypeDefXsd>& mutable_value_type() = 0;

  virtual void set_value_type(
    common::optional<DataTypeDefXsd> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Value of the extension

  virtual const common::optional<std::wstring>& value() const = 0;

  virtual common::optional<std::wstring>& mutable_value() = 0;

  virtual void set_value(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Reference to an element the extension refers to.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& refers_to() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_refers_to() = 0;

  virtual void set_refers_to(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) = 0;

  ///@}

  virtual DataTypeDefXsd ValueTypeOrDefault() const = 0;

  virtual ~IExtension() = default;
};

/// \brief Element that can be extended by proprietary extensions.
///
/// \note Extensions are proprietary, i.e. they do not support global interoperability.
class IHasExtensions
    : virtual public IClass {
 public:
  ///@{
  /// \brief An extension of the element.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() = 0;

  virtual void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IHasExtensions() = default;
};

/// \brief An element that is referable by its IReferable::id_short.
///
/// This ID is not globally unique.
/// This ID is unique within the name space of the element.
///
/// Constraint AASd-022:\n
/// IReferable::id_short of non-identifiable referables
/// within the same name space shall be unique (case-sensitive).
class IReferable
    : virtual public IHasExtensions {
 public:
  ///@{
  /// \brief The category is a value that gives further meta information
  /// w.r.t. to the class of the element.
  /// It affects the expected existence of attributes and the applicability of
  /// constraints.
  ///
  /// \note The category is not identical to the semantic definition
  /// (IHasSemantics) of an element. The category e.g. could denote that
  /// the element is a measurement value whereas the semantic definition of
  /// the element would denote that it is the measured temperature.

  virtual const common::optional<std::wstring>& category() const = 0;

  virtual common::optional<std::wstring>& mutable_category() = 0;

  virtual void set_category(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief In case of identifiables this attribute is a short name of the element.
  /// In case of referable this ID is an identifying string of the element within
  /// its name space.
  ///
  /// \note In case the element is a property and the property has a semantic definition
  /// (IHasSemantics::semantic_id) conformant to IEC61360
  /// the IReferable::id_short is typically identical to the short name in English.

  virtual const common::optional<std::wstring>& id_short() const = 0;

  virtual common::optional<std::wstring>& mutable_id_short() = 0;

  virtual void set_id_short(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Display name. Can be provided in several languages.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() = 0;

  virtual void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Description or comments on the element.
  ///
  /// The description can be provided in several languages.
  ///
  /// If no description is defined, then the definition of the concept
  /// description that defines the semantics of the element is used.
  ///
  /// Additional information can be provided, e.g., if the element is
  /// qualified and which qualifier types can be expected in which
  /// context or which additional data specification templates are
  /// provided.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() = 0;

  virtual void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IReferable() = default;
};

/// \brief An element that has a globally unique identifier.
class IIdentifiable
    : virtual public IReferable {
 public:
  ///@{
  /// \brief Administrative information of an identifiable element.
  ///
  /// \note Some of the administrative information like the version number might need to
  /// be part of the identification.

  virtual const common::optional<
    std::shared_ptr<IAdministrativeInformation>
  >& administration() const = 0;

  virtual common::optional<
    std::shared_ptr<IAdministrativeInformation>
  >& mutable_administration() = 0;

  virtual void set_administration(
    common::optional<
      std::shared_ptr<IAdministrativeInformation>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief The globally unique identification of the element.

  virtual const std::wstring& id() const = 0;

  virtual std::wstring& mutable_id() = 0;

  virtual void set_id(
    std::wstring value
  ) = 0;

  ///@}

  virtual ~IIdentifiable() = default;
};

/// \brief An element with a kind is an element that can either represent a template or an
/// instance.
///
/// Default for an element is that it is representing an instance.
class IHasKind
    : virtual public IClass {
 public:
  ///@{
  /// \brief Kind of the element: either type or instance.
  ///
  /// Default: ModellingKind::kInstance

  virtual const common::optional<ModellingKind>& kind() const = 0;

  virtual common::optional<ModellingKind>& mutable_kind() = 0;

  virtual void set_kind(
    common::optional<ModellingKind> value
  ) = 0;

  ///@}

  virtual ModellingKind KindOrDefault() const = 0;

  virtual ~IHasKind() = default;
};

/// \brief Element that can be extended by using data specification templates.
///
/// A data specification template defines a named set of additional attributes an
/// element may or shall have. The data specifications used are explicitly specified
/// with their global ID.
class IHasDataSpecification
    : virtual public IClass {
 public:
  ///@{
  /// \brief Embedded data specification.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() = 0;

  virtual void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IHasDataSpecification() = default;
};

/// \brief Administrative meta-information for an element like version
/// information.
///
/// Constraint AASd-005:\n
/// If IAdministrativeInformation::version is not specified then also IAdministrativeInformation::revision shall be
/// unspecified. This means, a revision requires a version. If there is no version
/// there is no revision neither. Revision is optional.
class IAdministrativeInformation
    : virtual public IHasDataSpecification {
 public:
  ///@{
  /// \brief Version of the element.

  virtual const common::optional<std::wstring>& version() const = 0;

  virtual common::optional<std::wstring>& mutable_version() = 0;

  virtual void set_version(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Revision of the element.

  virtual const common::optional<std::wstring>& revision() const = 0;

  virtual common::optional<std::wstring>& mutable_revision() = 0;

  virtual void set_revision(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief The subject ID of the subject responsible for making the element.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& creator() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_creator() = 0;

  virtual void set_creator(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Identifier of the template that guided the creation of the element.
  ///
  /// \note In case of a submodel the IAdministrativeInformation::template_id is the identifier
  /// of the submodel template ID that guided the creation of the submodel
  ///
  /// \note The IAdministrativeInformation::template_id is not relevant for validation in Submodels.
  /// For validation the ISubmodel::semantic_id shall be used.
  ///
  /// \note Usage of IAdministrativeInformation::template_id is not restricted to submodel instances. So also
  /// the creation of submodel templates can be guided by another submodel template.

  virtual const common::optional<std::wstring>& template_id() const = 0;

  virtual common::optional<std::wstring>& mutable_template_id() = 0;

  virtual void set_template_id(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  virtual ~IAdministrativeInformation() = default;
};

/// \brief The value of a qualifiable element may be further qualified by one or more
/// qualifiers.
///
/// Constraint AASd-119:\n
/// If any IQualifier::kind value of IQualifiable::qualifiers is
/// equal to QualifierKind::kTemplateQualifier and the qualified element
/// inherits from IHasKind then the qualified element shall be of
/// kind Template (IHasKind::kind = ModellingKind::kTemplate).
///
/// \note This constraint is checked at ISubmodel.
class IQualifiable
    : virtual public IClass {
 public:
  ///@{
  /// \brief Additional qualification of a qualifiable element.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() = 0;

  virtual void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IQualifiable() = default;
};

/// \brief A qualifier is a type-value-pair that makes additional statements w.r.t. the value
/// of the element.
///
/// Constraint AASd-006:\n
/// If both the IQualifier::value and the IQualifier::value_id of
/// a IQualifier are present then the IQualifier::value needs
/// to be identical to the value of the referenced coded value
/// in IQualifier::value_id.
///
/// Constraint AASd-020:\n
/// The value of IQualifier::value shall be consistent to the data type as
/// defined in IQualifier::value_type.
class IQualifier
    : virtual public IHasSemantics {
 public:
  ///@{
  /// \brief The qualifier kind describes the kind of the qualifier that is applied to the
  /// element.
  ///
  /// Default: QualifierKind::kConceptQualifier

  virtual const common::optional<QualifierKind>& kind() const = 0;

  virtual common::optional<QualifierKind>& mutable_kind() = 0;

  virtual void set_kind(
    common::optional<QualifierKind> value
  ) = 0;

  ///@}

  ///@{
  /// \brief The qualifier *type* describes the type of the qualifier that is applied to
  /// the element.

  virtual const std::wstring& type() const = 0;

  virtual std::wstring& mutable_type() = 0;

  virtual void set_type(
    std::wstring value
  ) = 0;

  ///@}

  ///@{
  /// \brief Data type of the qualifier value.

  virtual DataTypeDefXsd value_type() const = 0;

  virtual DataTypeDefXsd& mutable_value_type() = 0;

  virtual void set_value_type(
    DataTypeDefXsd value
  ) = 0;

  ///@}

  ///@{
  /// \brief The qualifier value is the value of the qualifier.

  virtual const common::optional<std::wstring>& value() const = 0;

  virtual common::optional<std::wstring>& mutable_value() = 0;

  virtual void set_value(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Reference to the global unique ID of a coded value.
  ///
  /// \note It is recommended to use a global reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& value_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_value_id() = 0;

  virtual void set_value_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  virtual QualifierKind KindOrDefault() const = 0;

  virtual ~IQualifier() = default;
};

/// \brief An asset administration shell.
class IAssetAdministrationShell
    : virtual public IIdentifiable,
    virtual public IHasDataSpecification {
 public:
  ///@{
  /// \brief The reference to the AAS the AAS was derived from.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& derived_from() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_derived_from() = 0;

  virtual void set_derived_from(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Meta-information about the asset the AAS is representing.

  virtual const std::shared_ptr<IAssetInformation>& asset_information() const = 0;

  virtual std::shared_ptr<IAssetInformation>& mutable_asset_information() = 0;

  virtual void set_asset_information(
    std::shared_ptr<IAssetInformation> value
  ) = 0;

  ///@}

  ///@{
  /// \brief References to submodels of the AAS.
  ///
  /// A submodel is a description of an aspect of the asset the AAS is representing.
  ///
  /// The asset of an AAS is typically described by one or more submodels.
  ///
  /// Temporarily no submodel might be assigned to the AAS.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& submodels() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_submodels() = 0;

  virtual void set_submodels(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IAssetAdministrationShell() = default;
};

/// \brief In IAssetInformation identifying meta data of the asset that is
/// represented by an AAS is defined.
///
/// The asset may either represent an asset type or an asset instance.
///
/// The asset has a globally unique identifier plus – if needed – additional domain
/// specific (proprietary) identifiers. However, to support the corner case of very
/// first phase of lifecycle where a stabilised/constant_set global asset identifier
/// does not already exist, the corresponding attribute IAssetInformation::global_asset_id is
/// optional.
///
/// Constraint AASd-116:\n
/// `globalAssetId` is a reserved key. If used as value for
/// ISpecificAssetId::name then ISpecificAssetId::value shall be
/// identical to IAssetInformation::global_asset_id.
///
/// \note Constraint AASd-116 is important to enable a generic search across
/// global and specific asset IDs.
///
/// \note \parblock
/// In the book, Constraint AASd-116 imposes a
/// case-insensitive equality against `globalAssetId`. This is
/// culturally-dependent, and depends on the system settings.
/// For example, the case-folding for the letters "i" and "I" is
/// different in Turkish from English.
///
/// We implement the constraint as case-sensitive instead to allow
/// for interoperability across different culture settings.
/// \endparblock
///
/// Constraint AASd-131:\n
/// For IAssetInformation either the IAssetInformation::global_asset_id shall be
/// defined or at least one item in IAssetInformation::specific_asset_ids.
class IAssetInformation
    : virtual public IClass {
 public:
  ///@{
  /// \brief Denotes whether the Asset is of kind AssetKind::kType or
  /// AssetKind::kInstance.

  virtual AssetKind asset_kind() const = 0;

  virtual AssetKind& mutable_asset_kind() = 0;

  virtual void set_asset_kind(
    AssetKind value
  ) = 0;

  ///@}

  ///@{
  /// \brief Global identifier of the asset the AAS is representing.
  ///
  /// This attribute is required as soon as the AAS is exchanged via partners in the life
  /// cycle of the asset. In a first phase of the life cycle the asset might not yet have
  /// a global ID but already an internal identifier. The internal identifier would be
  /// modelled via IAssetInformation::specific_asset_ids.
  ///
  /// \note This is a global reference.

  virtual const common::optional<std::wstring>& global_asset_id() const = 0;

  virtual common::optional<std::wstring>& mutable_global_asset_id() = 0;

  virtual void set_global_asset_id(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Additional domain-specific, typically proprietary identifier for the asset like
  /// e.g., serial number etc.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  >& specific_asset_ids() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  >& mutable_specific_asset_ids() = 0;

  virtual void set_specific_asset_ids(
    common::optional<
      std::vector<
        std::shared_ptr<ISpecificAssetId>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief In case IAssetInformation::asset_kind is applicable the IAssetInformation::asset_type is the asset ID
  /// of the type asset of the asset under consideration
  /// as identified by IAssetInformation::global_asset_id.
  ///
  /// \note In case IAssetInformation::asset_kind is "Instance" than the IAssetInformation::asset_type denotes
  /// which "Type" the asset is of. But it is also possible
  /// to have an IAssetInformation::asset_type of an asset of kind "Type".

  virtual const common::optional<std::wstring>& asset_type() const = 0;

  virtual common::optional<std::wstring>& mutable_asset_type() = 0;

  virtual void set_asset_type(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Thumbnail of the asset represented by the Asset Administration Shell.
  ///
  /// Used as default.

  virtual const common::optional<
    std::shared_ptr<IResource>
  >& default_thumbnail() const = 0;

  virtual common::optional<
    std::shared_ptr<IResource>
  >& mutable_default_thumbnail() = 0;

  virtual void set_default_thumbnail(
    common::optional<
      std::shared_ptr<IResource>
    > value
  ) = 0;

  ///@}

  virtual ~IAssetInformation() = default;
};

/// \brief Resource represents an address to a file (a locator). The value is an URI that
/// can represent an absolute or relative path
class IResource
    : virtual public IClass {
 public:
  ///@{
  /// \brief Path and name of the resource (with file extension).
  ///
  /// The path can be absolute or relative.

  virtual const std::wstring& path() const = 0;

  virtual std::wstring& mutable_path() = 0;

  virtual void set_path(
    std::wstring value
  ) = 0;

  ///@}

  ///@{
  /// \brief Content type of the content of the file.
  ///
  /// The content type states which file extensions the file can have.

  virtual const common::optional<std::wstring>& content_type() const = 0;

  virtual common::optional<std::wstring>& mutable_content_type() = 0;

  virtual void set_content_type(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  virtual ~IResource() = default;
};

/// \brief A specific asset ID describes a generic supplementary identifying attribute of the
/// asset.
///
/// The specific asset ID is not necessarily globally unique.
///
/// Constraint AASd-133:\n
/// ISpecificAssetId::external_subject_id shall be an external reference,
/// i.e. IReference::type = ReferenceTypes::kExternalReference.
class ISpecificAssetId
    : virtual public IHasSemantics {
 public:
  ///@{
  /// \brief Name of the identifier

  virtual const std::wstring& name() const = 0;

  virtual std::wstring& mutable_name() = 0;

  virtual void set_name(
    std::wstring value
  ) = 0;

  ///@}

  ///@{
  /// \brief The value of the specific asset identifier with the corresponding name.

  virtual const std::wstring& value() const = 0;

  virtual std::wstring& mutable_value() = 0;

  virtual void set_value(
    std::wstring value
  ) = 0;

  ///@}

  ///@{
  /// \brief The (external) subject the key belongs to or has meaning to.
  ///
  /// \note This is a global reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& external_subject_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_external_subject_id() = 0;

  virtual void set_external_subject_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  virtual ~ISpecificAssetId() = default;
};

/// \brief A submodel defines a specific aspect of the asset represented by the AAS.
///
/// A submodel is used to structure the digital representation and technical
/// functionality of an Administration Shell into distinguishable parts. Each submodel
/// refers to a well-defined domain or subject matter. Submodels can become
/// standardized and, thus, become submodels templates.
class ISubmodel
    : virtual public IIdentifiable,
    virtual public IHasKind,
    virtual public IHasSemantics,
    virtual public IQualifiable,
    virtual public IHasDataSpecification {
 public:
  ///@{
  /// \brief A submodel consists of zero or more submodel elements.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& submodel_elements() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& mutable_submodel_elements() = 0;

  virtual void set_submodel_elements(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value
  ) = 0;

  ///@}

  virtual ~ISubmodel() = default;
};

/// \brief A submodel element is an element suitable for the description and differentiation of
/// assets.
///
/// It is recommended to add a IHasSemantics::semantic_id to a submodel element.
///
/// Constraint AASd-129:\n
/// If any IQualifier::kind value of ISubmodelElement::qualifiers (attribute qualifier
/// inherited via Qualifiable) is equal to QualifierKind::kTemplateQualifier
/// then the submodel element shall be part of a submodel template, i.e.
/// a Submodel with ISubmodel::kind (attribute kind inherited via
/// IHasKind) value is equal to ModellingKind::kTemplate.
class ISubmodelElement
    : virtual public IReferable,
    virtual public IHasSemantics,
    virtual public IQualifiable,
    virtual public IHasDataSpecification {
 public:
  virtual ~ISubmodelElement() = default;
};

/// \brief A relationship element is used to define a relationship between two elements
/// being either referable (model reference) or external (global reference).
class IRelationshipElement
    : virtual public ISubmodelElement {
 public:
  ///@{
  /// \brief Reference to the first element in the relationship taking the role of the subject.

  virtual const std::shared_ptr<IReference>& first() const = 0;

  virtual std::shared_ptr<IReference>& mutable_first() = 0;

  virtual void set_first(
    std::shared_ptr<IReference> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Reference to the second element in the relationship taking the role of the object.

  virtual const std::shared_ptr<IReference>& second() const = 0;

  virtual std::shared_ptr<IReference>& mutable_second() = 0;

  virtual void set_second(
    std::shared_ptr<IReference> value
  ) = 0;

  ///@}

  virtual ~IRelationshipElement() = default;
};

/// \brief A submodel element list is an ordered list of submodel elements.
///
/// The numbering starts with zero (0).
///
/// Constraint AASd-107:\n
/// If a first level child element in a ISubmodelElementList has
/// a IHasSemantics::semantic_id it
/// shall be identical to ISubmodelElementList::semantic_id_list_element.
///
/// Constraint AASd-114:\n
/// If two first level child elements in a ISubmodelElementList have
/// a IHasSemantics::semantic_id then they shall be identical.
///
/// Constraint AASd-115:\n
/// If a first level child element in a ISubmodelElementList does not
/// specify a IHasSemantics::semantic_id then the value is assumed to be
/// identical to ISubmodelElementList::semantic_id_list_element.
///
/// Constraint AASd-120:\n
/// The ISubmodelElementList::id_short of a ISubmodelElement being a direct child of a
/// ISubmodelElementList shall not be specified.
///
/// Constraint AASd-108:\n
/// All first level child elements in a ISubmodelElementList shall have
/// the same submodel element type as specified in ISubmodelElementList::type_value_list_element.
///
/// Constraint AASd-109:\n
/// If ISubmodelElementList::type_value_list_element is equal to
/// AasSubmodelElements::kProperty or
/// AasSubmodelElements::kRange
/// ISubmodelElementList::value_type_list_element shall be set and all first
/// level child elements in the ISubmodelElementList shall have
/// the value type as specified in ISubmodelElementList::value_type_list_element.
class ISubmodelElementList
    : virtual public ISubmodelElement {
 public:
  ///@{
  /// \brief Defines whether order in list is relevant. If ISubmodelElementList::order_relevant = `False`
  /// then the list is representing a set or a bag.
  ///
  /// Default: `True`

  virtual const common::optional<bool>& order_relevant() const = 0;

  virtual common::optional<bool>& mutable_order_relevant() = 0;

  virtual void set_order_relevant(
    common::optional<bool> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Semantic ID the submodel elements contained in the list match to.
  ///
  /// \note It is recommended to use a global reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id_list_element() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id_list_element() = 0;

  virtual void set_semantic_id_list_element(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief The submodel element type of the submodel elements contained in the list.

  virtual AasSubmodelElements type_value_list_element() const = 0;

  virtual AasSubmodelElements& mutable_type_value_list_element() = 0;

  virtual void set_type_value_list_element(
    AasSubmodelElements value
  ) = 0;

  ///@}

  ///@{
  /// \brief The value type of the submodel element contained in the list.

  virtual const common::optional<DataTypeDefXsd>& value_type_list_element() const = 0;

  virtual common::optional<DataTypeDefXsd>& mutable_value_type_list_element() = 0;

  virtual void set_value_type_list_element(
    common::optional<DataTypeDefXsd> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Submodel element contained in the list.
  ///
  /// The list is ordered.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& value() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& mutable_value() = 0;

  virtual void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value
  ) = 0;

  ///@}

  virtual bool OrderRelevantOrDefault() const = 0;

  virtual ~ISubmodelElementList() = default;
};

/// \brief A submodel element collection is a kind of struct, i.e. a a logical encapsulation
/// of multiple named values. It has a fixed number of submodel elements.
class ISubmodelElementCollection
    : virtual public ISubmodelElement {
 public:
  ///@{
  /// \brief Submodel element contained in the collection.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& value() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& mutable_value() = 0;

  virtual void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value
  ) = 0;

  ///@}

  virtual ~ISubmodelElementCollection() = default;
};

/// \brief A data element is a submodel element that is not further composed out of
/// other submodel elements.
///
/// A data element is a submodel element that has a value. The type of value differs
/// for different subtypes of data elements.
///
/// Constraint AASd-090:\n
/// For data elements IDataElement::category shall be one of the following
/// values: `CONSTANT`, `PARAMETER` or `VARIABLE`.
///
/// Default: `VARIABLE`
class IDataElement
    : virtual public ISubmodelElement {
 public:
  virtual std::wstring CategoryOrDefault() const = 0;

  virtual ~IDataElement() = default;
};

/// \brief A property is a data element that has a single value.
///
/// Constraint AASd-007:\n
/// If both, the IProperty::value and the IProperty::value_id are
/// present then the value of IProperty::value needs to be identical to
/// the value of the referenced coded value in IProperty::value_id.
class IProperty
    : virtual public IDataElement {
 public:
  ///@{
  /// \brief Data type of the value

  virtual DataTypeDefXsd value_type() const = 0;

  virtual DataTypeDefXsd& mutable_value_type() = 0;

  virtual void set_value_type(
    DataTypeDefXsd value
  ) = 0;

  ///@}

  ///@{
  /// \brief The value of the property instance.

  virtual const common::optional<std::wstring>& value() const = 0;

  virtual common::optional<std::wstring>& mutable_value() = 0;

  virtual void set_value(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Reference to the global unique ID of a coded value.
  ///
  /// \note It is recommended to use a global reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& value_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_value_id() = 0;

  virtual void set_value_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  virtual ~IProperty() = default;
};

/// \brief A property is a data element that has a multi-language value.
///
/// Constraint AASd-012:\n
/// If both the IMultiLanguageProperty::value and the IMultiLanguageProperty::value_id are present then for each
/// string in a specific language the meaning must be the same as specified in
/// IMultiLanguageProperty::value_id.
class IMultiLanguageProperty
    : virtual public IDataElement {
 public:
  ///@{
  /// \brief The value of the property instance.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& value() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_value() = 0;

  virtual void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Reference to the global unique ID of a coded value.
  ///
  /// \note It is recommended to use a global reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& value_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_value_id() = 0;

  virtual void set_value_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  virtual ~IMultiLanguageProperty() = default;
};

/// \brief A range data element is a data element that defines a range with min and max.
class IRange
    : virtual public IDataElement {
 public:
  ///@{
  /// \brief Data type of the min und max

  virtual DataTypeDefXsd value_type() const = 0;

  virtual DataTypeDefXsd& mutable_value_type() = 0;

  virtual void set_value_type(
    DataTypeDefXsd value
  ) = 0;

  ///@}

  ///@{
  /// \brief The minimum value of the range.
  ///
  /// If the min value is missing, then the value is assumed to be negative infinite.

  virtual const common::optional<std::wstring>& min() const = 0;

  virtual common::optional<std::wstring>& mutable_min() = 0;

  virtual void set_min(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief The maximum value of the range.
  ///
  /// If the max value is missing, then the value is assumed to be positive infinite.

  virtual const common::optional<std::wstring>& max() const = 0;

  virtual common::optional<std::wstring>& mutable_max() = 0;

  virtual void set_max(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  virtual ~IRange() = default;
};

/// \brief A reference element is a data element that defines a logical reference to another
/// element within the same or another AAS or a reference to an external object or
/// entity.
class IReferenceElement
    : virtual public IDataElement {
 public:
  ///@{
  /// \brief Global reference to an external object or entity or a logical reference to
  /// another element within the same or another AAS (i.e. a model reference to
  /// a Referable).

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& value() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_value() = 0;

  virtual void set_value(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  virtual ~IReferenceElement() = default;
};

/// \brief A IBlob is a data element that represents a file that is contained with its
/// source code in the value attribute.
class IBlob
    : virtual public IDataElement {
 public:
  ///@{
  /// \brief The value of the IBlob instance of a blob data element.
  ///
  /// \note In contrast to the file property the file content is stored directly as value
  /// in the IBlob data element.

  virtual const common::optional<
    std::vector<std::uint8_t>
  >& value() const = 0;

  virtual common::optional<
    std::vector<std::uint8_t>
  >& mutable_value() = 0;

  virtual void set_value(
    common::optional<
      std::vector<std::uint8_t>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Content type of the content of the IBlob.
  ///
  /// The content type (MIME type) states which file extensions the file can have.
  ///
  /// Valid values are content types like e.g. `application/json`, `application/xls`,
  /// `image/jpg`.
  ///
  /// The allowed values are defined as in RFC2046.

  virtual const std::wstring& content_type() const = 0;

  virtual std::wstring& mutable_content_type() = 0;

  virtual void set_content_type(
    std::wstring value
  ) = 0;

  ///@}

  virtual ~IBlob() = default;
};

/// \brief A File is a data element that represents an address to a file (a locator).
///
/// The value is an URI that can represent an absolute or relative path.
class IFile
    : virtual public IDataElement {
 public:
  ///@{
  /// \brief Path and name of the referenced file (with file extension).
  ///
  /// The path can be absolute or relative.

  virtual const common::optional<std::wstring>& value() const = 0;

  virtual common::optional<std::wstring>& mutable_value() = 0;

  virtual void set_value(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Content type of the content of the file.
  ///
  /// The content type states which file extensions the file can have.

  virtual const std::wstring& content_type() const = 0;

  virtual std::wstring& mutable_content_type() = 0;

  virtual void set_content_type(
    std::wstring value
  ) = 0;

  ///@}

  virtual ~IFile() = default;
};

/// \brief An annotated relationship element is a relationship element that can be annotated
/// with additional data elements.
class IAnnotatedRelationshipElement
    : virtual public IRelationshipElement {
 public:
  ///@{
  /// \brief A data element that represents an annotation that holds for the relationship
  /// between the two elements

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IDataElement>
    >
  >& annotations() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IDataElement>
    >
  >& mutable_annotations() = 0;

  virtual void set_annotations(
    common::optional<
      std::vector<
        std::shared_ptr<IDataElement>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IAnnotatedRelationshipElement() = default;
};

/// \brief An entity is a submodel element that is used to model entities.
///
/// Constraint AASd-014:\n
/// Either the attribute IEntity::global_asset_id or IEntity::specific_asset_ids
/// of an IEntity must be set if IEntity::entity_type is set to
/// EntityType::kSelfManagedEntity. They are not existing otherwise.
class IEntity
    : virtual public ISubmodelElement {
 public:
  ///@{
  /// \brief Describes statements applicable to the entity by a set of submodel elements,
  /// typically with a qualified value.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& statements() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& mutable_statements() = 0;

  virtual void set_statements(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Describes whether the entity is a co-managed entity or a self-managed entity.

  virtual EntityType entity_type() const = 0;

  virtual EntityType& mutable_entity_type() = 0;

  virtual void set_entity_type(
    EntityType value
  ) = 0;

  ///@}

  ///@{
  /// \brief Global identifier of the asset the entity is representing.
  ///
  /// \note This is a global reference.

  virtual const common::optional<std::wstring>& global_asset_id() const = 0;

  virtual common::optional<std::wstring>& mutable_global_asset_id() = 0;

  virtual void set_global_asset_id(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Reference to a specific asset ID representing a supplementary identifier
  /// of the asset represented by the Asset Administration Shell.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  >& specific_asset_ids() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  >& mutable_specific_asset_ids() = 0;

  virtual void set_specific_asset_ids(
    common::optional<
      std::vector<
        std::shared_ptr<ISpecificAssetId>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IEntity() = default;
};

/// \brief Defines the necessary information of an event instance sent out or received.
///
/// \note This element is experimental and therefore may be subject to change or may be
/// removed completely in future versions of the meta-model.
class IEventPayload
    : virtual public IClass {
 public:
  ///@{
  /// \brief Reference to the source event element, including identification of
  /// IAssetAdministrationShell, ISubmodel,
  /// ISubmodelElement's.

  virtual const std::shared_ptr<IReference>& source() const = 0;

  virtual std::shared_ptr<IReference>& mutable_source() = 0;

  virtual void set_source(
    std::shared_ptr<IReference> value
  ) = 0;

  ///@}

  ///@{
  /// \brief IHasSemantics::semantic_id of the source event element, if available
  ///
  /// \note It is recommended to use a global reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& source_semantic_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_source_semantic_id() = 0;

  virtual void set_source_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Reference to the referable, which defines the scope of the event.
  ///
  /// Can be IAssetAdministrationShell, ISubmodel or
  /// ISubmodelElement.

  virtual const std::shared_ptr<IReference>& observable_reference() const = 0;

  virtual std::shared_ptr<IReference>& mutable_observable_reference() = 0;

  virtual void set_observable_reference(
    std::shared_ptr<IReference> value
  ) = 0;

  ///@}

  ///@{
  /// \brief IHasSemantics::semantic_id of the referable which defines the scope of
  /// the event, if available.
  ///
  /// \note It is recommended to use a global reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& observable_semantic_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_observable_semantic_id() = 0;

  virtual void set_observable_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Information for the outer message infrastructure for scheduling the event to
  /// the respective communication channel.

  virtual const common::optional<std::wstring>& topic() const = 0;

  virtual common::optional<std::wstring>& mutable_topic() = 0;

  virtual void set_topic(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Subject, who/which initiated the creation.
  ///
  /// \note This is an external reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& subject_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_subject_id() = 0;

  virtual void set_subject_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Timestamp in UTC, when this event was triggered.

  virtual const std::wstring& time_stamp() const = 0;

  virtual std::wstring& mutable_time_stamp() = 0;

  virtual void set_time_stamp(
    std::wstring value
  ) = 0;

  ///@}

  ///@{
  /// \brief Event specific payload.

  virtual const common::optional<
    std::vector<std::uint8_t>
  >& payload() const = 0;

  virtual common::optional<
    std::vector<std::uint8_t>
  >& mutable_payload() = 0;

  virtual void set_payload(
    common::optional<
      std::vector<std::uint8_t>
    > value
  ) = 0;

  ///@}

  virtual ~IEventPayload() = default;
};

/// \brief An event element.
///
/// \note This element is experimental and therefore may be subject to change or may be
/// removed completely in future versions of the meta-model.
class IEventElement
    : virtual public ISubmodelElement {
 public:
  virtual ~IEventElement() = default;
};

/// \brief A basic event element.
///
/// \note This element is experimental and therefore may be subject to change or may be
/// removed completely in future versions of the meta-model.
class IBasicEventElement
    : virtual public IEventElement {
 public:
  ///@{
  /// \brief Reference to the IReferable, which defines the scope of the event.
  /// Can be IAssetAdministrationShell, ISubmodel, or
  /// ISubmodelElement.
  ///
  /// Reference to a referable, e.g., a data element or
  /// a submodel, that is being observed.

  virtual const std::shared_ptr<IReference>& observed() const = 0;

  virtual std::shared_ptr<IReference>& mutable_observed() = 0;

  virtual void set_observed(
    std::shared_ptr<IReference> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Direction of event.
  ///
  /// Can be `{ Input, Output }`.

  virtual Direction direction() const = 0;

  virtual Direction& mutable_direction() = 0;

  virtual void set_direction(
    Direction value
  ) = 0;

  ///@}

  ///@{
  /// \brief State of event.
  ///
  /// Can be `{ On, Off }`.

  virtual StateOfEvent state() const = 0;

  virtual StateOfEvent& mutable_state() = 0;

  virtual void set_state(
    StateOfEvent value
  ) = 0;

  ///@}

  ///@{
  /// \brief Information for the outer message infrastructure for scheduling the event to the
  /// respective communication channel.

  virtual const common::optional<std::wstring>& message_topic() const = 0;

  virtual common::optional<std::wstring>& mutable_message_topic() = 0;

  virtual void set_message_topic(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Information, which outer message infrastructure shall handle messages for
  /// the IEventElement. Refers to a ISubmodel,
  /// ISubmodelElementList, ISubmodelElementCollection or
  /// IEntity, which contains IDataElement's describing
  /// the proprietary specification for the message broker.
  ///
  /// \note For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
  /// proprietary specification could be standardized by having respective Submodels.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& message_broker() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_message_broker() = 0;

  virtual void set_message_broker(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Timestamp in UTC, when the last event was received (input direction) or sent
  /// (output direction).

  virtual const common::optional<std::wstring>& last_update() const = 0;

  virtual common::optional<std::wstring>& mutable_last_update() = 0;

  virtual void set_last_update(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief For input direction, reports on the maximum frequency, the software entity behind
  /// the respective Referable can handle input events.
  ///
  /// For output events, specifies the maximum frequency of outputting this event to
  /// an outer infrastructure.
  ///
  /// Might be not specified, that is, there is no minimum interval.

  virtual const common::optional<std::wstring>& min_interval() const = 0;

  virtual common::optional<std::wstring>& mutable_min_interval() = 0;

  virtual void set_min_interval(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief For input direction: not applicable.
  ///
  /// For output direction: maximum interval in time, the respective Referable shall send
  /// an update of the status of the event, even if no other trigger condition for
  /// the event was not met.
  ///
  /// Might be not specified, that is, there is no maximum interval

  virtual const common::optional<std::wstring>& max_interval() const = 0;

  virtual common::optional<std::wstring>& mutable_max_interval() = 0;

  virtual void set_max_interval(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  virtual ~IBasicEventElement() = default;
};

/// \brief An operation is a submodel element with input and output variables.
///
/// Constraint AASd-134:\n
/// For an IOperation the IReferable::id_short of all
/// IOperationVariable::value's in
/// IOperation::input_variables, IOperation::output_variables
/// and IOperation::inoutput_variables shall be unique.
class IOperation
    : virtual public ISubmodelElement {
 public:
  ///@{
  /// \brief Input parameter of the operation.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& input_variables() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& mutable_input_variables() = 0;

  virtual void set_input_variables(
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Output parameter of the operation.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& output_variables() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& mutable_output_variables() = 0;

  virtual void set_output_variables(
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Parameter that is input and output of the operation.

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& inoutput_variables() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& mutable_inoutput_variables() = 0;

  virtual void set_inoutput_variables(
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IOperation() = default;
};

/// \brief The value of an operation variable is a submodel element that is used as input
/// and/or output variable of an operation.
class IOperationVariable
    : virtual public IClass {
 public:
  ///@{
  /// \brief Describes an argument or result of an operation via a submodel element

  virtual const std::shared_ptr<ISubmodelElement>& value() const = 0;

  virtual std::shared_ptr<ISubmodelElement>& mutable_value() = 0;

  virtual void set_value(
    std::shared_ptr<ISubmodelElement> value
  ) = 0;

  ///@}

  virtual ~IOperationVariable() = default;
};

/// \brief A capability is the implementation-independent description of the potential of an
/// asset to achieve a certain effect in the physical or virtual world.
///
/// \note The ICapability::semantic_id of a capability is typically an ontology.
/// Thus, reasoning on capabilities is enabled.
class ICapability
    : virtual public ISubmodelElement {
 public:
  virtual ~ICapability() = default;
};

/// \brief The semantics of a property or other elements that may have a semantic description
/// is defined by a concept description.
///
/// The description of the concept should follow a standardized schema (realized as
/// data specification template).
///
/// Constraint AASc-3a-004:\n
/// For a IConceptDescription with IConceptDescription::category `PROPERTY` or
/// `VALUE` using data specification IEC61360,
/// the IDataSpecificationIec61360::data_type is mandatory and shall be
/// one of: `DATE`, `STRING`, `STRING_TRANSLATABLE`, `INTEGER_MEASURE`,
/// `INTEGER_COUNT`, `INTEGER_CURRENCY`, `REAL_MEASURE`, `REAL_COUNT`,
/// `REAL_CURRENCY`, `BOOLEAN`, `RATIONAL`, `RATIONAL_MEASURE`,
/// `TIME`, `TIMESTAMP`.
///
/// \note Note: categories are deprecated since V3.0 of Part 1a of the document series
/// "Details of the Asset Administration Shell".
///
/// Constraint AASc-3a-005:\n
/// For a IConceptDescription with IConceptDescription::category `REFERENCE`
/// using data specification template IEC61360,
/// the IDataSpecificationIec61360::data_type shall be
/// one of: `STRING`, `IRI`, `IRDI`.
///
/// \note Note: categories are deprecated since V3.0 of Part 1a of the document series
/// "Details of the Asset Administration Shell".
///
/// Constraint AASc-3a-006:\n
/// For a IConceptDescription with IConceptDescription::category `DOCUMENT`
/// using data specification IEC61360,
/// the IDataSpecificationIec61360::data_type shall be one of `FILE`,
/// `BLOB`, `HTML`
///
/// \note Categories are deprecated since V3.0 of Part 1a of the document series
/// "Details of the Asset Administration Shell".
///
/// Constraint AASc-3a-007:\n
/// For a IConceptDescription with IConceptDescription::category `QUALIFIER_TYPE`
/// using data specification IEC61360,
/// the IDataSpecificationIec61360::data_type is mandatory and shall be
/// defined.
///
/// \note Categories are deprecated since V3.0 of Part 1a of the document series
/// "Details of the Asset Administration Shell".
///
/// Constraint AASc-3a-008:\n
/// For a IConceptDescription using data specification template IEC61360,
/// IDataSpecificationIec61360::definition is mandatory and shall be
/// defined at least in English.
///
/// Exception: The concept description describes a value, i.e.
/// IDataSpecificationIec61360::value is defined.
///
/// Constraint AASc-3a-003:\n
/// For a IConceptDescription using data specification template IEC61360,
/// referenced via IDataSpecificationIec61360::value_list
/// IValueReferencePair::value_id
/// the IDataSpecificationIec61360::value shall be set.
class IConceptDescription
    : virtual public IIdentifiable,
    virtual public IHasDataSpecification {
 public:
  ///@{
  /// \brief Reference to an external definition the concept is compatible to or was derived
  /// from.
  ///
  /// \note It is recommended to use a global reference.
  ///
  /// \note Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& is_case_of() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_is_case_of() = 0;

  virtual void set_is_case_of(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IConceptDescription() = default;
};

/// \brief Reference to either a model element of the same or another AAS or to an external
/// entity.
///
/// A reference is an ordered list of keys.
///
/// A model reference is an ordered list of keys, each key referencing an element. The
/// complete list of keys may for example be concatenated to a path that then gives
/// unique access to an element.
///
/// An external reference is a reference to an external entity.
///
/// Constraint AASd-121:\n
/// For IReference's the value of IKey::type of the first key of "
/// IReference::keys shall be one of constants::kGloballyIdentifiables.
///
/// Constraint AASd-122:\n
/// For external references, i.e. IReference's with
/// IReference::type = ReferenceTypes::kExternalReference, the value
/// of IKey::type of the first key of IReference::keys shall be one of
/// constants::kGenericGloballyIdentifiables.
///
/// Constraint AASd-123:\n
/// For model references, i.e. IReference's with
/// IReference::type = ReferenceTypes::kModelReference, the value
/// of IKey::type of the first key of IReference::keys shall be one of
/// constants::kAasIdentifiables.
///
/// Constraint AASd-124:\n
/// For external references, i.e. IReference's with
/// IReference::type = ReferenceTypes::kExternalReference, the last
/// key of IReference::keys shall be either one of
/// constants::kGenericGloballyIdentifiables or one of
/// constants::kGenericFragmentKeys.
///
/// Constraint AASd-125:\n
/// For model references, i.e. IReference's with
/// IReference::type = ReferenceTypes::kModelReference, with more
/// than one key in IReference::keys the value of IKey::type
/// of each of the keys following the first
/// key of IReference::keys shall be one of constants::kFragmentKeys.
///
/// \note Constraint AASd-125 ensures that the shortest path is used.
///
/// Constraint AASd-126:\n
/// For model references, i.e. IReference's with
/// IReference::type = ReferenceTypes::kModelReference, with more
/// than one key in IReference::keys the value of IKey::type
/// of the last key in the reference key chain may be
/// one of constants::kGenericFragmentKeys or no key at all
/// shall have a value out of constants::kGenericFragmentKeys.
///
/// Constraint AASd-127:\n
/// For model references, i.e. IReference's with
/// IReference::type = ReferenceTypes::kModelReference, with more
/// than one key in IReference::keys a key with IKey::type
/// KeyTypes::kFragmentReference shall be preceded by a key with
/// IKey::type KeyTypes::kFile or KeyTypes::kBlob. All other
/// AAS fragments, i.e. IKey::type values
/// out of constants::kAasSubmodelElementsAsKeys, do not support fragments.
///
/// \note Which kind of fragments are supported depends on the content type and the
/// specification of allowed fragment identifiers for the corresponding resource
/// being referenced via the reference.
///
/// Constraint AASd-128:\n
/// For model references, i.e. IReference's with
/// IReference::type = ReferenceTypes::kModelReference, the
/// IKey::value of a IKey preceded by a IKey with
/// IKey::type = KeyTypes::kSubmodelElementList is an integer
/// number denoting the position in the array of the submodel element list.
class IReference
    : virtual public IClass {
 public:
  ///@{
  /// \brief Type of the reference.
  ///
  /// Denotes, whether reference is an external reference or a model reference.

  virtual ReferenceTypes type() const = 0;

  virtual ReferenceTypes& mutable_type() = 0;

  virtual void set_type(
    ReferenceTypes value
  ) = 0;

  ///@}

  ///@{
  /// \brief IHasSemantics::semantic_id of the referenced model element
  /// (IReference::type = ReferenceTypes::kModelReference).
  ///
  /// For external references there typically is no semantic ID.
  ///
  /// \note It is recommended to use a external reference.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& referred_semantic_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_referred_semantic_id() = 0;

  virtual void set_referred_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Unique references in their name space.

  virtual const std::vector<
    std::shared_ptr<IKey>
  >& keys() const = 0;

  virtual std::vector<
    std::shared_ptr<IKey>
  >& mutable_keys() = 0;

  virtual void set_keys(
    std::vector<
      std::shared_ptr<IKey>
    > value
  ) = 0;

  ///@}

  virtual ~IReference() = default;
};

/// \brief A key is a reference to an element by its ID.
class IKey
    : virtual public IClass {
 public:
  ///@{
  /// \brief Denotes which kind of entity is referenced.
  ///
  /// In case IKey::type = KeyTypes::kGlobalReference,
  /// the key represents a reference to a source that can be globally identified.
  ///
  /// In case IKey::type = KeyTypes::kFragmentReference the key represents
  /// a bookmark or a similar local identifier within its parent element as specified
  /// by the key that precedes this key.
  ///
  /// In all other cases the key references a model element of the same or of another AAS.
  /// The name of the model element is explicitly listed.

  virtual KeyTypes type() const = 0;

  virtual KeyTypes& mutable_type() = 0;

  virtual void set_type(
    KeyTypes value
  ) = 0;

  ///@}

  ///@{
  /// \brief The key value, for example an IRDI or an URI

  virtual const std::wstring& value() const = 0;

  virtual std::wstring& mutable_value() = 0;

  virtual void set_value(
    std::wstring value
  ) = 0;

  ///@}

  virtual ~IKey() = default;
};

/// \brief Strings with language tags
class IAbstractLangString
    : virtual public IClass {
 public:
  ///@{
  /// \brief Language tag conforming to BCP 47

  virtual const std::wstring& language() const = 0;

  virtual std::wstring& mutable_language() = 0;

  virtual void set_language(
    std::wstring value
  ) = 0;

  ///@}

  ///@{
  /// \brief Text in the IAbstractLangString::language

  virtual const std::wstring& text() const = 0;

  virtual std::wstring& mutable_text() = 0;

  virtual void set_text(
    std::wstring value
  ) = 0;

  ///@}

  virtual ~IAbstractLangString() = default;
};

/// \brief String with length 128 maximum and minimum 1 characters and with language tags
class ILangStringNameType
    : virtual public IAbstractLangString {
 public:
  virtual ~ILangStringNameType() = default;
};

/// \brief String with length 1023 maximum and minimum 1 characters and with language tags
class ILangStringTextType
    : virtual public IAbstractLangString {
 public:
  virtual ~ILangStringTextType() = default;
};

/// \brief Container for the sets of different identifiables.
///
/// \note w.r.t. file exchange: There is exactly one environment independent on how many
/// files the contained elements are split. If the file is split then there
/// shall be no element with the same identifier in two different files.
class IEnvironment
    : virtual public IClass {
 public:
  ///@{
  /// \brief Asset administration shell

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IAssetAdministrationShell>
    >
  >& asset_administration_shells() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IAssetAdministrationShell>
    >
  >& mutable_asset_administration_shells() = 0;

  virtual void set_asset_administration_shells(
    common::optional<
      std::vector<
        std::shared_ptr<IAssetAdministrationShell>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Submodel

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ISubmodel>
    >
  >& submodels() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ISubmodel>
    >
  >& mutable_submodels() = 0;

  virtual void set_submodels(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodel>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Concept description

  virtual const common::optional<
    std::vector<
      std::shared_ptr<IConceptDescription>
    >
  >& concept_descriptions() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<IConceptDescription>
    >
  >& mutable_concept_descriptions() = 0;

  virtual void set_concept_descriptions(
    common::optional<
      std::vector<
        std::shared_ptr<IConceptDescription>
      >
    > value
  ) = 0;

  ///@}

  virtual ~IEnvironment() = default;
};

/// \brief Data specification content is part of a data specification template and defines
/// which additional attributes shall be added to the element instance that references
/// the data specification template and meta information about the template itself.
///
/// Constraint AASc-3a-050:\n
/// If the IDataSpecificationIec61360 is used
/// for an element, the value of
/// IHasDataSpecification::embedded_data_specifications
/// shall contain the global reference to the IRI of the corresponding
/// data specification template
/// https://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/3/0
class IDataSpecificationContent
    : virtual public IClass {
 public:
  virtual ~IDataSpecificationContent() = default;
};

/// \brief Embed the content of a data specification.
class IEmbeddedDataSpecification
    : virtual public IClass {
 public:
  ///@{
  /// \brief Actual content of the data specification

  virtual const std::shared_ptr<IDataSpecificationContent>& data_specification_content() const = 0;

  virtual std::shared_ptr<IDataSpecificationContent>& mutable_data_specification_content() = 0;

  virtual void set_data_specification_content(
    std::shared_ptr<IDataSpecificationContent> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Reference to the data specification

  virtual const std::shared_ptr<IReference>& data_specification() const = 0;

  virtual std::shared_ptr<IReference>& mutable_data_specification() = 0;

  virtual void set_data_specification(
    std::shared_ptr<IReference> value
  ) = 0;

  ///@}

  virtual ~IEmbeddedDataSpecification() = default;
};

/// \brief Value represented by up to four variants of a numeric value in a specific role:
/// `MIN`, `NOM`, `TYP` and `MAX`. True means that the value is available,
/// false means the value is not available.
///
/// EXAMPLE from [IEC61360-1]: In the case of having a property which is
/// of the LEVEL_TYPE min/max − expressing a range − only those two values
/// need to be provided.
///
/// \note \parblock
/// This is how AAS deals with the following combinations of level types:
///
/// * Either all attributes are false. In this case the concept is mapped
///   to a IProperty and level type is ignored.
/// * At most one of the attributes is set to true. In this case
///   the concept is mapped to a IProperty.
/// * Min and max are set to true. In this case the concept is mapped
///   to a IRange.
/// * More than one attribute is set to true but not min and max only
///   (see second case). In this case the concept is mapped
///   to a ISubmodelElementCollection with the corresponding
///   number of Properties.
///   Example: If attribute ILevelType::min and ILevelType::nom are set to true
///   then the concept is mapped to a ISubmodelElementCollection
///   with two Properties within: min and nom.
///   The data type of both Properties is the same.
/// \endparblock
///
/// \note In the cases 2. and 4. the IProperty::semantic_id of the Property
/// or Properties within the ISubmodelElementCollection needs to include
/// information about the level type. Otherwise, the semantics is not described
/// in a unique way. Please refer to the specification.
class ILevelType
    : virtual public IClass {
 public:
  ///@{
  /// \brief Minimum of the value

  virtual bool min() const = 0;

  virtual bool& mutable_min() = 0;

  virtual void set_min(
    bool value
  ) = 0;

  ///@}

  ///@{
  /// \brief Nominal value (value as designated)

  virtual bool nom() const = 0;

  virtual bool& mutable_nom() = 0;

  virtual void set_nom(
    bool value
  ) = 0;

  ///@}

  ///@{
  /// \brief Value as typically present

  virtual bool typ() const = 0;

  virtual bool& mutable_typ() = 0;

  virtual void set_typ(
    bool value
  ) = 0;

  ///@}

  ///@{
  /// \brief Maximum of the value

  virtual bool max() const = 0;

  virtual bool& mutable_max() = 0;

  virtual void set_max(
    bool value
  ) = 0;

  ///@}

  virtual ~ILevelType() = default;
};

/// \brief A value reference pair within a value list. Each value has a global unique id
/// defining its semantic.
class IValueReferencePair
    : virtual public IClass {
 public:
  ///@{
  /// \brief The value of the referenced concept definition of the value in IValueReferencePair::value_id.

  virtual const std::wstring& value() const = 0;

  virtual std::wstring& mutable_value() = 0;

  virtual void set_value(
    std::wstring value
  ) = 0;

  ///@}

  ///@{
  /// \brief Global unique id of the value.
  ///
  /// \note It is recommended to use a global reference.

  virtual const std::shared_ptr<IReference>& value_id() const = 0;

  virtual std::shared_ptr<IReference>& mutable_value_id() = 0;

  virtual void set_value_id(
    std::shared_ptr<IReference> value
  ) = 0;

  ///@}

  virtual ~IValueReferencePair() = default;
};

/// \brief A set of value reference pairs.
class IValueList
    : virtual public IClass {
 public:
  ///@{
  /// \brief A pair of a value together with its global unique id.

  virtual const std::vector<
    std::shared_ptr<IValueReferencePair>
  >& value_reference_pairs() const = 0;

  virtual std::vector<
    std::shared_ptr<IValueReferencePair>
  >& mutable_value_reference_pairs() = 0;

  virtual void set_value_reference_pairs(
    std::vector<
      std::shared_ptr<IValueReferencePair>
    > value
  ) = 0;

  ///@}

  virtual ~IValueList() = default;
};

/// \brief String with length 255 maximum and minimum 1 characters and with language tags
///
/// \note It is advised to keep the length of the name limited to 35 characters.
class ILangStringPreferredNameTypeIec61360
    : virtual public IAbstractLangString {
 public:
  virtual ~ILangStringPreferredNameTypeIec61360() = default;
};

/// \brief String with length 18 maximum and minimum 1 characters and with language tags
class ILangStringShortNameTypeIec61360
    : virtual public IAbstractLangString {
 public:
  virtual ~ILangStringShortNameTypeIec61360() = default;
};

/// \brief String with length 1023 maximum and minimum 1 characters and with language tags
class ILangStringDefinitionTypeIec61360
    : virtual public IAbstractLangString {
 public:
  virtual ~ILangStringDefinitionTypeIec61360() = default;
};

/// \brief Content of data specification template for concept descriptions for properties,
/// values and value lists conformant to IEC 61360.
///
/// \note IEC61360 requires also a globally unique identifier for a concept
/// description. This ID is not part of the data specification template.
/// Instead the IConceptDescription::id as inherited via
/// IIdentifiable is used. Same holds for administrative
/// information like the version and revision.
///
/// \note IConceptDescription::id_short and IDataSpecificationIec61360::short_name are very
/// similar. However, in this case the decision was to add
/// IDataSpecificationIec61360::short_name explicitly to the data specification. Same holds for
/// IConceptDescription::display_name and
/// IDataSpecificationIec61360::preferred_name. Same holds for
/// IConceptDescription::description and IDataSpecificationIec61360::definition.
///
/// Constraint AASc-3a-010:\n
/// If IDataSpecificationIec61360::value is not empty then IDataSpecificationIec61360::value_list shall be empty
/// and vice versa.
///
/// \note It is also possible that both IDataSpecificationIec61360::value and IDataSpecificationIec61360::value_list are
/// empty. This is the case for concept descriptions that define the semantics
/// of a property but do not have an enumeration (IDataSpecificationIec61360::value_list) as
/// data type.
///
/// \note Although it is possible to define a IConceptDescription for a
/// :attr:´value_list`,
/// it is not possible to reuse this IDataSpecificationIec61360::value_list.
/// It is only possible to directly add a IDataSpecificationIec61360::value_list as data type
/// to a specific semantic definition of a property.
///
/// Constraint AASc-3a-009:\n
/// If IDataSpecificationIec61360::data_type one of:
/// DataTypeIec61360::kIntegerMeasure,
/// DataTypeIec61360::kRealMeasure,
/// DataTypeIec61360::kRationalMeasure,
/// DataTypeIec61360::kIntegerCurrency,
/// DataTypeIec61360::kRealCurrency, then IDataSpecificationIec61360::unit or
/// IDataSpecificationIec61360::unit_id shall be defined.
class IDataSpecificationIec61360
    : virtual public IDataSpecificationContent {
 public:
  ///@{
  /// \brief Preferred name
  ///
  /// \note It is advised to keep the length of the name limited to 35 characters.

  virtual const std::vector<
    std::shared_ptr<ILangStringPreferredNameTypeIec61360>
  >& preferred_name() const = 0;

  virtual std::vector<
    std::shared_ptr<ILangStringPreferredNameTypeIec61360>
  >& mutable_preferred_name() = 0;

  virtual void set_preferred_name(
    std::vector<
      std::shared_ptr<ILangStringPreferredNameTypeIec61360>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Short name

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ILangStringShortNameTypeIec61360>
    >
  >& short_name() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ILangStringShortNameTypeIec61360>
    >
  >& mutable_short_name() = 0;

  virtual void set_short_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringShortNameTypeIec61360>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Unit

  virtual const common::optional<std::wstring>& unit() const = 0;

  virtual common::optional<std::wstring>& mutable_unit() = 0;

  virtual void set_unit(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Unique unit id
  ///
  /// IDataSpecificationIec61360::unit and IDataSpecificationIec61360::unit_id need to be consistent if both attributes
  /// are set
  ///
  /// \note It is recommended to use an external reference ID.

  virtual const common::optional<
    std::shared_ptr<IReference>
  >& unit_id() const = 0;

  virtual common::optional<
    std::shared_ptr<IReference>
  >& mutable_unit_id() = 0;

  virtual void set_unit_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Source of definition

  virtual const common::optional<std::wstring>& source_of_definition() const = 0;

  virtual common::optional<std::wstring>& mutable_source_of_definition() = 0;

  virtual void set_source_of_definition(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Symbol

  virtual const common::optional<std::wstring>& symbol() const = 0;

  virtual common::optional<std::wstring>& mutable_symbol() = 0;

  virtual void set_symbol(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Data Type

  virtual const common::optional<DataTypeIec61360>& data_type() const = 0;

  virtual common::optional<DataTypeIec61360>& mutable_data_type() = 0;

  virtual void set_data_type(
    common::optional<DataTypeIec61360> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Definition in different languages

  virtual const common::optional<
    std::vector<
      std::shared_ptr<ILangStringDefinitionTypeIec61360>
    >
  >& definition() const = 0;

  virtual common::optional<
    std::vector<
      std::shared_ptr<ILangStringDefinitionTypeIec61360>
    >
  >& mutable_definition() = 0;

  virtual void set_definition(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringDefinitionTypeIec61360>
      >
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Value Format
  ///
  /// \note The value format is based on ISO 13584-42 and IEC 61360-2.

  virtual const common::optional<std::wstring>& value_format() const = 0;

  virtual common::optional<std::wstring>& mutable_value_format() = 0;

  virtual void set_value_format(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief List of allowed values

  virtual const common::optional<
    std::shared_ptr<IValueList>
  >& value_list() const = 0;

  virtual common::optional<
    std::shared_ptr<IValueList>
  >& mutable_value_list() = 0;

  virtual void set_value_list(
    common::optional<
      std::shared_ptr<IValueList>
    > value
  ) = 0;

  ///@}

  ///@{
  /// \brief Value

  virtual const common::optional<std::wstring>& value() const = 0;

  virtual common::optional<std::wstring>& mutable_value() = 0;

  virtual void set_value(
    common::optional<std::wstring> value
  ) = 0;

  ///@}

  ///@{
  /// \brief Set of levels.

  virtual const common::optional<
    std::shared_ptr<ILevelType>
  >& level_type() const = 0;

  virtual common::optional<
    std::shared_ptr<ILevelType>
  >& mutable_level_type() = 0;

  virtual void set_level_type(
    common::optional<
      std::shared_ptr<ILevelType>
    > value
  ) = 0;

  ///@}

  virtual ~IDataSpecificationIec61360() = default;
};

// endregion

// region Definitions of concrete classes

class Extension
    : public IExtension {
 public:
  explicit Extension(
    std::wstring name,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<DataTypeDefXsd> value_type = common::nullopt,
    common::optional<std::wstring> value = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > refers_to = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set name_

  const std::wstring& name() const override;

  std::wstring& mutable_name() override;

  void set_name(
    std::wstring value
  ) override;

  // endregion

  // region Get and set value_type_

  const common::optional<DataTypeDefXsd>& value_type() const override;

  common::optional<DataTypeDefXsd>& mutable_value_type() override;

  void set_value_type(
    common::optional<DataTypeDefXsd> value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<std::wstring>& value() const override;

  common::optional<std::wstring>& mutable_value() override;

  void set_value(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set refers_to_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& refers_to() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_refers_to() override;

  void set_refers_to(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  DataTypeDefXsd ValueTypeOrDefault() const override;

  ~Extension() override = default;

 private:
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  std::wstring name_;

  common::optional<DataTypeDefXsd> value_type_;

  common::optional<std::wstring> value_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > refers_to_;
};

class AdministrativeInformation
    : public IAdministrativeInformation {
 public:
  AdministrativeInformation(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<std::wstring> version = common::nullopt,
    common::optional<std::wstring> revision = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > creator = common::nullopt,
    common::optional<std::wstring> template_id = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set version_

  const common::optional<std::wstring>& version() const override;

  common::optional<std::wstring>& mutable_version() override;

  void set_version(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set revision_

  const common::optional<std::wstring>& revision() const override;

  common::optional<std::wstring>& mutable_revision() override;

  void set_revision(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set creator_

  const common::optional<
    std::shared_ptr<IReference>
  >& creator() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_creator() override;

  void set_creator(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set template_id_

  const common::optional<std::wstring>& template_id() const override;

  common::optional<std::wstring>& mutable_template_id() override;

  void set_template_id(
    common::optional<std::wstring> value
  ) override;

  // endregion

  ~AdministrativeInformation() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<std::wstring> version_;

  common::optional<std::wstring> revision_;

  common::optional<
    std::shared_ptr<IReference>
  > creator_;

  common::optional<std::wstring> template_id_;
};

class Qualifier
    : public IQualifier {
 public:
  Qualifier(
    std::wstring type,
    DataTypeDefXsd value_type,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<QualifierKind> kind = common::nullopt,
    common::optional<std::wstring> value = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > value_id = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set kind_

  const common::optional<QualifierKind>& kind() const override;

  common::optional<QualifierKind>& mutable_kind() override;

  void set_kind(
    common::optional<QualifierKind> value
  ) override;

  // endregion

  // region Get and set type_

  const std::wstring& type() const override;

  std::wstring& mutable_type() override;

  void set_type(
    std::wstring value
  ) override;

  // endregion

  // region Get and set value_type_

  DataTypeDefXsd value_type() const override;

  DataTypeDefXsd& mutable_value_type() override;

  void set_value_type(
    DataTypeDefXsd value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<std::wstring>& value() const override;

  common::optional<std::wstring>& mutable_value() override;

  void set_value(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set value_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& value_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_value_id() override;

  void set_value_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  QualifierKind KindOrDefault() const override;

  ~Qualifier() override = default;

 private:
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<QualifierKind> kind_;

  std::wstring type_;

  DataTypeDefXsd value_type_;

  common::optional<std::wstring> value_;

  common::optional<
    std::shared_ptr<IReference>
  > value_id_;
};

class AssetAdministrationShell
    : public IAssetAdministrationShell {
 public:
  AssetAdministrationShell(
    std::wstring id,
    std::shared_ptr<IAssetInformation> asset_information,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IAdministrativeInformation>
    > administration = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > derived_from = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > submodels = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set administration_

  const common::optional<
    std::shared_ptr<IAdministrativeInformation>
  >& administration() const override;

  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  >& mutable_administration() override;

  void set_administration(
    common::optional<
      std::shared_ptr<IAdministrativeInformation>
    > value
  ) override;

  // endregion

  // region Get and set id_

  const std::wstring& id() const override;

  std::wstring& mutable_id() override;

  void set_id(
    std::wstring value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set derived_from_

  const common::optional<
    std::shared_ptr<IReference>
  >& derived_from() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_derived_from() override;

  void set_derived_from(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set asset_information_

  const std::shared_ptr<IAssetInformation>& asset_information() const override;

  std::shared_ptr<IAssetInformation>& mutable_asset_information() override;

  void set_asset_information(
    std::shared_ptr<IAssetInformation> value
  ) override;

  // endregion

  // region Get and set submodels_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& submodels() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_submodels() override;

  void set_submodels(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  ~AssetAdministrationShell() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > administration_;

  std::wstring id_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::shared_ptr<IReference>
  > derived_from_;

  std::shared_ptr<IAssetInformation> asset_information_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > submodels_;
};

class AssetInformation
    : public IAssetInformation {
 public:
  explicit AssetInformation(
    AssetKind asset_kind,
    common::optional<std::wstring> global_asset_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ISpecificAssetId>
      >
    > specific_asset_ids = common::nullopt,
    common::optional<std::wstring> asset_type = common::nullopt,
    common::optional<
      std::shared_ptr<IResource>
    > default_thumbnail = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set asset_kind_

  AssetKind asset_kind() const override;

  AssetKind& mutable_asset_kind() override;

  void set_asset_kind(
    AssetKind value
  ) override;

  // endregion

  // region Get and set global_asset_id_

  const common::optional<std::wstring>& global_asset_id() const override;

  common::optional<std::wstring>& mutable_global_asset_id() override;

  void set_global_asset_id(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set specific_asset_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  >& specific_asset_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  >& mutable_specific_asset_ids() override;

  void set_specific_asset_ids(
    common::optional<
      std::vector<
        std::shared_ptr<ISpecificAssetId>
      >
    > value
  ) override;

  // endregion

  // region Get and set asset_type_

  const common::optional<std::wstring>& asset_type() const override;

  common::optional<std::wstring>& mutable_asset_type() override;

  void set_asset_type(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set default_thumbnail_

  const common::optional<
    std::shared_ptr<IResource>
  >& default_thumbnail() const override;

  common::optional<
    std::shared_ptr<IResource>
  >& mutable_default_thumbnail() override;

  void set_default_thumbnail(
    common::optional<
      std::shared_ptr<IResource>
    > value
  ) override;

  // endregion

  ~AssetInformation() override = default;

 private:
  AssetKind asset_kind_;

  common::optional<std::wstring> global_asset_id_;

  common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  > specific_asset_ids_;

  common::optional<std::wstring> asset_type_;

  common::optional<
    std::shared_ptr<IResource>
  > default_thumbnail_;
};

class Resource
    : public IResource {
 public:
  explicit Resource(
    std::wstring path,
    common::optional<std::wstring> content_type = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set path_

  const std::wstring& path() const override;

  std::wstring& mutable_path() override;

  void set_path(
    std::wstring value
  ) override;

  // endregion

  // region Get and set content_type_

  const common::optional<std::wstring>& content_type() const override;

  common::optional<std::wstring>& mutable_content_type() override;

  void set_content_type(
    common::optional<std::wstring> value
  ) override;

  // endregion

  ~Resource() override = default;

 private:
  std::wstring path_;

  common::optional<std::wstring> content_type_;
};

class SpecificAssetId
    : public ISpecificAssetId {
 public:
  SpecificAssetId(
    std::wstring name,
    std::wstring value,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > external_subject_id = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set name_

  const std::wstring& name() const override;

  std::wstring& mutable_name() override;

  void set_name(
    std::wstring value
  ) override;

  // endregion

  // region Get and set value_

  const std::wstring& value() const override;

  std::wstring& mutable_value() override;

  void set_value(
    std::wstring value
  ) override;

  // endregion

  // region Get and set external_subject_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& external_subject_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_external_subject_id() override;

  void set_external_subject_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  ~SpecificAssetId() override = default;

 private:
  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  std::wstring name_;

  std::wstring value_;

  common::optional<
    std::shared_ptr<IReference>
  > external_subject_id_;
};

class Submodel
    : public ISubmodel {
 public:
  explicit Submodel(
    std::wstring id,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IAdministrativeInformation>
    > administration = common::nullopt,
    common::optional<ModellingKind> kind = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > submodel_elements = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set administration_

  const common::optional<
    std::shared_ptr<IAdministrativeInformation>
  >& administration() const override;

  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  >& mutable_administration() override;

  void set_administration(
    common::optional<
      std::shared_ptr<IAdministrativeInformation>
    > value
  ) override;

  // endregion

  // region Get and set id_

  const std::wstring& id() const override;

  std::wstring& mutable_id() override;

  void set_id(
    std::wstring value
  ) override;

  // endregion

  // region Get and set kind_

  const common::optional<ModellingKind>& kind() const override;

  common::optional<ModellingKind>& mutable_kind() override;

  void set_kind(
    common::optional<ModellingKind> value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set submodel_elements_

  const common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& submodel_elements() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& mutable_submodel_elements() override;

  void set_submodel_elements(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value
  ) override;

  // endregion

  ModellingKind KindOrDefault() const override;

  ~Submodel() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > administration_;

  std::wstring id_;

  common::optional<ModellingKind> kind_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > submodel_elements_;
};

class RelationshipElement
    : public IRelationshipElement {
 public:
  RelationshipElement(
    std::shared_ptr<IReference> first,
    std::shared_ptr<IReference> second,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set first_

  const std::shared_ptr<IReference>& first() const override;

  std::shared_ptr<IReference>& mutable_first() override;

  void set_first(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  // region Get and set second_

  const std::shared_ptr<IReference>& second() const override;

  std::shared_ptr<IReference>& mutable_second() override;

  void set_second(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  ~RelationshipElement() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  std::shared_ptr<IReference> first_;

  std::shared_ptr<IReference> second_;
};

class SubmodelElementList
    : public ISubmodelElementList {
 public:
  explicit SubmodelElementList(
    AasSubmodelElements type_value_list_element,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<bool> order_relevant = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id_list_element = common::nullopt,
    common::optional<DataTypeDefXsd> value_type_list_element = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set order_relevant_

  const common::optional<bool>& order_relevant() const override;

  common::optional<bool>& mutable_order_relevant() override;

  void set_order_relevant(
    common::optional<bool> value
  ) override;

  // endregion

  // region Get and set semantic_id_list_element_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id_list_element() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id_list_element() override;

  void set_semantic_id_list_element(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set type_value_list_element_

  AasSubmodelElements type_value_list_element() const override;

  AasSubmodelElements& mutable_type_value_list_element() override;

  void set_type_value_list_element(
    AasSubmodelElements value
  ) override;

  // endregion

  // region Get and set value_type_list_element_

  const common::optional<DataTypeDefXsd>& value_type_list_element() const override;

  common::optional<DataTypeDefXsd>& mutable_value_type_list_element() override;

  void set_value_type_list_element(
    common::optional<DataTypeDefXsd> value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& value() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& mutable_value() override;

  void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value
  ) override;

  // endregion

  bool OrderRelevantOrDefault() const override;

  ~SubmodelElementList() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<bool> order_relevant_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_list_element_;

  AasSubmodelElements type_value_list_element_;

  common::optional<DataTypeDefXsd> value_type_list_element_;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > value_;
};

class SubmodelElementCollection
    : public ISubmodelElementCollection {
 public:
  SubmodelElementCollection(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& value() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& mutable_value() override;

  void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value
  ) override;

  // endregion

  ~SubmodelElementCollection() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > value_;
};

class Property
    : public IProperty {
 public:
  explicit Property(
    DataTypeDefXsd value_type,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<std::wstring> value = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > value_id = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_type_

  DataTypeDefXsd value_type() const override;

  DataTypeDefXsd& mutable_value_type() override;

  void set_value_type(
    DataTypeDefXsd value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<std::wstring>& value() const override;

  common::optional<std::wstring>& mutable_value() override;

  void set_value(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set value_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& value_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_value_id() override;

  void set_value_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  std::wstring CategoryOrDefault() const override;

  ~Property() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  DataTypeDefXsd value_type_;

  common::optional<std::wstring> value_;

  common::optional<
    std::shared_ptr<IReference>
  > value_id_;
};

class MultiLanguageProperty
    : public IMultiLanguageProperty {
 public:
  MultiLanguageProperty(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > value_id = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& value() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_value() override;

  void set_value(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& value_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_value_id() override;

  void set_value_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  std::wstring CategoryOrDefault() const override;

  ~MultiLanguageProperty() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > value_;

  common::optional<
    std::shared_ptr<IReference>
  > value_id_;
};

class Range
    : public IRange {
 public:
  explicit Range(
    DataTypeDefXsd value_type,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<std::wstring> min = common::nullopt,
    common::optional<std::wstring> max = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_type_

  DataTypeDefXsd value_type() const override;

  DataTypeDefXsd& mutable_value_type() override;

  void set_value_type(
    DataTypeDefXsd value
  ) override;

  // endregion

  // region Get and set min_

  const common::optional<std::wstring>& min() const override;

  common::optional<std::wstring>& mutable_min() override;

  void set_min(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set max_

  const common::optional<std::wstring>& max() const override;

  common::optional<std::wstring>& mutable_max() override;

  void set_max(
    common::optional<std::wstring> value
  ) override;

  // endregion

  std::wstring CategoryOrDefault() const override;

  ~Range() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  DataTypeDefXsd value_type_;

  common::optional<std::wstring> min_;

  common::optional<std::wstring> max_;
};

class ReferenceElement
    : public IReferenceElement {
 public:
  ReferenceElement(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > value = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<
    std::shared_ptr<IReference>
  >& value() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_value() override;

  void set_value(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  std::wstring CategoryOrDefault() const override;

  ~ReferenceElement() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::shared_ptr<IReference>
  > value_;
};

class Blob
    : public IBlob {
 public:
  explicit Blob(
    std::wstring content_type,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::vector<std::uint8_t>
    > value = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<
    std::vector<std::uint8_t>
  >& value() const override;

  common::optional<
    std::vector<std::uint8_t>
  >& mutable_value() override;

  void set_value(
    common::optional<
      std::vector<std::uint8_t>
    > value
  ) override;

  // endregion

  // region Get and set content_type_

  const std::wstring& content_type() const override;

  std::wstring& mutable_content_type() override;

  void set_content_type(
    std::wstring value
  ) override;

  // endregion

  std::wstring CategoryOrDefault() const override;

  ~Blob() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::vector<std::uint8_t>
  > value_;

  std::wstring content_type_;
};

class File
    : public IFile {
 public:
  explicit File(
    std::wstring content_type,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<std::wstring> value = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<std::wstring>& value() const override;

  common::optional<std::wstring>& mutable_value() override;

  void set_value(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set content_type_

  const std::wstring& content_type() const override;

  std::wstring& mutable_content_type() override;

  void set_content_type(
    std::wstring value
  ) override;

  // endregion

  std::wstring CategoryOrDefault() const override;

  ~File() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<std::wstring> value_;

  std::wstring content_type_;
};

class AnnotatedRelationshipElement
    : public IAnnotatedRelationshipElement {
 public:
  AnnotatedRelationshipElement(
    std::shared_ptr<IReference> first,
    std::shared_ptr<IReference> second,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IDataElement>
      >
    > annotations = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set first_

  const std::shared_ptr<IReference>& first() const override;

  std::shared_ptr<IReference>& mutable_first() override;

  void set_first(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  // region Get and set second_

  const std::shared_ptr<IReference>& second() const override;

  std::shared_ptr<IReference>& mutable_second() override;

  void set_second(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  // region Get and set annotations_

  const common::optional<
    std::vector<
      std::shared_ptr<IDataElement>
    >
  >& annotations() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IDataElement>
    >
  >& mutable_annotations() override;

  void set_annotations(
    common::optional<
      std::vector<
        std::shared_ptr<IDataElement>
      >
    > value
  ) override;

  // endregion

  ~AnnotatedRelationshipElement() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  std::shared_ptr<IReference> first_;

  std::shared_ptr<IReference> second_;

  common::optional<
    std::vector<
      std::shared_ptr<IDataElement>
    >
  > annotations_;
};

class Entity
    : public IEntity {
 public:
  explicit Entity(
    EntityType entity_type,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > statements = common::nullopt,
    common::optional<std::wstring> global_asset_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ISpecificAssetId>
      >
    > specific_asset_ids = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set statements_

  const common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& statements() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  >& mutable_statements() override;

  void set_statements(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodelElement>
      >
    > value
  ) override;

  // endregion

  // region Get and set entity_type_

  EntityType entity_type() const override;

  EntityType& mutable_entity_type() override;

  void set_entity_type(
    EntityType value
  ) override;

  // endregion

  // region Get and set global_asset_id_

  const common::optional<std::wstring>& global_asset_id() const override;

  common::optional<std::wstring>& mutable_global_asset_id() override;

  void set_global_asset_id(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set specific_asset_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  >& specific_asset_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  >& mutable_specific_asset_ids() override;

  void set_specific_asset_ids(
    common::optional<
      std::vector<
        std::shared_ptr<ISpecificAssetId>
      >
    > value
  ) override;

  // endregion

  ~Entity() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodelElement>
    >
  > statements_;

  EntityType entity_type_;

  common::optional<std::wstring> global_asset_id_;

  common::optional<
    std::vector<
      std::shared_ptr<ISpecificAssetId>
    >
  > specific_asset_ids_;
};

class EventPayload
    : public IEventPayload {
 public:
  EventPayload(
    std::shared_ptr<IReference> source,
    std::shared_ptr<IReference> observable_reference,
    std::wstring time_stamp,
    common::optional<
      std::shared_ptr<IReference>
    > source_semantic_id = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > observable_semantic_id = common::nullopt,
    common::optional<std::wstring> topic = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > subject_id = common::nullopt,
    common::optional<
      std::vector<std::uint8_t>
    > payload = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set source_

  const std::shared_ptr<IReference>& source() const override;

  std::shared_ptr<IReference>& mutable_source() override;

  void set_source(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  // region Get and set source_semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& source_semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_source_semantic_id() override;

  void set_source_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set observable_reference_

  const std::shared_ptr<IReference>& observable_reference() const override;

  std::shared_ptr<IReference>& mutable_observable_reference() override;

  void set_observable_reference(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  // region Get and set observable_semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& observable_semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_observable_semantic_id() override;

  void set_observable_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set topic_

  const common::optional<std::wstring>& topic() const override;

  common::optional<std::wstring>& mutable_topic() override;

  void set_topic(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set subject_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& subject_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_subject_id() override;

  void set_subject_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set time_stamp_

  const std::wstring& time_stamp() const override;

  std::wstring& mutable_time_stamp() override;

  void set_time_stamp(
    std::wstring value
  ) override;

  // endregion

  // region Get and set payload_

  const common::optional<
    std::vector<std::uint8_t>
  >& payload() const override;

  common::optional<
    std::vector<std::uint8_t>
  >& mutable_payload() override;

  void set_payload(
    common::optional<
      std::vector<std::uint8_t>
    > value
  ) override;

  // endregion

  ~EventPayload() override = default;

 private:
  std::shared_ptr<IReference> source_;

  common::optional<
    std::shared_ptr<IReference>
  > source_semantic_id_;

  std::shared_ptr<IReference> observable_reference_;

  common::optional<
    std::shared_ptr<IReference>
  > observable_semantic_id_;

  common::optional<std::wstring> topic_;

  common::optional<
    std::shared_ptr<IReference>
  > subject_id_;

  std::wstring time_stamp_;

  common::optional<
    std::vector<std::uint8_t>
  > payload_;
};

class BasicEventElement
    : public IBasicEventElement {
 public:
  BasicEventElement(
    std::shared_ptr<IReference> observed,
    Direction direction,
    StateOfEvent state,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<std::wstring> message_topic = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > message_broker = common::nullopt,
    common::optional<std::wstring> last_update = common::nullopt,
    common::optional<std::wstring> min_interval = common::nullopt,
    common::optional<std::wstring> max_interval = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set observed_

  const std::shared_ptr<IReference>& observed() const override;

  std::shared_ptr<IReference>& mutable_observed() override;

  void set_observed(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  // region Get and set direction_

  Direction direction() const override;

  Direction& mutable_direction() override;

  void set_direction(
    Direction value
  ) override;

  // endregion

  // region Get and set state_

  StateOfEvent state() const override;

  StateOfEvent& mutable_state() override;

  void set_state(
    StateOfEvent value
  ) override;

  // endregion

  // region Get and set message_topic_

  const common::optional<std::wstring>& message_topic() const override;

  common::optional<std::wstring>& mutable_message_topic() override;

  void set_message_topic(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set message_broker_

  const common::optional<
    std::shared_ptr<IReference>
  >& message_broker() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_message_broker() override;

  void set_message_broker(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set last_update_

  const common::optional<std::wstring>& last_update() const override;

  common::optional<std::wstring>& mutable_last_update() override;

  void set_last_update(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set min_interval_

  const common::optional<std::wstring>& min_interval() const override;

  common::optional<std::wstring>& mutable_min_interval() override;

  void set_min_interval(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set max_interval_

  const common::optional<std::wstring>& max_interval() const override;

  common::optional<std::wstring>& mutable_max_interval() override;

  void set_max_interval(
    common::optional<std::wstring> value
  ) override;

  // endregion

  ~BasicEventElement() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  std::shared_ptr<IReference> observed_;

  Direction direction_;

  StateOfEvent state_;

  common::optional<std::wstring> message_topic_;

  common::optional<
    std::shared_ptr<IReference>
  > message_broker_;

  common::optional<std::wstring> last_update_;

  common::optional<std::wstring> min_interval_;

  common::optional<std::wstring> max_interval_;
};

class Operation
    : public IOperation {
 public:
  Operation(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > input_variables = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > output_variables = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > inoutput_variables = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set input_variables_

  const common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& input_variables() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& mutable_input_variables() override;

  void set_input_variables(
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > value
  ) override;

  // endregion

  // region Get and set output_variables_

  const common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& output_variables() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& mutable_output_variables() override;

  void set_output_variables(
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > value
  ) override;

  // endregion

  // region Get and set inoutput_variables_

  const common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& inoutput_variables() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  >& mutable_inoutput_variables() override;

  void set_inoutput_variables(
    common::optional<
      std::vector<
        std::shared_ptr<IOperationVariable>
      >
    > value
  ) override;

  // endregion

  ~Operation() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > input_variables_;

  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > output_variables_;

  common::optional<
    std::vector<
      std::shared_ptr<IOperationVariable>
    >
  > inoutput_variables_;
};

class OperationVariable
    : public IOperationVariable {
 public:
  explicit OperationVariable(
    std::shared_ptr<ISubmodelElement> value
  );

  ModelType model_type() const override;

  // region Get and set value_

  const std::shared_ptr<ISubmodelElement>& value() const override;

  std::shared_ptr<ISubmodelElement>& mutable_value() override;

  void set_value(
    std::shared_ptr<ISubmodelElement> value
  ) override;

  // endregion

  ~OperationVariable() override = default;

 private:
  std::shared_ptr<ISubmodelElement> value_;
};

class Capability
    : public ICapability {
 public:
  Capability(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > semantic_id = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > supplemental_semantic_ids = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > qualifiers = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_semantic_id() override;

  void set_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set supplemental_semantic_ids_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& supplemental_semantic_ids() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_supplemental_semantic_ids() override;

  void set_supplemental_semantic_ids(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  // region Get and set qualifiers_

  const common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& qualifiers() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  >& mutable_qualifiers() override;

  void set_qualifiers(
    common::optional<
      std::vector<
        std::shared_ptr<IQualifier>
      >
    > value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  ~Capability() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IReference>
  > semantic_id_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > supplemental_semantic_ids_;

  common::optional<
    std::vector<
      std::shared_ptr<IQualifier>
    >
  > qualifiers_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;
};

class ConceptDescription
    : public IConceptDescription {
 public:
  explicit ConceptDescription(
    std::wstring id,
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > extensions = common::nullopt,
    common::optional<std::wstring> category = common::nullopt,
    common::optional<std::wstring> id_short = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > display_name = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > description = common::nullopt,
    common::optional<
      std::shared_ptr<IAdministrativeInformation>
    > administration = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > embedded_data_specifications = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > is_case_of = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set extensions_

  const common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& extensions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  >& mutable_extensions() override;

  void set_extensions(
    common::optional<
      std::vector<
        std::shared_ptr<IExtension>
      >
    > value
  ) override;

  // endregion

  // region Get and set category_

  const common::optional<std::wstring>& category() const override;

  common::optional<std::wstring>& mutable_category() override;

  void set_category(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set id_short_

  const common::optional<std::wstring>& id_short() const override;

  common::optional<std::wstring>& mutable_id_short() override;

  void set_id_short(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set display_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& display_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  >& mutable_display_name() override;

  void set_display_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringNameType>
      >
    > value
  ) override;

  // endregion

  // region Get and set description_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& description() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  >& mutable_description() override;

  void set_description(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringTextType>
      >
    > value
  ) override;

  // endregion

  // region Get and set administration_

  const common::optional<
    std::shared_ptr<IAdministrativeInformation>
  >& administration() const override;

  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  >& mutable_administration() override;

  void set_administration(
    common::optional<
      std::shared_ptr<IAdministrativeInformation>
    > value
  ) override;

  // endregion

  // region Get and set id_

  const std::wstring& id() const override;

  std::wstring& mutable_id() override;

  void set_id(
    std::wstring value
  ) override;

  // endregion

  // region Get and set embedded_data_specifications_

  const common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& embedded_data_specifications() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  >& mutable_embedded_data_specifications() override;

  void set_embedded_data_specifications(
    common::optional<
      std::vector<
        std::shared_ptr<IEmbeddedDataSpecification>
      >
    > value
  ) override;

  // endregion

  // region Get and set is_case_of_

  const common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& is_case_of() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  >& mutable_is_case_of() override;

  void set_is_case_of(
    common::optional<
      std::vector<
        std::shared_ptr<IReference>
      >
    > value
  ) override;

  // endregion

  ~ConceptDescription() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IExtension>
    >
  > extensions_;

  common::optional<std::wstring> category_;

  common::optional<std::wstring> id_short_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringNameType>
    >
  > display_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringTextType>
    >
  > description_;

  common::optional<
    std::shared_ptr<IAdministrativeInformation>
  > administration_;

  std::wstring id_;

  common::optional<
    std::vector<
      std::shared_ptr<IEmbeddedDataSpecification>
    >
  > embedded_data_specifications_;

  common::optional<
    std::vector<
      std::shared_ptr<IReference>
    >
  > is_case_of_;
};

class Reference
    : public IReference {
 public:
  Reference(
    ReferenceTypes type,
    std::vector<
      std::shared_ptr<IKey>
    > keys,
    common::optional<
      std::shared_ptr<IReference>
    > referred_semantic_id = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set type_

  ReferenceTypes type() const override;

  ReferenceTypes& mutable_type() override;

  void set_type(
    ReferenceTypes value
  ) override;

  // endregion

  // region Get and set referred_semantic_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& referred_semantic_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_referred_semantic_id() override;

  void set_referred_semantic_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set keys_

  const std::vector<
    std::shared_ptr<IKey>
  >& keys() const override;

  std::vector<
    std::shared_ptr<IKey>
  >& mutable_keys() override;

  void set_keys(
    std::vector<
      std::shared_ptr<IKey>
    > value
  ) override;

  // endregion

  ~Reference() override = default;

 private:
  ReferenceTypes type_;

  common::optional<
    std::shared_ptr<IReference>
  > referred_semantic_id_;

  std::vector<
    std::shared_ptr<IKey>
  > keys_;
};

class Key
    : public IKey {
 public:
  Key(
    KeyTypes type,
    std::wstring value
  );

  ModelType model_type() const override;

  // region Get and set type_

  KeyTypes type() const override;

  KeyTypes& mutable_type() override;

  void set_type(
    KeyTypes value
  ) override;

  // endregion

  // region Get and set value_

  const std::wstring& value() const override;

  std::wstring& mutable_value() override;

  void set_value(
    std::wstring value
  ) override;

  // endregion

  ~Key() override = default;

 private:
  KeyTypes type_;

  std::wstring value_;
};

class LangStringNameType
    : public ILangStringNameType {
 public:
  LangStringNameType(
    std::wstring language,
    std::wstring text
  );

  ModelType model_type() const override;

  // region Get and set language_

  const std::wstring& language() const override;

  std::wstring& mutable_language() override;

  void set_language(
    std::wstring value
  ) override;

  // endregion

  // region Get and set text_

  const std::wstring& text() const override;

  std::wstring& mutable_text() override;

  void set_text(
    std::wstring value
  ) override;

  // endregion

  ~LangStringNameType() override = default;

 private:
  std::wstring language_;

  std::wstring text_;
};

class LangStringTextType
    : public ILangStringTextType {
 public:
  LangStringTextType(
    std::wstring language,
    std::wstring text
  );

  ModelType model_type() const override;

  // region Get and set language_

  const std::wstring& language() const override;

  std::wstring& mutable_language() override;

  void set_language(
    std::wstring value
  ) override;

  // endregion

  // region Get and set text_

  const std::wstring& text() const override;

  std::wstring& mutable_text() override;

  void set_text(
    std::wstring value
  ) override;

  // endregion

  ~LangStringTextType() override = default;

 private:
  std::wstring language_;

  std::wstring text_;
};

class Environment
    : public IEnvironment {
 public:
  Environment(
    common::optional<
      std::vector<
        std::shared_ptr<IAssetAdministrationShell>
      >
    > asset_administration_shells = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodel>
      >
    > submodels = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<IConceptDescription>
      >
    > concept_descriptions = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set asset_administration_shells_

  const common::optional<
    std::vector<
      std::shared_ptr<IAssetAdministrationShell>
    >
  >& asset_administration_shells() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IAssetAdministrationShell>
    >
  >& mutable_asset_administration_shells() override;

  void set_asset_administration_shells(
    common::optional<
      std::vector<
        std::shared_ptr<IAssetAdministrationShell>
      >
    > value
  ) override;

  // endregion

  // region Get and set submodels_

  const common::optional<
    std::vector<
      std::shared_ptr<ISubmodel>
    >
  >& submodels() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodel>
    >
  >& mutable_submodels() override;

  void set_submodels(
    common::optional<
      std::vector<
        std::shared_ptr<ISubmodel>
      >
    > value
  ) override;

  // endregion

  // region Get and set concept_descriptions_

  const common::optional<
    std::vector<
      std::shared_ptr<IConceptDescription>
    >
  >& concept_descriptions() const override;

  common::optional<
    std::vector<
      std::shared_ptr<IConceptDescription>
    >
  >& mutable_concept_descriptions() override;

  void set_concept_descriptions(
    common::optional<
      std::vector<
        std::shared_ptr<IConceptDescription>
      >
    > value
  ) override;

  // endregion

  ~Environment() override = default;

 private:
  common::optional<
    std::vector<
      std::shared_ptr<IAssetAdministrationShell>
    >
  > asset_administration_shells_;

  common::optional<
    std::vector<
      std::shared_ptr<ISubmodel>
    >
  > submodels_;

  common::optional<
    std::vector<
      std::shared_ptr<IConceptDescription>
    >
  > concept_descriptions_;
};

class EmbeddedDataSpecification
    : public IEmbeddedDataSpecification {
 public:
  EmbeddedDataSpecification(
    std::shared_ptr<IDataSpecificationContent> data_specification_content,
    std::shared_ptr<IReference> data_specification
  );

  ModelType model_type() const override;

  // region Get and set data_specification_content_

  const std::shared_ptr<IDataSpecificationContent>& data_specification_content() const override;

  std::shared_ptr<IDataSpecificationContent>& mutable_data_specification_content() override;

  void set_data_specification_content(
    std::shared_ptr<IDataSpecificationContent> value
  ) override;

  // endregion

  // region Get and set data_specification_

  const std::shared_ptr<IReference>& data_specification() const override;

  std::shared_ptr<IReference>& mutable_data_specification() override;

  void set_data_specification(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  ~EmbeddedDataSpecification() override = default;

 private:
  std::shared_ptr<IDataSpecificationContent> data_specification_content_;

  std::shared_ptr<IReference> data_specification_;
};

class LevelType
    : public ILevelType {
 public:
  LevelType(
    bool min,
    bool nom,
    bool typ,
    bool max
  );

  ModelType model_type() const override;

  // region Get and set min_

  bool min() const override;

  bool& mutable_min() override;

  void set_min(
    bool value
  ) override;

  // endregion

  // region Get and set nom_

  bool nom() const override;

  bool& mutable_nom() override;

  void set_nom(
    bool value
  ) override;

  // endregion

  // region Get and set typ_

  bool typ() const override;

  bool& mutable_typ() override;

  void set_typ(
    bool value
  ) override;

  // endregion

  // region Get and set max_

  bool max() const override;

  bool& mutable_max() override;

  void set_max(
    bool value
  ) override;

  // endregion

  ~LevelType() override = default;

 private:
  bool min_;

  bool nom_;

  bool typ_;

  bool max_;
};

class ValueReferencePair
    : public IValueReferencePair {
 public:
  ValueReferencePair(
    std::wstring value,
    std::shared_ptr<IReference> value_id
  );

  ModelType model_type() const override;

  // region Get and set value_

  const std::wstring& value() const override;

  std::wstring& mutable_value() override;

  void set_value(
    std::wstring value
  ) override;

  // endregion

  // region Get and set value_id_

  const std::shared_ptr<IReference>& value_id() const override;

  std::shared_ptr<IReference>& mutable_value_id() override;

  void set_value_id(
    std::shared_ptr<IReference> value
  ) override;

  // endregion

  ~ValueReferencePair() override = default;

 private:
  std::wstring value_;

  std::shared_ptr<IReference> value_id_;
};

class ValueList
    : public IValueList {
 public:
  explicit ValueList(
    std::vector<
      std::shared_ptr<IValueReferencePair>
    > value_reference_pairs
  );

  ModelType model_type() const override;

  // region Get and set value_reference_pairs_

  const std::vector<
    std::shared_ptr<IValueReferencePair>
  >& value_reference_pairs() const override;

  std::vector<
    std::shared_ptr<IValueReferencePair>
  >& mutable_value_reference_pairs() override;

  void set_value_reference_pairs(
    std::vector<
      std::shared_ptr<IValueReferencePair>
    > value
  ) override;

  // endregion

  ~ValueList() override = default;

 private:
  std::vector<
    std::shared_ptr<IValueReferencePair>
  > value_reference_pairs_;
};

class LangStringPreferredNameTypeIec61360
    : public ILangStringPreferredNameTypeIec61360 {
 public:
  LangStringPreferredNameTypeIec61360(
    std::wstring language,
    std::wstring text
  );

  ModelType model_type() const override;

  // region Get and set language_

  const std::wstring& language() const override;

  std::wstring& mutable_language() override;

  void set_language(
    std::wstring value
  ) override;

  // endregion

  // region Get and set text_

  const std::wstring& text() const override;

  std::wstring& mutable_text() override;

  void set_text(
    std::wstring value
  ) override;

  // endregion

  ~LangStringPreferredNameTypeIec61360() override = default;

 private:
  std::wstring language_;

  std::wstring text_;
};

class LangStringShortNameTypeIec61360
    : public ILangStringShortNameTypeIec61360 {
 public:
  LangStringShortNameTypeIec61360(
    std::wstring language,
    std::wstring text
  );

  ModelType model_type() const override;

  // region Get and set language_

  const std::wstring& language() const override;

  std::wstring& mutable_language() override;

  void set_language(
    std::wstring value
  ) override;

  // endregion

  // region Get and set text_

  const std::wstring& text() const override;

  std::wstring& mutable_text() override;

  void set_text(
    std::wstring value
  ) override;

  // endregion

  ~LangStringShortNameTypeIec61360() override = default;

 private:
  std::wstring language_;

  std::wstring text_;
};

class LangStringDefinitionTypeIec61360
    : public ILangStringDefinitionTypeIec61360 {
 public:
  LangStringDefinitionTypeIec61360(
    std::wstring language,
    std::wstring text
  );

  ModelType model_type() const override;

  // region Get and set language_

  const std::wstring& language() const override;

  std::wstring& mutable_language() override;

  void set_language(
    std::wstring value
  ) override;

  // endregion

  // region Get and set text_

  const std::wstring& text() const override;

  std::wstring& mutable_text() override;

  void set_text(
    std::wstring value
  ) override;

  // endregion

  ~LangStringDefinitionTypeIec61360() override = default;

 private:
  std::wstring language_;

  std::wstring text_;
};

class DataSpecificationIec61360
    : public IDataSpecificationIec61360 {
 public:
  explicit DataSpecificationIec61360(
    std::vector<
      std::shared_ptr<ILangStringPreferredNameTypeIec61360>
    > preferred_name,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringShortNameTypeIec61360>
      >
    > short_name = common::nullopt,
    common::optional<std::wstring> unit = common::nullopt,
    common::optional<
      std::shared_ptr<IReference>
    > unit_id = common::nullopt,
    common::optional<std::wstring> source_of_definition = common::nullopt,
    common::optional<std::wstring> symbol = common::nullopt,
    common::optional<DataTypeIec61360> data_type = common::nullopt,
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringDefinitionTypeIec61360>
      >
    > definition = common::nullopt,
    common::optional<std::wstring> value_format = common::nullopt,
    common::optional<
      std::shared_ptr<IValueList>
    > value_list = common::nullopt,
    common::optional<std::wstring> value = common::nullopt,
    common::optional<
      std::shared_ptr<ILevelType>
    > level_type = common::nullopt
  );

  ModelType model_type() const override;

  // region Get and set preferred_name_

  const std::vector<
    std::shared_ptr<ILangStringPreferredNameTypeIec61360>
  >& preferred_name() const override;

  std::vector<
    std::shared_ptr<ILangStringPreferredNameTypeIec61360>
  >& mutable_preferred_name() override;

  void set_preferred_name(
    std::vector<
      std::shared_ptr<ILangStringPreferredNameTypeIec61360>
    > value
  ) override;

  // endregion

  // region Get and set short_name_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringShortNameTypeIec61360>
    >
  >& short_name() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringShortNameTypeIec61360>
    >
  >& mutable_short_name() override;

  void set_short_name(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringShortNameTypeIec61360>
      >
    > value
  ) override;

  // endregion

  // region Get and set unit_

  const common::optional<std::wstring>& unit() const override;

  common::optional<std::wstring>& mutable_unit() override;

  void set_unit(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set unit_id_

  const common::optional<
    std::shared_ptr<IReference>
  >& unit_id() const override;

  common::optional<
    std::shared_ptr<IReference>
  >& mutable_unit_id() override;

  void set_unit_id(
    common::optional<
      std::shared_ptr<IReference>
    > value
  ) override;

  // endregion

  // region Get and set source_of_definition_

  const common::optional<std::wstring>& source_of_definition() const override;

  common::optional<std::wstring>& mutable_source_of_definition() override;

  void set_source_of_definition(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set symbol_

  const common::optional<std::wstring>& symbol() const override;

  common::optional<std::wstring>& mutable_symbol() override;

  void set_symbol(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set data_type_

  const common::optional<DataTypeIec61360>& data_type() const override;

  common::optional<DataTypeIec61360>& mutable_data_type() override;

  void set_data_type(
    common::optional<DataTypeIec61360> value
  ) override;

  // endregion

  // region Get and set definition_

  const common::optional<
    std::vector<
      std::shared_ptr<ILangStringDefinitionTypeIec61360>
    >
  >& definition() const override;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringDefinitionTypeIec61360>
    >
  >& mutable_definition() override;

  void set_definition(
    common::optional<
      std::vector<
        std::shared_ptr<ILangStringDefinitionTypeIec61360>
      >
    > value
  ) override;

  // endregion

  // region Get and set value_format_

  const common::optional<std::wstring>& value_format() const override;

  common::optional<std::wstring>& mutable_value_format() override;

  void set_value_format(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set value_list_

  const common::optional<
    std::shared_ptr<IValueList>
  >& value_list() const override;

  common::optional<
    std::shared_ptr<IValueList>
  >& mutable_value_list() override;

  void set_value_list(
    common::optional<
      std::shared_ptr<IValueList>
    > value
  ) override;

  // endregion

  // region Get and set value_

  const common::optional<std::wstring>& value() const override;

  common::optional<std::wstring>& mutable_value() override;

  void set_value(
    common::optional<std::wstring> value
  ) override;

  // endregion

  // region Get and set level_type_

  const common::optional<
    std::shared_ptr<ILevelType>
  >& level_type() const override;

  common::optional<
    std::shared_ptr<ILevelType>
  >& mutable_level_type() override;

  void set_level_type(
    common::optional<
      std::shared_ptr<ILevelType>
    > value
  ) override;

  // endregion

  ~DataSpecificationIec61360() override = default;

 private:
  std::vector<
    std::shared_ptr<ILangStringPreferredNameTypeIec61360>
  > preferred_name_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringShortNameTypeIec61360>
    >
  > short_name_;

  common::optional<std::wstring> unit_;

  common::optional<
    std::shared_ptr<IReference>
  > unit_id_;

  common::optional<std::wstring> source_of_definition_;

  common::optional<std::wstring> symbol_;

  common::optional<DataTypeIec61360> data_type_;

  common::optional<
    std::vector<
      std::shared_ptr<ILangStringDefinitionTypeIec61360>
    >
  > definition_;

  common::optional<std::wstring> value_format_;

  common::optional<
    std::shared_ptr<IValueList>
  > value_list_;

  common::optional<std::wstring> value_;

  common::optional<
    std::shared_ptr<ILevelType>
  > level_type_;
};

// endregion

// region Is-a functions

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IHasSemantics.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IHasSemantics
 */
bool IsHasSemantics(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IExtension.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IExtension
 */
bool IsExtension(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IHasExtensions.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IHasExtensions
 */
bool IsHasExtensions(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IReferable.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IReferable
 */
bool IsReferable(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IIdentifiable.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IIdentifiable
 */
bool IsIdentifiable(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IHasKind.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IHasKind
 */
bool IsHasKind(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IHasDataSpecification.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IHasDataSpecification
 */
bool IsHasDataSpecification(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IAdministrativeInformation.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IAdministrativeInformation
 */
bool IsAdministrativeInformation(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IQualifiable.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IQualifiable
 */
bool IsQualifiable(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IQualifier.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IQualifier
 */
bool IsQualifier(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IAssetAdministrationShell.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IAssetAdministrationShell
 */
bool IsAssetAdministrationShell(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IAssetInformation.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IAssetInformation
 */
bool IsAssetInformation(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IResource.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IResource
 */
bool IsResource(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ISpecificAssetId.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ISpecificAssetId
 */
bool IsSpecificAssetId(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ISubmodel.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ISubmodel
 */
bool IsSubmodel(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ISubmodelElement.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ISubmodelElement
 */
bool IsSubmodelElement(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IRelationshipElement.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IRelationshipElement
 */
bool IsRelationshipElement(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ISubmodelElementList.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ISubmodelElementList
 */
bool IsSubmodelElementList(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ISubmodelElementCollection.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ISubmodelElementCollection
 */
bool IsSubmodelElementCollection(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IDataElement.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IDataElement
 */
bool IsDataElement(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IProperty.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IProperty
 */
bool IsProperty(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IMultiLanguageProperty.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IMultiLanguageProperty
 */
bool IsMultiLanguageProperty(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IRange.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IRange
 */
bool IsRange(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IReferenceElement.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IReferenceElement
 */
bool IsReferenceElement(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IBlob.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IBlob
 */
bool IsBlob(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IFile.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IFile
 */
bool IsFile(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IAnnotatedRelationshipElement.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IAnnotatedRelationshipElement
 */
bool IsAnnotatedRelationshipElement(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IEntity.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IEntity
 */
bool IsEntity(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IEventPayload.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IEventPayload
 */
bool IsEventPayload(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IEventElement.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IEventElement
 */
bool IsEventElement(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IBasicEventElement.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IBasicEventElement
 */
bool IsBasicEventElement(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IOperation.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IOperation
 */
bool IsOperation(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IOperationVariable.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IOperationVariable
 */
bool IsOperationVariable(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ICapability.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ICapability
 */
bool IsCapability(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IConceptDescription.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IConceptDescription
 */
bool IsConceptDescription(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IReference.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IReference
 */
bool IsReference(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IKey.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IKey
 */
bool IsKey(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IAbstractLangString.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IAbstractLangString
 */
bool IsAbstractLangString(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ILangStringNameType.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ILangStringNameType
 */
bool IsLangStringNameType(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ILangStringTextType.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ILangStringTextType
 */
bool IsLangStringTextType(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IEnvironment.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IEnvironment
 */
bool IsEnvironment(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IDataSpecificationContent.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IDataSpecificationContent
 */
bool IsDataSpecificationContent(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IEmbeddedDataSpecification.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IEmbeddedDataSpecification
 */
bool IsEmbeddedDataSpecification(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ILevelType.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ILevelType
 */
bool IsLevelType(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IValueReferencePair.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IValueReferencePair
 */
bool IsValueReferencePair(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IValueList.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IValueList
 */
bool IsValueList(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ILangStringPreferredNameTypeIec61360.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ILangStringPreferredNameTypeIec61360
 */
bool IsLangStringPreferredNameTypeIec61360(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ILangStringShortNameTypeIec61360.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ILangStringShortNameTypeIec61360
 */
bool IsLangStringShortNameTypeIec61360(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref ILangStringDefinitionTypeIec61360.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref ILangStringDefinitionTypeIec61360
 */
bool IsLangStringDefinitionTypeIec61360(
  const IClass& that
);

/**
 * \brief Check whether \p that instance is of runtime type
 * \ref IDataSpecificationIec61360.
 *
 * We use `IClass::model_type` to determine the runtime type, which is
 * a bit faster than native C++'s RTTI.
 *
 * \param that instance to check for runtime type
 * \return `true` if \p that instance is indeed
 * an instance of \ref IDataSpecificationIec61360
 */
bool IsDataSpecificationIec61360(
  const IClass& that
);

// endregion Is-a functions

}  // namespace types
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_TYPES_GUARD_
