#ifndef AAS_CORE_AAS_3_0_REVM_GUARD_
#define AAS_CORE_AAS_3_0_REVM_GUARD_

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#pragma warning(push, 0)
#include <cstdint>
#include <memory>
#include <string>
#include <vector>
#pragma warning(pop)

namespace aas_core {
namespace aas_3_0 {

/**
 * \defgroup revm Match regular expressions using a multi-threaded virtual machine.
 *
 * The implementation in the standard library has exponential time complexity, so it was
 * a major blocker for most of the practical inputs. For example, see this bug report:
 * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=93502
 *
 * This implementation is based on Ken Thompson's approach which uses a virtual
 * machine to match regular expressions. The original technique has been
 * published in:
 * Thompson, K., "Regular expression search algorithm", ACM 11(6) (June 1968)
 *
 * We followed a very clear and concise blog post which described in detail:
 * https://swtch.com/~rsc/regexp/regexp2.html
 *
 * The ideas for additional instructions were taken from:
 * https://www.codeproject.com/Articles/5256833/Regex-as-a-Tiny-Threaded-Virtual-Machine  
 * @{
 */
namespace revm {

enum class InstructionKind : std::uint8_t {
  Char,
  Set,
  NotSet,
  Any,
  Match,
  Jump,
  Split,
  End
};

/**
 * Represent an instruction of the virtual machine.
 */
struct Instruction {
  // NOTE (mristin):
  // We avoid RTTI for performance reasons, and use our own enumerator instead.
  virtual InstructionKind kind() const = 0;

  virtual ~Instruction() = default;
};

/**
 * Match a single character. 
 *
 * If the character on the String Pointer does not match the `character`, stop this
 * thread as it failed. Otherwise, move the String Pointer to the next character,
 * and the Program Counter to the next instruction.
 */
struct InstructionChar : Instruction {
  wchar_t character;

  explicit InstructionChar(wchar_t a_character);
  InstructionKind kind() const override;
  ~InstructionChar() override = default;
};

std::string to_string(const InstructionChar& instruction);

/**
 * Define a character range.
 */
struct Range {
  wchar_t first;
  wchar_t last;

  Range(wchar_t a_first, wchar_t a_last);
};

std::string to_string(const Range& range);

/**
 * Check whether the character is in any of the given character ranges.
 *
 * @return true if the character is in any of the ranges
 */
bool CharacterInRanges(
  const std::vector<Range>& ranges,
  wchar_t character
);

/**
 * Match a set of characters.
 *
 * If the character on the String Pointer *is not* in the given set, stop this
 * thread as it failed. Otherwise, move the String Pointer to the next character,
 * and the Program Counter to the next instruction.
 */
struct InstructionSet : Instruction {
  std::vector<Range> ranges;

  explicit InstructionSet(std::vector<Range> a_ranges);
  InstructionKind kind() const override;
  ~InstructionSet() override = default;
};

std::string to_string(const InstructionSet& instruction);

/**
 * Match an out-of-set character.
 *
 * If the character on the String Pointer *is* in the given set, stop this
 * thread as it failed. Otherwise, move the String Pointer to the next character,
 * and the Program Counter to the next instruction.
 */
struct InstructionNotSet : Instruction {
  std::vector<Range> ranges;

  explicit InstructionNotSet(std::vector<Range> a_ranges);
  InstructionKind kind() const override;
  ~InstructionNotSet() override = default;
};

std::string to_string(const InstructionNotSet& instruction);

/**
 * Match any character.
 */
struct InstructionAny : Instruction {
  InstructionKind kind() const override;
  ~InstructionAny() override = default;
};

std::string to_string(const InstructionAny&);

/**
 * Stop this thread and signal that we found a match.
 */
struct InstructionMatch : Instruction {
  InstructionKind kind() const override;
  ~InstructionMatch() override = default;
};

std::string to_string(const InstructionMatch&);

/**
 * Jump to the indicated position in the program.
 */
struct InstructionJump : Instruction {
  size_t target;

  explicit InstructionJump(size_t a_target);
  InstructionKind kind() const override;
  ~InstructionJump() override = default;
};

std::string to_string(const InstructionJump& instruction);

/**
 * Split the program in two threads, both jumping to different locations. The string
 * pointer is kept as-is.
 */
struct InstructionSplit : Instruction {
  size_t first_target;
  size_t second_target;

  explicit InstructionSplit(size_t a_first_target, size_t a_second_target);
  InstructionKind kind() const override;
  ~InstructionSplit() override = default;
};

std::string to_string(const InstructionSplit& instruction);

/**
 * Match the end-of-input.
 */
struct InstructionEnd : Instruction {
  InstructionKind kind() const override;
  ~InstructionEnd() override = default;
};

std::string to_string(const InstructionEnd&);

std::string to_string(const Instruction& instruction);

std::string to_string(
  const std::vector<std::unique_ptr<Instruction> >& instructions
);

/**
 * Try to match the program against the text.
 * @return true if the text matches
 */
bool Match(
  const std::vector<std::unique_ptr<Instruction> >& program,
  const std::wstring& text
);

}  // namespace revm
/**@}*/

}  // namespace aas_3_0
}  // namespace aas_core

// This code has been automatically generated by aas-core-codegen.
// Do NOT edit or append.

#endif  // AAS_CORE_AAS_3_0_REVM_GUARD_
