/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package aas_core.aas3_0.reporting;

import java.util.ArrayList;
import java.util.Deque;
import java.util.Collections;
import java.util.Collection;
import java.util.List;
import java.util.LinkedList;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Provide reporting for de/serialization and verification.
 */
public class Reporting
{
    /**
     * Capture a path segment of a value in a model.
     */
    public static abstract class Segment {
        // Intentionally empty.
    }

    public static class NameSegment extends Segment {
        private final String name;
        public NameSegment(String name) {
            this.name = Objects.requireNonNull(name,
                "Argument \"name\" must be non-null.");
        }
        public String getName(){
            return name;
        }
    }

    public static class IndexSegment extends Segment{
        private final Integer index;
        public IndexSegment(int index) {
            this.index = index;
        }
        public Integer getIndex(){
            return index;
        }
    }

    private static final Pattern variableNameRe = Pattern.compile("^[a-zA-Z_][a-zA-Z_0-9]*$");

    /**
     * Generate a JSON Path based on the path segments.
     *
     * <p>See, for example, this page for more information on JSON path:
     * <a href="https://support.smartbear.com/alertsite/docs/monitors/api/endpoint/jsonpath.html">
     */
    public static String generateJsonPath(Collection<Segment> segments) {
        ArrayList<String> parts = new ArrayList<>(segments.size());
        int i = 0;

        for (Segment segment : segments) {
            String part;

            if (segment instanceof NameSegment) {
                NameSegment nameSegment = (NameSegment) segment;
                Matcher m = variableNameRe.matcher(nameSegment.getName());

                if (m.matches()) {
                    part = (i == 0) ? nameSegment.getName() : "." + nameSegment.getName();
                } else {
                    String escaped = nameSegment.getName()
                        .replace("\t", "\\t")
                        .replace("\b", "\\b")
                        .replace("\n", "\\n")
                        .replace("\r", "\\r")
                        .replace("\f", "\\f")
                        .replace("\"", "\\\"")
                        .replace("\\", "\\\\");

                    part = "[\"" + escaped + "\"]";
                }
            } else if (segment instanceof IndexSegment) {
                IndexSegment indexSegment = (IndexSegment) segment;
                part = "[" + indexSegment.getIndex() + "]";
            } else {
                throw new RuntimeException(
                    "Unexpected segment type: " + segment.getClass().getSimpleName()
                );
            }

            parts.add(part);
            i++;
        }
        return String.join("", parts);
    }

    /**
     * Escape special characters for XPath.
     */
    private static String escapeForXPath(String text) {
    return text
            .replace("&", "&amp;")
            .replace("/", "&#47;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")
            .replace("'", "&apos;");
    }

    /**
     * Generate a relative XPath based on the path segments.
     *
     * <p>This method leaves out the leading slash ('/'). This is helpful if
     * to embed the error report in a larger document with a prefix etc.
     */
    public static String generateRelativeXPath(Collection<Segment> segments) {
        final List<String> parts = new ArrayList<>();
        segments.forEach(segment -> {
            String part;
            if (segment instanceof NameSegment) {
                final NameSegment nameSegment = ((NameSegment) segment);
                final String name = nameSegment.getName();
                part = escapeForXPath(name);
            } else if (segment instanceof IndexSegment) {
                final IndexSegment indexSegment = ((IndexSegment) segment);
                final int index = indexSegment.getIndex();
                part = "*[" + index + "]";
            } else {
                throw new IllegalArgumentException("Unexpected segment type: " +
                    segment.getClass().getSimpleName());
            }
            parts.add(part);
        });
        return String.join("/", parts);
    }

    /**
     * Represent an error during the deserialization or the verification.
     */
    public static class Error {
        private final Deque<Segment> pathSegments = new LinkedList<>();
        private final String cause;

        public Error(String cause) {
            this.cause = cause;
        }

        public void prependSegment(Segment segment) {
            pathSegments.addFirst(segment);
        }

        public String getCause() {
            return cause;
        }

        public Collection<Segment> getPathSegments() {
            return pathSegments;
        }
    }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
