/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package aas_core.aas3_0.types.impl;

import aas_core.aas3_0.visitation.IVisitor;
import aas_core.aas3_0.visitation.IVisitorWithContext;
import aas_core.aas3_0.visitation.ITransformer;
import aas_core.aas3_0.visitation.ITransformerWithContext;
import aas_core.aas3_0.types.enums.*;
import aas_core.aas3_0.types.impl.*;
import aas_core.aas3_0.types.model.*;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Objects;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import aas_core.aas3_0.types.model.IQualifier;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

/**
 * A qualifier is a type-value-pair that makes additional statements w.r.t. the value
 * of the element.
 *
 * <p>Constraints:
 * <ul>
 *   <li> Constraint AASd-006:
 *   If both the {@link Qualifier#getValue value} and the {@link Qualifier#getValueId valueId} of
 *   a {@link Qualifier} are present then the {@link Qualifier#getValue value} needs
 *   to be identical to the value of the referenced coded value
 *   in {@link Qualifier#getValueId valueId}.
 *   <li> Constraint AASd-020:
 *   The value of {@link Qualifier#getValue value} shall be consistent to the data type as
 *   defined in {@link Qualifier#getValueType valueType}.
 * </ul>
 */
public class Qualifier implements IQualifier {
  /**
   * Identifier of the semantic definition of the element. It is called semantic ID
   * of the element or also main semantic ID of the element.
   *
   * <p>It is recommended to use a global reference.
   */
  private IReference semanticId;

  /**
   * Identifier of a supplemental semantic definition of the element.
   * It is called supplemental semantic ID of the element.
   *
   * <p>It is recommended to use a global reference.
   */
  private List<IReference> supplementalSemanticIds;

  /**
   * The qualifier kind describes the kind of the qualifier that is applied to the
   * element.
   *
   * <p>Default: {@link QualifierKind#CONCEPT_QUALIFIER}
   */
  private QualifierKind kind;

  /**
   * The qualifier <em>type</em> describes the type of the qualifier that is applied to
   * the element.
   */
  private String type;

  /**
   * Data type of the qualifier value.
   */
  private DataTypeDefXsd valueType;

  /**
   * The qualifier value is the value of the qualifier.
   */
  private String value;

  /**
   * Reference to the global unique ID of a coded value.
   *
   * <p>It is recommended to use a global reference.
   */
  private IReference valueId;

  public Qualifier(
    String type,
    DataTypeDefXsd valueType) {
    this.type = Objects.requireNonNull(
      type,
      "Argument \"type\" must be non-null.");
    this.valueType = Objects.requireNonNull(
      valueType,
      "Argument \"valueType\" must be non-null.");
  }

  public Qualifier(
    String type,
    DataTypeDefXsd valueType,
    IReference semanticId,
    List<IReference> supplementalSemanticIds,
    QualifierKind kind,
    String value,
    IReference valueId) {
    this.semanticId = semanticId;
    this.supplementalSemanticIds = supplementalSemanticIds;
    this.type = Objects.requireNonNull(
      type,
      "Argument \"type\" must be non-null.");
    this.valueType = Objects.requireNonNull(
      valueType,
      "Argument \"valueType\" must be non-null.");
    this.kind = kind;
    this.value = value;
    this.valueId = valueId;
  }

  @Override
  public Optional<IReference> getSemanticId() {
    return Optional.ofNullable(semanticId);
  }

  @Override
  public void setSemanticId(IReference semanticId) {
    this.semanticId = semanticId;
  }

  @Override
  public Optional<List<IReference>> getSupplementalSemanticIds() {
    return Optional.ofNullable(supplementalSemanticIds);
  }

  @Override
  public void setSupplementalSemanticIds(List<IReference> supplementalSemanticIds) {
    this.supplementalSemanticIds = supplementalSemanticIds;
  }

  @Override
  public Optional<QualifierKind> getKind() {
    return Optional.ofNullable(kind);
  }

  @Override
  public void setKind(QualifierKind kind) {
    this.kind = kind;
  }

  @Override
  public String getType() {
    return type;
  }

  @Override
  public void setType(String type) {
    this.type = Objects.requireNonNull(
      type,
      "Argument \"type\" must be non-null.");
  }

  @Override
  public DataTypeDefXsd getValueType() {
    return valueType;
  }

  @Override
  public void setValueType(DataTypeDefXsd valueType) {
    this.valueType = Objects.requireNonNull(
      valueType,
      "Argument \"valueType\" must be non-null.");
  }

  @Override
  public Optional<String> getValue() {
    return Optional.ofNullable(value);
  }

  @Override
  public void setValue(String value) {
    this.value = value;
  }

  @Override
  public Optional<IReference> getValueId() {
    return Optional.ofNullable(valueId);
  }

  @Override
  public void setValueId(IReference valueId) {
    this.valueId = valueId;
  }

  /**
   * Iterate over {@link Qualifier#supplementalSemanticIds}, if set,
   * and otherwise return an empty iterator.
   */
  public Iterable<IReference> overSupplementalSemanticIdsOrEmpty() {
    return getSupplementalSemanticIds().orElseGet(Collections::emptyList);
  }

  /**
   * @return the {@link QualifierKind} or the default value if it has not been set.
   */
  public QualifierKind kindOrDefault() {
    return kind != null ? kind : QualifierKind.CONCEPT_QUALIFIER;
  }

  /**
   * Iterate recursively over all the class instances referenced from this instance.
   */
  public Iterable<IClass> descend() {
    return new QualifierRecursiveIterable();
  }

  /**
   * Iterate over all the class instances referenced from this instance.
   */
  public Iterable<IClass> descendOnce() {
    return new QualifierIterable();
  }

  /**
   * Accept the {@code visitor} to visit this instance for double dispatch.
   **/
  @Override
  public void accept(IVisitor visitor) {
    visitor.visitQualifier(this);
  }

  /**
   * Accept the {@code visitor} to visit this instance for double dispatch
   * with the {@code context}.
   **/
  @Override
  public <ContextT> void accept(
      IVisitorWithContext<ContextT> visitor,
      ContextT context) {
    visitor.visitQualifier(this, context);
  }

  /**
   * Accept the {@code transformer} to visit this instance for double dispatch.
   **/
  @Override
  public <T> T transform(ITransformer<T> transformer) {
    return transformer.transformQualifier(this);
  }

  /**
   * Accept the {@code transformer} to visit this instance for double dispatch
   * with the {@code context}.
   **/
  @Override
  public <ContextT, T> T transform(
      ITransformerWithContext<ContextT, T> transformer,
      ContextT context) {
    return transformer.transformQualifier(this, context);
  }

  private class QualifierIterable implements Iterable<IClass> {
    @Override
    public Iterator<IClass> iterator() {
      Stream<IClass> stream = stream();

      return stream.iterator();
    }

    @Override
    public void forEach(Consumer<? super IClass> action) {
      Stream<IClass> stream = stream();

      stream.forEach(action);
    }

    @Override
    public Spliterator<IClass> spliterator() {
      Stream<IClass> stream = stream();

      return stream.spliterator();
    }

    private Stream<IClass> stream() {
      Stream<IClass> memberStream = Stream.empty();

      if (semanticId != null) {
        memberStream = Stream.concat(memberStream,
          Stream.<IClass>of(Qualifier.this.semanticId));
      }

      if (supplementalSemanticIds != null) {
        memberStream = Stream.concat(memberStream,
          Qualifier.this.supplementalSemanticIds.stream());
      }

      if (valueId != null) {
        memberStream = Stream.concat(memberStream,
          Stream.<IClass>of(Qualifier.this.valueId));
      }

      return memberStream;
    }
  }

  private class QualifierRecursiveIterable implements Iterable<IClass> {
    @Override
    public Iterator<IClass> iterator() {
      Stream<IClass> stream = stream();

      return stream.iterator();
    }

    @Override
    public void forEach(Consumer<? super IClass> action) {
      Stream<IClass> stream = stream();

      stream.forEach(action);
    }

    @Override
    public Spliterator<IClass> spliterator() {
      Stream<IClass> stream = stream();

      return stream.spliterator();
    }

    private Stream<IClass> stream() {
      Stream<IClass> memberStream = Stream.empty();

      if (semanticId != null) {
        memberStream = Stream.concat(memberStream,
          Stream.concat(Stream.<IClass>of(Qualifier.this.semanticId),
            StreamSupport.stream(Qualifier.this.semanticId.descend().spliterator(), false)));
      }

      if (supplementalSemanticIds != null) {
        memberStream = Stream.concat(memberStream,
          Qualifier.this.supplementalSemanticIds.stream()
            .flatMap(item -> Stream.concat(Stream.<IClass>of(item),
              StreamSupport.stream(item.descend().spliterator(), false))));
      }

      if (valueId != null) {
        memberStream = Stream.concat(memberStream,
          Stream.concat(Stream.<IClass>of(Qualifier.this.valueId),
            StreamSupport.stream(Qualifier.this.valueId.descend().spliterator(), false)));
      }

      return memberStream;
    }
  }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
