/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package aas_core.aas3_0.types.impl;

import aas_core.aas3_0.visitation.IVisitor;
import aas_core.aas3_0.visitation.IVisitorWithContext;
import aas_core.aas3_0.visitation.ITransformer;
import aas_core.aas3_0.visitation.ITransformerWithContext;
import aas_core.aas3_0.types.enums.*;
import aas_core.aas3_0.types.impl.*;
import aas_core.aas3_0.types.model.*;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Objects;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import aas_core.aas3_0.types.model.IAdministrativeInformation;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

/**
 * Administrative meta-information for an element like version
 * information.
 *
 * <p>Constraints:
 *
 * <ul>
 *   <li> Constraint AASd-005:
 *   If {@link #getVersion()} is not specified then also {@link #getRevision()} shall be
 *   unspecified. This means, a revision requires a version. If there is no version
 *   there is no revision neither. Revision is optional.
 * </ul>
 */
public class AdministrativeInformation implements IAdministrativeInformation {
  /**
   * Embedded data specification.
   */
  private List<IEmbeddedDataSpecification> embeddedDataSpecifications;

  /**
   * Version of the element.
   */
  private String version;

  /**
   * Revision of the element.
   */
  private String revision;

  /**
   * The subject ID of the subject responsible for making the element.
   */
  private IReference creator;

  /**
   * Identifier of the template that guided the creation of the element.
   *
   * <p>In case of a submodel the {@link #getTemplateId()} is the identifier
   * of the submodel template ID that guided the creation of the submodel
   *
   * <p>The {@link #getTemplateId()} is not relevant for validation in Submodels.
   * For validation the {@link aas_core.aas3_0.types.impl.Submodel#getSemanticId()} shall be used.
   *
   * <p>Usage of {@link #getTemplateId()} is not restricted to submodel instances. So also
   * the creation of submodel templates can be guided by another submodel template.
   */
  private String templateId;

  public AdministrativeInformation(
    List<IEmbeddedDataSpecification> embeddedDataSpecifications,
    String version,
    String revision,
    IReference creator,
    String templateId) {
    this.embeddedDataSpecifications = embeddedDataSpecifications;
    this.version = version;
    this.revision = revision;
    this.creator = creator;
    this.templateId = templateId;
  }

  @Override
  public Optional<List<IEmbeddedDataSpecification>> getEmbeddedDataSpecifications() {
    return Optional.ofNullable(embeddedDataSpecifications);
  }

  @Override
  public void setEmbeddedDataSpecifications(List<IEmbeddedDataSpecification> embeddedDataSpecifications) {
    this.embeddedDataSpecifications = embeddedDataSpecifications;
  }

  @Override
  public Optional<String> getVersion() {
    return Optional.ofNullable(version);
  }

  @Override
  public void setVersion(String version) {
    this.version = version;
  }

  @Override
  public Optional<String> getRevision() {
    return Optional.ofNullable(revision);
  }

  @Override
  public void setRevision(String revision) {
    this.revision = revision;
  }

  @Override
  public Optional<IReference> getCreator() {
    return Optional.ofNullable(creator);
  }

  @Override
  public void setCreator(IReference creator) {
    this.creator = creator;
  }

  @Override
  public Optional<String> getTemplateId() {
    return Optional.ofNullable(templateId);
  }

  @Override
  public void setTemplateId(String templateId) {
    this.templateId = templateId;
  }

  /**
   * Iterate over {@link AdministrativeInformation#embeddedDataSpecifications}, if set,
   * and otherwise return an empty iterator.
   */
  public Iterable<IEmbeddedDataSpecification> overEmbeddedDataSpecificationsOrEmpty() {
    return getEmbeddedDataSpecifications().orElseGet(Collections::emptyList);
  }

  /**
   * Iterate recursively over all the class instances referenced from this instance.
   */
  public Iterable<IClass> descend() {
    return new AdministrativeInformationRecursiveIterable();
  }

  /**
   * Iterate over all the class instances referenced from this instance.
   */
  public Iterable<IClass> descendOnce() {
    return new AdministrativeInformationIterable();
  }

  /**
   * Accept the {@code visitor} to visit this instance for double dispatch.
   **/
  @Override
  public void accept(IVisitor visitor) {
    visitor.visitAdministrativeInformation(this);
  }

  /**
   * Accept the {@code visitor} to visit this instance for double dispatch
   * with the {@code context}.
   **/
  @Override
  public <ContextT> void accept(
      IVisitorWithContext<ContextT> visitor,
      ContextT context) {
    visitor.visitAdministrativeInformation(this, context);
  }

  /**
   * Accept the {@code transformer} to visit this instance for double dispatch.
   **/
  @Override
  public <T> T transform(ITransformer<T> transformer) {
    return transformer.transformAdministrativeInformation(this);
  }

  /**
   * Accept the {@code transformer} to visit this instance for double dispatch
   * with the {@code context}.
   **/
  @Override
  public <ContextT, T> T transform(
      ITransformerWithContext<ContextT, T> transformer,
      ContextT context) {
    return transformer.transformAdministrativeInformation(this, context);
  }

  private class AdministrativeInformationIterable implements Iterable<IClass> {
    @Override
    public Iterator<IClass> iterator() {
      Stream<IClass> stream = stream();

      return stream.iterator();
    }

    @Override
    public void forEach(Consumer<? super IClass> action) {
      Stream<IClass> stream = stream();

      stream.forEach(action);
    }

    @Override
    public Spliterator<IClass> spliterator() {
      Stream<IClass> stream = stream();

      return stream.spliterator();
    }

    private Stream<IClass> stream() {
      Stream<IClass> memberStream = Stream.empty();

      if (embeddedDataSpecifications != null) {
        memberStream = Stream.concat(memberStream,
          AdministrativeInformation.this.embeddedDataSpecifications.stream());
      }

      if (creator != null) {
        memberStream = Stream.concat(memberStream,
          Stream.<IClass>of(AdministrativeInformation.this.creator));
      }

      return memberStream;
    }
  }

  private class AdministrativeInformationRecursiveIterable implements Iterable<IClass> {
    @Override
    public Iterator<IClass> iterator() {
      Stream<IClass> stream = stream();

      return stream.iterator();
    }

    @Override
    public void forEach(Consumer<? super IClass> action) {
      Stream<IClass> stream = stream();

      stream.forEach(action);
    }

    @Override
    public Spliterator<IClass> spliterator() {
      Stream<IClass> stream = stream();

      return stream.spliterator();
    }

    private Stream<IClass> stream() {
      Stream<IClass> memberStream = Stream.empty();

      if (embeddedDataSpecifications != null) {
        memberStream = Stream.concat(memberStream,
          AdministrativeInformation.this.embeddedDataSpecifications.stream()
            .flatMap(item -> Stream.concat(Stream.<IClass>of(item),
              StreamSupport.stream(item.descend().spliterator(), false))));
      }

      if (creator != null) {
        memberStream = Stream.concat(memberStream,
          Stream.concat(Stream.<IClass>of(AdministrativeInformation.this.creator),
            StreamSupport.stream(AdministrativeInformation.this.creator.descend().spliterator(), false)));
      }

      return memberStream;
    }
  }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
