/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package aas_core.aas3_0.types.impl;

import aas_core.aas3_0.visitation.IVisitor;
import aas_core.aas3_0.visitation.IVisitorWithContext;
import aas_core.aas3_0.visitation.ITransformer;
import aas_core.aas3_0.visitation.ITransformerWithContext;
import aas_core.aas3_0.types.enums.*;
import aas_core.aas3_0.types.impl.*;
import aas_core.aas3_0.types.model.*;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.Objects;
import java.util.Iterator;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import aas_core.aas3_0.types.model.IDataSpecificationIec61360;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

/**
 * Content of data specification template for concept descriptions for properties,
 * values and value lists conformant to IEC 61360.
 *
 * <p>IEC61360 requires also a globally unique identifier for a concept
 * description. This ID is not part of the data specification template.
 * Instead the {@link ConceptDescription#getId id} as inherited via
 * {@link IIdentifiable} is used. Same holds for administrative
 * information like the version and revision.
 *
 * <p>{@link ConceptDescription#getIdShort idShort} and {@link DataSpecificationIec61360#getShortName shortName} are very
 * similar. However, in this case the decision was to add
 * {@link DataSpecificationIec61360#getShortName shortName} explicitly to the data specification. Same holds for
 * {@link ConceptDescription#getDisplayName displayName} and
 * {@link DataSpecificationIec61360#getPreferredName preferredName}. Same holds for
 * {@link ConceptDescription#getDescription description} and {@link DataSpecificationIec61360#getDefinition definition}.
 *
 * <p>Constraints:
 * <ul>
 *   <li> Constraint AASc-3a-010:
 *   If {@link DataSpecificationIec61360#getValue value} is not empty then {@link DataSpecificationIec61360#getValueList valueList} shall be empty
 *   and vice versa.
 *
 *   <p>It is also possible that both {@link DataSpecificationIec61360#getValue value} and {@link DataSpecificationIec61360#getValueList valueList} are
 *   empty. This is the case for concept descriptions that define the semantics
 *   of a property but do not have an enumeration ({@link DataSpecificationIec61360#getValueList valueList}) as
 *   data type.
 *
 *   <p>Although it is possible to define a {@link ConceptDescription} for a
 *   :attr:Â´value_list`,
 *   it is not possible to reuse this {@link DataSpecificationIec61360#getValueList valueList}.
 *   It is only possible to directly add a {@link DataSpecificationIec61360#getValueList valueList} as data type
 *   to a specific semantic definition of a property.
 *   <li> Constraint AASc-3a-009:
 *   If {@link DataSpecificationIec61360#getDataType dataType} one of:
 *   {@link DataTypeIec61360#INTEGER_MEASURE},
 *   {@link DataTypeIec61360#REAL_MEASURE},
 *   {@link DataTypeIec61360#RATIONAL_MEASURE},
 *   {@link DataTypeIec61360#INTEGER_CURRENCY},
 *   {@link DataTypeIec61360#REAL_CURRENCY}, then {@link DataSpecificationIec61360#getUnit unit} or
 *   {@link DataSpecificationIec61360#getUnitId unitId} shall be defined.
 * </ul>
 */
public class DataSpecificationIec61360 implements IDataSpecificationIec61360 {
  /**
   * Preferred name
   *
   * <p>It is advised to keep the length of the name limited to 35 characters.
   *
   * <p>Constraints:
   * <ul>
   *   <li> Constraint AASc-3a-002:
   *   {@link DataSpecificationIec61360#getPreferredName preferredName} shall be provided at least in English.
   * </ul>
   */
  private List<ILangStringPreferredNameTypeIec61360> preferredName;

  /**
   * Short name
   */
  private List<ILangStringShortNameTypeIec61360> shortName;

  /**
   * Unit
   */
  private String unit;

  /**
   * Unique unit id
   *
   * <p>{@link DataSpecificationIec61360#getUnit unit} and {@link DataSpecificationIec61360#getUnitId unitId} need to be consistent if both attributes
   * are set
   *
   * <p>It is recommended to use an external reference ID.
   */
  private IReference unitId;

  /**
   * Source of definition
   */
  private String sourceOfDefinition;

  /**
   * Symbol
   */
  private String symbol;

  /**
   * Data Type
   */
  private DataTypeIec61360 dataType;

  /**
   * Definition in different languages
   */
  private List<ILangStringDefinitionTypeIec61360> definition;

  /**
   * Value Format
   *
   * <p>The value format is based on ISO 13584-42 and IEC 61360-2.
   */
  private String valueFormat;

  /**
   * List of allowed values
   */
  private IValueList valueList;

  /**
   * Value
   */
  private String value;

  /**
   * Set of levels.
   */
  private ILevelType levelType;

  public DataSpecificationIec61360(List<ILangStringPreferredNameTypeIec61360> preferredName) {
    this.preferredName = Objects.requireNonNull(
      preferredName,
      "Argument \"preferredName\" must be non-null.");
  }

  public DataSpecificationIec61360(
    List<ILangStringPreferredNameTypeIec61360> preferredName,
    List<ILangStringShortNameTypeIec61360> shortName,
    String unit,
    IReference unitId,
    String sourceOfDefinition,
    String symbol,
    DataTypeIec61360 dataType,
    List<ILangStringDefinitionTypeIec61360> definition,
    String valueFormat,
    IValueList valueList,
    String value,
    ILevelType levelType) {
    this.preferredName = Objects.requireNonNull(
      preferredName,
      "Argument \"preferredName\" must be non-null.");
    this.shortName = shortName;
    this.unit = unit;
    this.unitId = unitId;
    this.sourceOfDefinition = sourceOfDefinition;
    this.symbol = symbol;
    this.dataType = dataType;
    this.definition = definition;
    this.valueFormat = valueFormat;
    this.valueList = valueList;
    this.value = value;
    this.levelType = levelType;
  }

  @Override
  public List<ILangStringPreferredNameTypeIec61360> getPreferredName() {
    return preferredName;
  }

  @Override
  public void setPreferredName(List<ILangStringPreferredNameTypeIec61360> preferredName) {
    this.preferredName = Objects.requireNonNull(
      preferredName,
      "Argument \"preferredName\" must be non-null.");
  }

  @Override
  public Optional<List<ILangStringShortNameTypeIec61360>> getShortName() {
    return Optional.ofNullable(shortName);
  }

  @Override
  public void setShortName(List<ILangStringShortNameTypeIec61360> shortName) {
    this.shortName = shortName;
  }

  @Override
  public Optional<String> getUnit() {
    return Optional.ofNullable(unit);
  }

  @Override
  public void setUnit(String unit) {
    this.unit = unit;
  }

  @Override
  public Optional<IReference> getUnitId() {
    return Optional.ofNullable(unitId);
  }

  @Override
  public void setUnitId(IReference unitId) {
    this.unitId = unitId;
  }

  @Override
  public Optional<String> getSourceOfDefinition() {
    return Optional.ofNullable(sourceOfDefinition);
  }

  @Override
  public void setSourceOfDefinition(String sourceOfDefinition) {
    this.sourceOfDefinition = sourceOfDefinition;
  }

  @Override
  public Optional<String> getSymbol() {
    return Optional.ofNullable(symbol);
  }

  @Override
  public void setSymbol(String symbol) {
    this.symbol = symbol;
  }

  @Override
  public Optional<DataTypeIec61360> getDataType() {
    return Optional.ofNullable(dataType);
  }

  @Override
  public void setDataType(DataTypeIec61360 dataType) {
    this.dataType = dataType;
  }

  @Override
  public Optional<List<ILangStringDefinitionTypeIec61360>> getDefinition() {
    return Optional.ofNullable(definition);
  }

  @Override
  public void setDefinition(List<ILangStringDefinitionTypeIec61360> definition) {
    this.definition = definition;
  }

  @Override
  public Optional<String> getValueFormat() {
    return Optional.ofNullable(valueFormat);
  }

  @Override
  public void setValueFormat(String valueFormat) {
    this.valueFormat = valueFormat;
  }

  @Override
  public Optional<IValueList> getValueList() {
    return Optional.ofNullable(valueList);
  }

  @Override
  public void setValueList(IValueList valueList) {
    this.valueList = valueList;
  }

  @Override
  public Optional<String> getValue() {
    return Optional.ofNullable(value);
  }

  @Override
  public void setValue(String value) {
    this.value = value;
  }

  @Override
  public Optional<ILevelType> getLevelType() {
    return Optional.ofNullable(levelType);
  }

  @Override
  public void setLevelType(ILevelType levelType) {
    this.levelType = levelType;
  }

  /**
   * Iterate over {@link DataSpecificationIec61360#shortName}, if set,
   * and otherwise return an empty iterator.
   */
  public Iterable<ILangStringShortNameTypeIec61360> overShortNameOrEmpty() {
    return getShortName().orElseGet(Collections::emptyList);
  }

  /**
   * Iterate over {@link DataSpecificationIec61360#definition}, if set,
   * and otherwise return an empty iterator.
   */
  public Iterable<ILangStringDefinitionTypeIec61360> overDefinitionOrEmpty() {
    return getDefinition().orElseGet(Collections::emptyList);
  }

  /**
   * Iterate recursively over all the class instances referenced from this instance.
   */
  public Iterable<IClass> descend() {
    return new DataSpecificationIec61360RecursiveIterable();
  }

  /**
   * Iterate over all the class instances referenced from this instance.
   */
  public Iterable<IClass> descendOnce() {
    return new DataSpecificationIec61360Iterable();
  }

  /**
   * Accept the {@code visitor} to visit this instance for double dispatch.
   **/
  @Override
  public void accept(IVisitor visitor) {
    visitor.visitDataSpecificationIec61360(this);
  }

  /**
   * Accept the {@code visitor} to visit this instance for double dispatch
   * with the {@code context}.
   **/
  @Override
  public <ContextT> void accept(
      IVisitorWithContext<ContextT> visitor,
      ContextT context) {
    visitor.visitDataSpecificationIec61360(this, context);
  }

  /**
   * Accept the {@code transformer} to visit this instance for double dispatch.
   **/
  @Override
  public <T> T transform(ITransformer<T> transformer) {
    return transformer.transformDataSpecificationIec61360(this);
  }

  /**
   * Accept the {@code transformer} to visit this instance for double dispatch
   * with the {@code context}.
   **/
  @Override
  public <ContextT, T> T transform(
      ITransformerWithContext<ContextT, T> transformer,
      ContextT context) {
    return transformer.transformDataSpecificationIec61360(this, context);
  }

  private class DataSpecificationIec61360Iterable implements Iterable<IClass> {
    @Override
    public Iterator<IClass> iterator() {
      Stream<IClass> stream = stream();

      return stream.iterator();
    }

    @Override
    public void forEach(Consumer<? super IClass> action) {
      Stream<IClass> stream = stream();

      stream.forEach(action);
    }

    @Override
    public Spliterator<IClass> spliterator() {
      Stream<IClass> stream = stream();

      return stream.spliterator();
    }

    private Stream<IClass> stream() {
      Stream<IClass> memberStream = Stream.empty();

      if (preferredName != null) {
        memberStream = Stream.concat(memberStream,
          DataSpecificationIec61360.this.preferredName.stream());
      }

      if (shortName != null) {
        memberStream = Stream.concat(memberStream,
          DataSpecificationIec61360.this.shortName.stream());
      }

      if (unitId != null) {
        memberStream = Stream.concat(memberStream,
          Stream.<IClass>of(DataSpecificationIec61360.this.unitId));
      }

      if (definition != null) {
        memberStream = Stream.concat(memberStream,
          DataSpecificationIec61360.this.definition.stream());
      }

      if (valueList != null) {
        memberStream = Stream.concat(memberStream,
          Stream.<IClass>of(DataSpecificationIec61360.this.valueList));
      }

      if (levelType != null) {
        memberStream = Stream.concat(memberStream,
          Stream.<IClass>of(DataSpecificationIec61360.this.levelType));
      }

      return memberStream;
    }
  }

  private class DataSpecificationIec61360RecursiveIterable implements Iterable<IClass> {
    @Override
    public Iterator<IClass> iterator() {
      Stream<IClass> stream = stream();

      return stream.iterator();
    }

    @Override
    public void forEach(Consumer<? super IClass> action) {
      Stream<IClass> stream = stream();

      stream.forEach(action);
    }

    @Override
    public Spliterator<IClass> spliterator() {
      Stream<IClass> stream = stream();

      return stream.spliterator();
    }

    private Stream<IClass> stream() {
      Stream<IClass> memberStream = Stream.empty();

      if (preferredName != null) {
        memberStream = Stream.concat(memberStream,
          DataSpecificationIec61360.this.preferredName.stream()
            .flatMap(item -> Stream.concat(Stream.<IClass>of(item),
              StreamSupport.stream(item.descend().spliterator(), false))));
      }

      if (shortName != null) {
        memberStream = Stream.concat(memberStream,
          DataSpecificationIec61360.this.shortName.stream()
            .flatMap(item -> Stream.concat(Stream.<IClass>of(item),
              StreamSupport.stream(item.descend().spliterator(), false))));
      }

      if (unitId != null) {
        memberStream = Stream.concat(memberStream,
          Stream.concat(Stream.<IClass>of(DataSpecificationIec61360.this.unitId),
            StreamSupport.stream(DataSpecificationIec61360.this.unitId.descend().spliterator(), false)));
      }

      if (definition != null) {
        memberStream = Stream.concat(memberStream,
          DataSpecificationIec61360.this.definition.stream()
            .flatMap(item -> Stream.concat(Stream.<IClass>of(item),
              StreamSupport.stream(item.descend().spliterator(), false))));
      }

      if (valueList != null) {
        memberStream = Stream.concat(memberStream,
          Stream.concat(Stream.<IClass>of(DataSpecificationIec61360.this.valueList),
            StreamSupport.stream(DataSpecificationIec61360.this.valueList.descend().spliterator(), false)));
      }

      if (levelType != null) {
        memberStream = Stream.concat(memberStream,
          Stream.concat(Stream.<IClass>of(DataSpecificationIec61360.this.levelType),
            StreamSupport.stream(DataSpecificationIec61360.this.levelType.descend().spliterator(), false)));
      }

      return memberStream;
    }
  }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
