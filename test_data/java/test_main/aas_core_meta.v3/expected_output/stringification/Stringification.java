/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package aas_core.aas3_0.stringification;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import aas_core.aas3_0.types.enums.*;

public class Stringification {
  private static final Map<ModellingKind, String> modellingKindToString;
  static {
    final Map<ModellingKind, String> temp = new HashMap<>();

    temp.put(ModellingKind.TEMPLATE, "Template");
    temp.put(ModellingKind.INSTANCE, "Instance");

    if (!temp.keySet().containsAll(Arrays.asList(ModellingKind.values()))) {
      throw new IllegalStateException("Unmapped ModellingKind");
    }

    modellingKindToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(ModellingKind that)
  {
    return Optional.ofNullable(that).map(modellingKindToString::get);
  }

  private static final Map<String, ModellingKind> modellingKindFromString;
  static {
    final Map<String, ModellingKind> temp = new HashMap<>();

    temp.put("Template", ModellingKind.TEMPLATE);
    temp.put("Instance", ModellingKind.INSTANCE);

    if (!temp.values().containsAll(Arrays.asList(ModellingKind.values()))) {
      throw new IllegalStateException("Unmapped ModellingKind");
    }

    modellingKindFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "ModellingKind"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "ModellingKind"},
   * return {@code Optional#empty()}.
   */
  public static Optional<ModellingKind> modellingKindFromString(String text)
  {
    ModellingKind value = modellingKindFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<QualifierKind, String> qualifierKindToString;
  static {
    final Map<QualifierKind, String> temp = new HashMap<>();

    temp.put(QualifierKind.VALUE_QUALIFIER, "ValueQualifier");
    temp.put(QualifierKind.CONCEPT_QUALIFIER, "ConceptQualifier");
    temp.put(QualifierKind.TEMPLATE_QUALIFIER, "TemplateQualifier");

    if (!temp.keySet().containsAll(Arrays.asList(QualifierKind.values()))) {
      throw new IllegalStateException("Unmapped QualifierKind");
    }

    qualifierKindToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(QualifierKind that)
  {
    return Optional.ofNullable(that).map(qualifierKindToString::get);
  }

  private static final Map<String, QualifierKind> qualifierKindFromString;
  static {
    final Map<String, QualifierKind> temp = new HashMap<>();

    temp.put("ValueQualifier", QualifierKind.VALUE_QUALIFIER);
    temp.put("ConceptQualifier", QualifierKind.CONCEPT_QUALIFIER);
    temp.put("TemplateQualifier", QualifierKind.TEMPLATE_QUALIFIER);

    if (!temp.values().containsAll(Arrays.asList(QualifierKind.values()))) {
      throw new IllegalStateException("Unmapped QualifierKind");
    }

    qualifierKindFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "QualifierKind"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "QualifierKind"},
   * return {@code Optional#empty()}.
   */
  public static Optional<QualifierKind> qualifierKindFromString(String text)
  {
    QualifierKind value = qualifierKindFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<AssetKind, String> assetKindToString;
  static {
    final Map<AssetKind, String> temp = new HashMap<>();

    temp.put(AssetKind.TYPE, "Type");
    temp.put(AssetKind.INSTANCE, "Instance");
    temp.put(AssetKind.NOT_APPLICABLE, "NotApplicable");

    if (!temp.keySet().containsAll(Arrays.asList(AssetKind.values()))) {
      throw new IllegalStateException("Unmapped AssetKind");
    }

    assetKindToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(AssetKind that)
  {
    return Optional.ofNullable(that).map(assetKindToString::get);
  }

  private static final Map<String, AssetKind> assetKindFromString;
  static {
    final Map<String, AssetKind> temp = new HashMap<>();

    temp.put("Type", AssetKind.TYPE);
    temp.put("Instance", AssetKind.INSTANCE);
    temp.put("NotApplicable", AssetKind.NOT_APPLICABLE);

    if (!temp.values().containsAll(Arrays.asList(AssetKind.values()))) {
      throw new IllegalStateException("Unmapped AssetKind");
    }

    assetKindFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "AssetKind"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "AssetKind"},
   * return {@code Optional#empty()}.
   */
  public static Optional<AssetKind> assetKindFromString(String text)
  {
    AssetKind value = assetKindFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<AasSubmodelElements, String> aasSubmodelElementsToString;
  static {
    final Map<AasSubmodelElements, String> temp = new HashMap<>();

    temp.put(AasSubmodelElements.ANNOTATED_RELATIONSHIP_ELEMENT, "AnnotatedRelationshipElement");
    temp.put(AasSubmodelElements.BASIC_EVENT_ELEMENT, "BasicEventElement");
    temp.put(AasSubmodelElements.BLOB, "Blob");
    temp.put(AasSubmodelElements.CAPABILITY, "Capability");
    temp.put(AasSubmodelElements.DATA_ELEMENT, "DataElement");
    temp.put(AasSubmodelElements.ENTITY, "Entity");
    temp.put(AasSubmodelElements.EVENT_ELEMENT, "EventElement");
    temp.put(AasSubmodelElements.FILE, "File");
    temp.put(AasSubmodelElements.MULTI_LANGUAGE_PROPERTY, "MultiLanguageProperty");
    temp.put(AasSubmodelElements.OPERATION, "Operation");
    temp.put(AasSubmodelElements.PROPERTY, "Property");
    temp.put(AasSubmodelElements.RANGE, "Range");
    temp.put(AasSubmodelElements.REFERENCE_ELEMENT, "ReferenceElement");
    temp.put(AasSubmodelElements.RELATIONSHIP_ELEMENT, "RelationshipElement");
    temp.put(AasSubmodelElements.SUBMODEL_ELEMENT, "SubmodelElement");
    temp.put(AasSubmodelElements.SUBMODEL_ELEMENT_LIST, "SubmodelElementList");
    temp.put(AasSubmodelElements.SUBMODEL_ELEMENT_COLLECTION, "SubmodelElementCollection");

    if (!temp.keySet().containsAll(Arrays.asList(AasSubmodelElements.values()))) {
      throw new IllegalStateException("Unmapped AasSubmodelElements");
    }

    aasSubmodelElementsToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(AasSubmodelElements that)
  {
    return Optional.ofNullable(that).map(aasSubmodelElementsToString::get);
  }

  private static final Map<String, AasSubmodelElements> aasSubmodelElementsFromString;
  static {
    final Map<String, AasSubmodelElements> temp = new HashMap<>();

    temp.put("AnnotatedRelationshipElement", AasSubmodelElements.ANNOTATED_RELATIONSHIP_ELEMENT);
    temp.put("BasicEventElement", AasSubmodelElements.BASIC_EVENT_ELEMENT);
    temp.put("Blob", AasSubmodelElements.BLOB);
    temp.put("Capability", AasSubmodelElements.CAPABILITY);
    temp.put("DataElement", AasSubmodelElements.DATA_ELEMENT);
    temp.put("Entity", AasSubmodelElements.ENTITY);
    temp.put("EventElement", AasSubmodelElements.EVENT_ELEMENT);
    temp.put("File", AasSubmodelElements.FILE);
    temp.put("MultiLanguageProperty", AasSubmodelElements.MULTI_LANGUAGE_PROPERTY);
    temp.put("Operation", AasSubmodelElements.OPERATION);
    temp.put("Property", AasSubmodelElements.PROPERTY);
    temp.put("Range", AasSubmodelElements.RANGE);
    temp.put("ReferenceElement", AasSubmodelElements.REFERENCE_ELEMENT);
    temp.put("RelationshipElement", AasSubmodelElements.RELATIONSHIP_ELEMENT);
    temp.put("SubmodelElement", AasSubmodelElements.SUBMODEL_ELEMENT);
    temp.put("SubmodelElementList", AasSubmodelElements.SUBMODEL_ELEMENT_LIST);
    temp.put("SubmodelElementCollection", AasSubmodelElements.SUBMODEL_ELEMENT_COLLECTION);

    if (!temp.values().containsAll(Arrays.asList(AasSubmodelElements.values()))) {
      throw new IllegalStateException("Unmapped AasSubmodelElements");
    }

    aasSubmodelElementsFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "AasSubmodelElements"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "AasSubmodelElements"},
   * return {@code Optional#empty()}.
   */
  public static Optional<AasSubmodelElements> aasSubmodelElementsFromString(String text)
  {
    AasSubmodelElements value = aasSubmodelElementsFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<EntityType, String> entityTypeToString;
  static {
    final Map<EntityType, String> temp = new HashMap<>();

    temp.put(EntityType.CO_MANAGED_ENTITY, "CoManagedEntity");
    temp.put(EntityType.SELF_MANAGED_ENTITY, "SelfManagedEntity");

    if (!temp.keySet().containsAll(Arrays.asList(EntityType.values()))) {
      throw new IllegalStateException("Unmapped EntityType");
    }

    entityTypeToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(EntityType that)
  {
    return Optional.ofNullable(that).map(entityTypeToString::get);
  }

  private static final Map<String, EntityType> entityTypeFromString;
  static {
    final Map<String, EntityType> temp = new HashMap<>();

    temp.put("CoManagedEntity", EntityType.CO_MANAGED_ENTITY);
    temp.put("SelfManagedEntity", EntityType.SELF_MANAGED_ENTITY);

    if (!temp.values().containsAll(Arrays.asList(EntityType.values()))) {
      throw new IllegalStateException("Unmapped EntityType");
    }

    entityTypeFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "EntityType"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "EntityType"},
   * return {@code Optional#empty()}.
   */
  public static Optional<EntityType> entityTypeFromString(String text)
  {
    EntityType value = entityTypeFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<Direction, String> directionToString;
  static {
    final Map<Direction, String> temp = new HashMap<>();

    temp.put(Direction.INPUT, "input");
    temp.put(Direction.OUTPUT, "output");

    if (!temp.keySet().containsAll(Arrays.asList(Direction.values()))) {
      throw new IllegalStateException("Unmapped Direction");
    }

    directionToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(Direction that)
  {
    return Optional.ofNullable(that).map(directionToString::get);
  }

  private static final Map<String, Direction> directionFromString;
  static {
    final Map<String, Direction> temp = new HashMap<>();

    temp.put("input", Direction.INPUT);
    temp.put("output", Direction.OUTPUT);

    if (!temp.values().containsAll(Arrays.asList(Direction.values()))) {
      throw new IllegalStateException("Unmapped Direction");
    }

    directionFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "Direction"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "Direction"},
   * return {@code Optional#empty()}.
   */
  public static Optional<Direction> directionFromString(String text)
  {
    Direction value = directionFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<StateOfEvent, String> stateOfEventToString;
  static {
    final Map<StateOfEvent, String> temp = new HashMap<>();

    temp.put(StateOfEvent.ON, "on");
    temp.put(StateOfEvent.OFF, "off");

    if (!temp.keySet().containsAll(Arrays.asList(StateOfEvent.values()))) {
      throw new IllegalStateException("Unmapped StateOfEvent");
    }

    stateOfEventToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(StateOfEvent that)
  {
    return Optional.ofNullable(that).map(stateOfEventToString::get);
  }

  private static final Map<String, StateOfEvent> stateOfEventFromString;
  static {
    final Map<String, StateOfEvent> temp = new HashMap<>();

    temp.put("on", StateOfEvent.ON);
    temp.put("off", StateOfEvent.OFF);

    if (!temp.values().containsAll(Arrays.asList(StateOfEvent.values()))) {
      throw new IllegalStateException("Unmapped StateOfEvent");
    }

    stateOfEventFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "StateOfEvent"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "StateOfEvent"},
   * return {@code Optional#empty()}.
   */
  public static Optional<StateOfEvent> stateOfEventFromString(String text)
  {
    StateOfEvent value = stateOfEventFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<ReferenceTypes, String> referenceTypesToString;
  static {
    final Map<ReferenceTypes, String> temp = new HashMap<>();

    temp.put(ReferenceTypes.EXTERNAL_REFERENCE, "ExternalReference");
    temp.put(ReferenceTypes.MODEL_REFERENCE, "ModelReference");

    if (!temp.keySet().containsAll(Arrays.asList(ReferenceTypes.values()))) {
      throw new IllegalStateException("Unmapped ReferenceTypes");
    }

    referenceTypesToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(ReferenceTypes that)
  {
    return Optional.ofNullable(that).map(referenceTypesToString::get);
  }

  private static final Map<String, ReferenceTypes> referenceTypesFromString;
  static {
    final Map<String, ReferenceTypes> temp = new HashMap<>();

    temp.put("ExternalReference", ReferenceTypes.EXTERNAL_REFERENCE);
    temp.put("ModelReference", ReferenceTypes.MODEL_REFERENCE);

    if (!temp.values().containsAll(Arrays.asList(ReferenceTypes.values()))) {
      throw new IllegalStateException("Unmapped ReferenceTypes");
    }

    referenceTypesFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "ReferenceTypes"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "ReferenceTypes"},
   * return {@code Optional#empty()}.
   */
  public static Optional<ReferenceTypes> referenceTypesFromString(String text)
  {
    ReferenceTypes value = referenceTypesFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<KeyTypes, String> keyTypesToString;
  static {
    final Map<KeyTypes, String> temp = new HashMap<>();

    temp.put(KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT, "AnnotatedRelationshipElement");
    temp.put(KeyTypes.ASSET_ADMINISTRATION_SHELL, "AssetAdministrationShell");
    temp.put(KeyTypes.BASIC_EVENT_ELEMENT, "BasicEventElement");
    temp.put(KeyTypes.BLOB, "Blob");
    temp.put(KeyTypes.CAPABILITY, "Capability");
    temp.put(KeyTypes.CONCEPT_DESCRIPTION, "ConceptDescription");
    temp.put(KeyTypes.DATA_ELEMENT, "DataElement");
    temp.put(KeyTypes.ENTITY, "Entity");
    temp.put(KeyTypes.EVENT_ELEMENT, "EventElement");
    temp.put(KeyTypes.FILE, "File");
    temp.put(KeyTypes.FRAGMENT_REFERENCE, "FragmentReference");
    temp.put(KeyTypes.GLOBAL_REFERENCE, "GlobalReference");
    temp.put(KeyTypes.IDENTIFIABLE, "Identifiable");
    temp.put(KeyTypes.MULTI_LANGUAGE_PROPERTY, "MultiLanguageProperty");
    temp.put(KeyTypes.OPERATION, "Operation");
    temp.put(KeyTypes.PROPERTY, "Property");
    temp.put(KeyTypes.RANGE, "Range");
    temp.put(KeyTypes.REFERABLE, "Referable");
    temp.put(KeyTypes.REFERENCE_ELEMENT, "ReferenceElement");
    temp.put(KeyTypes.RELATIONSHIP_ELEMENT, "RelationshipElement");
    temp.put(KeyTypes.SUBMODEL, "Submodel");
    temp.put(KeyTypes.SUBMODEL_ELEMENT, "SubmodelElement");
    temp.put(KeyTypes.SUBMODEL_ELEMENT_COLLECTION, "SubmodelElementCollection");
    temp.put(KeyTypes.SUBMODEL_ELEMENT_LIST, "SubmodelElementList");

    if (!temp.keySet().containsAll(Arrays.asList(KeyTypes.values()))) {
      throw new IllegalStateException("Unmapped KeyTypes");
    }

    keyTypesToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(KeyTypes that)
  {
    return Optional.ofNullable(that).map(keyTypesToString::get);
  }

  private static final Map<String, KeyTypes> keyTypesFromString;
  static {
    final Map<String, KeyTypes> temp = new HashMap<>();

    temp.put("AnnotatedRelationshipElement", KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT);
    temp.put("AssetAdministrationShell", KeyTypes.ASSET_ADMINISTRATION_SHELL);
    temp.put("BasicEventElement", KeyTypes.BASIC_EVENT_ELEMENT);
    temp.put("Blob", KeyTypes.BLOB);
    temp.put("Capability", KeyTypes.CAPABILITY);
    temp.put("ConceptDescription", KeyTypes.CONCEPT_DESCRIPTION);
    temp.put("DataElement", KeyTypes.DATA_ELEMENT);
    temp.put("Entity", KeyTypes.ENTITY);
    temp.put("EventElement", KeyTypes.EVENT_ELEMENT);
    temp.put("File", KeyTypes.FILE);
    temp.put("FragmentReference", KeyTypes.FRAGMENT_REFERENCE);
    temp.put("GlobalReference", KeyTypes.GLOBAL_REFERENCE);
    temp.put("Identifiable", KeyTypes.IDENTIFIABLE);
    temp.put("MultiLanguageProperty", KeyTypes.MULTI_LANGUAGE_PROPERTY);
    temp.put("Operation", KeyTypes.OPERATION);
    temp.put("Property", KeyTypes.PROPERTY);
    temp.put("Range", KeyTypes.RANGE);
    temp.put("Referable", KeyTypes.REFERABLE);
    temp.put("ReferenceElement", KeyTypes.REFERENCE_ELEMENT);
    temp.put("RelationshipElement", KeyTypes.RELATIONSHIP_ELEMENT);
    temp.put("Submodel", KeyTypes.SUBMODEL);
    temp.put("SubmodelElement", KeyTypes.SUBMODEL_ELEMENT);
    temp.put("SubmodelElementCollection", KeyTypes.SUBMODEL_ELEMENT_COLLECTION);
    temp.put("SubmodelElementList", KeyTypes.SUBMODEL_ELEMENT_LIST);

    if (!temp.values().containsAll(Arrays.asList(KeyTypes.values()))) {
      throw new IllegalStateException("Unmapped KeyTypes");
    }

    keyTypesFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "KeyTypes"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "KeyTypes"},
   * return {@code Optional#empty()}.
   */
  public static Optional<KeyTypes> keyTypesFromString(String text)
  {
    KeyTypes value = keyTypesFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<DataTypeDefXsd, String> dataTypeDefXsdToString;
  static {
    final Map<DataTypeDefXsd, String> temp = new HashMap<>();

    temp.put(DataTypeDefXsd.ANY_URI, "xs:anyURI");
    temp.put(DataTypeDefXsd.BASE_64_BINARY, "xs:base64Binary");
    temp.put(DataTypeDefXsd.BOOLEAN, "xs:boolean");
    temp.put(DataTypeDefXsd.BYTE, "xs:byte");
    temp.put(DataTypeDefXsd.DATE, "xs:date");
    temp.put(DataTypeDefXsd.DATE_TIME, "xs:dateTime");
    temp.put(DataTypeDefXsd.DECIMAL, "xs:decimal");
    temp.put(DataTypeDefXsd.DOUBLE, "xs:double");
    temp.put(DataTypeDefXsd.DURATION, "xs:duration");
    temp.put(DataTypeDefXsd.FLOAT, "xs:float");
    temp.put(DataTypeDefXsd.G_DAY, "xs:gDay");
    temp.put(DataTypeDefXsd.G_MONTH, "xs:gMonth");
    temp.put(DataTypeDefXsd.G_MONTH_DAY, "xs:gMonthDay");
    temp.put(DataTypeDefXsd.G_YEAR, "xs:gYear");
    temp.put(DataTypeDefXsd.G_YEAR_MONTH, "xs:gYearMonth");
    temp.put(DataTypeDefXsd.HEX_BINARY, "xs:hexBinary");
    temp.put(DataTypeDefXsd.INT, "xs:int");
    temp.put(DataTypeDefXsd.INTEGER, "xs:integer");
    temp.put(DataTypeDefXsd.LONG, "xs:long");
    temp.put(DataTypeDefXsd.NEGATIVE_INTEGER, "xs:negativeInteger");
    temp.put(DataTypeDefXsd.NON_NEGATIVE_INTEGER, "xs:nonNegativeInteger");
    temp.put(DataTypeDefXsd.NON_POSITIVE_INTEGER, "xs:nonPositiveInteger");
    temp.put(DataTypeDefXsd.POSITIVE_INTEGER, "xs:positiveInteger");
    temp.put(DataTypeDefXsd.SHORT, "xs:short");
    temp.put(DataTypeDefXsd.STRING, "xs:string");
    temp.put(DataTypeDefXsd.TIME, "xs:time");
    temp.put(DataTypeDefXsd.UNSIGNED_BYTE, "xs:unsignedByte");
    temp.put(DataTypeDefXsd.UNSIGNED_INT, "xs:unsignedInt");
    temp.put(DataTypeDefXsd.UNSIGNED_LONG, "xs:unsignedLong");
    temp.put(DataTypeDefXsd.UNSIGNED_SHORT, "xs:unsignedShort");

    if (!temp.keySet().containsAll(Arrays.asList(DataTypeDefXsd.values()))) {
      throw new IllegalStateException("Unmapped DataTypeDefXsd");
    }

    dataTypeDefXsdToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(DataTypeDefXsd that)
  {
    return Optional.ofNullable(that).map(dataTypeDefXsdToString::get);
  }

  private static final Map<String, DataTypeDefXsd> dataTypeDefXsdFromString;
  static {
    final Map<String, DataTypeDefXsd> temp = new HashMap<>();

    temp.put("xs:anyURI", DataTypeDefXsd.ANY_URI);
    temp.put("xs:base64Binary", DataTypeDefXsd.BASE_64_BINARY);
    temp.put("xs:boolean", DataTypeDefXsd.BOOLEAN);
    temp.put("xs:byte", DataTypeDefXsd.BYTE);
    temp.put("xs:date", DataTypeDefXsd.DATE);
    temp.put("xs:dateTime", DataTypeDefXsd.DATE_TIME);
    temp.put("xs:decimal", DataTypeDefXsd.DECIMAL);
    temp.put("xs:double", DataTypeDefXsd.DOUBLE);
    temp.put("xs:duration", DataTypeDefXsd.DURATION);
    temp.put("xs:float", DataTypeDefXsd.FLOAT);
    temp.put("xs:gDay", DataTypeDefXsd.G_DAY);
    temp.put("xs:gMonth", DataTypeDefXsd.G_MONTH);
    temp.put("xs:gMonthDay", DataTypeDefXsd.G_MONTH_DAY);
    temp.put("xs:gYear", DataTypeDefXsd.G_YEAR);
    temp.put("xs:gYearMonth", DataTypeDefXsd.G_YEAR_MONTH);
    temp.put("xs:hexBinary", DataTypeDefXsd.HEX_BINARY);
    temp.put("xs:int", DataTypeDefXsd.INT);
    temp.put("xs:integer", DataTypeDefXsd.INTEGER);
    temp.put("xs:long", DataTypeDefXsd.LONG);
    temp.put("xs:negativeInteger", DataTypeDefXsd.NEGATIVE_INTEGER);
    temp.put("xs:nonNegativeInteger", DataTypeDefXsd.NON_NEGATIVE_INTEGER);
    temp.put("xs:nonPositiveInteger", DataTypeDefXsd.NON_POSITIVE_INTEGER);
    temp.put("xs:positiveInteger", DataTypeDefXsd.POSITIVE_INTEGER);
    temp.put("xs:short", DataTypeDefXsd.SHORT);
    temp.put("xs:string", DataTypeDefXsd.STRING);
    temp.put("xs:time", DataTypeDefXsd.TIME);
    temp.put("xs:unsignedByte", DataTypeDefXsd.UNSIGNED_BYTE);
    temp.put("xs:unsignedInt", DataTypeDefXsd.UNSIGNED_INT);
    temp.put("xs:unsignedLong", DataTypeDefXsd.UNSIGNED_LONG);
    temp.put("xs:unsignedShort", DataTypeDefXsd.UNSIGNED_SHORT);

    if (!temp.values().containsAll(Arrays.asList(DataTypeDefXsd.values()))) {
      throw new IllegalStateException("Unmapped DataTypeDefXsd");
    }

    dataTypeDefXsdFromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "DataTypeDefXsd"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "DataTypeDefXsd"},
   * return {@code Optional#empty()}.
   */
  public static Optional<DataTypeDefXsd> dataTypeDefXsdFromString(String text)
  {
    DataTypeDefXsd value = dataTypeDefXsdFromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }

  private static final Map<DataTypeIec61360, String> dataTypeIec61360ToString;
  static {
    final Map<DataTypeIec61360, String> temp = new HashMap<>();

    temp.put(DataTypeIec61360.DATE, "DATE");
    temp.put(DataTypeIec61360.STRING, "STRING");
    temp.put(DataTypeIec61360.STRING_TRANSLATABLE, "STRING_TRANSLATABLE");
    temp.put(DataTypeIec61360.INTEGER_MEASURE, "INTEGER_MEASURE");
    temp.put(DataTypeIec61360.INTEGER_COUNT, "INTEGER_COUNT");
    temp.put(DataTypeIec61360.INTEGER_CURRENCY, "INTEGER_CURRENCY");
    temp.put(DataTypeIec61360.REAL_MEASURE, "REAL_MEASURE");
    temp.put(DataTypeIec61360.REAL_COUNT, "REAL_COUNT");
    temp.put(DataTypeIec61360.REAL_CURRENCY, "REAL_CURRENCY");
    temp.put(DataTypeIec61360.BOOLEAN, "BOOLEAN");
    temp.put(DataTypeIec61360.IRI, "IRI");
    temp.put(DataTypeIec61360.IRDI, "IRDI");
    temp.put(DataTypeIec61360.RATIONAL, "RATIONAL");
    temp.put(DataTypeIec61360.RATIONAL_MEASURE, "RATIONAL_MEASURE");
    temp.put(DataTypeIec61360.TIME, "TIME");
    temp.put(DataTypeIec61360.TIMESTAMP, "TIMESTAMP");
    temp.put(DataTypeIec61360.FILE, "FILE");
    temp.put(DataTypeIec61360.HTML, "HTML");
    temp.put(DataTypeIec61360.BLOB, "BLOB");

    if (!temp.keySet().containsAll(Arrays.asList(DataTypeIec61360.values()))) {
      throw new IllegalStateException("Unmapped DataTypeIec61360");
    }

    dataTypeIec61360ToString = Collections.unmodifiableMap(temp);
  }

  /**
   * Retrieve the string representation of {@code that}.
   *
   * <p>If {@code that} is not a valid literal, return {@code Optional#empty()}.
   */
  public static Optional<String> toString(DataTypeIec61360 that)
  {
    return Optional.ofNullable(that).map(dataTypeIec61360ToString::get);
  }

  private static final Map<String, DataTypeIec61360> dataTypeIec61360FromString;
  static {
    final Map<String, DataTypeIec61360> temp = new HashMap<>();

    temp.put("DATE", DataTypeIec61360.DATE);
    temp.put("STRING", DataTypeIec61360.STRING);
    temp.put("STRING_TRANSLATABLE", DataTypeIec61360.STRING_TRANSLATABLE);
    temp.put("INTEGER_MEASURE", DataTypeIec61360.INTEGER_MEASURE);
    temp.put("INTEGER_COUNT", DataTypeIec61360.INTEGER_COUNT);
    temp.put("INTEGER_CURRENCY", DataTypeIec61360.INTEGER_CURRENCY);
    temp.put("REAL_MEASURE", DataTypeIec61360.REAL_MEASURE);
    temp.put("REAL_COUNT", DataTypeIec61360.REAL_COUNT);
    temp.put("REAL_CURRENCY", DataTypeIec61360.REAL_CURRENCY);
    temp.put("BOOLEAN", DataTypeIec61360.BOOLEAN);
    temp.put("IRI", DataTypeIec61360.IRI);
    temp.put("IRDI", DataTypeIec61360.IRDI);
    temp.put("RATIONAL", DataTypeIec61360.RATIONAL);
    temp.put("RATIONAL_MEASURE", DataTypeIec61360.RATIONAL_MEASURE);
    temp.put("TIME", DataTypeIec61360.TIME);
    temp.put("TIMESTAMP", DataTypeIec61360.TIMESTAMP);
    temp.put("FILE", DataTypeIec61360.FILE);
    temp.put("HTML", DataTypeIec61360.HTML);
    temp.put("BLOB", DataTypeIec61360.BLOB);

    if (!temp.values().containsAll(Arrays.asList(DataTypeIec61360.values()))) {
      throw new IllegalStateException("Unmapped DataTypeIec61360");
    }

    dataTypeIec61360FromString = Collections.unmodifiableMap(temp);
  }

  /**
   * Parse the string representation of {@link "DataTypeIec61360"}.
   *
   * <p>If {@code text} is not a valid string representation
   * of a literal of {@link "DataTypeIec61360"},
   * return {@code Optional#empty()}.
   */
  public static Optional<DataTypeIec61360> dataTypeIec61360FromString(String text)
  {
    DataTypeIec61360 value = dataTypeIec61360FromString.get(text);
    if (value == null) {
      return Optional.empty();
    } else {
      return Optional.of(value);
    }
  }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
