/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package aas_core.aas3_0.xmlization;

import javax.xml.stream.events.XMLEvent;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.function.Function;
import java.util.List;
import java.util.Optional;
import aas_core.aas3_0.reporting.Reporting;
import aas_core.aas3_0.stringification.Stringification;
import aas_core.aas3_0.types.enums.*;
import aas_core.aas3_0.types.impl.*;
import aas_core.aas3_0.types.model.*;
import aas_core.aas3_0.visitation.*;

/**
 * Provide de/serialization of meta-model classes to/from XML.
 */
public class Xmlization {
  /**
   * Represent a critical error during the deserialization.
   */
  @SuppressWarnings("serial")
  public static class DeserializeException extends RuntimeException {
    private final String path;
    private final String reason;

    public DeserializeException(String path, String reason) {
      super(reason + " at: " + ("".equals(path) ? "the beginning" : path));
      this.path = path;
      this.reason = reason;
    }

    public Optional<String> getPath() {
      return Optional.ofNullable(path);
    }

    public Optional<String> getReason() {
      return Optional.ofNullable(reason);
    }
  }

  /**
   * Represent a critical error during the serialization.
   */
  @SuppressWarnings("serial")
  public static class SerializeException extends RuntimeException {
    private final String path;
    private final String reason;

    public SerializeException(String path, String reason) {
      super(reason + " at: " + ("".equals(path) ? "the beginning" : path));
      this.path = path;
      this.reason = reason;
    }

    public Optional<String> getPath() {
      return Optional.ofNullable(path);
    }

    public Optional<String> getReason() {
      return Optional.ofNullable(reason);
    }
  }

  /**
   * The XML namespace of the meta-model
   */
  public static final String AAS_NAME_SPACE =
    "https://admin-shell.io/aas/3/0";

  private static class Result<T> {
    private final T result;
    private final Reporting.Error error;
    private final boolean success;

    private Result(T result, Reporting.Error error, boolean success) {
      this.result = result;
      this.error = error;
      this.success = success;
    }

    public static <T> Result<T> success(T result) {
      if(result == null) throw new IllegalArgumentException("Result must not be null.");
      return new Result<>(result, null, true);
    }

    public static <T> Result<T> failure(Reporting.Error error) {
      if(error == null) throw new IllegalArgumentException("Error must not be null.");
      return new Result<>(null, error, false);
    }

    @SuppressWarnings("unchecked")
    public <I> Result<I> castTo(Class<I> type){
      if(isError() || type.isInstance(result)) return (Result<I>) this;
      throw new IllegalStateException("Result of type "
        + result.getClass().getName()
        + " is not an instance of "
        + type.getName());
    }

    public T getResult() {
      if (!isSuccess()) throw new IllegalStateException("Result is not present.");
      return result;
    }

    public boolean isSuccess() {
      return success;
    }

    public boolean isError(){return !success;}

    public Reporting.Error getError() {
      if (isSuccess()) throw new IllegalStateException("Result is present.");
      return error;
    }

    public <R> R map(Function<T, R> successFunction, Function<Reporting.Error, R> errorFunction) {
      return isSuccess() ? successFunction.apply(result) : errorFunction.apply(error);
    }

    public T onError(Function<Reporting.Error, T>  errorFunction){
      return map(Function.identity(), errorFunction);
    }
  }

  /**
   * Implement the deserialization of meta-model classes from XML.
   *
   * <p>The implementation propagates an {@link Reporting.Error} instead of
   * relying on exceptions. Under the assumption that incorrect data is much less
   * frequent than correct data, this makes the deserialization more
   * efficient.
   *
   * <p>However, we do not want to force the client to deal with
   * the {@link Reporting.Error} class as this is not intuitive.
   * Therefore we distinguish the implementation, realized in
   * {@link DeserializeImplementation}, and the facade given in
   * {@link Deserialize} class.
   */
  private static class DeserializeImplementation
  {
    private static XMLEvent currentEvent(XMLEventReader reader) {
      try {
        return reader.peek();
      } catch (XMLStreamException xmlStreamException) {
        throw new Xmlization.DeserializeException("",
          "Failed in method peek because of: " +
          xmlStreamException.getMessage());
      }
    }

    private static String getEventTypeAsString(XMLEvent event) {
      switch (event.getEventType()) {
        case XMLStreamConstants.START_ELEMENT:
          return "Start-Element";
        case XMLStreamConstants.END_ELEMENT:
          return "End-Element";
        case XMLStreamConstants.PROCESSING_INSTRUCTION:
          return "Processing-Instruction";
        case XMLStreamConstants.CHARACTERS:
          return "Characters";
        case XMLStreamConstants.COMMENT:
          return "Comment";
        case XMLStreamConstants.SPACE:
          return "Space";
        case XMLStreamConstants.START_DOCUMENT:
          return "Start-Document";
        case XMLStreamConstants.END_DOCUMENT:
          return "End-Document";
        case XMLStreamConstants.ENTITY_REFERENCE:
          return "Entity-Reference";
        case XMLStreamConstants.ATTRIBUTE:
          return "Attribute";
        case XMLStreamConstants.NOTATION_DECLARATION:
          return "Notation-Declaration";
        default:
          return "Unknown-Type";
      }
    }

    private static boolean isEmptyElement(XMLEventReader reader) {
      // Skip the element node and go to the content
      try {
        reader.nextEvent();
      } catch (XMLStreamException xmlStreamException) {
        throw new Xmlization.DeserializeException("",
          "Failed in method isEmptyElement because of: " +
          xmlStreamException.getMessage());
      }
      return currentEvent(reader).isEndElement();
    }

    private static boolean isWrongClosingTag(
      Result<String> tryElementName,
      Result<String> tryEndElementName) {
      return !tryElementName.getResult().equals(tryEndElementName.getResult());
    }

    private static Result<XMLEvent> verifyClosingTagForClass(
      String className,
      XMLEventReader reader,
      Result<String> tryElementName) {
      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.isEndDocument()) {
        final Reporting.Error error = new Reporting.Error(
            "Expected an XML end element to conclude a property of class " + className
                + " with the element name " + tryElementName.getResult() + ", "
                + "but got the end-of-file.");
        return Result.failure(error);
      }

      if (!currentEvent.isEndElement()) {
        final Reporting.Error error = new Reporting.Error(
            "Expected an XML end element to conclude a property of class " + className
                + " with the element name " + tryElementName.getResult() + ", "
                + "but got the node of type " + getEventTypeAsString(currentEvent)
                + " with the value " + currentEvent);
        return Result.failure(error);
      }
      final Result<String> tryEndElementName = tryElementName(reader);
      if (tryEndElementName.isError()) {
        return tryEndElementName.castTo(XMLEvent.class);
      }
      if (isWrongClosingTag(tryElementName, tryEndElementName)) {
        final Reporting.Error error = new Reporting.Error(
            "Expected an XML end element to conclude a property of class " + className
                + " with the element name " + tryElementName.getResult() + ", "
                + "but got the end element with the name " + tryEndElementName.getResult());
        return Result.failure(error);
      }
      try {
        return Result.success(reader.nextEvent());
      } catch (XMLStreamException xmlStreamException) {
        throw new Xmlization.DeserializeException("",
          "Failed in method verifyClosingTagForClass because of: " +
          xmlStreamException.getMessage());
      }
    }

    private static void skipWhitespaceAndComments(XMLEventReader reader) {
      while (whiteSpaceOrComment(reader)) {
        reader.next();
      }
    }

    private static boolean whiteSpaceOrComment(XMLEventReader reader) {
      final XMLEvent currentEvent = currentEvent(reader);
      final boolean isComment = (currentEvent != null &&
        currentEvent.getEventType() == XMLStreamConstants.COMMENT);
      final boolean isWhiteSpace = (currentEvent != null &&
        currentEvent.getEventType() == XMLStreamConstants.CHARACTERS &&
        currentEvent.asCharacters().isWhiteSpace());
      return isComment || isWhiteSpace;
    }

    private static void skipStartDocument(XMLEventReader reader){
      if (currentEvent(reader).isStartDocument()){
        reader.next();
      }
    }

    private static boolean invalidNameSpace(XMLEvent event) {
      if (event.isStartElement()) {
        return !AAS_NAME_SPACE.equals(event.asStartElement().getName().getNamespaceURI());
      } else {
        return !AAS_NAME_SPACE.equals(event.asEndElement().getName().getNamespaceURI());
      }
    }

    /**
     * Check the namespace and extract the element's name.
     */
    private static Result<String> tryElementName(XMLEventReader reader) {
      final XMLEvent currentEvent = currentEvent(reader);
      final boolean precondition = currentEvent.isStartElement() || currentEvent.isEndElement();
      if (!precondition) {
        throw new IllegalStateException("Expected to be at a start or an end element "
            + "but got: " + getEventTypeAsString(currentEvent));
      }

      if (invalidNameSpace(currentEvent)) {
        String namespace = currentEvent.isStartElement()
            ? currentEvent.asStartElement().getName().getNamespaceURI()
            : currentEvent.asEndElement().getName().getNamespaceURI();
        final Reporting.Error error = new Reporting.Error(
            "Expected an element within a namespace " +
            AAS_NAME_SPACE + ", " + "but got: " + namespace);
        return Result.failure(error);
      }
      return Result.success(currentEvent.isStartElement()
          ? currentEvent.asStartElement().getName().getLocalPart()
          : currentEvent.asEndElement().getName().getLocalPart());
    }

    private static String readContentAsString(XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();

      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }

      return content.toString();
    }

    private static Boolean readContentAsBool(XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();

      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }
      if(!("true".equals(content.toString()) || "false".equals(content.toString()))){
        throw new IllegalStateException("Content cannot be converted to the type Boolean.");
      }
      return Boolean.valueOf(content.toString());
    }

    private static Long readContentAsLong(XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();

      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }

      return Long.valueOf(content.toString());
    }

    private static Double readContentAsDouble(XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();

      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }

      return Double.valueOf(content.toString());
    }

    /**
     * Read the whole content of an element into memory.
     */
    private static byte[] readContentAsBase64(
      XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();
      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }

      String encodedData = content.toString();
      final byte[] decodedData;
      Base64.Decoder decoder = Base64.getDecoder();

      try {
        decodedData = decoder.decode(encodedData);
      } catch (IllegalArgumentException exception) {
        throw new XMLStreamException(
          "Failed to read base64 encoded data: " +
          exception.getMessage());
      }

      return decodedData;
    }

    /**
     * Deserialize an instance of IHasSemantics from an XML element.
     */
    private static Result<? extends IHasSemantics> tryIHasSemanticsFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IHasSemantics, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IHasSemantics.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "relationshipElement":
          return tryRelationshipElementFromElement(reader);
        case "annotatedRelationshipElement":
          return tryAnnotatedRelationshipElementFromElement(reader);
        case "basicEventElement":
          return tryBasicEventElementFromElement(reader);
        case "blob":
          return tryBlobFromElement(reader);
        case "capability":
          return tryCapabilityFromElement(reader);
        case "entity":
          return tryEntityFromElement(reader);
        case "extension":
          return tryExtensionFromElement(reader);
        case "file":
          return tryFileFromElement(reader);
        case "multiLanguageProperty":
          return tryMultiLanguagePropertyFromElement(reader);
        case "operation":
          return tryOperationFromElement(reader);
        case "property":
          return tryPropertyFromElement(reader);
        case "qualifier":
          return tryQualifierFromElement(reader);
        case "range":
          return tryRangeFromElement(reader);
        case "referenceElement":
          return tryReferenceElementFromElement(reader);
        case "specificAssetId":
          return trySpecificAssetIdFromElement(reader);
        case "submodel":
          return trySubmodelFromElement(reader);
        case "submodelElementCollection":
          return trySubmodelElementCollectionFromElement(reader);
        case "submodelElementList":
          return trySubmodelElementListFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class Extension from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Extension> tryExtensionFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      String theName = null;
      DataTypeDefXsd theValueType = null;
      String theValue = null;
      List<IReference> theRefersTo = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Extension, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Extension, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Extension.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Extension.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Extension.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "name":
            {
              if (isEmptyProperty) {
                theName = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property name of an instance of class Extension, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theName = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property name of an instance of class Extension "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "name"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "valueType":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property valueType of an instance of class Extension " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "valueType"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property valueType of an instance of class Extension, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textValueType;
              try {
                textValueType = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueType of an instance of class Extension"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueType"));
                return Result.failure(error);
              }

              final Optional<DataTypeDefXsd> optionalValueType =
                Stringification.dataTypeDefXsdFromString(
                  textValueType);

              if (optionalValueType.isPresent()) {
                theValueType = optionalValueType.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueType of an instance of class Extension" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textValueType);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueType"));
                return Result.failure(error);
              }
              break;
            }
            case "value":
            {
              if (isEmptyProperty) {
                theValue = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class Extension, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class Extension "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "refersTo":
            {
              theRefersTo = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("refersTo"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("refersTo"));
                    return itemResult.castTo(Extension.class);
                  }

                  theRefersTo.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Extension, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Extension",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Extension.class);

        }
      }

      if (theName == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property name has not been given " +
          "in the XML representation of an instance of class Extension");
        return Result.failure(error);
      }

      return Result.success(new Extension(
        theName,
        theSemanticId,
        theSupplementalSemanticIds,
        theValueType,
        theValue,
        theRefersTo));
    }

    /**
     * Deserialize an instance of class Extension from an XML element.
     */
    private static Result<Extension> tryExtensionFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Extension, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Extension, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Extension.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"extension".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Extension " +
          "with element name extension, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Extension> result = tryExtensionFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Extension.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Extension",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Extension.class);


      return result;
    }

    /**
     * Deserialize an instance of IHasExtensions from an XML element.
     */
    private static Result<? extends IHasExtensions> tryIHasExtensionsFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IHasExtensions, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IHasExtensions.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "relationshipElement":
          return tryRelationshipElementFromElement(reader);
        case "annotatedRelationshipElement":
          return tryAnnotatedRelationshipElementFromElement(reader);
        case "assetAdministrationShell":
          return tryAssetAdministrationShellFromElement(reader);
        case "basicEventElement":
          return tryBasicEventElementFromElement(reader);
        case "blob":
          return tryBlobFromElement(reader);
        case "capability":
          return tryCapabilityFromElement(reader);
        case "conceptDescription":
          return tryConceptDescriptionFromElement(reader);
        case "entity":
          return tryEntityFromElement(reader);
        case "file":
          return tryFileFromElement(reader);
        case "multiLanguageProperty":
          return tryMultiLanguagePropertyFromElement(reader);
        case "operation":
          return tryOperationFromElement(reader);
        case "property":
          return tryPropertyFromElement(reader);
        case "range":
          return tryRangeFromElement(reader);
        case "referenceElement":
          return tryReferenceElementFromElement(reader);
        case "submodel":
          return trySubmodelFromElement(reader);
        case "submodelElementCollection":
          return trySubmodelElementCollectionFromElement(reader);
        case "submodelElementList":
          return trySubmodelElementListFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of IReferable from an XML element.
     */
    private static Result<? extends IReferable> tryIReferableFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IReferable, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IReferable.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "relationshipElement":
          return tryRelationshipElementFromElement(reader);
        case "annotatedRelationshipElement":
          return tryAnnotatedRelationshipElementFromElement(reader);
        case "assetAdministrationShell":
          return tryAssetAdministrationShellFromElement(reader);
        case "basicEventElement":
          return tryBasicEventElementFromElement(reader);
        case "blob":
          return tryBlobFromElement(reader);
        case "capability":
          return tryCapabilityFromElement(reader);
        case "conceptDescription":
          return tryConceptDescriptionFromElement(reader);
        case "entity":
          return tryEntityFromElement(reader);
        case "file":
          return tryFileFromElement(reader);
        case "multiLanguageProperty":
          return tryMultiLanguagePropertyFromElement(reader);
        case "operation":
          return tryOperationFromElement(reader);
        case "property":
          return tryPropertyFromElement(reader);
        case "range":
          return tryRangeFromElement(reader);
        case "referenceElement":
          return tryReferenceElementFromElement(reader);
        case "submodel":
          return trySubmodelFromElement(reader);
        case "submodelElementCollection":
          return trySubmodelElementCollectionFromElement(reader);
        case "submodelElementList":
          return trySubmodelElementListFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of IIdentifiable from an XML element.
     */
    private static Result<? extends IIdentifiable> tryIIdentifiableFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IIdentifiable, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IIdentifiable.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "assetAdministrationShell":
          return tryAssetAdministrationShellFromElement(reader);
        case "conceptDescription":
          return tryConceptDescriptionFromElement(reader);
        case "submodel":
          return trySubmodelFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of IHasKind from an XML element.
     */
    private static Result<? extends IHasKind> tryIHasKindFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IHasKind, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IHasKind.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "submodel":
          return trySubmodelFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of IHasDataSpecification from an XML element.
     */
    private static Result<? extends IHasDataSpecification> tryIHasDataSpecificationFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IHasDataSpecification, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IHasDataSpecification.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "administrativeInformation":
          return tryAdministrativeInformationFromElement(reader);
        case "relationshipElement":
          return tryRelationshipElementFromElement(reader);
        case "annotatedRelationshipElement":
          return tryAnnotatedRelationshipElementFromElement(reader);
        case "assetAdministrationShell":
          return tryAssetAdministrationShellFromElement(reader);
        case "basicEventElement":
          return tryBasicEventElementFromElement(reader);
        case "blob":
          return tryBlobFromElement(reader);
        case "capability":
          return tryCapabilityFromElement(reader);
        case "conceptDescription":
          return tryConceptDescriptionFromElement(reader);
        case "entity":
          return tryEntityFromElement(reader);
        case "file":
          return tryFileFromElement(reader);
        case "multiLanguageProperty":
          return tryMultiLanguagePropertyFromElement(reader);
        case "operation":
          return tryOperationFromElement(reader);
        case "property":
          return tryPropertyFromElement(reader);
        case "range":
          return tryRangeFromElement(reader);
        case "referenceElement":
          return tryReferenceElementFromElement(reader);
        case "submodel":
          return trySubmodelFromElement(reader);
        case "submodelElementCollection":
          return trySubmodelElementCollectionFromElement(reader);
        case "submodelElementList":
          return trySubmodelElementListFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class AdministrativeInformation from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<AdministrativeInformation> tryAdministrativeInformationFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      String theVersion = null;
      String theRevision = null;
      IReference theCreator = null;
      String theTemplateId = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class AdministrativeInformation, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class AdministrativeInformation, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(AdministrativeInformation.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(AdministrativeInformation.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "version":
            {
              if (isEmptyProperty) {
                theVersion = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property version of an instance of class AdministrativeInformation, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theVersion = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property version of an instance of class AdministrativeInformation "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "version"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "revision":
            {
              if (isEmptyProperty) {
                theRevision = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property revision of an instance of class AdministrativeInformation, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theRevision = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property revision of an instance of class AdministrativeInformation "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "revision"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "creator":
            {
              Result<Reference> tryCreator = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryCreator.isError()) {
                tryCreator.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "creator"));
                return tryCreator.castTo(AdministrativeInformation.class);
              }

              theCreator = tryCreator.getResult();
              break;
            }
            case "templateId":
            {
              if (isEmptyProperty) {
                theTemplateId = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property templateId of an instance of class AdministrativeInformation, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theTemplateId = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property templateId of an instance of class AdministrativeInformation "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "templateId"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class AdministrativeInformation, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "AdministrativeInformation",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(AdministrativeInformation.class);

        }
      }

      return Result.success(new AdministrativeInformation(
        theEmbeddedDataSpecifications,
        theVersion,
        theRevision,
        theCreator,
        theTemplateId));
    }

    /**
     * Deserialize an instance of class AdministrativeInformation from an XML element.
     */
    private static Result<AdministrativeInformation> tryAdministrativeInformationFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class AdministrativeInformation, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class AdministrativeInformation, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(AdministrativeInformation.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"administrativeInformation".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class AdministrativeInformation " +
          "with element name administrativeInformation, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<AdministrativeInformation> result = tryAdministrativeInformationFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(AdministrativeInformation.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "AdministrativeInformation",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(AdministrativeInformation.class);


      return result;
    }

    /**
     * Deserialize an instance of IQualifiable from an XML element.
     */
    private static Result<? extends IQualifiable> tryIQualifiableFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IQualifiable, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IQualifiable.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "relationshipElement":
          return tryRelationshipElementFromElement(reader);
        case "annotatedRelationshipElement":
          return tryAnnotatedRelationshipElementFromElement(reader);
        case "basicEventElement":
          return tryBasicEventElementFromElement(reader);
        case "blob":
          return tryBlobFromElement(reader);
        case "capability":
          return tryCapabilityFromElement(reader);
        case "entity":
          return tryEntityFromElement(reader);
        case "file":
          return tryFileFromElement(reader);
        case "multiLanguageProperty":
          return tryMultiLanguagePropertyFromElement(reader);
        case "operation":
          return tryOperationFromElement(reader);
        case "property":
          return tryPropertyFromElement(reader);
        case "range":
          return tryRangeFromElement(reader);
        case "referenceElement":
          return tryReferenceElementFromElement(reader);
        case "submodel":
          return trySubmodelFromElement(reader);
        case "submodelElementCollection":
          return trySubmodelElementCollectionFromElement(reader);
        case "submodelElementList":
          return trySubmodelElementListFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class Qualifier from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Qualifier> tryQualifierFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      QualifierKind theKind = null;
      String theType = null;
      DataTypeDefXsd theValueType = null;
      String theValue = null;
      IReference theValueId = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Qualifier, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Qualifier, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Qualifier.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Qualifier.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Qualifier.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "kind":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property kind of an instance of class Qualifier " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "kind"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property kind of an instance of class Qualifier, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textKind;
              try {
                textKind = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property kind of an instance of class Qualifier"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "kind"));
                return Result.failure(error);
              }

              final Optional<QualifierKind> optionalKind =
                Stringification.qualifierKindFromString(
                  textKind);

              if (optionalKind.isPresent()) {
                theKind = optionalKind.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property kind of an instance of class Qualifier" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textKind);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "kind"));
                return Result.failure(error);
              }
              break;
            }
            case "type":
            {
              if (isEmptyProperty) {
                theType = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property type of an instance of class Qualifier, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theType = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property type of an instance of class Qualifier "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "type"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "valueType":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property valueType of an instance of class Qualifier " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "valueType"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property valueType of an instance of class Qualifier, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textValueType;
              try {
                textValueType = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueType of an instance of class Qualifier"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueType"));
                return Result.failure(error);
              }

              final Optional<DataTypeDefXsd> optionalValueType =
                Stringification.dataTypeDefXsdFromString(
                  textValueType);

              if (optionalValueType.isPresent()) {
                theValueType = optionalValueType.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueType of an instance of class Qualifier" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textValueType);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueType"));
                return Result.failure(error);
              }
              break;
            }
            case "value":
            {
              if (isEmptyProperty) {
                theValue = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class Qualifier, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class Qualifier "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "valueId":
            {
              Result<Reference> tryValueId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryValueId.isError()) {
                tryValueId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "valueId"));
                return tryValueId.castTo(Qualifier.class);
              }

              theValueId = tryValueId.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Qualifier, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Qualifier",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Qualifier.class);

        }
      }

      if (theType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property type has not been given " +
          "in the XML representation of an instance of class Qualifier");
        return Result.failure(error);
      }

      if (theValueType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property valueType has not been given " +
          "in the XML representation of an instance of class Qualifier");
        return Result.failure(error);
      }

      return Result.success(new Qualifier(
        theType,
        theValueType,
        theSemanticId,
        theSupplementalSemanticIds,
        theKind,
        theValue,
        theValueId));
    }

    /**
     * Deserialize an instance of class Qualifier from an XML element.
     */
    private static Result<Qualifier> tryQualifierFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Qualifier, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Qualifier, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Qualifier.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"qualifier".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Qualifier " +
          "with element name qualifier, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Qualifier> result = tryQualifierFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Qualifier.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Qualifier",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Qualifier.class);


      return result;
    }

    /**
     * Deserialize an instance of class AssetAdministrationShell from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<AssetAdministrationShell> tryAssetAdministrationShellFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IAdministrativeInformation theAdministration = null;
      String theId = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      IReference theDerivedFrom = null;
      IAssetInformation theAssetInformation = null;
      List<IReference> theSubmodels = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class AssetAdministrationShell, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class AssetAdministrationShell, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(AssetAdministrationShell.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(AssetAdministrationShell.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class AssetAdministrationShell, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class AssetAdministrationShell "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class AssetAdministrationShell, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class AssetAdministrationShell "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(AssetAdministrationShell.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(AssetAdministrationShell.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "administration":
            {
              Result<AdministrativeInformation> tryAdministration = tryAdministrativeInformationFromSequence(
                reader, isEmptyProperty);

              if (tryAdministration.isError()) {
                tryAdministration.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "administration"));
                return tryAdministration.castTo(AssetAdministrationShell.class);
              }

              theAdministration = tryAdministration.getResult();
              break;
            }
            case "id":
            {
              if (isEmptyProperty) {
                theId = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property id of an instance of class AssetAdministrationShell, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theId = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property id of an instance of class AssetAdministrationShell "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "id"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(AssetAdministrationShell.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "derivedFrom":
            {
              Result<Reference> tryDerivedFrom = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryDerivedFrom.isError()) {
                tryDerivedFrom.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "derivedFrom"));
                return tryDerivedFrom.castTo(AssetAdministrationShell.class);
              }

              theDerivedFrom = tryDerivedFrom.getResult();
              break;
            }
            case "assetInformation":
            {
              Result<AssetInformation> tryAssetInformation = tryAssetInformationFromSequence(
                reader, isEmptyProperty);

              if (tryAssetInformation.isError()) {
                tryAssetInformation.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "assetInformation"));
                return tryAssetInformation.castTo(AssetAdministrationShell.class);
              }

              theAssetInformation = tryAssetInformation.getResult();
              break;
            }
            case "submodels":
            {
              theSubmodels = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("submodels"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("submodels"));
                    return itemResult.castTo(AssetAdministrationShell.class);
                  }

                  theSubmodels.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class AssetAdministrationShell, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "AssetAdministrationShell",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(AssetAdministrationShell.class);

        }
      }

      if (theId == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property id has not been given " +
          "in the XML representation of an instance of class AssetAdministrationShell");
        return Result.failure(error);
      }

      if (theAssetInformation == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property assetInformation has not been given " +
          "in the XML representation of an instance of class AssetAdministrationShell");
        return Result.failure(error);
      }

      return Result.success(new AssetAdministrationShell(
        theId,
        theAssetInformation,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theAdministration,
        theEmbeddedDataSpecifications,
        theDerivedFrom,
        theSubmodels));
    }

    /**
     * Deserialize an instance of class AssetAdministrationShell from an XML element.
     */
    private static Result<AssetAdministrationShell> tryAssetAdministrationShellFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class AssetAdministrationShell, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class AssetAdministrationShell, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(AssetAdministrationShell.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"assetAdministrationShell".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class AssetAdministrationShell " +
          "with element name assetAdministrationShell, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<AssetAdministrationShell> result = tryAssetAdministrationShellFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(AssetAdministrationShell.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "AssetAdministrationShell",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(AssetAdministrationShell.class);


      return result;
    }

    /**
     * Deserialize an instance of class AssetInformation from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<AssetInformation> tryAssetInformationFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      AssetKind theAssetKind = null;
      String theGlobalAssetId = null;
      List<ISpecificAssetId> theSpecificAssetIds = null;
      String theAssetType = null;
      IResource theDefaultThumbnail = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class AssetInformation, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class AssetInformation, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(AssetInformation.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "assetKind":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property assetKind of an instance of class AssetInformation " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "assetKind"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property assetKind of an instance of class AssetInformation, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textAssetKind;
              try {
                textAssetKind = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property assetKind of an instance of class AssetInformation"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "assetKind"));
                return Result.failure(error);
              }

              final Optional<AssetKind> optionalAssetKind =
                Stringification.assetKindFromString(
                  textAssetKind);

              if (optionalAssetKind.isPresent()) {
                theAssetKind = optionalAssetKind.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property assetKind of an instance of class AssetInformation" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textAssetKind);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "assetKind"));
                return Result.failure(error);
              }
              break;
            }
            case "globalAssetId":
            {
              if (isEmptyProperty) {
                theGlobalAssetId = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property globalAssetId of an instance of class AssetInformation, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theGlobalAssetId = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property globalAssetId of an instance of class AssetInformation "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "globalAssetId"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "specificAssetIds":
            {
              theSpecificAssetIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ISpecificAssetId, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("specificAssetIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ISpecificAssetId> itemResult = trySpecificAssetIdFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("specificAssetIds"));
                    return itemResult.castTo(AssetInformation.class);
                  }

                  theSpecificAssetIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "assetType":
            {
              if (isEmptyProperty) {
                theAssetType = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property assetType of an instance of class AssetInformation, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theAssetType = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property assetType of an instance of class AssetInformation "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "assetType"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "defaultThumbnail":
            {
              Result<Resource> tryDefaultThumbnail = tryResourceFromSequence(
                reader, isEmptyProperty);

              if (tryDefaultThumbnail.isError()) {
                tryDefaultThumbnail.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "defaultThumbnail"));
                return tryDefaultThumbnail.castTo(AssetInformation.class);
              }

              theDefaultThumbnail = tryDefaultThumbnail.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class AssetInformation, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "AssetInformation",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(AssetInformation.class);

        }
      }

      if (theAssetKind == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property assetKind has not been given " +
          "in the XML representation of an instance of class AssetInformation");
        return Result.failure(error);
      }

      return Result.success(new AssetInformation(
        theAssetKind,
        theGlobalAssetId,
        theSpecificAssetIds,
        theAssetType,
        theDefaultThumbnail));
    }

    /**
     * Deserialize an instance of class AssetInformation from an XML element.
     */
    private static Result<AssetInformation> tryAssetInformationFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class AssetInformation, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class AssetInformation, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(AssetInformation.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"assetInformation".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class AssetInformation " +
          "with element name assetInformation, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<AssetInformation> result = tryAssetInformationFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(AssetInformation.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "AssetInformation",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(AssetInformation.class);


      return result;
    }

    /**
     * Deserialize an instance of class Resource from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Resource> tryResourceFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      String thePath = null;
      String theContentType = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Resource, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Resource, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Resource.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "path":
            {
              if (isEmptyProperty) {
                thePath = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property path of an instance of class Resource, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  thePath = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property path of an instance of class Resource "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "path"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "contentType":
            {
              if (isEmptyProperty) {
                theContentType = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property contentType of an instance of class Resource, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theContentType = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property contentType of an instance of class Resource "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "contentType"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Resource, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Resource",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Resource.class);

        }
      }

      if (thePath == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property path has not been given " +
          "in the XML representation of an instance of class Resource");
        return Result.failure(error);
      }

      return Result.success(new Resource(
        thePath,
        theContentType));
    }

    /**
     * Deserialize an instance of class Resource from an XML element.
     */
    private static Result<Resource> tryResourceFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Resource, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Resource, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Resource.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"resource".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Resource " +
          "with element name resource, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Resource> result = tryResourceFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Resource.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Resource",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Resource.class);


      return result;
    }

    /**
     * Deserialize an instance of class SpecificAssetId from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<SpecificAssetId> trySpecificAssetIdFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      String theName = null;
      String theValue = null;
      IReference theExternalSubjectId = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class SpecificAssetId, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class SpecificAssetId, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(SpecificAssetId.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(SpecificAssetId.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(SpecificAssetId.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "name":
            {
              if (isEmptyProperty) {
                theName = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property name of an instance of class SpecificAssetId, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theName = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property name of an instance of class SpecificAssetId "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "name"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "value":
            {
              if (isEmptyProperty) {
                theValue = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class SpecificAssetId, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class SpecificAssetId "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "externalSubjectId":
            {
              Result<Reference> tryExternalSubjectId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryExternalSubjectId.isError()) {
                tryExternalSubjectId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "externalSubjectId"));
                return tryExternalSubjectId.castTo(SpecificAssetId.class);
              }

              theExternalSubjectId = tryExternalSubjectId.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class SpecificAssetId, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "SpecificAssetId",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(SpecificAssetId.class);

        }
      }

      if (theName == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property name has not been given " +
          "in the XML representation of an instance of class SpecificAssetId");
        return Result.failure(error);
      }

      if (theValue == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property value has not been given " +
          "in the XML representation of an instance of class SpecificAssetId");
        return Result.failure(error);
      }

      return Result.success(new SpecificAssetId(
        theName,
        theValue,
        theSemanticId,
        theSupplementalSemanticIds,
        theExternalSubjectId));
    }

    /**
     * Deserialize an instance of class SpecificAssetId from an XML element.
     */
    private static Result<SpecificAssetId> trySpecificAssetIdFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class SpecificAssetId, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class SpecificAssetId, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(SpecificAssetId.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"specificAssetId".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class SpecificAssetId " +
          "with element name specificAssetId, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<SpecificAssetId> result = trySpecificAssetIdFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(SpecificAssetId.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "SpecificAssetId",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(SpecificAssetId.class);


      return result;
    }

    /**
     * Deserialize an instance of class Submodel from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Submodel> trySubmodelFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IAdministrativeInformation theAdministration = null;
      String theId = null;
      ModellingKind theKind = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      List<ISubmodelElement> theSubmodelElements = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Submodel, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Submodel, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Submodel.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(Submodel.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class Submodel, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class Submodel "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class Submodel, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class Submodel "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(Submodel.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(Submodel.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "administration":
            {
              Result<AdministrativeInformation> tryAdministration = tryAdministrativeInformationFromSequence(
                reader, isEmptyProperty);

              if (tryAdministration.isError()) {
                tryAdministration.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "administration"));
                return tryAdministration.castTo(Submodel.class);
              }

              theAdministration = tryAdministration.getResult();
              break;
            }
            case "id":
            {
              if (isEmptyProperty) {
                theId = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property id of an instance of class Submodel, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theId = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property id of an instance of class Submodel "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "id"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "kind":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property kind of an instance of class Submodel " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "kind"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property kind of an instance of class Submodel, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textKind;
              try {
                textKind = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property kind of an instance of class Submodel"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "kind"));
                return Result.failure(error);
              }

              final Optional<ModellingKind> optionalKind =
                Stringification.modellingKindFromString(
                  textKind);

              if (optionalKind.isPresent()) {
                theKind = optionalKind.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property kind of an instance of class Submodel" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textKind);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "kind"));
                return Result.failure(error);
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Submodel.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Submodel.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(Submodel.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(Submodel.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "submodelElements":
            {
              theSubmodelElements = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ISubmodelElement, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("submodelElements"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ISubmodelElement> itemResult = tryISubmodelElementFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("submodelElements"));
                    return itemResult.castTo(Submodel.class);
                  }

                  theSubmodelElements.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Submodel, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Submodel",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Submodel.class);

        }
      }

      if (theId == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property id has not been given " +
          "in the XML representation of an instance of class Submodel");
        return Result.failure(error);
      }

      return Result.success(new Submodel(
        theId,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theAdministration,
        theKind,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theSubmodelElements));
    }

    /**
     * Deserialize an instance of class Submodel from an XML element.
     */
    private static Result<Submodel> trySubmodelFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Submodel, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Submodel, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Submodel.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"submodel".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Submodel " +
          "with element name submodel, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Submodel> result = trySubmodelFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Submodel.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Submodel",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Submodel.class);


      return result;
    }

    /**
     * Deserialize an instance of ISubmodelElement from an XML element.
     */
    private static Result<? extends ISubmodelElement> tryISubmodelElementFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ISubmodelElement, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(ISubmodelElement.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "relationshipElement":
          return tryRelationshipElementFromElement(reader);
        case "annotatedRelationshipElement":
          return tryAnnotatedRelationshipElementFromElement(reader);
        case "basicEventElement":
          return tryBasicEventElementFromElement(reader);
        case "blob":
          return tryBlobFromElement(reader);
        case "capability":
          return tryCapabilityFromElement(reader);
        case "entity":
          return tryEntityFromElement(reader);
        case "file":
          return tryFileFromElement(reader);
        case "multiLanguageProperty":
          return tryMultiLanguagePropertyFromElement(reader);
        case "operation":
          return tryOperationFromElement(reader);
        case "property":
          return tryPropertyFromElement(reader);
        case "range":
          return tryRangeFromElement(reader);
        case "referenceElement":
          return tryReferenceElementFromElement(reader);
        case "submodelElementCollection":
          return trySubmodelElementCollectionFromElement(reader);
        case "submodelElementList":
          return trySubmodelElementListFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class RelationshipElement from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<RelationshipElement> tryRelationshipElementFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      IReference theFirst = null;
      IReference theSecond = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class RelationshipElement, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class RelationshipElement, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(RelationshipElement.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(RelationshipElement.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class RelationshipElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class RelationshipElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class RelationshipElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class RelationshipElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(RelationshipElement.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(RelationshipElement.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(RelationshipElement.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(RelationshipElement.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(RelationshipElement.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(RelationshipElement.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "first":
            {
              Result<Reference> tryFirst = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryFirst.isError()) {
                tryFirst.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "first"));
                return tryFirst.castTo(RelationshipElement.class);
              }

              theFirst = tryFirst.getResult();
              break;
            }
            case "second":
            {
              Result<Reference> trySecond = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySecond.isError()) {
                trySecond.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "second"));
                return trySecond.castTo(RelationshipElement.class);
              }

              theSecond = trySecond.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class RelationshipElement, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "RelationshipElement",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(RelationshipElement.class);

        }
      }

      if (theFirst == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property first has not been given " +
          "in the XML representation of an instance of class RelationshipElement");
        return Result.failure(error);
      }

      if (theSecond == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property second has not been given " +
          "in the XML representation of an instance of class RelationshipElement");
        return Result.failure(error);
      }

      return Result.success(new RelationshipElement(
        theFirst,
        theSecond,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications));
    }

    /**
     * Deserialize an instance of IRelationshipElement from an XML element.
     */
    private static Result<? extends IRelationshipElement> tryIRelationshipElementFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IRelationshipElement, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IRelationshipElement.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "annotatedRelationshipElement":
          return tryAnnotatedRelationshipElementFromElement(reader);
        case "relationshipElement":
          return tryRelationshipElementFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class RelationshipElement from an XML element.
     */
    private static Result<RelationshipElement> tryRelationshipElementFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class RelationshipElement, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class RelationshipElement, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(RelationshipElement.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"relationshipElement".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class RelationshipElement " +
          "with element name relationshipElement, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<RelationshipElement> result = tryRelationshipElementFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(RelationshipElement.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "RelationshipElement",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(RelationshipElement.class);


      return result;
    }

    /**
     * Deserialize an instance of class SubmodelElementList from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<SubmodelElementList> trySubmodelElementListFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      Boolean theOrderRelevant = null;
      IReference theSemanticIdListElement = null;
      AasSubmodelElements theTypeValueListElement = null;
      DataTypeDefXsd theValueTypeListElement = null;
      List<ISubmodelElement> theValue = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class SubmodelElementList, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class SubmodelElementList, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(SubmodelElementList.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(SubmodelElementList.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class SubmodelElementList, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class SubmodelElementList "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class SubmodelElementList, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class SubmodelElementList "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(SubmodelElementList.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(SubmodelElementList.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(SubmodelElementList.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(SubmodelElementList.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(SubmodelElementList.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(SubmodelElementList.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "orderRelevant":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property orderRelevant of an instance of class SubmodelElementList " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "orderRelevant"));
                return Result.failure(error);
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property orderRelevant of an instance of class SubmodelElementList, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theOrderRelevant = readContentAsBool(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property orderRelevant of an instance of class SubmodelElementList "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "orderRelevant"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "semanticIdListElement":
            {
              Result<Reference> trySemanticIdListElement = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticIdListElement.isError()) {
                trySemanticIdListElement.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticIdListElement"));
                return trySemanticIdListElement.castTo(SubmodelElementList.class);
              }

              theSemanticIdListElement = trySemanticIdListElement.getResult();
              break;
            }
            case "typeValueListElement":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property typeValueListElement of an instance of class SubmodelElementList " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "typeValueListElement"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property typeValueListElement of an instance of class SubmodelElementList, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textTypeValueListElement;
              try {
                textTypeValueListElement = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property typeValueListElement of an instance of class SubmodelElementList"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "typeValueListElement"));
                return Result.failure(error);
              }

              final Optional<AasSubmodelElements> optionalTypeValueListElement =
                Stringification.aasSubmodelElementsFromString(
                  textTypeValueListElement);

              if (optionalTypeValueListElement.isPresent()) {
                theTypeValueListElement = optionalTypeValueListElement.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property typeValueListElement of an instance of class SubmodelElementList" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textTypeValueListElement);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "typeValueListElement"));
                return Result.failure(error);
              }
              break;
            }
            case "valueTypeListElement":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property valueTypeListElement of an instance of class SubmodelElementList " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "valueTypeListElement"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property valueTypeListElement of an instance of class SubmodelElementList, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textValueTypeListElement;
              try {
                textValueTypeListElement = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueTypeListElement of an instance of class SubmodelElementList"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueTypeListElement"));
                return Result.failure(error);
              }

              final Optional<DataTypeDefXsd> optionalValueTypeListElement =
                Stringification.dataTypeDefXsdFromString(
                  textValueTypeListElement);

              if (optionalValueTypeListElement.isPresent()) {
                theValueTypeListElement = optionalValueTypeListElement.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueTypeListElement of an instance of class SubmodelElementList" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textValueTypeListElement);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueTypeListElement"));
                return Result.failure(error);
              }
              break;
            }
            case "value":
            {
              theValue = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ISubmodelElement, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("value"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ISubmodelElement> itemResult = tryISubmodelElementFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("value"));
                    return itemResult.castTo(SubmodelElementList.class);
                  }

                  theValue.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class SubmodelElementList, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "SubmodelElementList",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(SubmodelElementList.class);

        }
      }

      if (theTypeValueListElement == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property typeValueListElement has not been given " +
          "in the XML representation of an instance of class SubmodelElementList");
        return Result.failure(error);
      }

      return Result.success(new SubmodelElementList(
        theTypeValueListElement,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theOrderRelevant,
        theSemanticIdListElement,
        theValueTypeListElement,
        theValue));
    }

    /**
     * Deserialize an instance of class SubmodelElementList from an XML element.
     */
    private static Result<SubmodelElementList> trySubmodelElementListFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class SubmodelElementList, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class SubmodelElementList, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(SubmodelElementList.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"submodelElementList".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class SubmodelElementList " +
          "with element name submodelElementList, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<SubmodelElementList> result = trySubmodelElementListFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(SubmodelElementList.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "SubmodelElementList",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(SubmodelElementList.class);


      return result;
    }

    /**
     * Deserialize an instance of class SubmodelElementCollection from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<SubmodelElementCollection> trySubmodelElementCollectionFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      List<ISubmodelElement> theValue = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class SubmodelElementCollection, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class SubmodelElementCollection, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(SubmodelElementCollection.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(SubmodelElementCollection.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class SubmodelElementCollection, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class SubmodelElementCollection "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class SubmodelElementCollection, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class SubmodelElementCollection "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(SubmodelElementCollection.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(SubmodelElementCollection.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(SubmodelElementCollection.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(SubmodelElementCollection.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(SubmodelElementCollection.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(SubmodelElementCollection.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "value":
            {
              theValue = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ISubmodelElement, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("value"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ISubmodelElement> itemResult = tryISubmodelElementFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("value"));
                    return itemResult.castTo(SubmodelElementCollection.class);
                  }

                  theValue.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class SubmodelElementCollection, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "SubmodelElementCollection",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(SubmodelElementCollection.class);

        }
      }

      return Result.success(new SubmodelElementCollection(
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theValue));
    }

    /**
     * Deserialize an instance of class SubmodelElementCollection from an XML element.
     */
    private static Result<SubmodelElementCollection> trySubmodelElementCollectionFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class SubmodelElementCollection, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class SubmodelElementCollection, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(SubmodelElementCollection.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"submodelElementCollection".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class SubmodelElementCollection " +
          "with element name submodelElementCollection, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<SubmodelElementCollection> result = trySubmodelElementCollectionFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(SubmodelElementCollection.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "SubmodelElementCollection",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(SubmodelElementCollection.class);


      return result;
    }

    /**
     * Deserialize an instance of IDataElement from an XML element.
     */
    private static Result<? extends IDataElement> tryIDataElementFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IDataElement, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IDataElement.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "blob":
          return tryBlobFromElement(reader);
        case "file":
          return tryFileFromElement(reader);
        case "multiLanguageProperty":
          return tryMultiLanguagePropertyFromElement(reader);
        case "property":
          return tryPropertyFromElement(reader);
        case "range":
          return tryRangeFromElement(reader);
        case "referenceElement":
          return tryReferenceElementFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class Property from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Property> tryPropertyFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      DataTypeDefXsd theValueType = null;
      String theValue = null;
      IReference theValueId = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Property, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Property, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Property.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(Property.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class Property, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class Property "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class Property, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class Property "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(Property.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(Property.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Property.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Property.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(Property.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(Property.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "valueType":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property valueType of an instance of class Property " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "valueType"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property valueType of an instance of class Property, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textValueType;
              try {
                textValueType = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueType of an instance of class Property"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueType"));
                return Result.failure(error);
              }

              final Optional<DataTypeDefXsd> optionalValueType =
                Stringification.dataTypeDefXsdFromString(
                  textValueType);

              if (optionalValueType.isPresent()) {
                theValueType = optionalValueType.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueType of an instance of class Property" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textValueType);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueType"));
                return Result.failure(error);
              }
              break;
            }
            case "value":
            {
              if (isEmptyProperty) {
                theValue = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class Property, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class Property "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "valueId":
            {
              Result<Reference> tryValueId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryValueId.isError()) {
                tryValueId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "valueId"));
                return tryValueId.castTo(Property.class);
              }

              theValueId = tryValueId.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Property, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Property",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Property.class);

        }
      }

      if (theValueType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property valueType has not been given " +
          "in the XML representation of an instance of class Property");
        return Result.failure(error);
      }

      return Result.success(new Property(
        theValueType,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theValue,
        theValueId));
    }

    /**
     * Deserialize an instance of class Property from an XML element.
     */
    private static Result<Property> tryPropertyFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Property, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Property, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Property.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"property".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Property " +
          "with element name property, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Property> result = tryPropertyFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Property.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Property",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Property.class);


      return result;
    }

    /**
     * Deserialize an instance of class MultiLanguageProperty from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<MultiLanguageProperty> tryMultiLanguagePropertyFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      List<ILangStringTextType> theValue = null;
      IReference theValueId = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class MultiLanguageProperty, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class MultiLanguageProperty, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(MultiLanguageProperty.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(MultiLanguageProperty.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class MultiLanguageProperty, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class MultiLanguageProperty "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class MultiLanguageProperty, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class MultiLanguageProperty "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(MultiLanguageProperty.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(MultiLanguageProperty.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(MultiLanguageProperty.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(MultiLanguageProperty.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(MultiLanguageProperty.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(MultiLanguageProperty.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "value":
            {
              theValue = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("value"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("value"));
                    return itemResult.castTo(MultiLanguageProperty.class);
                  }

                  theValue.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "valueId":
            {
              Result<Reference> tryValueId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryValueId.isError()) {
                tryValueId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "valueId"));
                return tryValueId.castTo(MultiLanguageProperty.class);
              }

              theValueId = tryValueId.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class MultiLanguageProperty, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "MultiLanguageProperty",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(MultiLanguageProperty.class);

        }
      }

      return Result.success(new MultiLanguageProperty(
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theValue,
        theValueId));
    }

    /**
     * Deserialize an instance of class MultiLanguageProperty from an XML element.
     */
    private static Result<MultiLanguageProperty> tryMultiLanguagePropertyFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class MultiLanguageProperty, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class MultiLanguageProperty, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(MultiLanguageProperty.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"multiLanguageProperty".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class MultiLanguageProperty " +
          "with element name multiLanguageProperty, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<MultiLanguageProperty> result = tryMultiLanguagePropertyFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(MultiLanguageProperty.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "MultiLanguageProperty",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(MultiLanguageProperty.class);


      return result;
    }

    /**
     * Deserialize an instance of class Range from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Range> tryRangeFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      DataTypeDefXsd theValueType = null;
      String theMin = null;
      String theMax = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Range, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Range, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Range.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(Range.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class Range, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class Range "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class Range, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class Range "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(Range.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(Range.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Range.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Range.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(Range.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(Range.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "valueType":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property valueType of an instance of class Range " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "valueType"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property valueType of an instance of class Range, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textValueType;
              try {
                textValueType = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueType of an instance of class Range"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueType"));
                return Result.failure(error);
              }

              final Optional<DataTypeDefXsd> optionalValueType =
                Stringification.dataTypeDefXsdFromString(
                  textValueType);

              if (optionalValueType.isPresent()) {
                theValueType = optionalValueType.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property valueType of an instance of class Range" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textValueType);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "valueType"));
                return Result.failure(error);
              }
              break;
            }
            case "min":
            {
              if (isEmptyProperty) {
                theMin = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property min of an instance of class Range, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theMin = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property min of an instance of class Range "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "min"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "max":
            {
              if (isEmptyProperty) {
                theMax = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property max of an instance of class Range, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theMax = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property max of an instance of class Range "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "max"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Range, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Range",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Range.class);

        }
      }

      if (theValueType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property valueType has not been given " +
          "in the XML representation of an instance of class Range");
        return Result.failure(error);
      }

      return Result.success(new Range(
        theValueType,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theMin,
        theMax));
    }

    /**
     * Deserialize an instance of class Range from an XML element.
     */
    private static Result<Range> tryRangeFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Range, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Range, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Range.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"range".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Range " +
          "with element name range, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Range> result = tryRangeFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Range.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Range",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Range.class);


      return result;
    }

    /**
     * Deserialize an instance of class ReferenceElement from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<ReferenceElement> tryReferenceElementFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      IReference theValue = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class ReferenceElement, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class ReferenceElement, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(ReferenceElement.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(ReferenceElement.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class ReferenceElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class ReferenceElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class ReferenceElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class ReferenceElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(ReferenceElement.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(ReferenceElement.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(ReferenceElement.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(ReferenceElement.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(ReferenceElement.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(ReferenceElement.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "value":
            {
              Result<Reference> tryValue = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryValue.isError()) {
                tryValue.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                return tryValue.castTo(ReferenceElement.class);
              }

              theValue = tryValue.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class ReferenceElement, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "ReferenceElement",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(ReferenceElement.class);

        }
      }

      return Result.success(new ReferenceElement(
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theValue));
    }

    /**
     * Deserialize an instance of class ReferenceElement from an XML element.
     */
    private static Result<ReferenceElement> tryReferenceElementFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ReferenceElement, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ReferenceElement, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(ReferenceElement.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"referenceElement".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class ReferenceElement " +
          "with element name referenceElement, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<ReferenceElement> result = tryReferenceElementFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(ReferenceElement.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "ReferenceElement",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(ReferenceElement.class);


      return result;
    }

    /**
     * Deserialize an instance of class Blob from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Blob> tryBlobFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      byte[] theValue = null;
      String theContentType = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Blob, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Blob, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Blob.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(Blob.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class Blob, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class Blob "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class Blob, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class Blob "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(Blob.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(Blob.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Blob.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Blob.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(Blob.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(Blob.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "value":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property value of an instance of class Blob " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "value"));
                return Result.failure(error);
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class Blob, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsBase64(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class Blob "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "contentType":
            {
              if (isEmptyProperty) {
                theContentType = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property contentType of an instance of class Blob, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theContentType = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property contentType of an instance of class Blob "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "contentType"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Blob, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Blob",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Blob.class);

        }
      }

      if (theContentType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property contentType has not been given " +
          "in the XML representation of an instance of class Blob");
        return Result.failure(error);
      }

      return Result.success(new Blob(
        theContentType,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theValue));
    }

    /**
     * Deserialize an instance of class Blob from an XML element.
     */
    private static Result<Blob> tryBlobFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Blob, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Blob, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Blob.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"blob".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Blob " +
          "with element name blob, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Blob> result = tryBlobFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Blob.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Blob",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Blob.class);


      return result;
    }

    /**
     * Deserialize an instance of class File from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<File> tryFileFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      String theValue = null;
      String theContentType = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class File, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class File, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(File.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(File.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class File, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class File "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class File, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class File "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(File.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(File.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(File.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(File.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(File.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(File.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "value":
            {
              if (isEmptyProperty) {
                theValue = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class File, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class File "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "contentType":
            {
              if (isEmptyProperty) {
                theContentType = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property contentType of an instance of class File, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theContentType = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property contentType of an instance of class File "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "contentType"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class File, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "File",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(File.class);

        }
      }

      if (theContentType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property contentType has not been given " +
          "in the XML representation of an instance of class File");
        return Result.failure(error);
      }

      return Result.success(new File(
        theContentType,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theValue));
    }

    /**
     * Deserialize an instance of class File from an XML element.
     */
    private static Result<File> tryFileFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class File, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class File, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(File.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"file".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class File " +
          "with element name file, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<File> result = tryFileFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(File.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "File",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(File.class);


      return result;
    }

    /**
     * Deserialize an instance of class AnnotatedRelationshipElement from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<AnnotatedRelationshipElement> tryAnnotatedRelationshipElementFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      IReference theFirst = null;
      IReference theSecond = null;
      List<IDataElement> theAnnotations = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class AnnotatedRelationshipElement, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class AnnotatedRelationshipElement, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(AnnotatedRelationshipElement.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(AnnotatedRelationshipElement.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class AnnotatedRelationshipElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class AnnotatedRelationshipElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class AnnotatedRelationshipElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class AnnotatedRelationshipElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(AnnotatedRelationshipElement.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(AnnotatedRelationshipElement.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(AnnotatedRelationshipElement.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(AnnotatedRelationshipElement.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(AnnotatedRelationshipElement.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(AnnotatedRelationshipElement.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "first":
            {
              Result<Reference> tryFirst = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryFirst.isError()) {
                tryFirst.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "first"));
                return tryFirst.castTo(AnnotatedRelationshipElement.class);
              }

              theFirst = tryFirst.getResult();
              break;
            }
            case "second":
            {
              Result<Reference> trySecond = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySecond.isError()) {
                trySecond.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "second"));
                return trySecond.castTo(AnnotatedRelationshipElement.class);
              }

              theSecond = trySecond.getResult();
              break;
            }
            case "annotations":
            {
              theAnnotations = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IDataElement, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("annotations"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IDataElement> itemResult = tryIDataElementFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("annotations"));
                    return itemResult.castTo(AnnotatedRelationshipElement.class);
                  }

                  theAnnotations.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class AnnotatedRelationshipElement, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "AnnotatedRelationshipElement",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(AnnotatedRelationshipElement.class);

        }
      }

      if (theFirst == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property first has not been given " +
          "in the XML representation of an instance of class AnnotatedRelationshipElement");
        return Result.failure(error);
      }

      if (theSecond == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property second has not been given " +
          "in the XML representation of an instance of class AnnotatedRelationshipElement");
        return Result.failure(error);
      }

      return Result.success(new AnnotatedRelationshipElement(
        theFirst,
        theSecond,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theAnnotations));
    }

    /**
     * Deserialize an instance of class AnnotatedRelationshipElement from an XML element.
     */
    private static Result<AnnotatedRelationshipElement> tryAnnotatedRelationshipElementFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class AnnotatedRelationshipElement, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class AnnotatedRelationshipElement, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(AnnotatedRelationshipElement.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"annotatedRelationshipElement".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class AnnotatedRelationshipElement " +
          "with element name annotatedRelationshipElement, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<AnnotatedRelationshipElement> result = tryAnnotatedRelationshipElementFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(AnnotatedRelationshipElement.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "AnnotatedRelationshipElement",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(AnnotatedRelationshipElement.class);


      return result;
    }

    /**
     * Deserialize an instance of class Entity from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Entity> tryEntityFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      List<ISubmodelElement> theStatements = null;
      EntityType theEntityType = null;
      String theGlobalAssetId = null;
      List<ISpecificAssetId> theSpecificAssetIds = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Entity, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Entity, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Entity.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(Entity.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class Entity, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class Entity "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class Entity, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class Entity "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(Entity.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(Entity.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Entity.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Entity.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(Entity.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(Entity.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "statements":
            {
              theStatements = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ISubmodelElement, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("statements"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ISubmodelElement> itemResult = tryISubmodelElementFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("statements"));
                    return itemResult.castTo(Entity.class);
                  }

                  theStatements.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "entityType":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property entityType of an instance of class Entity " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "entityType"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property entityType of an instance of class Entity, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textEntityType;
              try {
                textEntityType = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property entityType of an instance of class Entity"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "entityType"));
                return Result.failure(error);
              }

              final Optional<EntityType> optionalEntityType =
                Stringification.entityTypeFromString(
                  textEntityType);

              if (optionalEntityType.isPresent()) {
                theEntityType = optionalEntityType.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property entityType of an instance of class Entity" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textEntityType);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "entityType"));
                return Result.failure(error);
              }
              break;
            }
            case "globalAssetId":
            {
              if (isEmptyProperty) {
                theGlobalAssetId = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property globalAssetId of an instance of class Entity, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theGlobalAssetId = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property globalAssetId of an instance of class Entity "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "globalAssetId"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "specificAssetIds":
            {
              theSpecificAssetIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ISpecificAssetId, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("specificAssetIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ISpecificAssetId> itemResult = trySpecificAssetIdFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("specificAssetIds"));
                    return itemResult.castTo(Entity.class);
                  }

                  theSpecificAssetIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Entity, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Entity",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Entity.class);

        }
      }

      if (theEntityType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property entityType has not been given " +
          "in the XML representation of an instance of class Entity");
        return Result.failure(error);
      }

      return Result.success(new Entity(
        theEntityType,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theStatements,
        theGlobalAssetId,
        theSpecificAssetIds));
    }

    /**
     * Deserialize an instance of class Entity from an XML element.
     */
    private static Result<Entity> tryEntityFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Entity, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Entity, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Entity.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"entity".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Entity " +
          "with element name entity, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Entity> result = tryEntityFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Entity.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Entity",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Entity.class);


      return result;
    }

    /**
     * Deserialize an instance of class EventPayload from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<EventPayload> tryEventPayloadFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      IReference theSource = null;
      IReference theSourceSemanticId = null;
      IReference theObservableReference = null;
      IReference theObservableSemanticId = null;
      String theTopic = null;
      IReference theSubjectId = null;
      String theTimeStamp = null;
      byte[] thePayload = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class EventPayload, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class EventPayload, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(EventPayload.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "source":
            {
              Result<Reference> trySource = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySource.isError()) {
                trySource.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "source"));
                return trySource.castTo(EventPayload.class);
              }

              theSource = trySource.getResult();
              break;
            }
            case "sourceSemanticId":
            {
              Result<Reference> trySourceSemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySourceSemanticId.isError()) {
                trySourceSemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "sourceSemanticId"));
                return trySourceSemanticId.castTo(EventPayload.class);
              }

              theSourceSemanticId = trySourceSemanticId.getResult();
              break;
            }
            case "observableReference":
            {
              Result<Reference> tryObservableReference = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryObservableReference.isError()) {
                tryObservableReference.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "observableReference"));
                return tryObservableReference.castTo(EventPayload.class);
              }

              theObservableReference = tryObservableReference.getResult();
              break;
            }
            case "observableSemanticId":
            {
              Result<Reference> tryObservableSemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryObservableSemanticId.isError()) {
                tryObservableSemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "observableSemanticId"));
                return tryObservableSemanticId.castTo(EventPayload.class);
              }

              theObservableSemanticId = tryObservableSemanticId.getResult();
              break;
            }
            case "topic":
            {
              if (isEmptyProperty) {
                theTopic = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property topic of an instance of class EventPayload, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theTopic = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property topic of an instance of class EventPayload "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "topic"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "subjectId":
            {
              Result<Reference> trySubjectId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySubjectId.isError()) {
                trySubjectId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "subjectId"));
                return trySubjectId.castTo(EventPayload.class);
              }

              theSubjectId = trySubjectId.getResult();
              break;
            }
            case "timeStamp":
            {
              if (isEmptyProperty) {
                theTimeStamp = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property timeStamp of an instance of class EventPayload, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theTimeStamp = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property timeStamp of an instance of class EventPayload "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "timeStamp"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "payload":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property payload of an instance of class EventPayload " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "payload"));
                return Result.failure(error);
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property payload of an instance of class EventPayload, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  thePayload = readContentAsBase64(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property payload of an instance of class EventPayload "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "payload"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class EventPayload, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "EventPayload",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(EventPayload.class);

        }
      }

      if (theSource == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property source has not been given " +
          "in the XML representation of an instance of class EventPayload");
        return Result.failure(error);
      }

      if (theObservableReference == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property observableReference has not been given " +
          "in the XML representation of an instance of class EventPayload");
        return Result.failure(error);
      }

      if (theTimeStamp == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property timeStamp has not been given " +
          "in the XML representation of an instance of class EventPayload");
        return Result.failure(error);
      }

      return Result.success(new EventPayload(
        theSource,
        theObservableReference,
        theTimeStamp,
        theSourceSemanticId,
        theObservableSemanticId,
        theTopic,
        theSubjectId,
        thePayload));
    }

    /**
     * Deserialize an instance of class EventPayload from an XML element.
     */
    private static Result<EventPayload> tryEventPayloadFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class EventPayload, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class EventPayload, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(EventPayload.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"eventPayload".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class EventPayload " +
          "with element name eventPayload, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<EventPayload> result = tryEventPayloadFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(EventPayload.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "EventPayload",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(EventPayload.class);


      return result;
    }

    /**
     * Deserialize an instance of IEventElement from an XML element.
     */
    private static Result<? extends IEventElement> tryIEventElementFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IEventElement, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IEventElement.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "basicEventElement":
          return tryBasicEventElementFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class BasicEventElement from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<BasicEventElement> tryBasicEventElementFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      IReference theObserved = null;
      Direction theDirection = null;
      StateOfEvent theState = null;
      String theMessageTopic = null;
      IReference theMessageBroker = null;
      String theLastUpdate = null;
      String theMinInterval = null;
      String theMaxInterval = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class BasicEventElement, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class BasicEventElement, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(BasicEventElement.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(BasicEventElement.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class BasicEventElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class BasicEventElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class BasicEventElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class BasicEventElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(BasicEventElement.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(BasicEventElement.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(BasicEventElement.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(BasicEventElement.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(BasicEventElement.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(BasicEventElement.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "observed":
            {
              Result<Reference> tryObserved = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryObserved.isError()) {
                tryObserved.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "observed"));
                return tryObserved.castTo(BasicEventElement.class);
              }

              theObserved = tryObserved.getResult();
              break;
            }
            case "direction":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property direction of an instance of class BasicEventElement " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "direction"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property direction of an instance of class BasicEventElement, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textDirection;
              try {
                textDirection = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property direction of an instance of class BasicEventElement"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "direction"));
                return Result.failure(error);
              }

              final Optional<Direction> optionalDirection =
                Stringification.directionFromString(
                  textDirection);

              if (optionalDirection.isPresent()) {
                theDirection = optionalDirection.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property direction of an instance of class BasicEventElement" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textDirection);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "direction"));
                return Result.failure(error);
              }
              break;
            }
            case "state":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property state of an instance of class BasicEventElement " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "state"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property state of an instance of class BasicEventElement, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textState;
              try {
                textState = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property state of an instance of class BasicEventElement"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "state"));
                return Result.failure(error);
              }

              final Optional<StateOfEvent> optionalState =
                Stringification.stateOfEventFromString(
                  textState);

              if (optionalState.isPresent()) {
                theState = optionalState.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property state of an instance of class BasicEventElement" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textState);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "state"));
                return Result.failure(error);
              }
              break;
            }
            case "messageTopic":
            {
              if (isEmptyProperty) {
                theMessageTopic = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property messageTopic of an instance of class BasicEventElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theMessageTopic = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property messageTopic of an instance of class BasicEventElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "messageTopic"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "messageBroker":
            {
              Result<Reference> tryMessageBroker = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryMessageBroker.isError()) {
                tryMessageBroker.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "messageBroker"));
                return tryMessageBroker.castTo(BasicEventElement.class);
              }

              theMessageBroker = tryMessageBroker.getResult();
              break;
            }
            case "lastUpdate":
            {
              if (isEmptyProperty) {
                theLastUpdate = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property lastUpdate of an instance of class BasicEventElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theLastUpdate = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property lastUpdate of an instance of class BasicEventElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "lastUpdate"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "minInterval":
            {
              if (isEmptyProperty) {
                theMinInterval = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property minInterval of an instance of class BasicEventElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theMinInterval = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property minInterval of an instance of class BasicEventElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "minInterval"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "maxInterval":
            {
              if (isEmptyProperty) {
                theMaxInterval = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property maxInterval of an instance of class BasicEventElement, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theMaxInterval = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property maxInterval of an instance of class BasicEventElement "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "maxInterval"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class BasicEventElement, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "BasicEventElement",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(BasicEventElement.class);

        }
      }

      if (theObserved == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property observed has not been given " +
          "in the XML representation of an instance of class BasicEventElement");
        return Result.failure(error);
      }

      if (theDirection == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property direction has not been given " +
          "in the XML representation of an instance of class BasicEventElement");
        return Result.failure(error);
      }

      if (theState == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property state has not been given " +
          "in the XML representation of an instance of class BasicEventElement");
        return Result.failure(error);
      }

      return Result.success(new BasicEventElement(
        theObserved,
        theDirection,
        theState,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theMessageTopic,
        theMessageBroker,
        theLastUpdate,
        theMinInterval,
        theMaxInterval));
    }

    /**
     * Deserialize an instance of class BasicEventElement from an XML element.
     */
    private static Result<BasicEventElement> tryBasicEventElementFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class BasicEventElement, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class BasicEventElement, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(BasicEventElement.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"basicEventElement".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class BasicEventElement " +
          "with element name basicEventElement, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<BasicEventElement> result = tryBasicEventElementFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(BasicEventElement.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "BasicEventElement",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(BasicEventElement.class);


      return result;
    }

    /**
     * Deserialize an instance of class Operation from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Operation> tryOperationFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      List<IOperationVariable> theInputVariables = null;
      List<IOperationVariable> theOutputVariables = null;
      List<IOperationVariable> theInoutputVariables = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Operation, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Operation, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Operation.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(Operation.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class Operation, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class Operation "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class Operation, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class Operation "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(Operation.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(Operation.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Operation.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Operation.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(Operation.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(Operation.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "inputVariables":
            {
              theInputVariables = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IOperationVariable, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("inputVariables"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IOperationVariable> itemResult = tryOperationVariableFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("inputVariables"));
                    return itemResult.castTo(Operation.class);
                  }

                  theInputVariables.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "outputVariables":
            {
              theOutputVariables = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IOperationVariable, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("outputVariables"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IOperationVariable> itemResult = tryOperationVariableFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("outputVariables"));
                    return itemResult.castTo(Operation.class);
                  }

                  theOutputVariables.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "inoutputVariables":
            {
              theInoutputVariables = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IOperationVariable, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("inoutputVariables"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IOperationVariable> itemResult = tryOperationVariableFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("inoutputVariables"));
                    return itemResult.castTo(Operation.class);
                  }

                  theInoutputVariables.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Operation, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Operation",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Operation.class);

        }
      }

      return Result.success(new Operation(
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications,
        theInputVariables,
        theOutputVariables,
        theInoutputVariables));
    }

    /**
     * Deserialize an instance of class Operation from an XML element.
     */
    private static Result<Operation> tryOperationFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Operation, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Operation, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Operation.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"operation".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Operation " +
          "with element name operation, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Operation> result = tryOperationFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Operation.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Operation",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Operation.class);


      return result;
    }

    /**
     * Deserialize an instance of class OperationVariable from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<OperationVariable> tryOperationVariableFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      ISubmodelElement theValue = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class OperationVariable, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class OperationVariable, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(OperationVariable.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "value":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "Expected an XML element within the element " + tryElementName.getResult() + " representing " +
                  "the property value of an instance of class OperationVariable, " +
                  "but encountered a self-closing element.");
                return Result.failure(error);
              }

              // We need to skip the whitespace here in order to be able to look ahead
              // the discriminator element shortly.
              skipWhitespaceAndComments(reader);

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                  "Expected an XML element within the element " + tryElementName.getResult() + " representing " +
                  "the property value of an instance of class OperationVariable, " +
                  "but reached the end-of-file");
                return Result.failure(error);
              }

              // Try to look ahead the discriminator name;
              // we need this name only for the error reporting below.
              // ISubmodelElementFromElement will perform more sophisticated
              // checks.
              String discriminatorElementName = null;
              if (currentEvent(reader).isStartElement()) {
                Result<String> tryDiscriminatorElementName = tryElementName(reader);
                assert(!tryDiscriminatorElementName.isError());
                discriminatorElementName = tryDiscriminatorElementName.getResult();
              }

              Result<? extends ISubmodelElement> tryValue = tryISubmodelElementFromElement(reader);

              if (tryValue.isError()) {
                if (discriminatorElementName != null) {
                  tryValue.getError().
                    prependSegment(
                      new Reporting.NameSegment(
                        discriminatorElementName));
                }

                tryValue.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                return tryValue.castTo(OperationVariable.class);
              }

              theValue = tryValue.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class OperationVariable, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "OperationVariable",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(OperationVariable.class);

        }
      }

      if (theValue == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property value has not been given " +
          "in the XML representation of an instance of class OperationVariable");
        return Result.failure(error);
      }

      return Result.success(new OperationVariable(
        theValue));
    }

    /**
     * Deserialize an instance of class OperationVariable from an XML element.
     */
    private static Result<OperationVariable> tryOperationVariableFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class OperationVariable, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class OperationVariable, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(OperationVariable.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"operationVariable".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class OperationVariable " +
          "with element name operationVariable, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<OperationVariable> result = tryOperationVariableFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(OperationVariable.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "OperationVariable",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(OperationVariable.class);


      return result;
    }

    /**
     * Deserialize an instance of class Capability from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Capability> tryCapabilityFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IReference theSemanticId = null;
      List<IReference> theSupplementalSemanticIds = null;
      List<IQualifier> theQualifiers = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Capability, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Capability, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Capability.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(Capability.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class Capability, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class Capability "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class Capability, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class Capability "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(Capability.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(Capability.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "semanticId":
            {
              Result<Reference> trySemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (trySemanticId.isError()) {
                trySemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "semanticId"));
                return trySemanticId.castTo(Capability.class);
              }

              theSemanticId = trySemanticId.getResult();
              break;
            }
            case "supplementalSemanticIds":
            {
              theSupplementalSemanticIds = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("supplementalSemanticIds"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("supplementalSemanticIds"));
                    return itemResult.castTo(Capability.class);
                  }

                  theSupplementalSemanticIds.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "qualifiers":
            {
              theQualifiers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IQualifier, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("qualifiers"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IQualifier> itemResult = tryQualifierFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("qualifiers"));
                    return itemResult.castTo(Capability.class);
                  }

                  theQualifiers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(Capability.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Capability, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Capability",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Capability.class);

        }
      }

      return Result.success(new Capability(
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theSemanticId,
        theSupplementalSemanticIds,
        theQualifiers,
        theEmbeddedDataSpecifications));
    }

    /**
     * Deserialize an instance of class Capability from an XML element.
     */
    private static Result<Capability> tryCapabilityFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Capability, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Capability, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Capability.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"capability".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Capability " +
          "with element name capability, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Capability> result = tryCapabilityFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Capability.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Capability",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Capability.class);


      return result;
    }

    /**
     * Deserialize an instance of class ConceptDescription from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<ConceptDescription> tryConceptDescriptionFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IExtension> theExtensions = null;
      String theCategory = null;
      String theIdShort = null;
      List<ILangStringNameType> theDisplayName = null;
      List<ILangStringTextType> theDescription = null;
      IAdministrativeInformation theAdministration = null;
      String theId = null;
      List<IEmbeddedDataSpecification> theEmbeddedDataSpecifications = null;
      List<IReference> theIsCaseOf = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class ConceptDescription, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class ConceptDescription, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(ConceptDescription.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "extensions":
            {
              theExtensions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IExtension, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("extensions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IExtension> itemResult = tryExtensionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("extensions"));
                    return itemResult.castTo(ConceptDescription.class);
                  }

                  theExtensions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "category":
            {
              if (isEmptyProperty) {
                theCategory = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property category of an instance of class ConceptDescription, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theCategory = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property category of an instance of class ConceptDescription "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "category"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "idShort":
            {
              if (isEmptyProperty) {
                theIdShort = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property idShort of an instance of class ConceptDescription, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theIdShort = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property idShort of an instance of class ConceptDescription "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "idShort"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "displayName":
            {
              theDisplayName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringNameType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("displayName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringNameType> itemResult = tryLangStringNameTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("displayName"));
                    return itemResult.castTo(ConceptDescription.class);
                  }

                  theDisplayName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "description":
            {
              theDescription = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringTextType, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("description"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringTextType> itemResult = tryLangStringTextTypeFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("description"));
                    return itemResult.castTo(ConceptDescription.class);
                  }

                  theDescription.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "administration":
            {
              Result<AdministrativeInformation> tryAdministration = tryAdministrativeInformationFromSequence(
                reader, isEmptyProperty);

              if (tryAdministration.isError()) {
                tryAdministration.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "administration"));
                return tryAdministration.castTo(ConceptDescription.class);
              }

              theAdministration = tryAdministration.getResult();
              break;
            }
            case "id":
            {
              if (isEmptyProperty) {
                theId = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property id of an instance of class ConceptDescription, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theId = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property id of an instance of class ConceptDescription "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "id"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "embeddedDataSpecifications":
            {
              theEmbeddedDataSpecifications = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IEmbeddedDataSpecification, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("embeddedDataSpecifications"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IEmbeddedDataSpecification> itemResult = tryEmbeddedDataSpecificationFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("embeddedDataSpecifications"));
                    return itemResult.castTo(ConceptDescription.class);
                  }

                  theEmbeddedDataSpecifications.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "isCaseOf":
            {
              theIsCaseOf = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IReference, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("isCaseOf"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IReference> itemResult = tryReferenceFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("isCaseOf"));
                    return itemResult.castTo(ConceptDescription.class);
                  }

                  theIsCaseOf.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class ConceptDescription, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "ConceptDescription",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(ConceptDescription.class);

        }
      }

      if (theId == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property id has not been given " +
          "in the XML representation of an instance of class ConceptDescription");
        return Result.failure(error);
      }

      return Result.success(new ConceptDescription(
        theId,
        theExtensions,
        theCategory,
        theIdShort,
        theDisplayName,
        theDescription,
        theAdministration,
        theEmbeddedDataSpecifications,
        theIsCaseOf));
    }

    /**
     * Deserialize an instance of class ConceptDescription from an XML element.
     */
    private static Result<ConceptDescription> tryConceptDescriptionFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ConceptDescription, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ConceptDescription, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(ConceptDescription.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"conceptDescription".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class ConceptDescription " +
          "with element name conceptDescription, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<ConceptDescription> result = tryConceptDescriptionFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(ConceptDescription.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "ConceptDescription",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(ConceptDescription.class);


      return result;
    }

    /**
     * Deserialize an instance of class Reference from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Reference> tryReferenceFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      ReferenceTypes theType = null;
      IReference theReferredSemanticId = null;
      List<IKey> theKeys = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Reference, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Reference, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Reference.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "type":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property type of an instance of class Reference " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "type"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property type of an instance of class Reference, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textType;
              try {
                textType = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property type of an instance of class Reference"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "type"));
                return Result.failure(error);
              }

              final Optional<ReferenceTypes> optionalType =
                Stringification.referenceTypesFromString(
                  textType);

              if (optionalType.isPresent()) {
                theType = optionalType.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property type of an instance of class Reference" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textType);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "type"));
                return Result.failure(error);
              }
              break;
            }
            case "referredSemanticId":
            {
              Result<Reference> tryReferredSemanticId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryReferredSemanticId.isError()) {
                tryReferredSemanticId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "referredSemanticId"));
                return tryReferredSemanticId.castTo(Reference.class);
              }

              theReferredSemanticId = tryReferredSemanticId.getResult();
              break;
            }
            case "keys":
            {
              theKeys = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IKey, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("keys"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IKey> itemResult = tryKeyFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("keys"));
                    return itemResult.castTo(Reference.class);
                  }

                  theKeys.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Reference, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Reference",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Reference.class);

        }
      }

      if (theType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property type has not been given " +
          "in the XML representation of an instance of class Reference");
        return Result.failure(error);
      }

      if (theKeys == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property keys has not been given " +
          "in the XML representation of an instance of class Reference");
        return Result.failure(error);
      }

      return Result.success(new Reference(
        theType,
        theKeys,
        theReferredSemanticId));
    }

    /**
     * Deserialize an instance of class Reference from an XML element.
     */
    private static Result<Reference> tryReferenceFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Reference, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Reference, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Reference.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"reference".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Reference " +
          "with element name reference, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Reference> result = tryReferenceFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Reference.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Reference",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Reference.class);


      return result;
    }

    /**
     * Deserialize an instance of class Key from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Key> tryKeyFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      KeyTypes theType = null;
      String theValue = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Key, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Key, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Key.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "type":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property type of an instance of class Key " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "type"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property type of an instance of class Key, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textType;
              try {
                textType = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property type of an instance of class Key"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "type"));
                return Result.failure(error);
              }

              final Optional<KeyTypes> optionalType =
                Stringification.keyTypesFromString(
                  textType);

              if (optionalType.isPresent()) {
                theType = optionalType.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property type of an instance of class Key" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textType);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "type"));
                return Result.failure(error);
              }
              break;
            }
            case "value":
            {
              if (isEmptyProperty) {
                theValue = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class Key, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class Key "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Key, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Key",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Key.class);

        }
      }

      if (theType == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property type has not been given " +
          "in the XML representation of an instance of class Key");
        return Result.failure(error);
      }

      if (theValue == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property value has not been given " +
          "in the XML representation of an instance of class Key");
        return Result.failure(error);
      }

      return Result.success(new Key(
        theType,
        theValue));
    }

    /**
     * Deserialize an instance of class Key from an XML element.
     */
    private static Result<Key> tryKeyFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Key, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Key, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Key.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"key".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Key " +
          "with element name key, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Key> result = tryKeyFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Key.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Key",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Key.class);


      return result;
    }

    /**
     * Deserialize an instance of IAbstractLangString from an XML element.
     */
    private static Result<? extends IAbstractLangString> tryIAbstractLangStringFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IAbstractLangString, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IAbstractLangString.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "langStringDefinitionTypeIec61360":
          return tryLangStringDefinitionTypeIec61360FromElement(reader);
        case "langStringNameType":
          return tryLangStringNameTypeFromElement(reader);
        case "langStringPreferredNameTypeIec61360":
          return tryLangStringPreferredNameTypeIec61360FromElement(reader);
        case "langStringShortNameTypeIec61360":
          return tryLangStringShortNameTypeIec61360FromElement(reader);
        case "langStringTextType":
          return tryLangStringTextTypeFromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class LangStringNameType from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<LangStringNameType> tryLangStringNameTypeFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      String theLanguage = null;
      String theText = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class LangStringNameType, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class LangStringNameType, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(LangStringNameType.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "language":
            {
              if (isEmptyProperty) {
                theLanguage = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property language of an instance of class LangStringNameType, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theLanguage = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property language of an instance of class LangStringNameType "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "language"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "text":
            {
              if (isEmptyProperty) {
                theText = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property text of an instance of class LangStringNameType, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theText = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property text of an instance of class LangStringNameType "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "text"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class LangStringNameType, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "LangStringNameType",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(LangStringNameType.class);

        }
      }

      if (theLanguage == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property language has not been given " +
          "in the XML representation of an instance of class LangStringNameType");
        return Result.failure(error);
      }

      if (theText == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property text has not been given " +
          "in the XML representation of an instance of class LangStringNameType");
        return Result.failure(error);
      }

      return Result.success(new LangStringNameType(
        theLanguage,
        theText));
    }

    /**
     * Deserialize an instance of class LangStringNameType from an XML element.
     */
    private static Result<LangStringNameType> tryLangStringNameTypeFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringNameType, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringNameType, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(LangStringNameType.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"langStringNameType".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class LangStringNameType " +
          "with element name langStringNameType, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<LangStringNameType> result = tryLangStringNameTypeFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(LangStringNameType.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "LangStringNameType",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(LangStringNameType.class);


      return result;
    }

    /**
     * Deserialize an instance of class LangStringTextType from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<LangStringTextType> tryLangStringTextTypeFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      String theLanguage = null;
      String theText = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class LangStringTextType, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class LangStringTextType, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(LangStringTextType.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "language":
            {
              if (isEmptyProperty) {
                theLanguage = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property language of an instance of class LangStringTextType, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theLanguage = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property language of an instance of class LangStringTextType "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "language"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "text":
            {
              if (isEmptyProperty) {
                theText = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property text of an instance of class LangStringTextType, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theText = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property text of an instance of class LangStringTextType "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "text"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class LangStringTextType, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "LangStringTextType",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(LangStringTextType.class);

        }
      }

      if (theLanguage == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property language has not been given " +
          "in the XML representation of an instance of class LangStringTextType");
        return Result.failure(error);
      }

      if (theText == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property text has not been given " +
          "in the XML representation of an instance of class LangStringTextType");
        return Result.failure(error);
      }

      return Result.success(new LangStringTextType(
        theLanguage,
        theText));
    }

    /**
     * Deserialize an instance of class LangStringTextType from an XML element.
     */
    private static Result<LangStringTextType> tryLangStringTextTypeFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringTextType, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringTextType, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(LangStringTextType.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"langStringTextType".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class LangStringTextType " +
          "with element name langStringTextType, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<LangStringTextType> result = tryLangStringTextTypeFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(LangStringTextType.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "LangStringTextType",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(LangStringTextType.class);


      return result;
    }

    /**
     * Deserialize an instance of class Environment from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<Environment> tryEnvironmentFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IAssetAdministrationShell> theAssetAdministrationShells = null;
      List<ISubmodel> theSubmodels = null;
      List<IConceptDescription> theConceptDescriptions = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class Environment, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class Environment, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(Environment.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "assetAdministrationShells":
            {
              theAssetAdministrationShells = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IAssetAdministrationShell, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("assetAdministrationShells"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IAssetAdministrationShell> itemResult = tryAssetAdministrationShellFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("assetAdministrationShells"));
                    return itemResult.castTo(Environment.class);
                  }

                  theAssetAdministrationShells.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "submodels":
            {
              theSubmodels = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ISubmodel, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("submodels"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ISubmodel> itemResult = trySubmodelFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("submodels"));
                    return itemResult.castTo(Environment.class);
                  }

                  theSubmodels.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "conceptDescriptions":
            {
              theConceptDescriptions = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IConceptDescription, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("conceptDescriptions"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IConceptDescription> itemResult = tryConceptDescriptionFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("conceptDescriptions"));
                    return itemResult.castTo(Environment.class);
                  }

                  theConceptDescriptions.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class Environment, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "Environment",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(Environment.class);

        }
      }

      return Result.success(new Environment(
        theAssetAdministrationShells,
        theSubmodels,
        theConceptDescriptions));
    }

    /**
     * Deserialize an instance of class Environment from an XML element.
     */
    private static Result<Environment> tryEnvironmentFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Environment, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class Environment, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(Environment.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"environment".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class Environment " +
          "with element name environment, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<Environment> result = tryEnvironmentFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(Environment.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "Environment",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(Environment.class);


      return result;
    }

    /**
     * Deserialize an instance of IDataSpecificationContent from an XML element.
     */
    private static Result<? extends IDataSpecificationContent> tryIDataSpecificationContentFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element, but reached end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class IDataSpecificationContent, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      Result<String> tryElementName = tryElementName(
        reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(IDataSpecificationContent.class);
      }

      final String elementName = tryElementName.getResult();
      switch (elementName) {
        case "dataSpecificationIec61360":
          return tryDataSpecificationIec61360FromElement(reader);
        default:
          final Reporting.Error error = new Reporting.Error(
            "Unexpected element with the name " + getEventTypeAsString(currentEvent));
          return Result.failure(error);
      }
    }

    /**
     * Deserialize an instance of class EmbeddedDataSpecification from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<EmbeddedDataSpecification> tryEmbeddedDataSpecificationFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      IReference theDataSpecification = null;
      IDataSpecificationContent theDataSpecificationContent = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class EmbeddedDataSpecification, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class EmbeddedDataSpecification, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(EmbeddedDataSpecification.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "dataSpecification":
            {
              Result<Reference> tryDataSpecification = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryDataSpecification.isError()) {
                tryDataSpecification.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "dataSpecification"));
                return tryDataSpecification.castTo(EmbeddedDataSpecification.class);
              }

              theDataSpecification = tryDataSpecification.getResult();
              break;
            }
            case "dataSpecificationContent":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "Expected an XML element within the element " + tryElementName.getResult() + " representing " +
                  "the property dataSpecificationContent of an instance of class EmbeddedDataSpecification, " +
                  "but encountered a self-closing element.");
                return Result.failure(error);
              }

              // We need to skip the whitespace here in order to be able to look ahead
              // the discriminator element shortly.
              skipWhitespaceAndComments(reader);

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                  "Expected an XML element within the element " + tryElementName.getResult() + " representing " +
                  "the property dataSpecificationContent of an instance of class EmbeddedDataSpecification, " +
                  "but reached the end-of-file");
                return Result.failure(error);
              }

              // Try to look ahead the discriminator name;
              // we need this name only for the error reporting below.
              // IDataSpecificationContentFromElement will perform more sophisticated
              // checks.
              String discriminatorElementName = null;
              if (currentEvent(reader).isStartElement()) {
                Result<String> tryDiscriminatorElementName = tryElementName(reader);
                assert(!tryDiscriminatorElementName.isError());
                discriminatorElementName = tryDiscriminatorElementName.getResult();
              }

              Result<? extends IDataSpecificationContent> tryDataSpecificationContent = tryIDataSpecificationContentFromElement(reader);

              if (tryDataSpecificationContent.isError()) {
                if (discriminatorElementName != null) {
                  tryDataSpecificationContent.getError().
                    prependSegment(
                      new Reporting.NameSegment(
                        discriminatorElementName));
                }

                tryDataSpecificationContent.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "dataSpecificationContent"));
                return tryDataSpecificationContent.castTo(EmbeddedDataSpecification.class);
              }

              theDataSpecificationContent = tryDataSpecificationContent.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class EmbeddedDataSpecification, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "EmbeddedDataSpecification",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(EmbeddedDataSpecification.class);

        }
      }

      if (theDataSpecification == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property dataSpecification has not been given " +
          "in the XML representation of an instance of class EmbeddedDataSpecification");
        return Result.failure(error);
      }

      if (theDataSpecificationContent == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property dataSpecificationContent has not been given " +
          "in the XML representation of an instance of class EmbeddedDataSpecification");
        return Result.failure(error);
      }

      return Result.success(new EmbeddedDataSpecification(
        theDataSpecification,
        theDataSpecificationContent));
    }

    /**
     * Deserialize an instance of class EmbeddedDataSpecification from an XML element.
     */
    private static Result<EmbeddedDataSpecification> tryEmbeddedDataSpecificationFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class EmbeddedDataSpecification, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class EmbeddedDataSpecification, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(EmbeddedDataSpecification.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"embeddedDataSpecification".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class EmbeddedDataSpecification " +
          "with element name embeddedDataSpecification, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<EmbeddedDataSpecification> result = tryEmbeddedDataSpecificationFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(EmbeddedDataSpecification.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "EmbeddedDataSpecification",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(EmbeddedDataSpecification.class);


      return result;
    }

    /**
     * Deserialize an instance of class LevelType from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<LevelType> tryLevelTypeFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      Boolean theMin = null;
      Boolean theNom = null;
      Boolean theTyp = null;
      Boolean theMax = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class LevelType, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class LevelType, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(LevelType.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "min":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property min of an instance of class LevelType " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "min"));
                return Result.failure(error);
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property min of an instance of class LevelType, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theMin = readContentAsBool(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property min of an instance of class LevelType "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "min"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "nom":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property nom of an instance of class LevelType " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "nom"));
                return Result.failure(error);
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property nom of an instance of class LevelType, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theNom = readContentAsBool(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property nom of an instance of class LevelType "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "nom"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "typ":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property typ of an instance of class LevelType " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "typ"));
                return Result.failure(error);
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property typ of an instance of class LevelType, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theTyp = readContentAsBool(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property typ of an instance of class LevelType "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "typ"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "max":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property max of an instance of class LevelType " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "max"));
                return Result.failure(error);
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property max of an instance of class LevelType, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theMax = readContentAsBool(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property max of an instance of class LevelType "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "max"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class LevelType, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "LevelType",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(LevelType.class);

        }
      }

      if (theMin == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property min has not been given " +
          "in the XML representation of an instance of class LevelType");
        return Result.failure(error);
      }

      if (theNom == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property nom has not been given " +
          "in the XML representation of an instance of class LevelType");
        return Result.failure(error);
      }

      if (theTyp == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property typ has not been given " +
          "in the XML representation of an instance of class LevelType");
        return Result.failure(error);
      }

      if (theMax == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property max has not been given " +
          "in the XML representation of an instance of class LevelType");
        return Result.failure(error);
      }

      return Result.success(new LevelType(
        theMin,
        theNom,
        theTyp,
        theMax));
    }

    /**
     * Deserialize an instance of class LevelType from an XML element.
     */
    private static Result<LevelType> tryLevelTypeFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LevelType, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LevelType, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(LevelType.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"levelType".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class LevelType " +
          "with element name levelType, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<LevelType> result = tryLevelTypeFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(LevelType.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "LevelType",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(LevelType.class);


      return result;
    }

    /**
     * Deserialize an instance of class ValueReferencePair from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<ValueReferencePair> tryValueReferencePairFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      String theValue = null;
      IReference theValueId = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class ValueReferencePair, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class ValueReferencePair, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(ValueReferencePair.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "value":
            {
              if (isEmptyProperty) {
                theValue = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class ValueReferencePair, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class ValueReferencePair "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "valueId":
            {
              Result<Reference> tryValueId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryValueId.isError()) {
                tryValueId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "valueId"));
                return tryValueId.castTo(ValueReferencePair.class);
              }

              theValueId = tryValueId.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class ValueReferencePair, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "ValueReferencePair",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(ValueReferencePair.class);

        }
      }

      if (theValue == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property value has not been given " +
          "in the XML representation of an instance of class ValueReferencePair");
        return Result.failure(error);
      }

      if (theValueId == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property valueId has not been given " +
          "in the XML representation of an instance of class ValueReferencePair");
        return Result.failure(error);
      }

      return Result.success(new ValueReferencePair(
        theValue,
        theValueId));
    }

    /**
     * Deserialize an instance of class ValueReferencePair from an XML element.
     */
    private static Result<ValueReferencePair> tryValueReferencePairFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ValueReferencePair, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ValueReferencePair, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(ValueReferencePair.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"valueReferencePair".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class ValueReferencePair " +
          "with element name valueReferencePair, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<ValueReferencePair> result = tryValueReferencePairFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(ValueReferencePair.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "ValueReferencePair",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(ValueReferencePair.class);


      return result;
    }

    /**
     * Deserialize an instance of class ValueList from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<ValueList> tryValueListFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<IValueReferencePair> theValueReferencePairs = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class ValueList, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class ValueList, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(ValueList.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "valueReferencePairs":
            {
              theValueReferencePairs = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of IValueReferencePair, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("valueReferencePairs"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends IValueReferencePair> itemResult = tryValueReferencePairFromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("valueReferencePairs"));
                    return itemResult.castTo(ValueList.class);
                  }

                  theValueReferencePairs.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class ValueList, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "ValueList",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(ValueList.class);

        }
      }

      if (theValueReferencePairs == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property valueReferencePairs has not been given " +
          "in the XML representation of an instance of class ValueList");
        return Result.failure(error);
      }

      return Result.success(new ValueList(
        theValueReferencePairs));
    }

    /**
     * Deserialize an instance of class ValueList from an XML element.
     */
    private static Result<ValueList> tryValueListFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ValueList, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ValueList, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(ValueList.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"valueList".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class ValueList " +
          "with element name valueList, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<ValueList> result = tryValueListFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(ValueList.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "ValueList",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(ValueList.class);


      return result;
    }

    /**
     * Deserialize an instance of class LangStringPreferredNameTypeIec61360 from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<LangStringPreferredNameTypeIec61360> tryLangStringPreferredNameTypeIec61360FromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      String theLanguage = null;
      String theText = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class LangStringPreferredNameTypeIec61360, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class LangStringPreferredNameTypeIec61360, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(LangStringPreferredNameTypeIec61360.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "language":
            {
              if (isEmptyProperty) {
                theLanguage = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property language of an instance of class LangStringPreferredNameTypeIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theLanguage = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property language of an instance of class LangStringPreferredNameTypeIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "language"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "text":
            {
              if (isEmptyProperty) {
                theText = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property text of an instance of class LangStringPreferredNameTypeIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theText = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property text of an instance of class LangStringPreferredNameTypeIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "text"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class LangStringPreferredNameTypeIec61360, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "LangStringPreferredNameTypeIec61360",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(LangStringPreferredNameTypeIec61360.class);

        }
      }

      if (theLanguage == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property language has not been given " +
          "in the XML representation of an instance of class LangStringPreferredNameTypeIec61360");
        return Result.failure(error);
      }

      if (theText == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property text has not been given " +
          "in the XML representation of an instance of class LangStringPreferredNameTypeIec61360");
        return Result.failure(error);
      }

      return Result.success(new LangStringPreferredNameTypeIec61360(
        theLanguage,
        theText));
    }

    /**
     * Deserialize an instance of class LangStringPreferredNameTypeIec61360 from an XML element.
     */
    private static Result<LangStringPreferredNameTypeIec61360> tryLangStringPreferredNameTypeIec61360FromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringPreferredNameTypeIec61360, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringPreferredNameTypeIec61360, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(LangStringPreferredNameTypeIec61360.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"langStringPreferredNameTypeIec61360".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class LangStringPreferredNameTypeIec61360 " +
          "with element name langStringPreferredNameTypeIec61360, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<LangStringPreferredNameTypeIec61360> result = tryLangStringPreferredNameTypeIec61360FromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(LangStringPreferredNameTypeIec61360.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "LangStringPreferredNameTypeIec61360",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(LangStringPreferredNameTypeIec61360.class);


      return result;
    }

    /**
     * Deserialize an instance of class LangStringShortNameTypeIec61360 from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<LangStringShortNameTypeIec61360> tryLangStringShortNameTypeIec61360FromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      String theLanguage = null;
      String theText = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class LangStringShortNameTypeIec61360, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class LangStringShortNameTypeIec61360, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(LangStringShortNameTypeIec61360.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "language":
            {
              if (isEmptyProperty) {
                theLanguage = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property language of an instance of class LangStringShortNameTypeIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theLanguage = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property language of an instance of class LangStringShortNameTypeIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "language"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "text":
            {
              if (isEmptyProperty) {
                theText = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property text of an instance of class LangStringShortNameTypeIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theText = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property text of an instance of class LangStringShortNameTypeIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "text"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class LangStringShortNameTypeIec61360, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "LangStringShortNameTypeIec61360",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(LangStringShortNameTypeIec61360.class);

        }
      }

      if (theLanguage == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property language has not been given " +
          "in the XML representation of an instance of class LangStringShortNameTypeIec61360");
        return Result.failure(error);
      }

      if (theText == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property text has not been given " +
          "in the XML representation of an instance of class LangStringShortNameTypeIec61360");
        return Result.failure(error);
      }

      return Result.success(new LangStringShortNameTypeIec61360(
        theLanguage,
        theText));
    }

    /**
     * Deserialize an instance of class LangStringShortNameTypeIec61360 from an XML element.
     */
    private static Result<LangStringShortNameTypeIec61360> tryLangStringShortNameTypeIec61360FromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringShortNameTypeIec61360, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringShortNameTypeIec61360, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(LangStringShortNameTypeIec61360.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"langStringShortNameTypeIec61360".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class LangStringShortNameTypeIec61360 " +
          "with element name langStringShortNameTypeIec61360, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<LangStringShortNameTypeIec61360> result = tryLangStringShortNameTypeIec61360FromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(LangStringShortNameTypeIec61360.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "LangStringShortNameTypeIec61360",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(LangStringShortNameTypeIec61360.class);


      return result;
    }

    /**
     * Deserialize an instance of class LangStringDefinitionTypeIec61360 from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<LangStringDefinitionTypeIec61360> tryLangStringDefinitionTypeIec61360FromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      String theLanguage = null;
      String theText = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class LangStringDefinitionTypeIec61360, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class LangStringDefinitionTypeIec61360, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(LangStringDefinitionTypeIec61360.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "language":
            {
              if (isEmptyProperty) {
                theLanguage = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property language of an instance of class LangStringDefinitionTypeIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theLanguage = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property language of an instance of class LangStringDefinitionTypeIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "language"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "text":
            {
              if (isEmptyProperty) {
                theText = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property text of an instance of class LangStringDefinitionTypeIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theText = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property text of an instance of class LangStringDefinitionTypeIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "text"));
                  return Result.failure(error);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class LangStringDefinitionTypeIec61360, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "LangStringDefinitionTypeIec61360",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(LangStringDefinitionTypeIec61360.class);

        }
      }

      if (theLanguage == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property language has not been given " +
          "in the XML representation of an instance of class LangStringDefinitionTypeIec61360");
        return Result.failure(error);
      }

      if (theText == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property text has not been given " +
          "in the XML representation of an instance of class LangStringDefinitionTypeIec61360");
        return Result.failure(error);
      }

      return Result.success(new LangStringDefinitionTypeIec61360(
        theLanguage,
        theText));
    }

    /**
     * Deserialize an instance of class LangStringDefinitionTypeIec61360 from an XML element.
     */
    private static Result<LangStringDefinitionTypeIec61360> tryLangStringDefinitionTypeIec61360FromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringDefinitionTypeIec61360, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class LangStringDefinitionTypeIec61360, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(LangStringDefinitionTypeIec61360.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"langStringDefinitionTypeIec61360".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class LangStringDefinitionTypeIec61360 " +
          "with element name langStringDefinitionTypeIec61360, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<LangStringDefinitionTypeIec61360> result = tryLangStringDefinitionTypeIec61360FromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(LangStringDefinitionTypeIec61360.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "LangStringDefinitionTypeIec61360",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(LangStringDefinitionTypeIec61360.class);


      return result;
    }

    /**
     * Deserialize an instance of class DataSpecificationIec61360 from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<DataSpecificationIec61360> tryDataSpecificationIec61360FromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<ILangStringPreferredNameTypeIec61360> thePreferredName = null;
      List<ILangStringShortNameTypeIec61360> theShortName = null;
      String theUnit = null;
      IReference theUnitId = null;
      String theSourceOfDefinition = null;
      String theSymbol = null;
      DataTypeIec61360 theDataType = null;
      List<ILangStringDefinitionTypeIec61360> theDefinition = null;
      String theValueFormat = null;
      IValueList theValueList = null;
      String theValue = null;
      ILevelType theLevelType = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class DataSpecificationIec61360, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class DataSpecificationIec61360, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(DataSpecificationIec61360.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "preferredName":
            {
              thePreferredName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringPreferredNameTypeIec61360, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("preferredName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringPreferredNameTypeIec61360> itemResult = tryLangStringPreferredNameTypeIec61360FromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("preferredName"));
                    return itemResult.castTo(DataSpecificationIec61360.class);
                  }

                  thePreferredName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "shortName":
            {
              theShortName = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringShortNameTypeIec61360, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("shortName"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringShortNameTypeIec61360> itemResult = tryLangStringShortNameTypeIec61360FromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("shortName"));
                    return itemResult.castTo(DataSpecificationIec61360.class);
                  }

                  theShortName.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "unit":
            {
              if (isEmptyProperty) {
                theUnit = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property unit of an instance of class DataSpecificationIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theUnit = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property unit of an instance of class DataSpecificationIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "unit"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "unitId":
            {
              Result<Reference> tryUnitId = tryReferenceFromSequence(
                reader, isEmptyProperty);

              if (tryUnitId.isError()) {
                tryUnitId.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "unitId"));
                return tryUnitId.castTo(DataSpecificationIec61360.class);
              }

              theUnitId = tryUnitId.getResult();
              break;
            }
            case "sourceOfDefinition":
            {
              if (isEmptyProperty) {
                theSourceOfDefinition = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property sourceOfDefinition of an instance of class DataSpecificationIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theSourceOfDefinition = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property sourceOfDefinition of an instance of class DataSpecificationIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "sourceOfDefinition"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "symbol":
            {
              if (isEmptyProperty) {
                theSymbol = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property symbol of an instance of class DataSpecificationIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theSymbol = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property symbol of an instance of class DataSpecificationIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "symbol"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "dataType":
            {
              if (isEmptyProperty) {
                final Reporting.Error error = new Reporting.Error(
                  "The property dataType of an instance of class DataSpecificationIec61360 " +
                  "can not be de-serialized from a self-closing element " +
                  "since it needs content");
                error.prependSegment(
                  new Reporting.NameSegment(
                    "dataType"));
                return Result.failure(error);
              }

              if (currentEvent(reader).isEndDocument()) {
                final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing "
                        + "the property dataType of an instance of class DataSpecificationIec61360, "
                        + "but reached the end-of-file");
                return Result.failure(error);
              }

              String textDataType;
              try {
                textDataType = readContentAsString(reader);
              } catch (Exception e) {
                final Reporting.Error error = new Reporting.Error(
                    "The property dataType of an instance of class DataSpecificationIec61360"
                        + " could not be de-serialized: " + e.getMessage());
                error.prependSegment(
                    new Reporting.NameSegment(
                        "dataType"));
                return Result.failure(error);
              }

              final Optional<DataTypeIec61360> optionalDataType =
                Stringification.dataTypeIec61360FromString(
                  textDataType);

              if (optionalDataType.isPresent()) {
                theDataType = optionalDataType.get();
              } else {
                final Reporting.Error error = new Reporting.Error(
                    "The property dataType of an instance of class DataSpecificationIec61360" +
                        " could not be de-serialized from an unexpected enumeration literal: " +
                        textDataType);
                error.prependSegment(
                    new Reporting.NameSegment(
                        "dataType"));
                return Result.failure(error);
              }
              break;
            }
            case "definition":
            {
              theDefinition = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of ILangStringDefinitionTypeIec61360, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment("definition"));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends ILangStringDefinitionTypeIec61360> itemResult = tryLangStringDefinitionTypeIec61360FromElement(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment("definition"));
                    return itemResult.castTo(DataSpecificationIec61360.class);
                  }

                  theDefinition.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "valueFormat":
            {
              if (isEmptyProperty) {
                theValueFormat = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property valueFormat of an instance of class DataSpecificationIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValueFormat = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property valueFormat of an instance of class DataSpecificationIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "valueFormat"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "valueList":
            {
              Result<ValueList> tryValueList = tryValueListFromSequence(
                reader, isEmptyProperty);

              if (tryValueList.isError()) {
                tryValueList.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "valueList"));
                return tryValueList.castTo(DataSpecificationIec61360.class);
              }

              theValueList = tryValueList.getResult();
              break;
            }
            case "value":
            {
              if (isEmptyProperty) {
                theValue = "";
              }
              else {
                if (currentEvent(reader).isEndDocument()) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected an XML content representing " +
                    "the property value of an instance of class DataSpecificationIec61360, " +
                    "but reached the end-of-file");
                  return Result.failure(error);
                }

                try {
                  theValue = readContentAsString(reader);
                } catch (Exception e) {
                  final Reporting.Error error = new Reporting.Error(
                    "The property value of an instance of class DataSpecificationIec61360 "
                      + " could not be de-serialized: " + e.getMessage());
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "value"));
                  return Result.failure(error);
                }
              }
              break;
            }
            case "levelType":
            {
              Result<LevelType> tryLevelType = tryLevelTypeFromSequence(
                reader, isEmptyProperty);

              if (tryLevelType.isError()) {
                tryLevelType.getError()
                  .prependSegment(
                    new Reporting.NameSegment(
                      "levelType"));
                return tryLevelType.castTo(DataSpecificationIec61360.class);
              }

              theLevelType = tryLevelType.getResult();
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class DataSpecificationIec61360, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "DataSpecificationIec61360",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(DataSpecificationIec61360.class);

        }
      }

      if (thePreferredName == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property preferredName has not been given " +
          "in the XML representation of an instance of class DataSpecificationIec61360");
        return Result.failure(error);
      }

      return Result.success(new DataSpecificationIec61360(
        thePreferredName,
        theShortName,
        theUnit,
        theUnitId,
        theSourceOfDefinition,
        theSymbol,
        theDataType,
        theDefinition,
        theValueFormat,
        theValueList,
        theValue,
        theLevelType));
    }

    /**
     * Deserialize an instance of class DataSpecificationIec61360 from an XML element.
     */
    private static Result<DataSpecificationIec61360> tryDataSpecificationIec61360FromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class DataSpecificationIec61360, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class DataSpecificationIec61360, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(DataSpecificationIec61360.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"dataSpecificationIec61360".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class DataSpecificationIec61360 " +
          "with element name dataSpecificationIec61360, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<DataSpecificationIec61360> result = tryDataSpecificationIec61360FromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(DataSpecificationIec61360.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "DataSpecificationIec61360",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(DataSpecificationIec61360.class);


      return result;
    }
  }

  /**
   * Deserialize instances of meta-model classes from XML.
   */
  /** <pre>
   * Here is an example how to parse an instance of class IHasSemantics:
   * {@code
   * XMLEventReader reader = xmlFactory.createXMLEventReader(...some arguments...);
   * IHasSemantics anInstance = Deserialize.deserializeIHasSemantics(
   *   reader);
   * }
   * </pre>
   *
   * <pre>
   * If the elements live in a namespace, you have to supply it. For example:
   * {@code
   * XMLEventReader reader = xmlFactory.createXMLEventReader(...some arguments...);
   * IHasSemantics anInstance = Deserialize.deserializeIHasSemantics(
   *   reader,
   *   "http://www.example.com/5/12");
   * }
   * </pre>
   */
  public static class Deserialize
  {
    /**
     * Deserialize an instance of IHasSemantics from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IHasSemantics deserializeIHasSemantics(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IHasSemantics> result =
        DeserializeImplementation.tryIHasSemanticsFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("ihassemantics"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Extension from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Extension deserializeExtension(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Extension> result =
        DeserializeImplementation.tryExtensionFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("extension"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IHasExtensions from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IHasExtensions deserializeIHasExtensions(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IHasExtensions> result =
        DeserializeImplementation.tryIHasExtensionsFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("ihasextensions"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IReferable from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IReferable deserializeIReferable(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IReferable> result =
        DeserializeImplementation.tryIReferableFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("ireferable"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IIdentifiable from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IIdentifiable deserializeIIdentifiable(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IIdentifiable> result =
        DeserializeImplementation.tryIIdentifiableFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("iidentifiable"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IHasKind from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IHasKind deserializeIHasKind(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IHasKind> result =
        DeserializeImplementation.tryIHasKindFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("ihaskind"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IHasDataSpecification from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IHasDataSpecification deserializeIHasDataSpecification(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IHasDataSpecification> result =
        DeserializeImplementation.tryIHasDataSpecificationFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("ihasdataspecification"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of AdministrativeInformation from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static AdministrativeInformation deserializeAdministrativeInformation(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends AdministrativeInformation> result =
        DeserializeImplementation.tryAdministrativeInformationFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("administrativeinformation"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IQualifiable from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IQualifiable deserializeIQualifiable(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IQualifiable> result =
        DeserializeImplementation.tryIQualifiableFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("iqualifiable"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Qualifier from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Qualifier deserializeQualifier(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Qualifier> result =
        DeserializeImplementation.tryQualifierFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("qualifier"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of AssetAdministrationShell from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static AssetAdministrationShell deserializeAssetAdministrationShell(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends AssetAdministrationShell> result =
        DeserializeImplementation.tryAssetAdministrationShellFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("assetadministrationshell"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of AssetInformation from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static AssetInformation deserializeAssetInformation(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends AssetInformation> result =
        DeserializeImplementation.tryAssetInformationFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("assetinformation"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Resource from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Resource deserializeResource(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Resource> result =
        DeserializeImplementation.tryResourceFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("resource"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of SpecificAssetId from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static SpecificAssetId deserializeSpecificAssetId(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends SpecificAssetId> result =
        DeserializeImplementation.trySpecificAssetIdFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("specificassetid"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Submodel from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Submodel deserializeSubmodel(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Submodel> result =
        DeserializeImplementation.trySubmodelFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("submodel"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of ISubmodelElement from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static ISubmodelElement deserializeISubmodelElement(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends ISubmodelElement> result =
        DeserializeImplementation.tryISubmodelElementFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("isubmodelelement"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IRelationshipElement from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IRelationshipElement deserializeIRelationshipElement(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IRelationshipElement> result =
        DeserializeImplementation.tryIRelationshipElementFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("irelationshipelement"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of RelationshipElement from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static RelationshipElement deserializeRelationshipElement(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends RelationshipElement> result =
        DeserializeImplementation.tryRelationshipElementFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("relationshipelement"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of SubmodelElementList from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static SubmodelElementList deserializeSubmodelElementList(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends SubmodelElementList> result =
        DeserializeImplementation.trySubmodelElementListFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("submodelelementlist"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of SubmodelElementCollection from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static SubmodelElementCollection deserializeSubmodelElementCollection(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends SubmodelElementCollection> result =
        DeserializeImplementation.trySubmodelElementCollectionFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("submodelelementcollection"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IDataElement from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IDataElement deserializeIDataElement(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IDataElement> result =
        DeserializeImplementation.tryIDataElementFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("idataelement"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Property from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Property deserializeProperty(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Property> result =
        DeserializeImplementation.tryPropertyFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("property"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of MultiLanguageProperty from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static MultiLanguageProperty deserializeMultiLanguageProperty(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends MultiLanguageProperty> result =
        DeserializeImplementation.tryMultiLanguagePropertyFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("multilanguageproperty"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Range from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Range deserializeRange(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Range> result =
        DeserializeImplementation.tryRangeFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("range"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of ReferenceElement from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static ReferenceElement deserializeReferenceElement(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends ReferenceElement> result =
        DeserializeImplementation.tryReferenceElementFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("referenceelement"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Blob from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Blob deserializeBlob(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Blob> result =
        DeserializeImplementation.tryBlobFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("blob"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of File from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static File deserializeFile(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends File> result =
        DeserializeImplementation.tryFileFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("file"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of AnnotatedRelationshipElement from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static AnnotatedRelationshipElement deserializeAnnotatedRelationshipElement(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends AnnotatedRelationshipElement> result =
        DeserializeImplementation.tryAnnotatedRelationshipElementFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("annotatedrelationshipelement"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Entity from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Entity deserializeEntity(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Entity> result =
        DeserializeImplementation.tryEntityFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("entity"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of EventPayload from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static EventPayload deserializeEventPayload(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends EventPayload> result =
        DeserializeImplementation.tryEventPayloadFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("eventpayload"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IEventElement from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IEventElement deserializeIEventElement(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IEventElement> result =
        DeserializeImplementation.tryIEventElementFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("ieventelement"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of BasicEventElement from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static BasicEventElement deserializeBasicEventElement(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends BasicEventElement> result =
        DeserializeImplementation.tryBasicEventElementFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("basiceventelement"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Operation from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Operation deserializeOperation(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Operation> result =
        DeserializeImplementation.tryOperationFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("operation"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of OperationVariable from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static OperationVariable deserializeOperationVariable(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends OperationVariable> result =
        DeserializeImplementation.tryOperationVariableFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("operationvariable"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Capability from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Capability deserializeCapability(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Capability> result =
        DeserializeImplementation.tryCapabilityFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("capability"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of ConceptDescription from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static ConceptDescription deserializeConceptDescription(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends ConceptDescription> result =
        DeserializeImplementation.tryConceptDescriptionFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("conceptdescription"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Reference from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Reference deserializeReference(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Reference> result =
        DeserializeImplementation.tryReferenceFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("reference"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Key from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Key deserializeKey(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Key> result =
        DeserializeImplementation.tryKeyFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("key"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IAbstractLangString from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IAbstractLangString deserializeIAbstractLangString(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IAbstractLangString> result =
        DeserializeImplementation.tryIAbstractLangStringFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("iabstractlangstring"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of LangStringNameType from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static LangStringNameType deserializeLangStringNameType(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends LangStringNameType> result =
        DeserializeImplementation.tryLangStringNameTypeFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("langstringnametype"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of LangStringTextType from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static LangStringTextType deserializeLangStringTextType(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends LangStringTextType> result =
        DeserializeImplementation.tryLangStringTextTypeFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("langstringtexttype"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of Environment from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static Environment deserializeEnvironment(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends Environment> result =
        DeserializeImplementation.tryEnvironmentFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("environment"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of IDataSpecificationContent from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static IDataSpecificationContent deserializeIDataSpecificationContent(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends IDataSpecificationContent> result =
        DeserializeImplementation.tryIDataSpecificationContentFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("idataspecificationcontent"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of EmbeddedDataSpecification from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static EmbeddedDataSpecification deserializeEmbeddedDataSpecification(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends EmbeddedDataSpecification> result =
        DeserializeImplementation.tryEmbeddedDataSpecificationFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("embeddeddataspecification"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of LevelType from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static LevelType deserializeLevelType(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends LevelType> result =
        DeserializeImplementation.tryLevelTypeFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("leveltype"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of ValueReferencePair from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static ValueReferencePair deserializeValueReferencePair(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends ValueReferencePair> result =
        DeserializeImplementation.tryValueReferencePairFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("valuereferencepair"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of ValueList from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static ValueList deserializeValueList(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends ValueList> result =
        DeserializeImplementation.tryValueListFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("valuelist"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of LangStringPreferredNameTypeIec61360 from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static LangStringPreferredNameTypeIec61360 deserializeLangStringPreferredNameTypeIec61360(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends LangStringPreferredNameTypeIec61360> result =
        DeserializeImplementation.tryLangStringPreferredNameTypeIec61360FromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("langstringpreferrednametypeiec61360"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of LangStringShortNameTypeIec61360 from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static LangStringShortNameTypeIec61360 deserializeLangStringShortNameTypeIec61360(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends LangStringShortNameTypeIec61360> result =
        DeserializeImplementation.tryLangStringShortNameTypeIec61360FromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("langstringshortnametypeiec61360"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of LangStringDefinitionTypeIec61360 from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static LangStringDefinitionTypeIec61360 deserializeLangStringDefinitionTypeIec61360(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends LangStringDefinitionTypeIec61360> result =
        DeserializeImplementation.tryLangStringDefinitionTypeIec61360FromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("langstringdefinitiontypeiec61360"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }

    /**
     * Deserialize an instance of DataSpecificationIec61360 from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static DataSpecificationIec61360 deserializeDataSpecificationIec61360(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends DataSpecificationIec61360> result =
        DeserializeImplementation.tryDataSpecificationIec61360FromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("dataspecificationiec61360"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }
  }

  /**
   * Serialize recursively the instances as XML elements.
   */
  static class VisitorWithWriter
    extends AbstractVisitorWithContext<XMLStreamWriter> {

    private boolean topLevel = true;

    private void extensionToSequence(
      IExtension that,
      XMLStreamWriter writer) {
      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "name");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getName().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValueType().isPresent()) {
          writer.writeStartElement(
            "valueType");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          Optional<String> textValueType = Stringification.toString(
            that.getValueType().get());

          if (!textValueType.isPresent()) {
            throw new IllegalArgumentException(
              "Invalid literal for the enumeration DataTypeDefXsd: " +
              that.getValueType().get().toString());
          }

          writer.writeCharacters(textValueType.get());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
            "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getValue().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getRefersTo().isPresent()) {
          writer.writeStartElement(
          "refersTo");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getRefersTo().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitExtension(
      IExtension that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "extension");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.extensionToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void administrativeInformationToSequence(
      IAdministrativeInformation that,
      XMLStreamWriter writer) {
      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getVersion().isPresent()) {
          writer.writeStartElement(
            "version");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getVersion().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getRevision().isPresent()) {
          writer.writeStartElement(
            "revision");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getRevision().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCreator().isPresent()) {
          writer.writeStartElement(
            "creator");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getCreator().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getTemplateId().isPresent()) {
          writer.writeStartElement(
            "templateId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getTemplateId().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitAdministrativeInformation(
      IAdministrativeInformation that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "administrativeInformation");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.administrativeInformationToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void qualifierToSequence(
      IQualifier that,
      XMLStreamWriter writer) {
      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getKind().isPresent()) {
          writer.writeStartElement(
            "kind");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          Optional<String> textKind = Stringification.toString(
            that.getKind().get());

          if (!textKind.isPresent()) {
            throw new IllegalArgumentException(
              "Invalid literal for the enumeration QualifierKind: " +
              that.getKind().get().toString());
          }

          writer.writeCharacters(textKind.get());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "type");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getType().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "valueType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textValueType = Stringification.toString(
          that.getValueType());

        if (!textValueType.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration DataTypeDefXsd: " +
            that.getValueType().toString());
        }

        writer.writeCharacters(textValueType.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
            "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getValue().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValueId().isPresent()) {
          writer.writeStartElement(
            "valueId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getValueId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitQualifier(
      IQualifier that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "qualifier");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.qualifierToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void assetAdministrationShellToSequence(
      IAssetAdministrationShell that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getAdministration().isPresent()) {
          writer.writeStartElement(
            "administration");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.administrativeInformationToSequence(
            that.getAdministration().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "id");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getId().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDerivedFrom().isPresent()) {
          writer.writeStartElement(
            "derivedFrom");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getDerivedFrom().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "assetInformation");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.assetInformationToSequence(
          that.getAssetInformation(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSubmodels().isPresent()) {
          writer.writeStartElement(
          "submodels");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSubmodels().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitAssetAdministrationShell(
      IAssetAdministrationShell that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "assetAdministrationShell");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.assetAdministrationShellToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void assetInformationToSequence(
      IAssetInformation that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "assetKind");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textAssetKind = Stringification.toString(
          that.getAssetKind());

        if (!textAssetKind.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration AssetKind: " +
            that.getAssetKind().toString());
        }

        writer.writeCharacters(textAssetKind.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getGlobalAssetId().isPresent()) {
          writer.writeStartElement(
            "globalAssetId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getGlobalAssetId().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSpecificAssetIds().isPresent()) {
          writer.writeStartElement(
          "specificAssetIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSpecificAssetIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getAssetType().isPresent()) {
          writer.writeStartElement(
            "assetType");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getAssetType().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDefaultThumbnail().isPresent()) {
          writer.writeStartElement(
            "defaultThumbnail");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.resourceToSequence(
            that.getDefaultThumbnail().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitAssetInformation(
      IAssetInformation that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "assetInformation");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.assetInformationToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void resourceToSequence(
      IResource that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "path");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getPath().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getContentType().isPresent()) {
          writer.writeStartElement(
            "contentType");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getContentType().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitResource(
      IResource that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "resource");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.resourceToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void specificAssetIdToSequence(
      ISpecificAssetId that,
      XMLStreamWriter writer) {
      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "name");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getName().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "value");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getValue().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getExternalSubjectId().isPresent()) {
          writer.writeStartElement(
            "externalSubjectId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getExternalSubjectId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitSpecificAssetId(
      ISpecificAssetId that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "specificAssetId");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.specificAssetIdToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void submodelToSequence(
      ISubmodel that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getAdministration().isPresent()) {
          writer.writeStartElement(
            "administration");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.administrativeInformationToSequence(
            that.getAdministration().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "id");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getId().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getKind().isPresent()) {
          writer.writeStartElement(
            "kind");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          Optional<String> textKind = Stringification.toString(
            that.getKind().get());

          if (!textKind.isPresent()) {
            throw new IllegalArgumentException(
              "Invalid literal for the enumeration ModellingKind: " +
              that.getKind().get().toString());
          }

          writer.writeCharacters(textKind.get());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSubmodelElements().isPresent()) {
          writer.writeStartElement(
          "submodelElements");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSubmodelElements().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitSubmodel(
      ISubmodel that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "submodel");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.submodelToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void relationshipElementToSequence(
      IRelationshipElement that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "first");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getFirst(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "second");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getSecond(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitRelationshipElement(
      IRelationshipElement that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "relationshipElement");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.relationshipElementToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void submodelElementListToSequence(
      ISubmodelElementList that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getOrderRelevant().isPresent()) {
          writer.writeStartElement(
            "orderRelevant");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getOrderRelevant().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticIdListElement().isPresent()) {
          writer.writeStartElement(
            "semanticIdListElement");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticIdListElement().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "typeValueListElement");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textTypeValueListElement = Stringification.toString(
          that.getTypeValueListElement());

        if (!textTypeValueListElement.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration AasSubmodelElements: " +
            that.getTypeValueListElement().toString());
        }

        writer.writeCharacters(textTypeValueListElement.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValueTypeListElement().isPresent()) {
          writer.writeStartElement(
            "valueTypeListElement");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          Optional<String> textValueTypeListElement = Stringification.toString(
            that.getValueTypeListElement().get());

          if (!textValueTypeListElement.isPresent()) {
            throw new IllegalArgumentException(
              "Invalid literal for the enumeration DataTypeDefXsd: " +
              that.getValueTypeListElement().get().toString());
          }

          writer.writeCharacters(textValueTypeListElement.get());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
          "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getValue().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitSubmodelElementList(
      ISubmodelElementList that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "submodelElementList");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.submodelElementListToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void submodelElementCollectionToSequence(
      ISubmodelElementCollection that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
          "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getValue().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitSubmodelElementCollection(
      ISubmodelElementCollection that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "submodelElementCollection");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.submodelElementCollectionToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void propertyToSequence(
      IProperty that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "valueType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textValueType = Stringification.toString(
          that.getValueType());

        if (!textValueType.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration DataTypeDefXsd: " +
            that.getValueType().toString());
        }

        writer.writeCharacters(textValueType.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
            "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getValue().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValueId().isPresent()) {
          writer.writeStartElement(
            "valueId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getValueId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitProperty(
      IProperty that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "property");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.propertyToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void multiLanguagePropertyToSequence(
      IMultiLanguageProperty that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
          "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getValue().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValueId().isPresent()) {
          writer.writeStartElement(
            "valueId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getValueId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitMultiLanguageProperty(
      IMultiLanguageProperty that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "multiLanguageProperty");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.multiLanguagePropertyToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void rangeToSequence(
      IRange that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "valueType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textValueType = Stringification.toString(
          that.getValueType());

        if (!textValueType.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration DataTypeDefXsd: " +
            that.getValueType().toString());
        }

        writer.writeCharacters(textValueType.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getMin().isPresent()) {
          writer.writeStartElement(
            "min");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getMin().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getMax().isPresent()) {
          writer.writeStartElement(
            "max");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getMax().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitRange(
      IRange that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "range");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.rangeToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void referenceElementToSequence(
      IReferenceElement that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
            "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getValue().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitReferenceElement(
      IReferenceElement that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "referenceElement");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.referenceElementToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void blobToSequence(
      IBlob that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement("value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          String theB64Value = Base64.getEncoder().encodeToString(
            that.getValue().get());
          writer.writeCharacters(theB64Value);
          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "contentType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getContentType().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitBlob(
      IBlob that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "blob");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.blobToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void fileToSequence(
      IFile that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
            "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getValue().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "contentType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getContentType().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitFile(
      IFile that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "file");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.fileToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void annotatedRelationshipElementToSequence(
      IAnnotatedRelationshipElement that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "first");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getFirst(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "second");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getSecond(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getAnnotations().isPresent()) {
          writer.writeStartElement(
          "annotations");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getAnnotations().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitAnnotatedRelationshipElement(
      IAnnotatedRelationshipElement that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "annotatedRelationshipElement");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.annotatedRelationshipElementToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void entityToSequence(
      IEntity that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getStatements().isPresent()) {
          writer.writeStartElement(
          "statements");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getStatements().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "entityType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textEntityType = Stringification.toString(
          that.getEntityType());

        if (!textEntityType.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration EntityType: " +
            that.getEntityType().toString());
        }

        writer.writeCharacters(textEntityType.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getGlobalAssetId().isPresent()) {
          writer.writeStartElement(
            "globalAssetId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getGlobalAssetId().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSpecificAssetIds().isPresent()) {
          writer.writeStartElement(
          "specificAssetIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSpecificAssetIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitEntity(
      IEntity that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "entity");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.entityToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void eventPayloadToSequence(
      IEventPayload that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "source");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getSource(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSourceSemanticId().isPresent()) {
          writer.writeStartElement(
            "sourceSemanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSourceSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "observableReference");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getObservableReference(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getObservableSemanticId().isPresent()) {
          writer.writeStartElement(
            "observableSemanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getObservableSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getTopic().isPresent()) {
          writer.writeStartElement(
            "topic");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getTopic().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSubjectId().isPresent()) {
          writer.writeStartElement(
            "subjectId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSubjectId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "timeStamp");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getTimeStamp().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getPayload().isPresent()) {
          writer.writeStartElement("payload");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          String theB64Payload = Base64.getEncoder().encodeToString(
            that.getPayload().get());
          writer.writeCharacters(theB64Payload);
          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitEventPayload(
      IEventPayload that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "eventPayload");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.eventPayloadToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void basicEventElementToSequence(
      IBasicEventElement that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "observed");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getObserved(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "direction");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textDirection = Stringification.toString(
          that.getDirection());

        if (!textDirection.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration Direction: " +
            that.getDirection().toString());
        }

        writer.writeCharacters(textDirection.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "state");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textState = Stringification.toString(
          that.getState());

        if (!textState.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration StateOfEvent: " +
            that.getState().toString());
        }

        writer.writeCharacters(textState.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getMessageTopic().isPresent()) {
          writer.writeStartElement(
            "messageTopic");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getMessageTopic().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getMessageBroker().isPresent()) {
          writer.writeStartElement(
            "messageBroker");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getMessageBroker().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getLastUpdate().isPresent()) {
          writer.writeStartElement(
            "lastUpdate");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getLastUpdate().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getMinInterval().isPresent()) {
          writer.writeStartElement(
            "minInterval");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getMinInterval().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getMaxInterval().isPresent()) {
          writer.writeStartElement(
            "maxInterval");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getMaxInterval().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitBasicEventElement(
      IBasicEventElement that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "basicEventElement");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.basicEventElementToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void operationToSequence(
      IOperation that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getInputVariables().isPresent()) {
          writer.writeStartElement(
          "inputVariables");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getInputVariables().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getOutputVariables().isPresent()) {
          writer.writeStartElement(
          "outputVariables");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getOutputVariables().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getInoutputVariables().isPresent()) {
          writer.writeStartElement(
          "inoutputVariables");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getInoutputVariables().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitOperation(
      IOperation that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "operation");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.operationToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void operationVariableToSequence(
      IOperationVariable that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "value");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.visit(
          that.getValue(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitOperationVariable(
      IOperationVariable that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "operationVariable");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.operationVariableToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void capabilityToSequence(
      ICapability that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSemanticId().isPresent()) {
          writer.writeStartElement(
            "semanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSupplementalSemanticIds().isPresent()) {
          writer.writeStartElement(
          "supplementalSemanticIds");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSupplementalSemanticIds().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getQualifiers().isPresent()) {
          writer.writeStartElement(
          "qualifiers");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getQualifiers().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitCapability(
      ICapability that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "capability");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.capabilityToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void conceptDescriptionToSequence(
      IConceptDescription that,
      XMLStreamWriter writer) {
      try {
        if (that.getExtensions().isPresent()) {
          writer.writeStartElement(
          "extensions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getExtensions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getCategory().isPresent()) {
          writer.writeStartElement(
            "category");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getCategory().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIdShort().isPresent()) {
          writer.writeStartElement(
            "idShort");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getIdShort().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDisplayName().isPresent()) {
          writer.writeStartElement(
          "displayName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDisplayName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDescription().isPresent()) {
          writer.writeStartElement(
          "description");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDescription().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getAdministration().isPresent()) {
          writer.writeStartElement(
            "administration");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.administrativeInformationToSequence(
            that.getAdministration().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "id");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getId().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getEmbeddedDataSpecifications().isPresent()) {
          writer.writeStartElement(
          "embeddedDataSpecifications");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getEmbeddedDataSpecifications().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getIsCaseOf().isPresent()) {
          writer.writeStartElement(
          "isCaseOf");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getIsCaseOf().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitConceptDescription(
      IConceptDescription that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "conceptDescription");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.conceptDescriptionToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void referenceToSequence(
      IReference that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "type");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textType = Stringification.toString(
          that.getType());

        if (!textType.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration ReferenceTypes: " +
            that.getType().toString());
        }

        writer.writeCharacters(textType.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getReferredSemanticId().isPresent()) {
          writer.writeStartElement(
            "referredSemanticId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getReferredSemanticId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "keys");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        for (IClass item : that.getKeys()) {
          this.visit(
            item,
            writer);
        }

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitReference(
      IReference that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "reference");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.referenceToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void keyToSequence(
      IKey that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "type");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        Optional<String> textType = Stringification.toString(
          that.getType());

        if (!textType.isPresent()) {
          throw new IllegalArgumentException(
            "Invalid literal for the enumeration KeyTypes: " +
            that.getType().toString());
        }

        writer.writeCharacters(textType.get());

        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "value");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getValue().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitKey(
      IKey that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "key");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.keyToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void langStringNameTypeToSequence(
      ILangStringNameType that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "language");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getLanguage().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "text");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getText().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitLangStringNameType(
      ILangStringNameType that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "langStringNameType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.langStringNameTypeToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void langStringTextTypeToSequence(
      ILangStringTextType that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "language");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getLanguage().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "text");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getText().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitLangStringTextType(
      ILangStringTextType that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "langStringTextType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.langStringTextTypeToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void environmentToSequence(
      IEnvironment that,
      XMLStreamWriter writer) {
      try {
        if (that.getAssetAdministrationShells().isPresent()) {
          writer.writeStartElement(
          "assetAdministrationShells");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getAssetAdministrationShells().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSubmodels().isPresent()) {
          writer.writeStartElement(
          "submodels");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getSubmodels().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getConceptDescriptions().isPresent()) {
          writer.writeStartElement(
          "conceptDescriptions");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getConceptDescriptions().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitEnvironment(
      IEnvironment that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "environment");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.environmentToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void embeddedDataSpecificationToSequence(
      IEmbeddedDataSpecification that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "dataSpecification");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getDataSpecification(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "dataSpecificationContent");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.visit(
          that.getDataSpecificationContent(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitEmbeddedDataSpecification(
      IEmbeddedDataSpecification that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "embeddedDataSpecification");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.embeddedDataSpecificationToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void levelTypeToSequence(
      ILevelType that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "min");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getMin().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "nom");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getNom().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "typ");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getTyp().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "max");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getMax().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitLevelType(
      ILevelType that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "levelType");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.levelTypeToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void valueReferencePairToSequence(
      IValueReferencePair that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "value");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getValue().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "valueId");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        this.referenceToSequence(
          that.getValueId(),
          writer);

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitValueReferencePair(
      IValueReferencePair that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "valueReferencePair");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.valueReferencePairToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void valueListToSequence(
      IValueList that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "valueReferencePairs");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        for (IClass item : that.getValueReferencePairs()) {
          this.visit(
            item,
            writer);
        }

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitValueList(
      IValueList that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "valueList");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.valueListToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void langStringPreferredNameTypeIec61360ToSequence(
      ILangStringPreferredNameTypeIec61360 that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "language");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getLanguage().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "text");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getText().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitLangStringPreferredNameTypeIec61360(
      ILangStringPreferredNameTypeIec61360 that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "langStringPreferredNameTypeIec61360");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.langStringPreferredNameTypeIec61360ToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void langStringShortNameTypeIec61360ToSequence(
      ILangStringShortNameTypeIec61360 that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "language");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getLanguage().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "text");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getText().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitLangStringShortNameTypeIec61360(
      ILangStringShortNameTypeIec61360 that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "langStringShortNameTypeIec61360");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.langStringShortNameTypeIec61360ToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void langStringDefinitionTypeIec61360ToSequence(
      ILangStringDefinitionTypeIec61360 that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "language");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getLanguage().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "text");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        writer.writeCharacters(
          that.getText().toString());
        writer.writeEndElement();
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitLangStringDefinitionTypeIec61360(
      ILangStringDefinitionTypeIec61360 that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "langStringDefinitionTypeIec61360");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.langStringDefinitionTypeIec61360ToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }

    private void dataSpecificationIec61360ToSequence(
      IDataSpecificationIec61360 that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "preferredName");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        for (IClass item : that.getPreferredName()) {
          this.visit(
            item,
            writer);
        }

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getShortName().isPresent()) {
          writer.writeStartElement(
          "shortName");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getShortName().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getUnit().isPresent()) {
          writer.writeStartElement(
            "unit");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getUnit().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getUnitId().isPresent()) {
          writer.writeStartElement(
            "unitId");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.referenceToSequence(
            that.getUnitId().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSourceOfDefinition().isPresent()) {
          writer.writeStartElement(
            "sourceOfDefinition");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getSourceOfDefinition().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getSymbol().isPresent()) {
          writer.writeStartElement(
            "symbol");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getSymbol().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDataType().isPresent()) {
          writer.writeStartElement(
            "dataType");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          Optional<String> textDataType = Stringification.toString(
            that.getDataType().get());

          if (!textDataType.isPresent()) {
            throw new IllegalArgumentException(
              "Invalid literal for the enumeration DataTypeIec61360: " +
              that.getDataType().get().toString());
          }

          writer.writeCharacters(textDataType.get());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getDefinition().isPresent()) {
          writer.writeStartElement(
          "definition");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }
          for (IClass item : that.getDefinition().get()) {
            this.visit(
              item,
              writer);
            }
          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValueFormat().isPresent()) {
          writer.writeStartElement(
            "valueFormat");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getValueFormat().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValueList().isPresent()) {
          writer.writeStartElement(
            "valueList");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.valueListToSequence(
            that.getValueList().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getValue().isPresent()) {
          writer.writeStartElement(
            "value");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          writer.writeCharacters(
            that.getValue().get().toString());

          writer.writeEndElement();
        }
      } catch (Exception exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        if (that.getLevelType().isPresent()) {
          writer.writeStartElement(
            "levelType");
          if (topLevel) {
            writer.writeNamespace("xmlns", AAS_NAME_SPACE);
            topLevel = false;
          }

          this.levelTypeToSequence(
            that.getLevelType().get(),
            writer);

          writer.writeEndElement();
        }
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitDataSpecificationIec61360(
      IDataSpecificationIec61360 that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "dataSpecificationIec61360");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.dataSpecificationIec61360ToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }
  }

  /**
   * Serialize instances of meta-model classes to XML.
   */
  /**
   * <pre>
   * Here is an example how to serialize an instance of IHasSemantics:
   * {@code
   * IClass anInstance = new IHasSemantics(
   *     ... some constructor arguments ...
   * );
   * XMLStreamWriter writer = xmlWriterFactory.createXMLStreamWriter(...some arguments...);
   * Serialize.to(
   *   anInstance,
   *   writer);
   * }
   * </pre>
   */
  public static class Serialize
  {
    /**
     * Serialize an instance of the meta-model to XML.
     */
    public static void to(
      IClass that,
      XMLStreamWriter writer) throws SerializeException {
      VisitorWithWriter visitor = new VisitorWithWriter(); 
      visitor.visit(
        that, writer);
    }
  }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
