/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package aas_core.aas3_0.verification;

import java.lang.Iterable;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Collections;
import java.util.function.Consumer;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import aas_core.aas3_0.constants.*;
import aas_core.aas3_0.reporting.Reporting;
import aas_core.aas3_0.types.enums.*;
import aas_core.aas3_0.types.model.*;
import aas_core.aas3_0.visitation.AbstractTransformer;

public class Verification {
  private static Pattern constructMatchesIdShort() {
    String pattern = "^[a-zA-Z][a-zA-Z0-9_]*$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesIdShort = constructMatchesIdShort();

  /**
   * Check that {@code text} is a valid short ID.
   */
  public static Boolean matchesIdShort(String text) {
    return regexMatchesIdShort.matcher(text).matches();
  }

  private static Pattern constructMatchesVersionType() {
    String pattern = "^(0|[1-9][0-9]*)$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesVersionType = constructMatchesVersionType();

  /**
   * Check that {@code text} is a valid version string.
   */
  public static Boolean matchesVersionType(String text) {
    return regexMatchesVersionType.matcher(text).matches();
  }

  private static Pattern constructMatchesRevisionType() {
    String pattern = "^(0|[1-9][0-9]*)$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesRevisionType = constructMatchesRevisionType();

  /**
   * Check that {@code text} is a valid revision string.
   */
  public static Boolean matchesRevisionType(String text) {
    return regexMatchesRevisionType.matcher(text).matches();
  }

  private static Pattern constructMatchesXsDateTimeUtc() {
    String digit = "[0-9]";
    String yearFrag = "-?(([1-9]" + digit + digit + digit + "+)|(0" + digit + digit + digit + "))";
    String monthFrag = "((0[1-9])|(1[0-2]))";
    String dayFrag = "((0[1-9])|([12]" + digit + ")|(3[01]))";
    String hourFrag = "(([01]" + digit + ")|(2[0-3]))";
    String minuteFrag = "[0-5]" + digit;
    String secondFrag = "([0-5]" + digit + ")(\\." + digit + "+)?";
    String endOfDayFrag = "24:00:00(\\.0+)?";
    String timezoneFrag = "(Z|\\+00:00|-00:00)";
    String dateTimeLexicalRep = yearFrag + "-" + monthFrag + "-" + dayFrag + "T((" + hourFrag + ":" + minuteFrag + ":" + secondFrag + ")|" + endOfDayFrag + ")" + timezoneFrag;
    String pattern = "^" + dateTimeLexicalRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsDateTimeUtc = constructMatchesXsDateTimeUtc();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:dateTime}.
   *
   * <p>The time zone must be fixed to UTC. We verify only that the {@code text} matches
   * a pre-defined pattern. We <em>do not</em> verify that the day of month is
   * correct nor do we check for leap seconds.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23dateTime'>https://www.w3.org/TR/xmlschema-2/#dateTime</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsDateTimeUtc(String text) {
    return regexMatchesXsDateTimeUtc.matcher(text).matches();
  }

  /**
  * Check that value is a xs:dateTime with
  * the time zone set to UTC.
  * @param value the value to check
  */
  public static boolean isXsDateTimeUtc(String value){
    Objects.requireNonNull(value);

    if (!matchesXsDateTimeUtc(value)) {
      return false;
    }

    return isPrefixedWithValidDate(value);
  }

  private static Pattern constructMatchesMimeType() {
    String tchar = "[!#$%&\'*+\\-.^_`|~0-9a-zA-Z]";
    String token = "(" + tchar + ")+";
    String type = token;
    String subtype = token;
    String ows = "[ \\t]*";
    String obsText = "[\\x{80}-\\x{ff}]";
    String qdText = "([\\t !#-\\[\\]-~]|" + obsText + ")";
    String quotedPair = "\\\\([\\t !-~]|" + obsText + ")";
    String quotedString = "\"(" + qdText + "|" + quotedPair + ")*\"";
    String parameter = token + "=(" + token + "|" + quotedString + ")";
    String mediaType = "^" + type + "/" + subtype + "(" + ows + ";" + ows + parameter + ")*$";

    return Pattern.compile(mediaType);
  }

  private static final Pattern regexMatchesMimeType = constructMatchesMimeType();

  /**
   * Check that {@code text} conforms to the pattern of MIME type.
   *
   * <p>The definition has been taken from:
   * <a href='https%3A//www.rfc-editor.org/rfc/rfc7231%23section-3.1.1.1'>https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1</a>,
   * <a href='https%3A//www.rfc-editor.org/rfc/rfc7230%23section-3.2.3'>https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3</a> and
   * <a href='https%3A//www.rfc-editor.org/rfc/rfc7230%23section-3.2.6'>https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6</a>.
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesMimeType(String text) {
    return regexMatchesMimeType.matcher(text).matches();
  }

  private static Pattern constructMatchesRfc8089Path() {
    String h16 = "[0-9A-Fa-f]{1,4}";
    String decOctet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])";
    String ipv4address = decOctet + "\\." + decOctet + "\\." + decOctet + "\\." + decOctet;
    String ls32 = "(" + h16 + ":" + h16 + "|" + ipv4address + ")";
    String ipv6address = "((" + h16 + ":){6}" + ls32 + "|::(" + h16 + ":){5}" + ls32 + "|(" + h16 + ")?::(" + h16 + ":){4}" + ls32 + "|((" + h16 + ":)?" + h16 + ")?::(" + h16 + ":){3}" + ls32 + "|((" + h16 + ":){0,2}" + h16 + ")?::(" + h16 + ":){2}" + ls32 + "|((" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32 + "|((" + h16 + ":){0,4}" + h16 + ")?::" + ls32 + "|((" + h16 + ":){0,5}" + h16 + ")?::" + h16 + "|((" + h16 + ":){0,6}" + h16 + ")?::)";
    String unreserved = "[a-zA-Z0-9\\-._~]";
    String subDelims = "[!$&\'()*+,;=]";
    String ipvfuture = "[vV][0-9A-Fa-f]+\\.(" + unreserved + "|" + subDelims + "|:)+";
    String ipLiteral = "\\[(" + ipv6address + "|" + ipvfuture + ")\\]";
    String pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
    String regName = "(" + unreserved + "|" + pctEncoded + "|" + subDelims + ")*";
    String host = "(" + ipLiteral + "|" + ipv4address + "|" + regName + ")";
    String fileAuth = "(localhost|" + host + ")";
    String pchar = "(" + unreserved + "|" + pctEncoded + "|" + subDelims + "|[:@])";
    String segmentNz = "(" + pchar + ")+";
    String segment = "(" + pchar + ")*";
    String pathAbsolute = "/(" + segmentNz + "(/" + segment + ")*)?";
    String authPath = "(" + fileAuth + ")?" + pathAbsolute;
    String localPath = pathAbsolute;
    String fileHierPart = "(//" + authPath + "|" + localPath + ")";
    String fileScheme = "file";
    String fileUri = fileScheme + ":" + fileHierPart;
    String pattern = "^" + fileUri + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesRfc8089Path = constructMatchesRfc8089Path();

  /**
   * Check that {@code text} is a path conforming to the pattern of RFC 8089.
   *
   * <p>The definition has been taken from:
   * <a href='https%3A//datatracker.ietf.org/doc/html/rfc8089'>https://datatracker.ietf.org/doc/html/rfc8089</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesRfc8089Path(String text) {
    return regexMatchesRfc8089Path.matcher(text).matches();
  }

  private static Pattern constructMatchesBcp47() {
    String alphanum = "[a-zA-Z0-9]";
    String singleton = "[0-9A-WY-Za-wy-z]";
    String extension = singleton + "(-(" + alphanum + "){2,8})+";
    String extlang = "[a-zA-Z]{3}(-[a-zA-Z]{3}){0,2}";
    String irregular = "(en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)";
    String regular = "(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)";
    String grandfathered = "(" + irregular + "|" + regular + ")";
    String language = "([a-zA-Z]{2,3}(-" + extlang + ")?|[a-zA-Z]{4}|[a-zA-Z]{5,8})";
    String script = "[a-zA-Z]{4}";
    String region = "([a-zA-Z]{2}|[0-9]{3})";
    String variant = "((" + alphanum + "){5,8}|[0-9](" + alphanum + "){3})";
    String privateuse = "[xX](-(" + alphanum + "){1,8})+";
    String langtag = language + "(-" + script + ")?(-" + region + ")?(-" + variant + ")*(-" + extension + ")*(-" + privateuse + ")?";
    String languageTag = "(" + langtag + "|" + privateuse + "|" + grandfathered + ")";
    String pattern = "^" + languageTag + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesBcp47 = constructMatchesBcp47();

  /**
   * Check that {@code text} is a valid BCP 47 language tag.
   *
   * <p>See: <a href='https%3A//en.wikipedia.org/wiki/IETF_language_tag'>https://en.wikipedia.org/wiki/IETF_language_tag</a>
   */
  public static Boolean matchesBcp47(String text) {
    return regexMatchesBcp47.matcher(text).matches();
  }

  /**
  * Check that {@link IAbstractLangString langStrings} are specified each for a unique
  * language.
   * @param langStrings  the langStrings.
  */
  public static boolean langStringsHaveUniqueLanguages(
    Iterable<? extends IAbstractLangString> langStrings
  ){
    Objects.requireNonNull(langStrings);

    Set<String> languageSet = new HashSet<>();
    for (IAbstractLangString langString : langStrings) {
      if (languageSet.contains(langString.getLanguage())) {
        return false;
      }
      languageSet.add(langString.getLanguage());
    }
    return true;
  }

  /**
  * Check that there are no duplicate {@link IQualifier#getType() type}'s
  * in the qualifiers.
   * @param qualifiers the qualifiers
  */
  public static boolean qualifierTypesAreUnique(
    Iterable<IQualifier> qualifiers
  ) {
    Objects.requireNonNull(qualifiers);

    Set<String> typeSet = new HashSet<>();
    for (IQualifier qualifier : qualifiers) {
      if (typeSet.contains(qualifier.getType())) {
        return false;
      }
      typeSet.add(qualifier.getType());
    }
    return true;
  }

  private static Pattern constructMatchesXmlSerializableString() {
    String pattern = "^[\\x{09}\\x{0a}\\x{0d}\\x{20}-\\x{d7ff}\\x{e000}-\\x{fffd}\\x{10000}-\\x{10ffff}]*$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXmlSerializableString = constructMatchesXmlSerializableString();

  /**
   * Check that {@code text} conforms to the pattern of the Constraint AASd-130.
   *
   * <p>Ensures that encoding is possible and interoperability between different
   * serializations is possible.
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXmlSerializableString(String text) {
    return regexMatchesXmlSerializableString.matcher(text).matches();
  }

  private static Pattern constructMatchesXsAnyUri() {
    String scheme = "[a-zA-Z][a-zA-Z0-9+\\-.]*";
    String ucschar = "[\\x{a0}-\\x{d7ff}\\x{f900}-\\x{fdcf}\\x{fdf0}-\\x{ffef}\\x{10000}-\\x{1fffd}\\x{20000}-\\x{2fffd}\\x{30000}-\\x{3fffd}\\x{40000}-\\x{4fffd}\\x{50000}-\\x{5fffd}\\x{60000}-\\x{6fffd}\\x{70000}-\\x{7fffd}\\x{80000}-\\x{8fffd}\\x{90000}-\\x{9fffd}\\x{a0000}-\\x{afffd}\\x{b0000}-\\x{bfffd}\\x{c0000}-\\x{cfffd}\\x{d0000}-\\x{dfffd}\\x{e1000}-\\x{efffd}]";
    String iunreserved = "([a-zA-Z0-9\\-._~]|" + ucschar + ")";
    String pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
    String subDelims = "[!$&\'()*+,;=]";
    String iuserinfo = "(" + iunreserved + "|" + pctEncoded + "|" + subDelims + "|:)*";
    String h16 = "[0-9A-Fa-f]{1,4}";
    String decOctet = "([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])";
    String ipv4address = decOctet + "\\." + decOctet + "\\." + decOctet + "\\." + decOctet;
    String ls32 = "(" + h16 + ":" + h16 + "|" + ipv4address + ")";
    String ipv6address = "((" + h16 + ":){6}" + ls32 + "|::(" + h16 + ":){5}" + ls32 + "|(" + h16 + ")?::(" + h16 + ":){4}" + ls32 + "|((" + h16 + ":)?" + h16 + ")?::(" + h16 + ":){3}" + ls32 + "|((" + h16 + ":){0,2}" + h16 + ")?::(" + h16 + ":){2}" + ls32 + "|((" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32 + "|((" + h16 + ":){0,4}" + h16 + ")?::" + ls32 + "|((" + h16 + ":){0,5}" + h16 + ")?::" + h16 + "|((" + h16 + ":){0,6}" + h16 + ")?::)";
    String unreserved = "[a-zA-Z0-9\\-._~]";
    String ipvfuture = "[vV][0-9A-Fa-f]+\\.(" + unreserved + "|" + subDelims + "|:)+";
    String ipLiteral = "\\[(" + ipv6address + "|" + ipvfuture + ")\\]";
    String iregName = "(" + iunreserved + "|" + pctEncoded + "|" + subDelims + ")*";
    String ihost = "(" + ipLiteral + "|" + ipv4address + "|" + iregName + ")";
    String port = "[0-9]*";
    String iauthority = "(" + iuserinfo + "@)?" + ihost + "(:" + port + ")?";
    String ipchar = "(" + iunreserved + "|" + pctEncoded + "|" + subDelims + "|[:@])";
    String isegment = "(" + ipchar + ")*";
    String ipathAbempty = "(/" + isegment + ")*";
    String isegmentNz = "(" + ipchar + ")+";
    String ipathAbsolute = "/(" + isegmentNz + "(/" + isegment + ")*)?";
    String ipathRootless = isegmentNz + "(/" + isegment + ")*";
    String ipathEmpty = "(" + ipchar + "){0}";
    String ihierPart = "(//" + iauthority + ipathAbempty + "|" + ipathAbsolute + "|" + ipathRootless + "|" + ipathEmpty + ")";
    String iprivate = "[\\x{e000}-\\x{f8ff}\\x{f0000}-\\x{ffffd}\\x{100000}-\\x{10fffd}]";
    String iquery = "(" + ipchar + "|" + iprivate + "|[/?])*";
    String ifragment = "(" + ipchar + "|[/?])*";
    String isegmentNzNc = "(" + iunreserved + "|" + pctEncoded + "|" + subDelims + "|@)+";
    String ipathNoscheme = isegmentNzNc + "(/" + isegment + ")*";
    String irelativePart = "(//" + iauthority + ipathAbempty + "|" + ipathAbsolute + "|" + ipathNoscheme + "|" + ipathEmpty + ")";
    String irelativeRef = irelativePart + "(\\?" + iquery + ")?(#" + ifragment + ")?";
    String iri = scheme + ":" + ihierPart + "(\\?" + iquery + ")?(#" + ifragment + ")?";
    String iriReference = "(" + iri + "|" + irelativeRef + ")";
    String pattern = "^" + iriReference + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsAnyUri = constructMatchesXsAnyUri();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:anyURI}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23anyURI'>https://www.w3.org/TR/xmlschema-2/#anyURI</a> and
   * <a href='https%3A//datatracker.ietf.org/doc/html/rfc3987'>https://datatracker.ietf.org/doc/html/rfc3987</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsAnyUri(String text) {
    return regexMatchesXsAnyUri.matcher(text).matches();
  }

  private static Pattern constructMatchesXsBase64Binary() {
    String b04Char = "[AQgw]";
    String b04 = b04Char + "\\x{20}?";
    String b16Char = "[AEIMQUYcgkosw048]";
    String b16 = b16Char + "\\x{20}?";
    String b64Char = "[A-Za-z0-9+/]";
    String b64 = b64Char + "\\x{20}?";
    String b64quad = "(" + b64 + b64 + b64 + b64 + ")";
    String b64FinalQuad = "(" + b64 + b64 + b64 + b64Char + ")";
    String padded8 = b64 + b04 + "= ?=";
    String padded16 = b64 + b64 + b16 + "=";
    String b64final = "(" + b64FinalQuad + "|" + padded16 + "|" + padded8 + ")";
    String base64Binary = "(" + b64quad + "*" + b64final + ")?";
    String pattern = "^" + base64Binary + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsBase64Binary = constructMatchesXsBase64Binary();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:base64Binary}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23base64Binary'>https://www.w3.org/TR/xmlschema-2/#base64Binary</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsBase64Binary(String text) {
    return regexMatchesXsBase64Binary.matcher(text).matches();
  }

  private static Pattern constructMatchesXsBoolean() {
    String pattern = "^(true|false|1|0)$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsBoolean = constructMatchesXsBoolean();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:boolean}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23boolean'>https://www.w3.org/TR/xmlschema-2/#boolean</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsBoolean(String text) {
    return regexMatchesXsBoolean.matcher(text).matches();
  }

  private static Pattern constructMatchesXsDate() {
    String digit = "[0-9]";
    String yearFrag = "-?(([1-9]" + digit + digit + digit + "+)|(0" + digit + digit + digit + "))";
    String monthFrag = "((0[1-9])|(1[0-2]))";
    String dayFrag = "((0[1-9])|([12]" + digit + ")|(3[01]))";
    String minuteFrag = "[0-5]" + digit;
    String timezoneFrag = "(Z|(\\+|-)((0" + digit + "|1[0-3]):" + minuteFrag + "|14:00))";
    String dateLexicalRep = yearFrag + "-" + monthFrag + "-" + dayFrag + timezoneFrag + "?";
    String pattern = "^" + dateLexicalRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsDate = constructMatchesXsDate();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:date}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23date'>https://www.w3.org/TR/xmlschema-2/#date</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsDate(String text) {
    return regexMatchesXsDate.matcher(text).matches();
  }

  private static Pattern constructMatchesXsDateTime() {
    String digit = "[0-9]";
    String yearFrag = "-?(([1-9]" + digit + digit + digit + "+)|(0" + digit + digit + digit + "))";
    String monthFrag = "((0[1-9])|(1[0-2]))";
    String dayFrag = "((0[1-9])|([12]" + digit + ")|(3[01]))";
    String hourFrag = "(([01]" + digit + ")|(2[0-3]))";
    String minuteFrag = "[0-5]" + digit;
    String secondFrag = "([0-5]" + digit + ")(\\." + digit + "+)?";
    String endOfDayFrag = "24:00:00(\\.0+)?";
    String timezoneFrag = "(Z|(\\+|-)((0" + digit + "|1[0-3]):" + minuteFrag + "|14:00))";
    String dateTimeLexicalRep = yearFrag + "-" + monthFrag + "-" + dayFrag + "T((" + hourFrag + ":" + minuteFrag + ":" + secondFrag + ")|" + endOfDayFrag + ")" + timezoneFrag + "?";
    String pattern = "^" + dateTimeLexicalRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsDateTime = constructMatchesXsDateTime();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:dateTime}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23dateTime'>https://www.w3.org/TR/xmlschema-2/#dateTime</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsDateTime(String text) {
    return regexMatchesXsDateTime.matcher(text).matches();
  }

  private static final Pattern regexDatePrefix = Pattern.compile("^(-?[0-9]+)-([0-9]{2})-([0-9]{2})");
  private static final BigInteger FOUR = new BigInteger("4");
  private static final BigInteger HUNDRED = new BigInteger("100");
  private static final BigInteger FOUR_HUNDRED = new BigInteger("100");

  /**
  * Check whether the given year is a leap year.
  * Year 1 BCE is a leap year.
  * @param year to be checked
  * @return  True if 'year' is a leap year
  */

  public static boolean isLeapYear(BigInteger year) {
  // We consider the years B.C. to be one-off.
  // See the note at: https://www.w3.org/TR/xmlschema-2/#dateTime:
  // "'-0001' is the lexical representation of the year 1 Before Common Era
  // (1 BCE, sometimes written "1 BC")."
  //
  // Hence, -1 year in XML is 1 BCE, which is 0 year in astronomical years.
  if (year.signum() < 0) {
    year = year.negate().subtract(BigInteger.ONE);
  }

  // See: See: https://en.wikipedia.org/wiki/Leap_year#Algorithm
  if (year.mod(FOUR).signum() > 0) {
    return false;
  }

  if (year.mod(HUNDRED).signum() > 0) {
    return true;
  }

  if (year.mod(FOUR_HUNDRED).signum() > 0) {
    return false;
  }

  return true;
  }

  /**
  * Check that the value starts with a valid date.
  * @param value an xs:date, an xs:dateTime,or an xs:dateTimeStamp
  * @return true if the value starts with a valid date
  */
  private static boolean isPrefixedWithValidDate(
    String value) {
    Objects.requireNonNull(value);

    Matcher match = regexDatePrefix.matcher(value);
    if (!match.lookingAt()) {
      return false;
    }

    BigInteger year;
    try {
       year = new BigInteger(match.group(1));
    } catch (NumberFormatException exception) {
      throw new IllegalArgumentException(
        "Expected to parse the year from " + match.group(1)
        + "but the parsing failed");
    }

    int month;
    try {
      month = Integer.parseInt(match.group(2));
    } catch (NumberFormatException exception) {
      throw new IllegalArgumentException(
        "Expected to parse the month from " + match.group(2)
        + "but the parsing failed");
    }

    int day;
    try {
      day = Integer.parseInt(match.group(3));
    } catch (NumberFormatException exception) {
      throw new IllegalArgumentException(
        "Expected to parse the day from " + match.group(3)
        + "but the parsing failed");
    }

    // Year zero does not exist, see: https://www.w3.org/TR/xmlschema-2/#dateTime
    if (year.signum() == 0) {
      return false;
    }

    if (day <= 0 || day > 31) {
      return false;
    }

    if (month <= 0 || month >= 13) {
      return false;
    }

    int maxDaysInMonth;
    switch (month) {
      case 1:
        maxDaysInMonth = 31;
        break;
      case 2:
        maxDaysInMonth = (isLeapYear(year)) ? 29 : 28;
        break;
      case 3:
        maxDaysInMonth = 31;
        break;
      case 4:
        maxDaysInMonth = 30;
        break;
      case 5:
        maxDaysInMonth = 31;
        break;
      case 6:
        maxDaysInMonth = 30;
        break;
      case 7:
        maxDaysInMonth = 31;
        break;
      case 8:
        maxDaysInMonth = 31;
        break;
      case 9:
        maxDaysInMonth = 30;
        break;
      case 10:
        maxDaysInMonth = 31;
        break;
      case 11:
        maxDaysInMonth = 30;
        break;
      case 12:
        maxDaysInMonth = 31;
        break;
      default:
        throw new IllegalArgumentException("Unexpected month: " + month);
    }

    if (day > maxDaysInMonth) {
      return false;
    }

    return true;
  }



  /**
  * Check that value is a xs:dateTime with
  * the time zone set to UTC.
  * @param value to check
  */
  public static boolean isXsDateTime(String value) {
    if (!matchesXsDateTime(value)) {
      return false;
    }

    return isPrefixedWithValidDate(value);
  }

  private static Pattern constructMatchesXsDecimal() {
    String digit = "[0-9]";
    String unsignedNoDecimalPtNumeral = digit + "+";
    String noDecimalPtNumeral = "(\\+|-)?" + unsignedNoDecimalPtNumeral;
    String fracFrag = digit + "+";
    String unsignedDecimalPtNumeral = "(" + unsignedNoDecimalPtNumeral + "\\." + fracFrag + "|\\." + fracFrag + ")";
    String decimalPtNumeral = "(\\+|-)?" + unsignedDecimalPtNumeral;
    String decimalLexicalRep = "(" + decimalPtNumeral + "|" + noDecimalPtNumeral + ")";
    String pattern = "^" + decimalLexicalRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsDecimal = constructMatchesXsDecimal();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:decimal}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23decimal'>https://www.w3.org/TR/xmlschema-2/#decimal</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsDecimal(String text) {
    return regexMatchesXsDecimal.matcher(text).matches();
  }

  private static Pattern constructMatchesXsDouble() {
    String doubleRep = "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)";
    String pattern = "^" + doubleRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsDouble = constructMatchesXsDouble();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:double}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23double'>https://www.w3.org/TR/xmlschema-2/#double</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsDouble(String text) {
    return regexMatchesXsDouble.matcher(text).matches();
  }

  private static Pattern constructMatchesXsDuration() {
    String durationRep = "-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))";
    String pattern = "^" + durationRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsDuration = constructMatchesXsDuration();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:duration}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23duration'>https://www.w3.org/TR/xmlschema-2/#duration</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsDuration(String text) {
    return regexMatchesXsDuration.matcher(text).matches();
  }

  private static Pattern constructMatchesXsFloat() {
    String floatRep = "((\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|-?INF|NaN)";
    String pattern = "^" + floatRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsFloat = constructMatchesXsFloat();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:float}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23float'>https://www.w3.org/TR/xmlschema-2/#float</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsFloat(String text) {
    return regexMatchesXsFloat.matcher(text).matches();
  }

  private static Pattern constructMatchesXsGDay() {
    String gDayLexicalRep = "---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
    String pattern = "^" + gDayLexicalRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsGDay = constructMatchesXsGDay();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:gDay}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23gDay'>https://www.w3.org/TR/xmlschema-2/#gDay</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsGDay(String text) {
    return regexMatchesXsGDay.matcher(text).matches();
  }

  private static Pattern constructMatchesXsGMonth() {
    String gMonthLexicalRep = "--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
    String pattern = "^" + gMonthLexicalRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsGMonth = constructMatchesXsGMonth();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:gMonth}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23gMonth'>https://www.w3.org/TR/xmlschema-2/#gMonth</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsGMonth(String text) {
    return regexMatchesXsGMonth.matcher(text).matches();
  }

  private static Pattern constructMatchesXsGMonthDay() {
    String gMonthDayRep = "--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
    String pattern = "^" + gMonthDayRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsGMonthDay = constructMatchesXsGMonthDay();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:gMonthDay}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23gMonthDay'>https://www.w3.org/TR/xmlschema-2/#gMonthDay</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsGMonthDay(String text) {
    return regexMatchesXsGMonthDay.matcher(text).matches();
  }

  private static Pattern constructMatchesXsGYear() {
    String gYearRep = "-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
    String pattern = "^" + gYearRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsGYear = constructMatchesXsGYear();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:gYear}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23gYear'>https://www.w3.org/TR/xmlschema-2/#gYear</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsGYear(String text) {
    return regexMatchesXsGYear.matcher(text).matches();
  }

  private static Pattern constructMatchesXsGYearMonth() {
    String gYearMonthRep = "-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
    String pattern = "^" + gYearMonthRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsGYearMonth = constructMatchesXsGYearMonth();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:gYearMonth}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23gYearMonth'>https://www.w3.org/TR/xmlschema-2/#gYearMonth</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsGYearMonth(String text) {
    return regexMatchesXsGYearMonth.matcher(text).matches();
  }

  private static Pattern constructMatchesXsHexBinary() {
    String hexBinary = "([0-9a-fA-F]{2})*";
    String pattern = "^" + hexBinary + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsHexBinary = constructMatchesXsHexBinary();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:hexBinary}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23hexBinary'>https://www.w3.org/TR/xmlschema-2/#hexBinary</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsHexBinary(String text) {
    return regexMatchesXsHexBinary.matcher(text).matches();
  }

  private static Pattern constructMatchesXsTime() {
    String timeRep = "(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?";
    String pattern = "^" + timeRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsTime = constructMatchesXsTime();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:time}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23time'>https://www.w3.org/TR/xmlschema-2/#time</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsTime(String text) {
    return regexMatchesXsTime.matcher(text).matches();
  }

  private static Pattern constructMatchesXsInteger() {
    String integerRep = "[-+]?[0-9]+";
    String pattern = "^" + integerRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsInteger = constructMatchesXsInteger();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:integer}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23integer'>https://www.w3.org/TR/xmlschema-2/#integer</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsInteger(String text) {
    return regexMatchesXsInteger.matcher(text).matches();
  }

  private static Pattern constructMatchesXsLong() {
    String longRep = "[-+]?0*[0-9]{1,20}";
    String pattern = "^" + longRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsLong = constructMatchesXsLong();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:long}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23long'>https://www.w3.org/TR/xmlschema-2/#long</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsLong(String text) {
    return regexMatchesXsLong.matcher(text).matches();
  }

  private static Pattern constructMatchesXsInt() {
    String intRep = "[-+]?0*[0-9]{1,10}";
    String pattern = "^" + intRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsInt = constructMatchesXsInt();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:int}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23int'>https://www.w3.org/TR/xmlschema-2/#int</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsInt(String text) {
    return regexMatchesXsInt.matcher(text).matches();
  }

  private static Pattern constructMatchesXsShort() {
    String shortRep = "[-+]?0*[0-9]{1,5}";
    String pattern = "^" + shortRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsShort = constructMatchesXsShort();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:short}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23short'>https://www.w3.org/TR/xmlschema-2/#short</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsShort(String text) {
    return regexMatchesXsShort.matcher(text).matches();
  }

  private static Pattern constructMatchesXsByte() {
    String byteRep = "[-+]?0*[0-9]{1,3}";
    String pattern = "^" + byteRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsByte = constructMatchesXsByte();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:byte}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23byte'>https://www.w3.org/TR/xmlschema-2/#byte</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsByte(String text) {
    return regexMatchesXsByte.matcher(text).matches();
  }

  private static Pattern constructMatchesXsNonNegativeInteger() {
    String nonNegativeIntegerRep = "(-0|\\+?[0-9]+)";
    String pattern = "^" + nonNegativeIntegerRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsNonNegativeInteger = constructMatchesXsNonNegativeInteger();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:nonNegativeInteger}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23nonNegativeInteger'>https://www.w3.org/TR/xmlschema-2/#nonNegativeInteger</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsNonNegativeInteger(String text) {
    return regexMatchesXsNonNegativeInteger.matcher(text).matches();
  }

  private static Pattern constructMatchesXsPositiveInteger() {
    String positiveIntegerRep = "\\+?0*[1-9][0-9]*";
    String pattern = "^" + positiveIntegerRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsPositiveInteger = constructMatchesXsPositiveInteger();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:positiveInteger}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23positiveInteger'>https://www.w3.org/TR/xmlschema-2/#positiveInteger</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsPositiveInteger(String text) {
    return regexMatchesXsPositiveInteger.matcher(text).matches();
  }

  private static Pattern constructMatchesXsUnsignedLong() {
    String unsignedLongRep = "(-0|\\+?0*[0-9]{1,20})";
    String pattern = "^" + unsignedLongRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsUnsignedLong = constructMatchesXsUnsignedLong();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:unsignedLong}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23unsignedLong'>https://www.w3.org/TR/xmlschema-2/#unsignedLong</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsUnsignedLong(String text) {
    return regexMatchesXsUnsignedLong.matcher(text).matches();
  }

  private static Pattern constructMatchesXsUnsignedInt() {
    String unsignedIntRep = "(-0|\\+?0*[0-9]{1,10})";
    String pattern = "^" + unsignedIntRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsUnsignedInt = constructMatchesXsUnsignedInt();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:unsignedInt}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23unsignedInt'>https://www.w3.org/TR/xmlschema-2/#unsignedInt</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsUnsignedInt(String text) {
    return regexMatchesXsUnsignedInt.matcher(text).matches();
  }

  private static Pattern constructMatchesXsUnsignedShort() {
    String unsignedShortRep = "(-0|\\+?0*[0-9]{1,5})";
    String pattern = "^" + unsignedShortRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsUnsignedShort = constructMatchesXsUnsignedShort();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:unsignedShort}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23unsignedShort'>https://www.w3.org/TR/xmlschema-2/#unsignedShort</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsUnsignedShort(String text) {
    return regexMatchesXsUnsignedShort.matcher(text).matches();
  }

  private static Pattern constructMatchesXsUnsignedByte() {
    String unsignedByteRep = "(-0|\\+?0*[0-9]{1,3})";
    String pattern = "^" + unsignedByteRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsUnsignedByte = constructMatchesXsUnsignedByte();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:unsignedByte}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23unsignedByte'>https://www.w3.org/TR/xmlschema-2/#unsignedByte</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsUnsignedByte(String text) {
    return regexMatchesXsUnsignedByte.matcher(text).matches();
  }

  private static Pattern constructMatchesXsNonPositiveInteger() {
    String nonPositiveIntegerRep = "(\\+0|0|-[0-9]+)";
    String pattern = "^" + nonPositiveIntegerRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsNonPositiveInteger = constructMatchesXsNonPositiveInteger();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:nonPositiveInteger}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23nonPositiveInteger'>https://www.w3.org/TR/xmlschema-2/#nonPositiveInteger</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsNonPositiveInteger(String text) {
    return regexMatchesXsNonPositiveInteger.matcher(text).matches();
  }

  private static Pattern constructMatchesXsNegativeInteger() {
    String negativeIntegerRep = "(-0*[1-9][0-9]*)";
    String pattern = "^" + negativeIntegerRep + "$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsNegativeInteger = constructMatchesXsNegativeInteger();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:negativeInteger}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23negativeInteger'>https://www.w3.org/TR/xmlschema-2/#negativeInteger</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsNegativeInteger(String text) {
    return regexMatchesXsNegativeInteger.matcher(text).matches();
  }

  private static Pattern constructMatchesXsString() {
    String pattern = "^[\\x{09}\\x{0a}\\x{0d}\\x{20}-\\x{d7ff}\\x{e000}-\\x{fffd}\\x{10000}-\\x{10ffff}]*$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexMatchesXsString = constructMatchesXsString();

  /**
   * Check that {@code text} conforms to the pattern of an {@code xs:string}.
   *
   * <p>See: <a href='https%3A//www.w3.org/TR/xmlschema-2/%23string'>https://www.w3.org/TR/xmlschema-2/#string</a>
   *
   * @param text Text to be checked
   * @return True if the {@code text} conforms to the pattern
   */
  public static Boolean matchesXsString(String text) {
    return regexMatchesXsString.matcher(text).matches();
  }

  /**
  * Check that the value is consistent with
  * the given valueType.
  * @param value the value to check
  * @param valueType the value type
  */
  public static boolean valueConsistentWithXsdType(
    String value,
    DataTypeDefXsd valueType){
    Objects.requireNonNull(value);
    Objects.requireNonNull(valueType);

    switch (valueType) {
      case ANY_URI: {
        return matchesXsAnyUri(value);
      }
      case BASE_64_BINARY: {
        return matchesXsBase64Binary(value);
      }
      case BOOLEAN: {
        return matchesXsBoolean(value);
      }
      case BYTE: {
        try {
          Byte.valueOf(value);
          return true;
        } catch (NumberFormatException numberFormatException) {
          return false;
        }
      }
      case DATE: {
        if (!matchesXsDate(value)) {
          return false;
        }

        return isPrefixedWithValidDate(value);
      }
      case DATE_TIME: {
        if (!matchesXsDateTime(value)) {
          return false;
        }

        // The time part and the time zone part will be checked by
        // MatchesXsDateTime. We need to check that the date part is
        // correct in sense of the day/month combination.
        return isPrefixedWithValidDate(value);
      }
      case DECIMAL: {
        return matchesXsDecimal(value);
      }
      case DOUBLE: {
        // We need to check explicitly for the regular expression.
        // See: https://www.w3.org/TR/xmlschema-2/#double
        if (!matchesXsDouble(value)) {
          return false;
        }

        if("INF".equals(value) || "-INF".equals(value)) return true;

        double converted;
        try {
          converted = Double.parseDouble(value);
        } catch (Exception exception) {
          return false;
        }
        return !Double.isInfinite(converted);
      }
      case DURATION: {
        return matchesXsDuration(value);
      }
      case FLOAT: {
        // We need to check explicitly for the regular expression.
        // See: https://www.w3.org/TR/xmlschema-2/#float
        if (!matchesXsFloat(value)) {
          return false;
        }

        if("INF".equals(value) || "-INF".equals(value)) return true;

        float converted;
        try {
          converted = Float.parseFloat(value);
        } catch (Exception exception) {
          return false;
        }
        return !Float.isInfinite(converted);
      }
      case G_DAY: {
        return matchesXsGDay(value);
      }
      case G_MONTH: {
        return matchesXsGMonth(value);
      }
      case G_MONTH_DAY: {
        if (!matchesXsGMonthDay(value)) {
          return false;
        }

        int month = Integer.parseInt(value.substring(2,4));
        int day = Integer.parseInt(value.substring(5,7));
        switch (month)
        {
          case 1:
          case 3:
          case 5:
          case 7:
          case 8:
          case 10:
          case 12:
          return day <= 31;
          case 4:
          case 6:
          case 9:
          case 11:
          return day <= 30;
          case 2:
            return day <= 29;
          default:
            throw new IllegalArgumentException(
                "Unhandled month: " + month +
                "is there maybe a bug in MatchesXsGMonthDay?"
            );
        }
      }
      case G_YEAR: {
        return matchesXsGYear(value);
      }
      case G_YEAR_MONTH: {
        return matchesXsGYearMonth(value);
      }
      case HEX_BINARY: {
        return matchesXsHexBinary(value);
      }
      case INT: {
        try {
          Integer.parseInt(value);
          return true;
        } catch (Exception exception) {
          return false;
        }
      }
      case INTEGER: {
        return matchesXsInteger(value);
      }
      case LONG: {
        try {
          Long.parseLong(value);
          return true;
        } catch (Exception exception) {
          return false;
        }
      }
      case NEGATIVE_INTEGER: {
        return matchesXsNegativeInteger(value);
      }
      case NON_NEGATIVE_INTEGER: {
        return matchesXsNonNegativeInteger(value);
      }
      case NON_POSITIVE_INTEGER: {
        return matchesXsNonPositiveInteger(value);
      }
      case POSITIVE_INTEGER: {
        return matchesXsPositiveInteger(value);
      }
      case SHORT: {
        try {
          Short.parseShort(value);
          return true;
        } catch (Exception exception) {
          return false;
        }
      }
      case STRING: {
        return matchesXsString(value);
      }
      case TIME: {
        return matchesXsTime(value);
      }
      case UNSIGNED_BYTE: {
        if (value.isEmpty()) {
          return false;
        }

        // We need to allow negative zeros which are allowed in the lexical
        // representation of an unsigned byte.
        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedByte
        if (value.equals("-0")) {
          return true;
        }

        try {
          int converted = Integer.parseInt(value);
          return 0 <= converted && converted <= 255;
        } catch (Exception exception) {
          return false;
        }
      }
      case UNSIGNED_INT: {
        if (value.isEmpty()) {
          return false;
        }

        // We need to allow negative zeros which are allowed in the lexical
        // representation of an unsigned int.
        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedInt
        if (value.equals("-0")) {
          return true;
        }

        try {
          //Java does not support UInt32 like C#, so we need to use long.
          long converted = Long.parseUnsignedLong(value);
          return converted <= 4294967295L;
        } catch (Exception exception) {
          return false;
        }
      }
      case UNSIGNED_LONG: {
        if (value.isEmpty()) {
          return false;
        }

        // We need to allow negative zeros which are allowed in the lexical
        // representation of an unsigned long.
        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedLong
        if (value.equals("-0")) {
          return true;
        }

        try {
          Long.parseUnsignedLong(value);
          return true;
        } catch (Exception exception) {
          return false;
        }
      }
      case UNSIGNED_SHORT: {
        if (value.isEmpty()) {
          return false;
        }

        // We need to allow negative zeros which are allowed in the lexical
        // representation of an unsigned short.
        // See: https://www.w3.org/TR/xmlschema11-2/#unsignedShort
        if (value.equals("-0")) {
          return true;
        }

        try {
          int converted = Integer.parseInt(value);
          return  0 <= converted && converted <= 65535;
        } catch (Exception exception) {
          return false;
        }
      }
      default:
        throw new IllegalArgumentException(
            "valueType is an invalid DataTypeDefXsd: " + valueType
        );
    }
  }

  /**
   * Check that the target of the model reference matches the {@code expectedType}.
   */
  public static Boolean isModelReferenceTo(
    IReference reference,
    KeyTypes expectedType) {
    return reference.getType() == ReferenceTypes.MODEL_REFERENCE
    && reference.getKeys().size() != 0
    && reference.getKeys().get(reference.getKeys().size() - 1).getType() == expectedType;
  }

  /**
   * Check that the target of the reference matches a {@link aas_core.aas3_0.constants.Constants#aasReferables}.
   */
  public static Boolean isModelReferenceToReferable(
    IReference reference) {
    return reference.getType() == ReferenceTypes.MODEL_REFERENCE
    && reference.getKeys().size() != 0
    && Constants.aasReferables.contains(reference.getKeys().get(reference.getKeys().size() - 1).getType());
  }

  /**
  * Check that all {@link IReferable#getIdShort() idShort}  are unique among referables.
  * @param referables the referables.
  */
  public static boolean idShortsAreUnique(
    Iterable<? extends IReferable> referables) {
    Objects.requireNonNull(referables);

    Set<String> idShortSet = new HashSet<>();

    for (IReferable referable : referables) {
      if (referable.getIdShort().isPresent()) {
        if (idShortSet.contains(referable.getIdShort().get())) {
          return false;
        }
        idShortSet.add(referable.getIdShort().get());
      }
    }
    return true;
  }

  /**
  * Check that all {@link IReferable#getIdShort idShort} 's are among all the inputVariables, outputVariables and inoutputVariables are unique.
  * @param inputVariables the inputVariables
   * @param outputVariables the outputVariables
   * @param inoutputVariables the inoutputVariables
  */
  public static boolean idShortsOfVariablesAreUnique(
      Iterable<? extends IOperationVariable> inputVariables,
      Iterable<? extends IOperationVariable> outputVariables,
      Iterable<? extends IOperationVariable> inoutputVariables) {

    Set<String> idShortSet = new HashSet<>();

    if (inputVariables != null) {
      for(IOperationVariable variable : inputVariables) {
        if (variable.getValue().getIdShort().isPresent()) {
          if (idShortSet.contains(variable.getValue().getIdShort().get())) {
            return false;
          }
          idShortSet.add(variable.getValue().getIdShort().get());
        }
      }
    }

    if (outputVariables != null) {
      for (IOperationVariable variable : outputVariables) {
        if (variable.getValue().getIdShort().isPresent()) {
          if (idShortSet.contains(variable.getValue().getIdShort().get())) {
            return false;
          }
          idShortSet.add(variable.getValue().getIdShort().get());
        }
      }
    }

    if (inoutputVariables != null) {
      for (IOperationVariable variable :  inoutputVariables) {
        if (variable.getValue().getIdShort().isPresent()) {
          if (idShortSet.contains(variable.getValue().getIdShort().get())) {
            return false;
          }
          idShortSet.add(variable.getValue().getIdShort().get());
        }
      }
    }

    return true;
  }

  /**
  * Check that all {@link IExtension#getName() name}  are unique among extensions.
  * @param extensions the extensions
  */
  public static boolean extensionNamesAreUnique(
    Iterable<? extends IExtension> extensions) {
    Objects.requireNonNull(extensions);

    Set<String> nameSet = new HashSet<>();

    for (IExtension extension : extensions) {
      if (nameSet.contains(extension.getName())) {
        return false;
      }
      nameSet.add(extension.getName());
    }
    return true;
  }

  /**
  * Check that all elements have the identical
  * {@link IHasSemantics#getSemanticId() semanticId}'s.
  */
  public static boolean submodelElementsHaveIdenticalSemanticIds(
    Iterable<? extends ISubmodelElement> elements) {
    Objects.requireNonNull(elements);

    IReference thatSemanticId = null;

    for (ISubmodelElement element : elements) {
      if (!element.getSemanticId().isPresent()) {
        continue;
      }

      if (thatSemanticId == null) {
        thatSemanticId = element.getSemanticId().get();
        continue;
      }

      IReference thisSemanticId = element.getSemanticId().get();

      if (thatSemanticId.getKeys().size() != thisSemanticId.getKeys().size()) {
        return false;
      }

      for (int i = 0; i < thisSemanticId.getKeys().size(); i++) {
        if (!Objects.equals(thatSemanticId.getKeys().get(i).getValue(),
                            thisSemanticId.getKeys().get(i).getValue())) {
          return false;
        }
      }
    }

    return true;
  }

  public static boolean submodelElementIsOfType(
    ISubmodelElement element,
    AasSubmodelElements expectedType
  ) {
    Objects.requireNonNull(element);
    Objects.requireNonNull(expectedType);

    switch (expectedType) {
      case ANNOTATED_RELATIONSHIP_ELEMENT:
        return element instanceof IAnnotatedRelationshipElement;

      case BASIC_EVENT_ELEMENT:
        return element instanceof IBasicEventElement;

      case BLOB:
        return element instanceof IBlob;

      case CAPABILITY:
        return element instanceof ICapability;

      case DATA_ELEMENT:
        return element instanceof IDataElement;

      case ENTITY:
        return element instanceof IEntity;

      case EVENT_ELEMENT:
        return element instanceof IEventElement;

      case FILE:
        return element instanceof IFile;

      case MULTI_LANGUAGE_PROPERTY:
        return element instanceof IMultiLanguageProperty;

      case OPERATION:
        return element instanceof IOperation;

      case PROPERTY:
        return element instanceof IProperty;

      case RANGE:
        return element instanceof IRange;

      case REFERENCE_ELEMENT:
        return element instanceof IReferenceElement;

      case RELATIONSHIP_ELEMENT:
        return element instanceof IRelationshipElement;

      case SUBMODEL_ELEMENT:
        return element instanceof ISubmodelElement;

      case SUBMODEL_ELEMENT_LIST:
        return element instanceof ISubmodelElementList;

      case SUBMODEL_ELEMENT_COLLECTION:
        return element instanceof ISubmodelElementCollection;

      default:
        throw new IllegalArgumentException(
            "expectedType is not a valid AasSubmodelElements: " + expectedType
        );
    }
  }

  /**
  * Check that the elements which are
  * {@link IProperty} or {@link IRange}
  * have the given valueType.
   * @param elements the elements.
   * @param valueType the valueType.
  */
  public static boolean propertiesOrRangesHaveValueType(
    Iterable<? extends ISubmodelElement> elements,
    DataTypeDefXsd valueType
  ) {
    Objects.requireNonNull(elements);
    Objects.requireNonNull(valueType);

    for (ISubmodelElement element : elements) {
       if(element instanceof IProperty) {
         if (((IProperty) element).getValueType() != valueType) {
           return false;
         }
       } else if (element instanceof IRange) {
         if (((IRange) element).getValueType() != valueType) {
           return false;
         }
       }
    }
    return true;
  }

  /**
  * Check that the two references,'that' and
  * 'other', are equal by comparing
  * their {@link IReference#getKeys() keys} by
  * {@link IKey#getValue() value}'s.
  */
  public static boolean referenceKeyValuesEqual(
    IReference that,
    IReference other) {
    Objects.requireNonNull(that);
    Objects.requireNonNull(other);

    if (that.getKeys().size() != other.getKeys().size()) {
      return false;
    }

    for (int i = 0; i < that.getKeys().size(); i++) {
      if (!Objects.equals(that.getKeys().get(i).getValue(), other.getKeys().get(i).getValue())) {
        return false;
      }
    }

    return true;
  }

  /**
  *Check that the {@link IDataSpecificationIec61360#getValue() dataType} is defined
  *appropriately for all data specifications whose content is given as IEC 61360.
  */
  public static boolean dataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(
    Iterable<? extends IEmbeddedDataSpecification> embeddedDataSpecifications){
    Objects.requireNonNull(embeddedDataSpecifications);

    for (IEmbeddedDataSpecification embeddedDataSpecification : embeddedDataSpecifications){
      IDataSpecificationIec61360 iec61360 =
        (IDataSpecificationIec61360) embeddedDataSpecification.getDataSpecificationContent();
      if(iec61360 != null){
        if (!iec61360.getDataType().isPresent()
          || !Constants.dataTypeIec61360ForPropertyOrValue.contains(
             iec61360.getDataType().get())) {
          return false;
        }
      }
    }
    return true;
  }

  /**
  * Check that the {@link IDataSpecificationIec61360#getDataType() dataType} is defined
  * appropriately for all data specifications whose content is given as IEC 61360.
  */
  public static boolean dataSpecificationIec61360sForReferenceHaveAppropriateDataType(
    Iterable<? extends IEmbeddedDataSpecification> embeddedDataSpecifications) {
    Objects.requireNonNull(embeddedDataSpecifications);

    for(IEmbeddedDataSpecification embeddedDataSpecification :embeddedDataSpecifications) {
      IDataSpecificationIec61360 iec61360 =
        (IDataSpecificationIec61360) embeddedDataSpecification.getDataSpecificationContent();
      if (iec61360 != null) {
        if (!iec61360.getDataType().isPresent()
          || !Constants.dataTypeIec61360ForReference.contains(
             iec61360.getDataType().get())) {
          return false;
        }
      }
    }
    return true;
  }

  /**
  * Check that the {@link  IDataSpecificationIec61360#getDataType dataType} is defined
  * appropriately for all data specifications whose content is given as IEC 61360.
  */
  public static boolean dataSpecificationIec61360sForDocumentHaveAppropriateDataType(
    Iterable<? extends IEmbeddedDataSpecification> embeddedDataSpecifications) {
    Objects.requireNonNull(embeddedDataSpecifications);

    for (IEmbeddedDataSpecification embeddedDataSpecification : embeddedDataSpecifications) {
      IDataSpecificationIec61360 iec61360 =
        (IDataSpecificationIec61360) embeddedDataSpecification.getDataSpecificationContent();
      if(iec61360 != null) {
        if (!iec61360.getDataType().isPresent()
          || !Constants.dataTypeIec61360ForDocument.contains(
             iec61360.getDataType().get())) {
          return false;
        }
      }
    }
    return true;
  }

  /**
  * Check that the {@link IDataSpecificationIec61360#getDataType() dataType} is defined
  * for all data specifications whose content is given as IEC 61360.
  */
  public static boolean dataSpecificationIec61360sHaveDataType(
    Iterable<? extends IEmbeddedDataSpecification> embeddedDataSpecifications){
    Objects.requireNonNull(embeddedDataSpecifications);

    for (IEmbeddedDataSpecification embeddedDataSpecification : embeddedDataSpecifications) {
      IDataSpecificationIec61360 iec61360
        = (IDataSpecificationIec61360) embeddedDataSpecification.getDataSpecificationContent();
      if (iec61360 != null) {
        if (!iec61360.getDataType().isPresent()) {
          return false;
        }
      }
    }
    return true;
  }

  /** Check that the {@link IDataSpecificationIec61360#getValue() value}  is defined
  * for all data specifications whose content is given as IEC 61360.
  */
  public static boolean dataSpecificationIec61360sHaveValue(
      Iterable<? extends IEmbeddedDataSpecification> embeddedDataSpecifications) {
    Objects.requireNonNull(embeddedDataSpecifications);

    for (IEmbeddedDataSpecification embeddedDataSpecification : embeddedDataSpecifications) {
      IDataSpecificationIec61360 iec61360 =
        (IDataSpecificationIec61360) embeddedDataSpecification.getDataSpecificationContent();
      if (iec61360 != null) {
        if (!iec61360.getValue().isPresent()) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Check that the {@link IDataSpecificationIec61360#getDefinition() definition} is defined
  * for all data specifications whose content is given as IEC 61360 at least in English.
  */
  public static boolean dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(
      Iterable<? extends IEmbeddedDataSpecification> embeddedDataSpecifications){
    Objects.requireNonNull(embeddedDataSpecifications);

    for (IEmbeddedDataSpecification embeddedDataSpecification : embeddedDataSpecifications) {
      IDataSpecificationIec61360 iec61360 =
        (IDataSpecificationIec61360) embeddedDataSpecification.getDataSpecificationContent();
      if (iec61360 != null) {
        if (!iec61360.getDefinition().isPresent()) {
          return false;
        }

        boolean noDefinitionInEnglish = true;
        for (ILangStringDefinitionTypeIec61360 langString : iec61360.getDefinition().get()) {
          if (isBcp47ForEnglish(langString.getLanguage())) {
            noDefinitionInEnglish = false;
            break;
          }
        }

        if (noDefinitionInEnglish) {
          return false;
        }
      }
    }
    return true;
  }

  private static Pattern constructIsBcp47ForEnglish() {
    String pattern = "^(en|EN)(-.*)?$";

    return Pattern.compile(pattern);
  }

  private static final Pattern regexIsBcp47ForEnglish = constructIsBcp47ForEnglish();

  /**
   * Check that the {@code text} corresponds to a BCP47 code for english.
   */
  public static Boolean isBcp47ForEnglish(String text) {
    return regexIsBcp47ForEnglish.matcher(text).matches();
  }

  /**
   * Hash allowed enum values for efficient validation of enums.
   */
  private static class EnumValueSet {
    private static final Set<ModellingKind> forModellingKind;
    static {
      final Set<ModellingKind> temp = new HashSet<>();

      temp.add(ModellingKind.TEMPLATE);
      temp.add(ModellingKind.INSTANCE);

      if (!temp.containsAll(Arrays.asList(ModellingKind.values()))) {
        throw new IllegalStateException("Uncovered ModellingKind");
      }

      forModellingKind = Collections.unmodifiableSet(temp);
    }

    private static final Set<QualifierKind> forQualifierKind;
    static {
      final Set<QualifierKind> temp = new HashSet<>();

      temp.add(QualifierKind.VALUE_QUALIFIER);
      temp.add(QualifierKind.CONCEPT_QUALIFIER);
      temp.add(QualifierKind.TEMPLATE_QUALIFIER);

      if (!temp.containsAll(Arrays.asList(QualifierKind.values()))) {
        throw new IllegalStateException("Uncovered QualifierKind");
      }

      forQualifierKind = Collections.unmodifiableSet(temp);
    }

    private static final Set<AssetKind> forAssetKind;
    static {
      final Set<AssetKind> temp = new HashSet<>();

      temp.add(AssetKind.TYPE);
      temp.add(AssetKind.INSTANCE);
      temp.add(AssetKind.NOT_APPLICABLE);

      if (!temp.containsAll(Arrays.asList(AssetKind.values()))) {
        throw new IllegalStateException("Uncovered AssetKind");
      }

      forAssetKind = Collections.unmodifiableSet(temp);
    }

    private static final Set<AasSubmodelElements> forAasSubmodelElements;
    static {
      final Set<AasSubmodelElements> temp = new HashSet<>();

      temp.add(AasSubmodelElements.ANNOTATED_RELATIONSHIP_ELEMENT);
      temp.add(AasSubmodelElements.BASIC_EVENT_ELEMENT);
      temp.add(AasSubmodelElements.BLOB);
      temp.add(AasSubmodelElements.CAPABILITY);
      temp.add(AasSubmodelElements.DATA_ELEMENT);
      temp.add(AasSubmodelElements.ENTITY);
      temp.add(AasSubmodelElements.EVENT_ELEMENT);
      temp.add(AasSubmodelElements.FILE);
      temp.add(AasSubmodelElements.MULTI_LANGUAGE_PROPERTY);
      temp.add(AasSubmodelElements.OPERATION);
      temp.add(AasSubmodelElements.PROPERTY);
      temp.add(AasSubmodelElements.RANGE);
      temp.add(AasSubmodelElements.REFERENCE_ELEMENT);
      temp.add(AasSubmodelElements.RELATIONSHIP_ELEMENT);
      temp.add(AasSubmodelElements.SUBMODEL_ELEMENT);
      temp.add(AasSubmodelElements.SUBMODEL_ELEMENT_LIST);
      temp.add(AasSubmodelElements.SUBMODEL_ELEMENT_COLLECTION);

      if (!temp.containsAll(Arrays.asList(AasSubmodelElements.values()))) {
        throw new IllegalStateException("Uncovered AasSubmodelElements");
      }

      forAasSubmodelElements = Collections.unmodifiableSet(temp);
    }

    private static final Set<EntityType> forEntityType;
    static {
      final Set<EntityType> temp = new HashSet<>();

      temp.add(EntityType.CO_MANAGED_ENTITY);
      temp.add(EntityType.SELF_MANAGED_ENTITY);

      if (!temp.containsAll(Arrays.asList(EntityType.values()))) {
        throw new IllegalStateException("Uncovered EntityType");
      }

      forEntityType = Collections.unmodifiableSet(temp);
    }

    private static final Set<Direction> forDirection;
    static {
      final Set<Direction> temp = new HashSet<>();

      temp.add(Direction.INPUT);
      temp.add(Direction.OUTPUT);

      if (!temp.containsAll(Arrays.asList(Direction.values()))) {
        throw new IllegalStateException("Uncovered Direction");
      }

      forDirection = Collections.unmodifiableSet(temp);
    }

    private static final Set<StateOfEvent> forStateOfEvent;
    static {
      final Set<StateOfEvent> temp = new HashSet<>();

      temp.add(StateOfEvent.ON);
      temp.add(StateOfEvent.OFF);

      if (!temp.containsAll(Arrays.asList(StateOfEvent.values()))) {
        throw new IllegalStateException("Uncovered StateOfEvent");
      }

      forStateOfEvent = Collections.unmodifiableSet(temp);
    }

    private static final Set<ReferenceTypes> forReferenceTypes;
    static {
      final Set<ReferenceTypes> temp = new HashSet<>();

      temp.add(ReferenceTypes.EXTERNAL_REFERENCE);
      temp.add(ReferenceTypes.MODEL_REFERENCE);

      if (!temp.containsAll(Arrays.asList(ReferenceTypes.values()))) {
        throw new IllegalStateException("Uncovered ReferenceTypes");
      }

      forReferenceTypes = Collections.unmodifiableSet(temp);
    }

    private static final Set<KeyTypes> forKeyTypes;
    static {
      final Set<KeyTypes> temp = new HashSet<>();

      temp.add(KeyTypes.ANNOTATED_RELATIONSHIP_ELEMENT);
      temp.add(KeyTypes.ASSET_ADMINISTRATION_SHELL);
      temp.add(KeyTypes.BASIC_EVENT_ELEMENT);
      temp.add(KeyTypes.BLOB);
      temp.add(KeyTypes.CAPABILITY);
      temp.add(KeyTypes.CONCEPT_DESCRIPTION);
      temp.add(KeyTypes.DATA_ELEMENT);
      temp.add(KeyTypes.ENTITY);
      temp.add(KeyTypes.EVENT_ELEMENT);
      temp.add(KeyTypes.FILE);
      temp.add(KeyTypes.FRAGMENT_REFERENCE);
      temp.add(KeyTypes.GLOBAL_REFERENCE);
      temp.add(KeyTypes.IDENTIFIABLE);
      temp.add(KeyTypes.MULTI_LANGUAGE_PROPERTY);
      temp.add(KeyTypes.OPERATION);
      temp.add(KeyTypes.PROPERTY);
      temp.add(KeyTypes.RANGE);
      temp.add(KeyTypes.REFERABLE);
      temp.add(KeyTypes.REFERENCE_ELEMENT);
      temp.add(KeyTypes.RELATIONSHIP_ELEMENT);
      temp.add(KeyTypes.SUBMODEL);
      temp.add(KeyTypes.SUBMODEL_ELEMENT);
      temp.add(KeyTypes.SUBMODEL_ELEMENT_COLLECTION);
      temp.add(KeyTypes.SUBMODEL_ELEMENT_LIST);

      if (!temp.containsAll(Arrays.asList(KeyTypes.values()))) {
        throw new IllegalStateException("Uncovered KeyTypes");
      }

      forKeyTypes = Collections.unmodifiableSet(temp);
    }

    private static final Set<DataTypeDefXsd> forDataTypeDefXsd;
    static {
      final Set<DataTypeDefXsd> temp = new HashSet<>();

      temp.add(DataTypeDefXsd.ANY_URI);
      temp.add(DataTypeDefXsd.BASE_64_BINARY);
      temp.add(DataTypeDefXsd.BOOLEAN);
      temp.add(DataTypeDefXsd.BYTE);
      temp.add(DataTypeDefXsd.DATE);
      temp.add(DataTypeDefXsd.DATE_TIME);
      temp.add(DataTypeDefXsd.DECIMAL);
      temp.add(DataTypeDefXsd.DOUBLE);
      temp.add(DataTypeDefXsd.DURATION);
      temp.add(DataTypeDefXsd.FLOAT);
      temp.add(DataTypeDefXsd.G_DAY);
      temp.add(DataTypeDefXsd.G_MONTH);
      temp.add(DataTypeDefXsd.G_MONTH_DAY);
      temp.add(DataTypeDefXsd.G_YEAR);
      temp.add(DataTypeDefXsd.G_YEAR_MONTH);
      temp.add(DataTypeDefXsd.HEX_BINARY);
      temp.add(DataTypeDefXsd.INT);
      temp.add(DataTypeDefXsd.INTEGER);
      temp.add(DataTypeDefXsd.LONG);
      temp.add(DataTypeDefXsd.NEGATIVE_INTEGER);
      temp.add(DataTypeDefXsd.NON_NEGATIVE_INTEGER);
      temp.add(DataTypeDefXsd.NON_POSITIVE_INTEGER);
      temp.add(DataTypeDefXsd.POSITIVE_INTEGER);
      temp.add(DataTypeDefXsd.SHORT);
      temp.add(DataTypeDefXsd.STRING);
      temp.add(DataTypeDefXsd.TIME);
      temp.add(DataTypeDefXsd.UNSIGNED_BYTE);
      temp.add(DataTypeDefXsd.UNSIGNED_INT);
      temp.add(DataTypeDefXsd.UNSIGNED_LONG);
      temp.add(DataTypeDefXsd.UNSIGNED_SHORT);

      if (!temp.containsAll(Arrays.asList(DataTypeDefXsd.values()))) {
        throw new IllegalStateException("Uncovered DataTypeDefXsd");
      }

      forDataTypeDefXsd = Collections.unmodifiableSet(temp);
    }

    private static final Set<DataTypeIec61360> forDataTypeIec61360;
    static {
      final Set<DataTypeIec61360> temp = new HashSet<>();

      temp.add(DataTypeIec61360.DATE);
      temp.add(DataTypeIec61360.STRING);
      temp.add(DataTypeIec61360.STRING_TRANSLATABLE);
      temp.add(DataTypeIec61360.INTEGER_MEASURE);
      temp.add(DataTypeIec61360.INTEGER_COUNT);
      temp.add(DataTypeIec61360.INTEGER_CURRENCY);
      temp.add(DataTypeIec61360.REAL_MEASURE);
      temp.add(DataTypeIec61360.REAL_COUNT);
      temp.add(DataTypeIec61360.REAL_CURRENCY);
      temp.add(DataTypeIec61360.BOOLEAN);
      temp.add(DataTypeIec61360.IRI);
      temp.add(DataTypeIec61360.IRDI);
      temp.add(DataTypeIec61360.RATIONAL);
      temp.add(DataTypeIec61360.RATIONAL_MEASURE);
      temp.add(DataTypeIec61360.TIME);
      temp.add(DataTypeIec61360.TIMESTAMP);
      temp.add(DataTypeIec61360.FILE);
      temp.add(DataTypeIec61360.HTML);
      temp.add(DataTypeIec61360.BLOB);

      if (!temp.containsAll(Arrays.asList(DataTypeIec61360.values()))) {
        throw new IllegalStateException("Uncovered DataTypeIec61360");
      }

      forDataTypeIec61360 = Collections.unmodifiableSet(temp);
    }
  }

  private static final Transformer transformer = new Transformer();

  private static class Transformer extends AbstractTransformer<Stream<Reporting.Error>> {
    @Override
    public Stream<Reporting.Error> transformExtension(
      IExtension that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getRefersTo().isPresent())
        || (that.getRefersTo().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Refers-to must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || valueConsistentWithXsdType(
            that.getValue().orElse(null),
            that.valueTypeOrDefault()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "The value must match the value type.")));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getName())
          .flatMap(Verification::verifyNameType)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("name"));
              return error;
            }));

      if (that.getValueType().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValueType().get())
            .flatMap(Verification::verifyDataTypeDefXsd)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("valueType"));
                return error;
              }));
      }

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValue().get())
            .flatMap(Verification::verifyValueDataType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("value"));
                return error;
              }));
      }

      if (that.getRefersTo().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getRefersTo().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("refersTo"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformAdministrativeInformation(
      IAdministrativeInformation that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getRevision().isPresent())
        || (that.getVersion().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-005: If version is not specified then also " +
            "revision shall be unspecified. This means, a revision " +
            "requires a version. If there is no version there is no " +
            "revision either. Revision is optional.")));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getVersion().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getVersion().get())
            .flatMap(Verification::verifyVersionType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("version"));
                return error;
              }));
      }

      if (that.getRevision().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getRevision().get())
            .flatMap(Verification::verifyRevisionType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("revision"));
                return error;
              }));
      }

      if (that.getCreator().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCreator().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("creator"));
                return error;
              }));
      }

      if (that.getTemplateId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getTemplateId().get())
            .flatMap(Verification::verifyIdentifier)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("templateId"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformQualifier(
      IQualifier that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || valueConsistentWithXsdType(that.getValue().orElse(null), that.getValueType()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-020: The value shall be consistent to " +
            "the data type as defined in value type.")));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getKind().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getKind().get())
            .flatMap(Verification::verifyQualifierKind)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("kind"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getType())
          .flatMap(Verification::verifyQualifierType)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("type"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getValueType())
          .flatMap(Verification::verifyDataTypeDefXsd)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("valueType"));
              return error;
            }));

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValue().get())
            .flatMap(Verification::verifyValueDataType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("value"));
                return error;
              }));
      }

      if (that.getValueId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValueId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("valueId"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformAssetAdministrationShell(
      IAssetAdministrationShell that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getSubmodels().isPresent())
        || (that.getSubmodels().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Submodels must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getDerivedFrom().isPresent())
        || isModelReferenceTo(
            that.getDerivedFrom().orElse(null),
            KeyTypes.ASSET_ADMINISTRATION_SHELL))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Derived-from must be a model reference to an asset " +
            "administration shell.")));
      }

      if (!(
        !(that.getSubmodels().isPresent())
        || (
            that.getSubmodels().get().stream().allMatch(
                reference -> isModelReferenceTo(reference, KeyTypes.SUBMODEL))
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "All submodels must be model references to a submodel.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getAdministration().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getAdministration().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("administration"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getId())
          .flatMap(Verification::verifyIdentifier)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("id"));
              return error;
            }));

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getDerivedFrom().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getDerivedFrom().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("derivedFrom"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getAssetInformation())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("assetInformation"));
              return error;
            }));

      if (that.getSubmodels().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSubmodels().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("submodels"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformAssetInformation(
      IAssetInformation that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getSpecificAssetIds().isPresent())
        || (
            that.getSpecificAssetIds().get().stream().allMatch(
                specificAssetId -> specificAssetId.getName() != "globalAssetId"
                    || (
                        (that.getGlobalAssetId().isPresent())
                        && specificAssetId.getName() == "globalAssetId"
                        && specificAssetId.getValue() == that.getGlobalAssetId().get()
                    ))
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-116: ``globalAssetId`` is a reserved key. " +
            "If used as value for the name of specific asset ID then " +
            "the value of specific asset ID shall be identical to " +
            "the global asset ID.")));
      }

      if (!(
        (
            (that.getGlobalAssetId().isPresent())
            || (that.getSpecificAssetIds().isPresent())
        )
        && (
            !(that.getSpecificAssetIds().isPresent())
            || (that.getSpecificAssetIds().get().size() >= 1)
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-131: Either the global asset ID shall be " +
            "defined or at least one specific asset ID.")));
      }

      if (!(
        !(that.getSpecificAssetIds().isPresent())
        || (that.getSpecificAssetIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Specific asset IDs must be either not set or have at least " +
            "one item.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getAssetKind())
          .flatMap(Verification::verifyAssetKind)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("assetKind"));
              return error;
            }));

      if (that.getGlobalAssetId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getGlobalAssetId().get())
            .flatMap(Verification::verifyIdentifier)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("globalAssetId"));
                return error;
              }));
      }

      if (that.getSpecificAssetIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSpecificAssetIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("specificAssetIds"));
              return error;
            }));
      }

      if (that.getAssetType().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getAssetType().get())
            .flatMap(Verification::verifyIdentifier)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("assetType"));
                return error;
              }));
      }

      if (that.getDefaultThumbnail().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getDefaultThumbnail().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("defaultThumbnail"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformResource(
      IResource that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getPath())
          .flatMap(Verification::verifyPathType)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("path"));
              return error;
            }));

      if (that.getContentType().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getContentType().get())
            .flatMap(Verification::verifyContentType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("contentType"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformSpecificAssetId(
      ISpecificAssetId that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getExternalSubjectId().isPresent())
        || (that.getExternalSubjectId().get().getType() == ReferenceTypes.EXTERNAL_REFERENCE))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-133: External subject ID shall be " +
            "an external reference.")));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getName())
          .flatMap(Verification::verifyLabelType)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("name"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getValue())
          .flatMap(Verification::verifyIdentifier)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("value"));
              return error;
            }));

      if (that.getExternalSubjectId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getExternalSubjectId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("externalSubjectId"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformSubmodel(
      ISubmodel that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getSubmodelElements().isPresent())
        || (that.getSubmodelElements().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Submodel elements must be either not set or have at least " +
            "one item.")));
      }

      if (!(
        !(that.getSubmodelElements().isPresent())
        || (
            that.getSubmodelElements().get().stream().allMatch(
                item -> item.getIdShort().isPresent())
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "ID-shorts need to be defined for all the items of submodel " +
            "elements according to AASd-117 (ID-short of Referables not " +
            "being a direct child of a Submodel element list shall be " +
            "specified).")));
      }

      if (!(
        !(that.getSubmodelElements().isPresent())
        || idShortsAreUnique(that.getSubmodelElements().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-022: ID-short of non-identifiable " +
            "referables within the same name space shall be unique " +
            "(case-sensitive).")));
      }

      if (!(
        !(that.getSubmodelElements().isPresent())
        || (
            !(that.kindOrDefault() != ModellingKind.TEMPLATE)
            || (
                that.getSubmodelElements().get().stream().allMatch(
                    submodelElement -> !(submodelElement.getQualifiers().isPresent())
                        || (
                            submodelElement.getQualifiers().get().stream().allMatch(
                                qualifier -> qualifier.kindOrDefault() != QualifierKind.TEMPLATE_QUALIFIER)
                        ))
            )
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-129: If any qualifier kind value of " +
            "a Submodel element qualifier (attribute qualifier inherited " +
            "via Qualifiable) is equal to Template Qualifier then " +
            "the submodel element shall be part of a submodel template, " +
            "i.e. a Submodel with submodel kind (attribute kind " +
            "inherited via Has-Kind) value is equal to Template.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (
            !(
                that.getQualifiers().get().stream().anyMatch(
                    qualifier -> qualifier.kindOrDefault() == QualifierKind.TEMPLATE_QUALIFIER)
            )
            || (that.kindOrDefault() == ModellingKind.TEMPLATE)
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-119: If any qualifier kind value of " +
            "a qualifiable qualifier is equal to template qualifier and " +
            "the qualified element has kind then the qualified element " +
            "shall be of kind template.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getAdministration().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getAdministration().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("administration"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getId())
          .flatMap(Verification::verifyIdentifier)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("id"));
              return error;
            }));

      if (that.getKind().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getKind().get())
            .flatMap(Verification::verifyModellingKind)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("kind"));
                return error;
              }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getSubmodelElements().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSubmodelElements().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("submodelElements"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformRelationshipElement(
      IRelationshipElement that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getFirst())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("first"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getSecond())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("second"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformSubmodelElementList(
      ISubmodelElementList that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || (that.getValue().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Value must be either not set or have at least one item.")));
      }

      if (!(
        !(
            (that.getValue().isPresent())
            && (that.getSemanticIdListElement().isPresent())
        )
        || (
            that.getValue().get().stream().allMatch(
                child -> !(child.getSemanticId().isPresent())
                    || referenceKeyValuesEqual(
                        child.getSemanticId().orElse(null),
                        that.getSemanticIdListElement().orElse(null)))
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-107: If a first level child element has " +
            "a semantic ID it shall be identical to semantic ID list " +
            "element.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || submodelElementsHaveIdenticalSemanticIds(that.getValue().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-114: If two first level child elements have " +
            "a semantic ID then they shall be identical.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || (
            that.getValue().get().stream().allMatch(
                element -> submodelElementIsOfType(element, that.getTypeValueListElement()))
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-108: All first level child elements shall " +
            "have the same submodel element type as specified in type " +
            "value list element.")));
      }

      if (!(
        !(
            that.getTypeValueListElement() == AasSubmodelElements.PROPERTY
            || that.getTypeValueListElement() == AasSubmodelElements.RANGE
        )
        || (
            (that.getValueTypeListElement().isPresent())
            && (
                (!that.getValue().isPresent())
                || propertiesOrRangesHaveValueType(
                    that.getValue().orElse(null),
                    that.getValueTypeListElement().orElse(null))
            )
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-109: If type value list element is equal to " +
            "Property or Range value type list element shall be set and " +
            "all first level child elements shall have the value type as " +
            "specified in value type list element.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || (
            that.getValue().get().stream().allMatch(
                element -> !element.getIdShort().isPresent())
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-120: ID-short of submodel elements being " +
            "a direct child of a  Submodel element list shall not be " +
            "specified.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getSemanticIdListElement().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticIdListElement().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticIdListElement"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getTypeValueListElement())
          .flatMap(Verification::verifyAasSubmodelElements)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("typeValueListElement"));
              return error;
            }));

      if (that.getValueTypeListElement().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValueTypeListElement().get())
            .flatMap(Verification::verifyDataTypeDefXsd)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("valueTypeListElement"));
                return error;
              }));
      }

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getValue().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("value"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformSubmodelElementCollection(
      ISubmodelElementCollection that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || (that.getValue().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Value must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || (
            that.getValue().get().stream().allMatch(
                item -> item.getIdShort().isPresent())
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "ID-shorts need to be defined for all the items of value " +
            "according to AASd-117 (ID-short of Referables not being " +
            "a direct child of a Submodel element list shall be " +
            "specified).")));
      }

      if (!(
        !(that.getValue().isPresent())
        || idShortsAreUnique(that.getValue().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "ID-shorts of the value must be unique.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getValue().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("value"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformProperty(
      IProperty that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getCategory().isPresent())
        || Constants.validCategoriesForDataElement.contains(that.getCategory().get()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-090: For data elements category shall be " +
            "one of the following values: CONSTANT, PARAMETER or " +
            "VARIABLE.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || valueConsistentWithXsdType(that.getValue().orElse(null), that.getValueType()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Value must be consistent with the value type.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getValueType())
          .flatMap(Verification::verifyDataTypeDefXsd)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("valueType"));
              return error;
            }));

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValue().get())
            .flatMap(Verification::verifyValueDataType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("value"));
                return error;
              }));
      }

      if (that.getValueId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValueId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("valueId"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformMultiLanguageProperty(
      IMultiLanguageProperty that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getCategory().isPresent())
        || Constants.validCategoriesForDataElement.contains(that.getCategory().get()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-090: For data elements category shall be " +
            "one of the following values: CONSTANT, PARAMETER or " +
            "VARIABLE.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || langStringsHaveUniqueLanguages(that.getValue().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Value must specify unique languages.")));
      }

      if (!(
        !(that.getValue().isPresent())
        || (that.getValue().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Value must be either not set or have at least one item.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getValue().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("value"));
              return error;
            }));
      }

      if (that.getValueId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValueId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("valueId"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformRange(
      IRange that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getCategory().isPresent())
        || Constants.validCategoriesForDataElement.contains(that.getCategory().get()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-090: For data elements category shall be " +
            "one of the following values: CONSTANT, PARAMETER or " +
            "VARIABLE.")));
      }

      if (!(
        !(that.getMax().isPresent())
        || valueConsistentWithXsdType(that.getMax().orElse(null), that.getValueType()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Max must be consistent with the value type.")));
      }

      if (!(
        !(that.getMin().isPresent())
        || valueConsistentWithXsdType(that.getMin().orElse(null), that.getValueType()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Min must be consistent with the value type.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getValueType())
          .flatMap(Verification::verifyDataTypeDefXsd)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("valueType"));
              return error;
            }));

      if (that.getMin().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getMin().get())
            .flatMap(Verification::verifyValueDataType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("min"));
                return error;
              }));
      }

      if (that.getMax().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getMax().get())
            .flatMap(Verification::verifyValueDataType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("max"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformReferenceElement(
      IReferenceElement that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getCategory().isPresent())
        || Constants.validCategoriesForDataElement.contains(that.getCategory().get()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-090: For data elements category shall be " +
            "one of the following values: CONSTANT, PARAMETER or " +
            "VARIABLE.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValue().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("value"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformBlob(
      IBlob that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getCategory().isPresent())
        || Constants.validCategoriesForDataElement.contains(that.getCategory().get()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-090: For data elements category shall be " +
            "one of the following values: CONSTANT, PARAMETER or " +
            "VARIABLE.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValue().get())
            .flatMap(Verification::verifyBlobType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("value"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getContentType())
          .flatMap(Verification::verifyContentType)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("contentType"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformFile(
      IFile that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getCategory().isPresent())
        || Constants.validCategoriesForDataElement.contains(that.getCategory().get()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-090: For data elements category shall be " +
            "one of the following values: CONSTANT, PARAMETER or " +
            "VARIABLE.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValue().get())
            .flatMap(Verification::verifyPathType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("value"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getContentType())
          .flatMap(Verification::verifyContentType)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("contentType"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformAnnotatedRelationshipElement(
      IAnnotatedRelationshipElement that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getAnnotations().isPresent())
        || (that.getAnnotations().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Annotations must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getAnnotations().isPresent())
        || (
            that.getAnnotations().get().stream().allMatch(
                item -> item.getIdShort().isPresent())
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "ID-shorts need to be defined for all the items of " +
            "annotations according to AASd-117 (ID-short of Referables " +
            "not being a direct child of a Submodel element list shall " +
            "be specified).")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getFirst())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("first"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getSecond())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("second"));
              return error;
            }));

      if (that.getAnnotations().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getAnnotations().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("annotations"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformEntity(
      IEntity that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getStatements().isPresent())
        || (that.getStatements().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Statements must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getStatements().isPresent())
        || (
            that.getStatements().get().stream().allMatch(
                item -> item.getIdShort().isPresent())
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "ID-shorts need to be defined for all the items of " +
            "statements according to AASd-117 (ID-short of Referables " +
            "not being a direct child of a Submodel element list shall " +
            "be specified).")));
      }

      if (!(
        (
            that.getEntityType() == EntityType.SELF_MANAGED_ENTITY
            && (
                (
                    (that.getGlobalAssetId().isPresent())
                    && (!that.getSpecificAssetIds().isPresent())
                )
                || (
                    (!that.getGlobalAssetId().isPresent())
                    && (that.getSpecificAssetIds().isPresent())
                    && that.getSpecificAssetIds().get().size() >= 1
                )
            )
        )
        || (
            that.getEntityType() != EntityType.SELF_MANAGED_ENTITY
            && (!that.getGlobalAssetId().isPresent())
            && (!that.getSpecificAssetIds().isPresent())
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-014: Either the attribute global asset ID " +
            "or specific asset ID must be set if entity type is set to " +
            "self-managed entity. They are not existing otherwise.")));
      }

      if (!(
        !(that.getSpecificAssetIds().isPresent())
        || (that.getSpecificAssetIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Specific asset IDs must be either not set or have at least " +
            "one item.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getStatements().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getStatements().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("statements"));
              return error;
            }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getEntityType())
          .flatMap(Verification::verifyEntityType)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("entityType"));
              return error;
            }));

      if (that.getGlobalAssetId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getGlobalAssetId().get())
            .flatMap(Verification::verifyIdentifier)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("globalAssetId"));
                return error;
              }));
      }

      if (that.getSpecificAssetIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSpecificAssetIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("specificAssetIds"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformEventPayload(
      IEventPayload that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        isModelReferenceTo(that.getSource(), KeyTypes.EVENT_ELEMENT)
        || isModelReferenceTo(that.getSource(), KeyTypes.BASIC_EVENT_ELEMENT))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Source must be a model reference to an Event element.")));
      }

      if (!(
        isModelReferenceToReferable(that.getObservableReference()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Observable reference must be a model reference to " +
            "a referable.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getSource())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("source"));
              return error;
            }));

      if (that.getSourceSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSourceSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("sourceSemanticId"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getObservableReference())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("observableReference"));
              return error;
            }));

      if (that.getObservableSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getObservableSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("observableSemanticId"));
                return error;
              }));
      }

      if (that.getTopic().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getTopic().get())
            .flatMap(Verification::verifyMessageTopicType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("topic"));
                return error;
              }));
      }

      if (that.getSubjectId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSubjectId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("subjectId"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getTimeStamp())
          .flatMap(Verification::verifyDateTimeUtc)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("timeStamp"));
              return error;
            }));

      if (that.getPayload().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getPayload().get())
            .flatMap(Verification::verifyBlobType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("payload"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformBasicEventElement(
      IBasicEventElement that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getDirection() == Direction.INPUT)
        || (!that.getMaxInterval().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Max. interval is not applicable for input direction.")));
      }

      if (!isModelReferenceToReferable(that.getObserved())) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Observed must be a model reference to a referable.")));
      }

      if (!(
        !(that.getMessageBroker().isPresent())
        || isModelReferenceToReferable(that.getMessageBroker().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Message broker must be a model reference to a referable.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getObserved())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("observed"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getDirection())
          .flatMap(Verification::verifyDirection)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("direction"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getState())
          .flatMap(Verification::verifyStateOfEvent)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("state"));
              return error;
            }));

      if (that.getMessageTopic().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getMessageTopic().get())
            .flatMap(Verification::verifyMessageTopicType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("messageTopic"));
                return error;
              }));
      }

      if (that.getMessageBroker().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getMessageBroker().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("messageBroker"));
                return error;
              }));
      }

      if (that.getLastUpdate().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getLastUpdate().get())
            .flatMap(Verification::verifyDateTimeUtc)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("lastUpdate"));
                return error;
              }));
      }

      if (that.getMinInterval().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getMinInterval().get())
            .flatMap(Verification::verifyDuration)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("minInterval"));
                return error;
              }));
      }

      if (that.getMaxInterval().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getMaxInterval().get())
            .flatMap(Verification::verifyDuration)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("maxInterval"));
                return error;
              }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformOperation(
      IOperation that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        idShortsOfVariablesAreUnique(
            that.getInputVariables().orElse(null),
            that.getOutputVariables().orElse(null),
            that.getInoutputVariables().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-134: For an Operation the ID-short of all " +
            "values of input, output and in/output variables.")));
      }

      if (!(
        !(that.getInputVariables().isPresent())
        || (that.getInputVariables().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Input variables must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getOutputVariables().isPresent())
        || (that.getOutputVariables().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Output variables must be either not set or have at least " +
            "one item.")));
      }

      if (!(
        !(that.getInoutputVariables().isPresent())
        || (that.getInoutputVariables().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Inoutput variables must be either not set or have at least " +
            "one item.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getInputVariables().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getInputVariables().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("inputVariables"));
              return error;
            }));
      }

      if (that.getOutputVariables().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getOutputVariables().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("outputVariables"));
              return error;
            }));
      }

      if (that.getInoutputVariables().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getInoutputVariables().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("inoutputVariables"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformOperationVariable(
      IOperationVariable that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(that.getValue().getIdShort().isPresent())) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Value must have the ID-short specified according to " +
            "Constraint AASd-117 (ID-short of Referables not being " +
            "a direct child of a Submodel element list shall be " +
            "specified).")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getValue())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("value"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformCapability(
      ICapability that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSupplementalSemanticIds().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Supplemental semantic IDs must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSupplementalSemanticIds().isPresent())
        || (that.getSemanticId().isPresent()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-118: If there are supplemental semantic IDs " +
            "defined then there shall be also a main semantic ID.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || (that.getQualifiers().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Qualifiers must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getQualifiers().isPresent())
        || qualifierTypesAreUnique(that.getQualifiers().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-021: Every qualifiable can only have one " +
            "qualifier with the same type.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("semanticId"));
                return error;
              }));
      }

      if (that.getSupplementalSemanticIds().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSupplementalSemanticIds().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("supplementalSemanticIds"));
              return error;
            }));
      }

      if (that.getQualifiers().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getQualifiers().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("qualifiers"));
              return error;
            }));
      }

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformConceptDescription(
      IConceptDescription that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getExtensions().isPresent())
        || (that.getExtensions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Extensions must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getExtensions().isPresent())
        || extensionNamesAreUnique(that.getExtensions().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-077: The name of an extension within " +
            "Has-Extensions needs to be unique.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || (that.getDescription().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDescription().isPresent())
        || langStringsHaveUniqueLanguages(that.getDescription().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Description must specify unique languages.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || (that.getDisplayName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must be either not set or have at least one " +
            "item.")));
      }

      if (!(
        !(that.getDisplayName().isPresent())
        || langStringsHaveUniqueLanguages(that.getDisplayName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Display name must specify unique languages.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (that.getEmbeddedDataSpecifications().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Embedded data specifications must be either not set or have " +
            "at least one item.")));
      }

      if (!(
        !(that.getIsCaseOf().isPresent())
        || (that.getIsCaseOf().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Is-case-of must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getEmbeddedDataSpecifications().isPresent())
        || (
            dataSpecificationIec61360sHaveDefinitionAtLeastInEnglish(that.getEmbeddedDataSpecifications().orElse(null))
            || dataSpecificationIec61360sHaveValue(that.getEmbeddedDataSpecifications().orElse(null))
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASc-3a-008: For a concept description using " +
            "data specification template IEC 61360, the definition is " +
            "mandatory and shall be defined at least in English. " +
            "Exception: The concept description describes a value.")));
      }

      if (!(
        !(
            (that.getCategory().isPresent())
            && that.getCategory().get() == "QUALIFIER_TYPE"
            && (that.getEmbeddedDataSpecifications().isPresent())
        )
        || dataSpecificationIec61360sHaveDataType(that.getEmbeddedDataSpecifications().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASc-3a-007: For a concept description with " +
            "category QUALIFIER_TYPE using data specification IEC 61360, " +
            "the data type of the data specification is mandatory and " +
            "shall be defined.")));
      }

      if (!(
        !(
            (that.getCategory().isPresent())
            && that.getCategory().get() == "DOCUMENT"
            && (that.getEmbeddedDataSpecifications().isPresent())
        )
        || dataSpecificationIec61360sForDocumentHaveAppropriateDataType(that.getEmbeddedDataSpecifications().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASc-3a-006: For a concept description with " +
            "category DOCUMENT using data specification IEC 61360, " +
            "the data type of the data specification shall be one of: " +
            "FILE, BLOB, HTML.")));
      }

      if (!(
        !(
            (that.getCategory().isPresent())
            && that.getCategory().get() == "REFERENCE"
            && (that.getEmbeddedDataSpecifications().isPresent())
        )
        || dataSpecificationIec61360sForReferenceHaveAppropriateDataType(that.getEmbeddedDataSpecifications().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASc-3a-005: For a concept description with " +
            "category REFERENCE using data specification IEC 61360, " +
            "the data type of the data specification shall be one of: " +
            "STRING, IRI, IRDI.")));
      }

      if (!(
        !(
            (that.getCategory().isPresent())
            && (
                that.getCategory().get() == "PROPERTY"
                || that.getCategory().get() == "VALUE"
            )
            && (that.getEmbeddedDataSpecifications().isPresent())
        )
        || dataSpecificationIec61360sForPropertyOrValueHaveAppropriateDataType(that.getEmbeddedDataSpecifications().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASc-3a-004: For a concept description with " +
            "category PROPERTY or VALUE using data specification IEC " +
            "61360, the data type of the data specification is mandatory " +
            "and shall be one of: DATE, STRING, STRING_TRANSLATABLE, " +
            "INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, " +
            "REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, " +
            "RATIONAL_MEASURE, TIME, TIMESTAMP.")));
      }

      if (that.getExtensions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getExtensions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("extensions"));
              return error;
            }));
      }

      if (that.getCategory().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getCategory().get())
            .flatMap(Verification::verifyNameType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("category"));
                return error;
              }));
      }

      if (that.getIdShort().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getIdShort().get())
            .flatMap(Verification::verifyIdShortType)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("idShort"));
                return error;
              }));
      }

      if (that.getDisplayName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDisplayName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("displayName"));
              return error;
            }));
      }

      if (that.getDescription().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDescription().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("description"));
              return error;
            }));
      }

      if (that.getAdministration().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getAdministration().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("administration"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getId())
          .flatMap(Verification::verifyIdentifier)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("id"));
              return error;
            }));

      if (that.getEmbeddedDataSpecifications().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getEmbeddedDataSpecifications().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("embeddedDataSpecifications"));
              return error;
            }));
      }

      if (that.getIsCaseOf().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getIsCaseOf().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("isCaseOf"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformReference(
      IReference that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(that.getKeys().size() >= 1)) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Keys must contain at least one item.")));
      }

      if (!(
        !(that.getKeys().size() >= 1)
        || Constants.globallyIdentifiables.contains(that.getKeys().get(0).getType()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-121: For References the value of type of " +
            "the first key of keys shall be one of Globally " +
            "Identifiables.")));
      }

      if (!(
        !(
            that.getType() == ReferenceTypes.EXTERNAL_REFERENCE
            && that.getKeys().size() >= 1
        )
        || Constants.genericGloballyIdentifiables.contains(that.getKeys().get(0).getType()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-122: For external references the value of " +
            "type of the first key of keys shall be one of Generic " +
            "Globally Identifiables.")));
      }

      if (!(
        !(
            that.getType() == ReferenceTypes.MODEL_REFERENCE
            && that.getKeys().size() >= 1
        )
        || Constants.aasIdentifiables.contains(that.getKeys().get(0).getType()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-123: For model references the value of type " +
            "of the first key of keys shall be one of AAS identifiables.")));
      }

      if (!(
        !(
            that.getType() == ReferenceTypes.EXTERNAL_REFERENCE
            && that.getKeys().size() >= 1
        )
        || (
            Constants.genericGloballyIdentifiables.contains(that.getKeys().get(that.getKeys().size() - 1).getType())
            || Constants.genericFragmentKeys.contains(that.getKeys().get(that.getKeys().size() - 1).getType())
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-124: For external references the last key " +
            "of keys shall be either one of Generic Globally " +
            "Identifiables or one of Generic Fragment Keys.")));
      }

      if (!(
        !(
            that.getType() == ReferenceTypes.MODEL_REFERENCE
            && that.getKeys().size() > 1
        )
        || (
            IntStream.range(
                1,
                that.getKeys().size()
            ).allMatch(
                i -> Constants.fragmentKeys.contains(that.getKeys().get(i).getType()))
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-125: For model references with more than " +
            "one key in keys the value of type of each of the keys " +
            "following the first key of keys shall be one of Fragment " +
            "Keys.")));
      }

      if (!(
        !(
            that.getType() == ReferenceTypes.MODEL_REFERENCE
            && that.getKeys().size() > 1
        )
        || (
            IntStream.range(
                0,
                that.getKeys().size() - 1
            ).allMatch(
                i -> !Constants.genericFragmentKeys.contains(that.getKeys().get(i).getType()))
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-126: For model references with more than " +
            "one key in keys the value of type of the last key in " +
            "the reference key chain may be one of Generic Fragment Keys " +
            "or no key at all shall have a value out of Generic Fragment " +
            "Keys.")));
      }

      if (!(
        !(
            that.getType() == ReferenceTypes.MODEL_REFERENCE
            && that.getKeys().size() > 1
            && that.getKeys().get(that.getKeys().size() - 1).getType() == KeyTypes.FRAGMENT_REFERENCE
        )
        || (
            that.getKeys().get(that.getKeys().size() - 2).getType() == KeyTypes.FILE
            || that.getKeys().get(that.getKeys().size() - 2).getType() == KeyTypes.BLOB
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-127: For model references, with more than " +
            "one key in keys a key with type Fragment Reference shall be " +
            "preceded by a key with type File or Blob.")));
      }

      if (!(
        !(
            that.getType() == ReferenceTypes.MODEL_REFERENCE
            && that.getKeys().size() > 2
        )
        || (
            IntStream.range(
                0,
                that.getKeys().size() - 1
            ).allMatch(
                i -> !(that.getKeys().get(i).getType() == KeyTypes.SUBMODEL_ELEMENT_LIST)
                    || matchesXsPositiveInteger(that.getKeys().get(i + 1).getValue()))
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASd-128: For model references, the value of " +
            "a key preceded by a key with type Submodel element list is " +
            "an integer number denoting the position in the array of " +
            "the submodel element list.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getType())
          .flatMap(Verification::verifyReferenceTypes)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("type"));
              return error;
            }));

      if (that.getReferredSemanticId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getReferredSemanticId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("referredSemanticId"));
                return error;
              }));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Verification.zip(
          IntStream.iterate(0, i -> i + 1).boxed(),
          that.getKeys().stream())
            .flatMap(elemTuple -> {
              final int index = elemTuple.getFirst();
              final IClass elem = elemTuple.getSecond();
              return Verification.verifyToErrorStream(elem)
                .map(error -> {
                  error.prependSegment(new Reporting.IndexSegment(index));
                  return error;
                });
            })
          .map(error -> {
            error.prependSegment(
              new Reporting.NameSegment("keys"));
            return error;
          }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformKey(
      IKey that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getType())
          .flatMap(Verification::verifyKeyTypes)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("type"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getValue())
          .flatMap(Verification::verifyIdentifier)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("value"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformLangStringNameType(
      ILangStringNameType that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(that.getText().length() <= 128)) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "String shall have a maximum length of 128 characters.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getLanguage())
          .flatMap(Verification::verifyBcp47LanguageTag)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("language"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getText())
          .flatMap(Verification::verifyNonEmptyXmlSerializableString)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("text"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformLangStringTextType(
      ILangStringTextType that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(that.getText().length() <= 1023)) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "String shall have a maximum length of 1023 characters.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getLanguage())
          .flatMap(Verification::verifyBcp47LanguageTag)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("language"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getText())
          .flatMap(Verification::verifyNonEmptyXmlSerializableString)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("text"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformEnvironment(
      IEnvironment that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !(that.getConceptDescriptions().isPresent())
        || (that.getConceptDescriptions().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Concept descriptions must be either not set or have at " +
            "least one item.")));
      }

      if (!(
        !(that.getSubmodels().isPresent())
        || (that.getSubmodels().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Submodels must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getAssetAdministrationShells().isPresent())
        || (that.getAssetAdministrationShells().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Asset administration shells must be either not set or have " +
            "at least one item.")));
      }

      if (that.getAssetAdministrationShells().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getAssetAdministrationShells().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("assetAdministrationShells"));
              return error;
            }));
      }

      if (that.getSubmodels().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getSubmodels().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("submodels"));
              return error;
            }));
      }

      if (that.getConceptDescriptions().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getConceptDescriptions().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("conceptDescriptions"));
              return error;
            }));
      }

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformEmbeddedDataSpecification(
      IEmbeddedDataSpecification that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getDataSpecification())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("dataSpecification"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getDataSpecificationContent())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("dataSpecificationContent"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformLevelType(
      ILevelType that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      // No verification has been defined for LevelType.

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformValueReferencePair(
      IValueReferencePair that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getValue())
          .flatMap(Verification::verifyValueTypeIec61360)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("value"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getValueId())
          .flatMap(Verification::verifyToErrorStream)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("valueId"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformValueList(
      IValueList that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(that.getValueReferencePairs().size() >= 1)) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Value reference pair types must contain at least one item.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Verification.zip(
          IntStream.iterate(0, i -> i + 1).boxed(),
          that.getValueReferencePairs().stream())
            .flatMap(elemTuple -> {
              final int index = elemTuple.getFirst();
              final IClass elem = elemTuple.getSecond();
              return Verification.verifyToErrorStream(elem)
                .map(error -> {
                  error.prependSegment(new Reporting.IndexSegment(index));
                  return error;
                });
            })
          .map(error -> {
            error.prependSegment(
              new Reporting.NameSegment("valueReferencePairs"));
            return error;
          }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformLangStringPreferredNameTypeIec61360(
      ILangStringPreferredNameTypeIec61360 that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(that.getText().length() <= 255)) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "String shall have a maximum length of 255 characters.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getLanguage())
          .flatMap(Verification::verifyBcp47LanguageTag)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("language"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getText())
          .flatMap(Verification::verifyNonEmptyXmlSerializableString)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("text"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformLangStringShortNameTypeIec61360(
      ILangStringShortNameTypeIec61360 that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(that.getText().length() <= 18)) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "String shall have a maximum length of 18 characters.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getLanguage())
          .flatMap(Verification::verifyBcp47LanguageTag)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("language"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getText())
          .flatMap(Verification::verifyNonEmptyXmlSerializableString)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("text"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformLangStringDefinitionTypeIec61360(
      ILangStringDefinitionTypeIec61360 that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(that.getText().length() <= 1023)) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "String shall have a maximum length of 1023 characters.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getLanguage())
          .flatMap(Verification::verifyBcp47LanguageTag)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("language"));
              return error;
            }));

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(that.getText())
          .flatMap(Verification::verifyNonEmptyXmlSerializableString)
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("text"));
              return error;
            }));

      return errorStream;
    }

    @Override
    public Stream<Reporting.Error> transformDataSpecificationIec61360(
      IDataSpecificationIec61360 that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      if (!(
        !((that.getValue().isPresent())
        && (that.getValueList().isPresent())))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASc-3a-010: If value is not empty then value " +
            "list shall be empty and vice versa.")));
      }

      if (!(
        !(
            (that.getDataType().isPresent())
            && Constants.iec61360DataTypesWithUnit.contains(that.getDataType().get())
        )
        || (
            (that.getUnit().isPresent())
            || (that.getUnitId().isPresent())
        ))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASc-3a-009: If data type is a an integer, real " +
            "or rational with a measure or currency, unit or unit ID " +
            "shall be defined.")));
      }

      if (!(
        !(that.getDefinition().isPresent())
        || (that.getDefinition().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Definition must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getDefinition().isPresent())
        || langStringsHaveUniqueLanguages(that.getDefinition().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Definition must specify unique languages.")));
      }

      if (!(
        !(that.getShortName().isPresent())
        || (that.getShortName().get().size() >= 1))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Short name must be either not set or have at least one item.")));
      }

      if (!(
        !(that.getShortName().isPresent())
        || langStringsHaveUniqueLanguages(that.getShortName().orElse(null)))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Short name must specify unique languages.")));
      }

      if (!(that.getPreferredName().size() >= 1)) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Preferred name must have at least one item.")));
      }

      if (!(
        langStringsHaveUniqueLanguages(that.getPreferredName()))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Preferred name must specify unique languages.")));
      }

      if (!(
        that.getPreferredName().stream().anyMatch(
            langString -> isBcp47ForEnglish(langString.getLanguage())))) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(new Reporting.Error(
            "Invariant violated:\n" +
            "Constraint AASc-3a-002: preferred name shall be provided at " +
            "least in English.")));
      }

      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Verification.zip(
          IntStream.iterate(0, i -> i + 1).boxed(),
          that.getPreferredName().stream())
            .flatMap(elemTuple -> {
              final int index = elemTuple.getFirst();
              final IClass elem = elemTuple.getSecond();
              return Verification.verifyToErrorStream(elem)
                .map(error -> {
                  error.prependSegment(new Reporting.IndexSegment(index));
                  return error;
                });
            })
          .map(error -> {
            error.prependSegment(
              new Reporting.NameSegment("preferredName"));
            return error;
          }));

      if (that.getShortName().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getShortName().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("shortName"));
              return error;
            }));
      }

      if (that.getUnit().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getUnit().get())
            .flatMap(Verification::verifyNonEmptyXmlSerializableString)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("unit"));
                return error;
              }));
      }

      if (that.getUnitId().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getUnitId().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("unitId"));
                return error;
              }));
      }

      if (that.getSourceOfDefinition().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSourceOfDefinition().get())
            .flatMap(Verification::verifyNonEmptyXmlSerializableString)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("sourceOfDefinition"));
                return error;
              }));
      }

      if (that.getSymbol().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getSymbol().get())
            .flatMap(Verification::verifyNonEmptyXmlSerializableString)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("symbol"));
                return error;
              }));
      }

      if (that.getDataType().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getDataType().get())
            .flatMap(Verification::verifyDataTypeIec61360)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("dataType"));
                return error;
              }));
      }

      if (that.getDefinition().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Verification.zip(
            IntStream.iterate(0, i -> i + 1).boxed(),
            that.getDefinition().get().stream())
              .flatMap(elemTuple -> {
                final int index = elemTuple.getFirst();
                final IClass elem = elemTuple.getSecond();
                return Verification.verifyToErrorStream(elem)
                  .map(error -> {
                    error.prependSegment(new Reporting.IndexSegment(index));
                    return error;
                  });
              })
            .map(error -> {
              error.prependSegment(
                new Reporting.NameSegment("definition"));
              return error;
            }));
      }

      if (that.getValueFormat().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValueFormat().get())
            .flatMap(Verification::verifyNonEmptyXmlSerializableString)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("valueFormat"));
                return error;
              }));
      }

      if (that.getValueList().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValueList().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("valueList"));
                return error;
              }));
      }

      if (that.getValue().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getValue().get())
            .flatMap(Verification::verifyValueTypeIec61360)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("value"));
                return error;
              }));
      }

      if (that.getLevelType().isPresent()) {
        errorStream = Stream.<Reporting.Error>concat(errorStream,
          Stream.of(that.getLevelType().get())
            .flatMap(Verification::verifyToErrorStream)
              .map(error -> {
                error.prependSegment(
                  new Reporting.NameSegment("levelType"));
                return error;
              }));
      }

      return errorStream;
    }
  }

  public static Stream<Reporting.Error> verifyToErrorStream(IClass that) {
    return transformer.transform(that);
  }

  private static class ValidationErrorIterable implements Iterable<Reporting.Error> {
    private final IClass element;

    public ValidationErrorIterable(IClass element) {
      this.element = element;
  }

    @Override
    public Iterator<Reporting.Error> iterator() {
      Stream<Reporting.Error> stream = stream();

      return stream.iterator();
    }

    @Override
    public void forEach(Consumer<? super Reporting.Error> action) {
      Stream<Reporting.Error> stream = stream();

      stream.forEach(action);
    }

    @Override
    public Spliterator<Reporting.Error> spliterator() {
      Stream<Reporting.Error> stream = stream();

      return stream.spliterator();
    }

    private Stream<Reporting.Error> stream() {
      return Verification.verifyToErrorStream(element);
    }
  }

  /**
   * Verify the constraints of {@code that} recursively.
   *
   * @param that The instance of the meta-model to be verified
   */
  public static Iterable<Reporting.Error> verify(IClass that) {
    return new ValidationErrorIterable(that);
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyXmlSerializableString (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyNonEmptyXmlSerializableString (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyDateTimeUtc (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXsDateTimeUtc(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must match the pattern of xs:dateTime with " +
          "the time zone fixed to UTC.")));
    }

    if (!isXsDateTimeUtc(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must represent a valid xs:dateTime with the time " +
          "zone fixed to UTC.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyDuration (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXsDuration(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must match the pattern of xs:duration.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyBlobType (
    byte[] that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    // There is no verification specified.

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyIdentifier (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 2000)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Identifier shall have a maximum length of 2000 characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyValueTypeIec61360 (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 2000)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Value type IEC 61360 shall have a maximum length of 2000 " +
          "characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyNameType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 128)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Name type shall have a maximum length of 128 characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyVersionType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!matchesVersionType(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Version type shall match the version pattern.")));
    }

    if (!(that.length() <= 4)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Version type shall have a maximum length of 4 characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyRevisionType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!matchesRevisionType(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Revision type shall match the revision pattern.")));
    }

    if (!(that.length() <= 4)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Revision type shall have a maximum length of 4 characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyLabelType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 64)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Label type shall have a maximum length of 64 characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyMessageTopicType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 255)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Message topic type shall have a maximum length of 255 " +
          "characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyBcp47LanguageTag (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesBcp47(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must represent a value language tag conformant to " +
          "BCP 47.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyContentType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 100)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Content type shall have a maximum length of 100 characters.")));
    }

    if (!matchesMimeType(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must represent a valid content MIME type " +
          "according to RFC 2046.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyPathType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 2000)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Identifier shall have a maximum length of 2000 characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyQualifierType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 128)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Name type shall have a maximum length of 128 characters.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyValueDataType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    return errorStream;
  }

  /**
   * Verify the constraints of {@code that}.
   */
  public static Stream<Reporting.Error> verifyIdShortType (
    String that) {
    Stream<Reporting.Error> errorStream = Stream.empty();

    if (!matchesXmlSerializableString(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Constraint AASd-130: An attribute with data type \'string\' " +
          "shall consist of these characters only: " +
          "^[\\x09\\x0A\\x0D\\x20-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$.")));
    }

    if (!(that.length() >= 1)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "The value must not be empty.")));
    }

    if (!(that.length() <= 128)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "Name type shall have a maximum length of 128 characters.")));
    }

    if (!matchesIdShort(that)) {
      errorStream = Stream.<Reporting.Error>concat(errorStream,
        Stream.of(new Reporting.Error(
          "Invariant violated:\n" +
          "ID-short of Referables shall only feature letters, digits, " +
          "underscore (``_``); starting mandatory with a letter. " +
          "*I.e.* ``[a-zA-Z][a-zA-Z0-9_]*``.")));
    }

    return errorStream;
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyModellingKind(
    ModellingKind that) {
    if (!EnumValueSet.forModellingKind.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid ModellingKind: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyQualifierKind(
    QualifierKind that) {
    if (!EnumValueSet.forQualifierKind.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid QualifierKind: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyAssetKind(
    AssetKind that) {
    if (!EnumValueSet.forAssetKind.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid AssetKind: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyAasSubmodelElements(
    AasSubmodelElements that) {
    if (!EnumValueSet.forAasSubmodelElements.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid AasSubmodelElements: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyEntityType(
    EntityType that) {
    if (!EnumValueSet.forEntityType.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid EntityType: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyDirection(
    Direction that) {
    if (!EnumValueSet.forDirection.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid Direction: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyStateOfEvent(
    StateOfEvent that) {
    if (!EnumValueSet.forStateOfEvent.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid StateOfEvent: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyReferenceTypes(
    ReferenceTypes that) {
    if (!EnumValueSet.forReferenceTypes.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid ReferenceTypes: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyKeyTypes(
    KeyTypes that) {
    if (!EnumValueSet.forKeyTypes.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid KeyTypes: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyDataTypeDefXsd(
    DataTypeDefXsd that) {
    if (!EnumValueSet.forDataTypeDefXsd.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid DataTypeDefXsd: " + that));
    } else {
      return Stream.empty();
    }
  }

  /**
   * Verify that {@code that} is a valid enumeration value.
   */
  public static Stream<Reporting.Error> verifyDataTypeIec61360(
    DataTypeIec61360 that) {
    if (!EnumValueSet.forDataTypeIec61360.contains(that)) {
      return Stream.of(new Reporting.Error(
        "Invalid DataTypeIec61360: " + that));
    } else {
      return Stream.empty();
    }
  }

  private static class Pair<A, B> {
    private final A first;
    private final B second;

    public Pair(A first, B second) {
      this.first = first;
      this.second = second;
    }

    public A getFirst() {
      return first;
    }

    public B getSecond() {
      return second;
    }
  }

  // Java 8 doesn't provide a split operation out of the box, so we have to ship our own.
  // Adapted from: https://stackoverflow.com/a/23529010
  private static <A, B> Stream<Pair<A, B>> zip(
    Stream<? extends A> a,
    Stream<? extends B> b) {
    Spliterator<? extends A> aSplit = Objects.requireNonNull(a).spliterator();
    Spliterator<? extends B> bSplit = Objects.requireNonNull(b).spliterator();

    int characteristics = aSplit.characteristics() & bSplit.characteristics() &
      ~(Spliterator.DISTINCT | Spliterator.SORTED);

    long zipSize = ((characteristics & Spliterator.SIZED) != 0)
      ? Math.min(aSplit.getExactSizeIfKnown(), bSplit.getExactSizeIfKnown())
      : -1;

    Iterator<A> aIter = Spliterators.iterator(aSplit);
    Iterator<B> bIter = Spliterators.iterator(bSplit);
    Iterator<Pair<A, B>> cIter = new Iterator<Pair<A, B>>() {
      @Override
      public boolean hasNext() {
        return aIter.hasNext() && bIter.hasNext();
      }

      @Override
      public Pair<A, B> next() {
        return new Pair<>(aIter.next(), bIter.next());
      }
    };

    Spliterator<Pair<A, B>> split = Spliterators.spliterator(cIter, zipSize, characteristics);
    return StreamSupport.stream(split, false);
  }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
