/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package test.jsonization;

import aas_core.aas3_0.reporting.Reporting;
import aas_core.aas3_0.types.enums.*;
import aas_core.aas3_0.types.impl.*;
import aas_core.aas3_0.types.model.*;
import aas_core.aas3_0.stringification.Stringification;
import aas_core.aas3_0.visitation.AbstractTransformer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeFactory;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.util.*;
import java.util.function.Function;

/**
 * Provide de/serialization of meta-model classes to/from JSON.
 *
 * <p>We can not use one-pass deserialization for JSON since the object
 * properties do not have fixed order, and hence we can not read
 * {@code modelType} property ahead of the remaining properties.
 */
public class Jsonization {
    /**
     * Implement the deserialization of meta-model classes from JSON nodes.
     *
     * <p>The implementation propagates an {@link Reporting.Error} instead
     * of relying on exceptions. Under the assumption that incorrect data is much
     * less frequent than correct data, this makes the deserialization more
     * efficient.
     *
     * However, we do not want to force the client to deal with
     * the {@link Reporting.Error} class as this is not intuitive. Therefore
     * we distinguish the implementation, realized in
     * {@link DeserializeImplementation}, and the facade given in
     * {@link Deserialize} class.
     */
    private static class DeserializeImplementation {
      /** Convert {@code value} to a string.
       * @param node JSON node to be parsed
       */
      private static Result<String> tryStringFrom(JsonNode value) {
        if (!value.isTextual()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected a JsonValue of String, but got " + value.getNodeType());
          return Result.failure(error);
        }
        return Result.success(value.asText());
      }

      /** Convert {@code value} to a boolean.
       * @param node JSON node to be parsed
       */
      private static Result<Boolean> tryBooleanFrom(JsonNode value) {
        if (!value.isBoolean()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected a JsonValue of Boolean, but got " + value.getNodeType());
          return Result.failure(error);
        }
        return Result.success(value.asBoolean());
      }

      /** Convert {@code value} to a long 64-bit integer.
       * @param node JSON node to be parsed
       */
      private static Result<Long> tryLongFrom(JsonNode value) {
        if (!value.isLong()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected a JsonValue of Long, but got " + value.getNodeType());
          return Result.failure(error);
        }
        return Result.success(value.asLong());
      }

      /** Convert {@code value} to a double-precision 64-bit float.
       * @param node JSON node to be parsed
       */
      private static Result<Double> tryDoubleFrom(JsonNode value) {
        if (!value.isDouble()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected a JsonValue of Double, but got " + value.getNodeType());
          return Result.failure(error);
        }
        return Result.success(value.asDouble());
      }

      private static Result<byte[]> tryBytesFrom(JsonNode value) {
        if (!value.isTextual()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected a JsonValue of String, but got " + value.getNodeType());
          return Result.failure(error);
        }
        final byte[] decodedData;
        Base64.Decoder decoder = Base64.getDecoder();

        try {
          decodedData = decoder.decode(value.textValue());
        } catch (Exception exception) {
          final Reporting.Error error = new Reporting.Error(
            "Expected Base-64 encoded bytes, but the conversion failed " +
              "because: " + exception.getMessage());
          return Result.failure(error);
        }

        return Result.success(decodedData);
      }

      /**
       * Deserialize an instance of ListOfPrimitives from {@param node}.
       *
       * @param node JSON node to be parsed
       * @param elem Error, if any, during the deserialization
       */
      private static Result<ListOfPrimitives> tryListOfPrimitivesFrom(JsonNode node) {
        if (node == null || !node.isObject()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected a JsonObject, but got " + (node == null ? "null" : node.getNodeType()));
          return Result.failure(error);
        }

        List<String> theStrings = null;
        List<Long> theIntegers = null;
        List<Boolean> theBooleans = null;

        for (Iterator<Map.Entry<String, JsonNode>> iterator = node.fields(); iterator.hasNext(); ) {
          Map.Entry<String, JsonNode> currentNode = iterator.next();

          switch (currentNode.getKey()) {
            case "strings": {
              if (currentNode.getValue() == null) {
                continue;
              }

              final JsonNode arrayStrings = currentNode.getValue();
              if (!arrayStrings.isArray()) {
                final Reporting.Error error = new Reporting.Error(
                  "Expected a JsonArray, but got " + arrayStrings.getNodeType());
                error.prependSegment(
                  new Reporting.NameSegment(
                    "strings"));
                return Result.failure(error);
              }
              theStrings = new ArrayList<>(
                arrayStrings.size());
              int indexStrings = 0;
              for (JsonNode item : arrayStrings) {
                if (item == null) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected a non-null item, but got a null");
                  error.prependSegment(
                    new Reporting.IndexSegment(
                      indexStrings));
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "strings"));
                  return Result.failure(error);
                }
                final Result<? extends String> parsedItemResult =
                  tryStringFrom(item);
                if (parsedItemResult.isError()) {
                  parsedItemResult
                    .getError()
                    .prependSegment(
                    new Reporting.IndexSegment(
                      indexStrings));
                  parsedItemResult
                    .getError()
                    .prependSegment(
                    new Reporting.NameSegment(
                      "strings"));
                  return parsedItemResult.castTo(ListOfPrimitives.class);
                }
                theStrings.add(
                  parsedItemResult.getResult());
                indexStrings++;
              }
              break;
            }
            case "integers": {
              if (currentNode.getValue() == null) {
                continue;
              }

              final JsonNode arrayIntegers = currentNode.getValue();
              if (!arrayIntegers.isArray()) {
                final Reporting.Error error = new Reporting.Error(
                  "Expected a JsonArray, but got " + arrayIntegers.getNodeType());
                error.prependSegment(
                  new Reporting.NameSegment(
                    "integers"));
                return Result.failure(error);
              }
              theIntegers = new ArrayList<>(
                arrayIntegers.size());
              int indexIntegers = 0;
              for (JsonNode item : arrayIntegers) {
                if (item == null) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected a non-null item, but got a null");
                  error.prependSegment(
                    new Reporting.IndexSegment(
                      indexIntegers));
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "integers"));
                  return Result.failure(error);
                }
                final Result<? extends Long> parsedItemResult =
                  tryLongFrom(item);
                if (parsedItemResult.isError()) {
                  parsedItemResult
                    .getError()
                    .prependSegment(
                    new Reporting.IndexSegment(
                      indexIntegers));
                  parsedItemResult
                    .getError()
                    .prependSegment(
                    new Reporting.NameSegment(
                      "integers"));
                  return parsedItemResult.castTo(ListOfPrimitives.class);
                }
                theIntegers.add(
                  parsedItemResult.getResult());
                indexIntegers++;
              }
              break;
            }
            case "booleans": {
              if (currentNode.getValue() == null) {
                continue;
              }

              final JsonNode arrayBooleans = currentNode.getValue();
              if (!arrayBooleans.isArray()) {
                final Reporting.Error error = new Reporting.Error(
                  "Expected a JsonArray, but got " + arrayBooleans.getNodeType());
                error.prependSegment(
                  new Reporting.NameSegment(
                    "booleans"));
                return Result.failure(error);
              }
              theBooleans = new ArrayList<>(
                arrayBooleans.size());
              int indexBooleans = 0;
              for (JsonNode item : arrayBooleans) {
                if (item == null) {
                  final Reporting.Error error = new Reporting.Error(
                    "Expected a non-null item, but got a null");
                  error.prependSegment(
                    new Reporting.IndexSegment(
                      indexBooleans));
                  error.prependSegment(
                    new Reporting.NameSegment(
                      "booleans"));
                  return Result.failure(error);
                }
                final Result<? extends Boolean> parsedItemResult =
                  tryBooleanFrom(item);
                if (parsedItemResult.isError()) {
                  parsedItemResult
                    .getError()
                    .prependSegment(
                    new Reporting.IndexSegment(
                      indexBooleans));
                  parsedItemResult
                    .getError()
                    .prependSegment(
                    new Reporting.NameSegment(
                      "booleans"));
                  return parsedItemResult.castTo(ListOfPrimitives.class);
                }
                theBooleans.add(
                  parsedItemResult.getResult());
                indexBooleans++;
              }
              break;
            }
            default: {
              final Reporting.Error error = new Reporting.Error(
                "Unexpected property: " + currentNode.getKey());
              return Result.failure(error);
            }
          }
        }

        if (theStrings == null) {
          final Reporting.Error error = new Reporting.Error(
            "Required property \"strings\" is missing");
          return Result.failure(error);
        }

        if (theIntegers == null) {
          final Reporting.Error error = new Reporting.Error(
            "Required property \"integers\" is missing");
          return Result.failure(error);
        }

        if (theBooleans == null) {
          final Reporting.Error error = new Reporting.Error(
            "Required property \"booleans\" is missing");
          return Result.failure(error);
        }

        return Result.success(new ListOfPrimitives(
          theStrings,
          theIntegers,
          theBooleans));
      }
    }

    /**
    * Represent a critical error during the deserialization.
    */
    @SuppressWarnings("serial")
      public static class DeserializeException extends RuntimeException {
        private final String path;
        private final String reason;

        public DeserializeException(String path, String reason) {
          super(reason + " at: " + ("".equals(path) ? "the beginning" : path));
          this.path = path;
          this.reason = reason;
        }

        public Optional<String> getPath() {
          return Optional.ofNullable(path);
        }

        public Optional<String> getReason() {
          return Optional.ofNullable(reason);
        }
      }

    private static class Result<T> {
      private final T result;
      private final Reporting.Error error;
      private final boolean success;

      private Result(T result, Reporting.Error error, boolean success) {
        this.result = result;
        this.error = error;
        this.success = success;
      }

      public static <T> Result<T> success(T result) {
        if (result == null) throw new IllegalArgumentException("Result must not be null.");
        return new Result<>(result, null, true);
      }

      public static <T> Result<T> failure(Reporting.Error error) {
        if (error == null) throw new IllegalArgumentException("Error must not be null.");
        return new Result<>(null, error, false);
      }

      @SuppressWarnings("unchecked")
      public <I> Result<I> castTo(Class<I> type) {
        if (isError() || type.isInstance(result)) return (Result<I>) this;
        throw new IllegalStateException("Result of type "
          + result.getClass().getName()
          + " is not an instance of "
          + type.getName());
      }

      public T getResult() {
        if (!isSuccess()) throw new IllegalStateException("Result is not present.");
        return result;
      }

      public boolean isSuccess() {
        return success;
      }

      public boolean isError() {
        return !success;
      }

      public Reporting.Error getError() {
        if (isSuccess()) throw new IllegalStateException("Result is present.");
        return error;
      }

      public <R> R map(Function<T, R> successFunction, Function<Reporting.Error, R> errorFunction) {
        return isSuccess() ? successFunction.apply(result) : errorFunction.apply(error);
      }

      public T onError(Function<Reporting.Error, T> errorFunction) {
        return map(Function.identity(), errorFunction);
      }
    }

    /**
     * Deserialize instances of meta-model classes from JSON nodes.
     *
     * Here is an example how to parse an instance of ListOfPrimitives:
     * <pre>{@code
     * String someString = "... some JSON ...";
     * ObjectMapper objectMapper = new ObjectMapper();
     * JsonNode node = objectMapper.readTree(someString);
     * ListOfPrimitives anInstance = Deserialize.deserializeListOfPrimitives(
     *   node);
     * }</pre>
     */
    public static class Deserialize
    {
      /**
       * Deserialize an instance of ListOfPrimitives from {@code node}.
       *
       * @param node JSON node to be parsed
       */
      public static ListOfPrimitives deserializeListOfPrimitives(JsonNode node) {
        final Result<? extends ListOfPrimitives> result =
          DeserializeImplementation.tryListOfPrimitivesFrom(
            node);

        return result.onError(error -> {
          throw new DeserializeException(
            Reporting.generateJsonPath(error.getPathSegments()),
            error.getCause());
        });
      }
    }

    private static class Transformer extends AbstractTransformer<JsonNode> {
      /**
       * Convert {@code that} 64-bit long integer to a JSON value.
       *
       * @param that value to be converted
       */
      private static JsonNode toJsonNode(Long that) {
        // We need to check that we can perform a lossless conversion.
        long primitiveThat = that.longValue();
        if ((long)((double)primitiveThat) != primitiveThat) {
          throw new IllegalArgumentException(
            "The number can not be losslessly represented in JSON: " + that);
        }
        return JsonNodeFactory.instance.numberNode(that);
      }

      @Override
      public JsonNode transformListOfPrimitives(
        IListOfPrimitives that
      ) {
        final ObjectNode result = JsonNodeFactory.instance.objectNode();

        final ArrayNode arrayStrings = JsonNodeFactory.instance.arrayNode();
        for (String item : that.getStrings()) {
          arrayStrings.add(
            JsonNodeFactory.instance.textNode(
              item));
        }
        result.set("strings", arrayStrings);

        final ArrayNode arrayIntegers = JsonNodeFactory.instance.arrayNode();
        for (Long item : that.getIntegers()) {
          arrayIntegers.add(
            Transformer.toJsonValue(
              item));
        }
        result.set("integers", arrayIntegers);

        final ArrayNode arrayBooleans = JsonNodeFactory.instance.arrayNode();
        for (Boolean item : that.getBooleans()) {
          arrayBooleans.add(
            JsonNodeFactory.instance.booleanNode(
              item));
        }
        result.set("booleans", arrayBooleans);

        return result;
      }
    }

    /**
     * Serialize instances of meta-model classes to JSON elements.
     *
     * Here is an example how to serialize an instance of ListOfPrimitives:
     * <pre>{@code
     * ListOfPrimitives anInstance = new ListOfPrimitives(
     *     // ... some constructor arguments ...
     * );
     * JsonNode element = Jsonization.Serialize.toJsonObject(
     *     anInstance));
     * }</pre>
     */
    public static class Serialize
    {
      private static final Transformer transformer = new Transformer();

      /**
       * Serialize an instance of the meta-model into a JSON object.
       */
      public static JsonNode toJsonObject(IClass that) {
        return transformer.transform(that);
      }
    }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
