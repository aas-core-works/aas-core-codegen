/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package test.xmlization;

import javax.xml.stream.events.XMLEvent;
import javax.xml.stream.XMLEventReader;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamWriter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.function.Function;
import java.util.List;
import java.util.Optional;
import test.reporting.Reporting;
import test.stringification.Stringification;
import test.types.enums.*;
import test.types.impl.*;
import test.types.model.*;
import test.visitation.*;

/**
 * Provide de/serialization of meta-model classes to/from XML.
 */
public class Xmlization {
  /**
   * Represent a critical error during the deserialization.
   */
  @SuppressWarnings("serial")
  public static class DeserializeException extends RuntimeException {
    private final String path;
    private final String reason;

    public DeserializeException(String path, String reason) {
      super(reason + " at: " + ("".equals(path) ? "the beginning" : path));
      this.path = path;
      this.reason = reason;
    }

    public Optional<String> getPath() {
      return Optional.ofNullable(path);
    }

    public Optional<String> getReason() {
      return Optional.ofNullable(reason);
    }
  }

  /**
   * Represent a critical error during the serialization.
   */
  @SuppressWarnings("serial")
  public static class SerializeException extends RuntimeException {
    private final String path;
    private final String reason;

    public SerializeException(String path, String reason) {
      super(reason + " at: " + ("".equals(path) ? "the beginning" : path));
      this.path = path;
      this.reason = reason;
    }

    public Optional<String> getPath() {
      return Optional.ofNullable(path);
    }

    public Optional<String> getReason() {
      return Optional.ofNullable(reason);
    }
  }

  /**
   * The XML namespace of the meta-model
   */
  public static final String AAS_NAME_SPACE =
    "https://dummy.com";

  private static class Result<T> {
    private final T result;
    private final Reporting.Error error;
    private final boolean success;

    private Result(T result, Reporting.Error error, boolean success) {
      this.result = result;
      this.error = error;
      this.success = success;
    }

    public static <T> Result<T> success(T result) {
      if(result == null) throw new IllegalArgumentException("Result must not be null.");
      return new Result<>(result, null, true);
    }

    public static <T> Result<T> failure(Reporting.Error error) {
      if(error == null) throw new IllegalArgumentException("Error must not be null.");
      return new Result<>(null, error, false);
    }

    @SuppressWarnings("unchecked")
    public <I> Result<I> castTo(Class<I> type){
      if(isError() || type.isInstance(result)) return (Result<I>) this;
      throw new IllegalStateException("Result of type "
        + result.getClass().getName()
        + " is not an instance of "
        + type.getName());
    }

    public T getResult() {
      if (!isSuccess()) throw new IllegalStateException("Result is not present.");
      return result;
    }

    public boolean isSuccess() {
      return success;
    }

    public boolean isError(){return !success;}

    public Reporting.Error getError() {
      if (isSuccess()) throw new IllegalStateException("Result is present.");
      return error;
    }

    public <R> R map(Function<T, R> successFunction, Function<Reporting.Error, R> errorFunction) {
      return isSuccess() ? successFunction.apply(result) : errorFunction.apply(error);
    }

    public T onError(Function<Reporting.Error, T>  errorFunction){
      return map(Function.identity(), errorFunction);
    }
  }

  /**
   * Implement the deserialization of meta-model classes from XML.
   *
   * <p>The implementation propagates an {@link Reporting.Error} instead of
   * relying on exceptions. Under the assumption that incorrect data is much less
   * frequent than correct data, this makes the deserialization more
   * efficient.
   *
   * <p>However, we do not want to force the client to deal with
   * the {@link Reporting.Error} class as this is not intuitive.
   * Therefore we distinguish the implementation, realized in
   * {@link DeserializeImplementation}, and the facade given in
   * {@link Deserialize} class.
   */
  private static class DeserializeImplementation
  {
    private static XMLEvent currentEvent(XMLEventReader reader) {
      try {
        return reader.peek();
      } catch (XMLStreamException xmlStreamException) {
        throw new Xmlization.DeserializeException("",
          "Failed in method peek because of: " +
          xmlStreamException.getMessage());
      }
    }

    private static String getEventTypeAsString(XMLEvent event) {
      switch (event.getEventType()) {
        case XMLStreamConstants.START_ELEMENT:
          return "Start-Element";
        case XMLStreamConstants.END_ELEMENT:
          return "End-Element";
        case XMLStreamConstants.PROCESSING_INSTRUCTION:
          return "Processing-Instruction";
        case XMLStreamConstants.CHARACTERS:
          return "Characters";
        case XMLStreamConstants.COMMENT:
          return "Comment";
        case XMLStreamConstants.SPACE:
          return "Space";
        case XMLStreamConstants.START_DOCUMENT:
          return "Start-Document";
        case XMLStreamConstants.END_DOCUMENT:
          return "End-Document";
        case XMLStreamConstants.ENTITY_REFERENCE:
          return "Entity-Reference";
        case XMLStreamConstants.ATTRIBUTE:
          return "Attribute";
        case XMLStreamConstants.NOTATION_DECLARATION:
          return "Notation-Declaration";
        default:
          return "Unknown-Type";
      }
    }

    private static boolean isEmptyElement(XMLEventReader reader) {
      // Skip the element node and go to the content
      try {
        reader.nextEvent();
      } catch (XMLStreamException xmlStreamException) {
        throw new Xmlization.DeserializeException("",
          "Failed in method isEmptyElement because of: " +
          xmlStreamException.getMessage());
      }
      return currentEvent(reader).isEndElement();
    }

    private static boolean isWrongClosingTag(
      Result<String> tryElementName,
      Result<String> tryEndElementName) {
      return !tryElementName.getResult().equals(tryEndElementName.getResult());
    }

    private static Result<XMLEvent> verifyClosingTagForClass(
      String className,
      XMLEventReader reader,
      Result<String> tryElementName) {
      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.isEndDocument()) {
        final Reporting.Error error = new Reporting.Error(
            "Expected an XML end element to conclude a property of class " + className
                + " with the element name " + tryElementName.getResult() + ", "
                + "but got the end-of-file.");
        return Result.failure(error);
      }

      if (!currentEvent.isEndElement()) {
        final Reporting.Error error = new Reporting.Error(
            "Expected an XML end element to conclude a property of class " + className
                + " with the element name " + tryElementName.getResult() + ", "
                + "but got the node of type " + getEventTypeAsString(currentEvent)
                + " with the value " + currentEvent);
        return Result.failure(error);
      }
      final Result<String> tryEndElementName = tryElementName(reader);
      if (tryEndElementName.isError()) {
        return tryEndElementName.castTo(XMLEvent.class);
      }
      if (isWrongClosingTag(tryElementName, tryEndElementName)) {
        final Reporting.Error error = new Reporting.Error(
            "Expected an XML end element to conclude a property of class " + className
                + " with the element name " + tryElementName.getResult() + ", "
                + "but got the end element with the name " + tryEndElementName.getResult());
        return Result.failure(error);
      }
      try {
        return Result.success(reader.nextEvent());
      } catch (XMLStreamException xmlStreamException) {
        throw new Xmlization.DeserializeException("",
          "Failed in method verifyClosingTagForClass because of: " +
          xmlStreamException.getMessage());
      }
    }

    private static void skipWhitespaceAndComments(XMLEventReader reader) {
      while (whiteSpaceOrComment(reader)) {
        reader.next();
      }
    }

    private static boolean whiteSpaceOrComment(XMLEventReader reader) {
      final XMLEvent currentEvent = currentEvent(reader);
      final boolean isComment = (currentEvent != null &&
        currentEvent.getEventType() == XMLStreamConstants.COMMENT);
      final boolean isWhiteSpace = (currentEvent != null &&
        currentEvent.getEventType() == XMLStreamConstants.CHARACTERS &&
        currentEvent.asCharacters().isWhiteSpace());
      return isComment || isWhiteSpace;
    }

    private static void skipStartDocument(XMLEventReader reader){
      if (currentEvent(reader).isStartDocument()){
        reader.next();
      }
    }

    private static boolean invalidNameSpace(XMLEvent event) {
      if (event.isStartElement()) {
        return !AAS_NAME_SPACE.equals(event.asStartElement().getName().getNamespaceURI());
      } else {
        return !AAS_NAME_SPACE.equals(event.asEndElement().getName().getNamespaceURI());
      }
    }

    /**
     * Check the namespace and extract the element's name.
     */
    private static Result<String> tryElementName(XMLEventReader reader) {
      final XMLEvent currentEvent = currentEvent(reader);
      final boolean precondition = currentEvent.isStartElement() || currentEvent.isEndElement();
      if (!precondition) {
        throw new IllegalStateException("Expected to be at a start or an end element "
            + "but got: " + getEventTypeAsString(currentEvent));
      }

      if (invalidNameSpace(currentEvent)) {
        String namespace = currentEvent.isStartElement()
            ? currentEvent.asStartElement().getName().getNamespaceURI()
            : currentEvent.asEndElement().getName().getNamespaceURI();
        final Reporting.Error error = new Reporting.Error(
            "Expected an element within a namespace " +
            AAS_NAME_SPACE + ", " + "but got: " + namespace);
        return Result.failure(error);
      }
      return Result.success(currentEvent.isStartElement()
          ? currentEvent.asStartElement().getName().getLocalPart()
          : currentEvent.asEndElement().getName().getLocalPart());
    }

    private static String readContentAsString(XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();

      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }

      return content.toString();
    }

    private static Boolean readContentAsBool(XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();

      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }
      if(!("true".equals(content.toString()) || "false".equals(content.toString()))){
        throw new IllegalStateException("Content cannot be converted to the type Boolean.");
      }
      return Boolean.valueOf(content.toString());
    }

    private static Long readContentAsLong(XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();

      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }

      return Long.valueOf(content.toString());
    }

    private static Double readContentAsDouble(XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();

      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }

      return Double.valueOf(content.toString());
    }

    /**
     * Read the whole content of an element into memory.
     */
    private static byte[] readContentAsBase64(
      XMLEventReader reader) throws XMLStreamException {
      final StringBuilder content = new StringBuilder();
      while (reader.peek().isCharacters() || reader.peek().getEventType() == XMLStreamConstants.COMMENT) {
        if (reader.peek().isCharacters()) {
          content.append(reader.peek().asCharacters().getData());
        }
        reader.nextEvent();
      }

      String encodedData = content.toString();
      final byte[] decodedData;
      Base64.Decoder decoder = Base64.getDecoder();

      try {
        decodedData = decoder.decode(encodedData);
      } catch (IllegalArgumentException exception) {
        throw new XMLStreamException(
          "Failed to read base64 encoded data: " +
          exception.getMessage());
      }

      return decodedData;
    }

    /**
     * Deserialize an instance of class ListOfPrimitives from a sequence of XML elements.
     *
     * <p>If {@code isEmptySequence} is set, we should try to deserialize
     * the instance from an empty sequence. That is, the parent element
     * was a self-closing element.
     */
    private static Result<ListOfPrimitives> tryListOfPrimitivesFromSequence(
      XMLEventReader reader,
      boolean isEmptySequence) {
      List<String> theStrings = null;
      List<Long> theIntegers = null;
      List<Boolean> theBooleans = null;

      if (!isEmptySequence) {
        skipWhitespaceAndComments(reader);
        if (currentEvent(reader).isEndDocument()) {
          final Reporting.Error error = new Reporting.Error(
            "Expected an XML element representing " +
            "a property of an instance of class ListOfPrimitives, " +
            "but reached the end-of-file");
          return Result.failure(error);
        }
        while (true) {
          skipWhitespaceAndComments(reader);

          if (currentEvent(reader).isEndElement() || currentEvent(reader).isEndDocument()) {
            break;
          }

          if (!currentEvent(reader).isStartElement()) {
            final Reporting.Error error = new Reporting.Error(
              "Expected an XML start element representing " +
              "a property of an instance of class ListOfPrimitives, " +
              "but got the node of type " + getEventTypeAsString(currentEvent(reader)) +
              " with the value " + currentEvent(reader));
            return Result.failure(error);
          }

          final Result<String> tryElementName = tryElementName(reader);
          if (tryElementName.isError()) {
            return tryElementName.castTo(ListOfPrimitives.class);
          }

          final boolean isEmptyProperty = isEmptyElement(reader);
          final String elementName = tryElementName.getResult();

          switch (tryElementName.getResult()) {
            case "strings":
            {
              theStrings = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of BAR, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment(BAR));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends BAR> itemResult = tryFOO(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment(BAR));
                    return itemResult.castTo(BAR.class);
                  }

                  theStrings.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "integers":
            {
              theIntegers = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of BAR, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment(BAR));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends BAR> itemResult = tryFOO(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment(BAR));
                    return itemResult.castTo(BAR.class);
                  }

                  theIntegers.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            case "booleans":
            {
              theBooleans = new ArrayList<>();
              if (!isEmptyProperty) {
                skipWhitespaceAndComments(reader);
                int index = 0;
                if(!currentEvent(reader).isStartElement()){
                  final Reporting.Error error = new Reporting.Error(
                  "Expected a start element opening an instance of BAR, but got an XML "
                    + getEventTypeAsString(currentEvent(reader)));
                  error.prependSegment(new Reporting.IndexSegment(index));
                  error.prependSegment(new Reporting.NameSegment(BAR));
                  return Result.failure(error);
                }
                while (currentEvent(reader).isStartElement()) {

                  Result<? extends BAR> itemResult = tryFOO(reader);

                  if (itemResult.isError()) {
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.IndexSegment(index));
                    itemResult.getError()
                      .prependSegment(
                        new Reporting.NameSegment(BAR));
                    return itemResult.castTo(BAR.class);
                  }

                  theBooleans.add(itemResult.getResult());
                  index++;
                  skipWhitespaceAndComments(reader);
                }
              }
              break;
            }
            default:
              final Reporting.Error error = new Reporting.Error(
                "We expected properties of the class ListOfPrimitives, " +
                "but got an unexpected element " +
                "with the name " + elementName);
              return Result.failure(error);
          }

          skipWhitespaceAndComments(reader);


          final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
            "ListOfPrimitives",
            reader,
            tryElementName);
          if (checkEndElement.isError()) return checkEndElement.castTo(ListOfPrimitives.class);

        }
      }

      if (theStrings == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property strings has not been given " +
          "in the XML representation of an instance of class ListOfPrimitives");
        return Result.failure(error);
      }

      if (theIntegers == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property integers has not been given " +
          "in the XML representation of an instance of class ListOfPrimitives");
        return Result.failure(error);
      }

      if (theBooleans == null) {
        final Reporting.Error error = new Reporting.Error(
          "The required property booleans has not been given " +
          "in the XML representation of an instance of class ListOfPrimitives");
        return Result.failure(error);
      }

      return Result.success(new ListOfPrimitives(
        theStrings,
        theIntegers,
        theBooleans));
    }

    /**
     * Deserialize an instance of class ListOfPrimitives from an XML element.
     */
    private static Result<ListOfPrimitives> tryListOfPrimitivesFromElement(
      XMLEventReader reader) {
      skipWhitespaceAndComments(reader);

      final XMLEvent currentEvent = currentEvent(reader);
      if (currentEvent.getEventType() == XMLStreamConstants.END_DOCUMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ListOfPrimitives, " +
          "but reached the end-of-file");
        return Result.failure(error);
      }

      if (currentEvent.getEventType() != XMLStreamConstants.START_ELEMENT) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an XML element representing an instance of class ListOfPrimitives, " +
          "but got a node of type " + getEventTypeAsString(currentEvent) +
          " with value " + currentEvent);
        return Result.failure(error);
      }

      final Result<String> tryElementName = tryElementName(reader);
      if (tryElementName.isError()) {
        return tryElementName.castTo(ListOfPrimitives.class);
      }

      final String elementName = tryElementName.getResult();
      if (!"listOfPrimitives".equals(tryElementName.getResult())) {
        final Reporting.Error error = new Reporting.Error(
          "Expected an element representing an instance of class ListOfPrimitives " +
          "with element name listOfPrimitives, but got: " + elementName);
        return Result.failure(error);
      }

      final boolean isEmptyElement = isEmptyElement(reader);

      Result<ListOfPrimitives> result = tryListOfPrimitivesFromSequence(
        reader,
        isEmptyElement);
      if (result.isError()) return result.castTo(ListOfPrimitives.class);


      final Result<XMLEvent> checkEndElement = verifyClosingTagForClass(
        "ListOfPrimitives",
        reader,
        tryElementName);
      if (checkEndElement.isError()) return checkEndElement.castTo(ListOfPrimitives.class);


      return result;
    }
  }

  /**
   * Deserialize instances of meta-model classes from XML.
   */
  /** <pre>
   * Here is an example how to parse an instance of class ListOfPrimitives:
   * {@code
   * XMLEventReader reader = xmlFactory.createXMLEventReader(...some arguments...);
   * ListOfPrimitives anInstance = Deserialize.deserializeListOfPrimitives(
   *   reader);
   * }
   * </pre>
   *
   * <pre>
   * If the elements live in a namespace, you have to supply it. For example:
   * {@code
   * XMLEventReader reader = xmlFactory.createXMLEventReader(...some arguments...);
   * ListOfPrimitives anInstance = Deserialize.deserializeListOfPrimitives(
   *   reader,
   *   "http://www.example.com/5/12");
   * }
   * </pre>
   */
  public static class Deserialize
  {
    /**
     * Deserialize an instance of ListOfPrimitives from {@code reader}.
     *
     * @param reader Initialized XML reader with reader.peek() set to the element
     */
    public static ListOfPrimitives deserializeListOfPrimitives(
      XMLEventReader reader) {

      DeserializeImplementation.skipStartDocument(reader);
      DeserializeImplementation.skipWhitespaceAndComments(reader);

      Result<? extends ListOfPrimitives> result =
        DeserializeImplementation.tryListOfPrimitivesFromElement(
          reader);

      return result.onError(error -> {
        error.prependSegment(new Reporting.NameSegment("listofprimitives"));
        throw new DeserializeException(
          Reporting.generateRelativeXPath(error.getPathSegments()),
          error.getCause());
      });
    }
  }

  /**
   * Serialize recursively the instances as XML elements.
   */
  static class VisitorWithWriter
    extends AbstractVisitorWithContext<XMLStreamWriter> {

    private boolean topLevel = true;

    private void listOfPrimitivesToSequence(
      IListOfPrimitives that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "strings");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        for (IClass item : that.getStrings()) {
          this.visit(
            item,
            writer);
        }

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "integers");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        for (IClass item : that.getIntegers()) {
          this.visit(
            item,
            writer);
        }

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }

      try {
        writer.writeStartElement(
          "booleans");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }

        for (IClass item : that.getBooleans()) {
          this.visit(
            item,
            writer);
        }

        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("",exception.getMessage());
      }
    }

    @Override
    public void visitListOfPrimitives(
      IListOfPrimitives that,
      XMLStreamWriter writer) {
      try {
        writer.writeStartElement(
          "listOfPrimitives");
        if (topLevel) {
          writer.writeNamespace("xmlns", AAS_NAME_SPACE);
          topLevel = false;
        }
        this.listOfPrimitivesToSequence(
          that,
          writer);
        writer.writeEndElement();
      } catch (XMLStreamException exception) {
        throw new SerializeException("", exception.getMessage());
      }
    }
  }

  /**
   * Serialize instances of meta-model classes to XML.
   */
  /**
   * <pre>
   * Here is an example how to serialize an instance of ListOfPrimitives:
   * {@code
   * IClass anInstance = new ListOfPrimitives(
   *     ... some constructor arguments ...
   * );
   * XMLStreamWriter writer = xmlWriterFactory.createXMLStreamWriter(...some arguments...);
   * Serialize.to(
   *   anInstance,
   *   writer);
   * }
   * </pre>
   */
  public static class Serialize
  {
    /**
     * Serialize an instance of the meta-model to XML.
     */
    public static void to(
      IClass that,
      XMLStreamWriter writer) throws SerializeException {
      VisitorWithWriter visitor = new VisitorWithWriter();
      visitor.visit(
        that, writer);
    }
  }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
