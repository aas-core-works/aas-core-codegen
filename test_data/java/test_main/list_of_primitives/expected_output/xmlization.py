"""
Read and write AAS models as XML.

For reading, we provide different reading functions, each handling a different kind
of input. All the reading functions operate in one pass, *i.e.*, the source is read
incrementally and the complete XML is not held in memory.

We provide the following four reading functions (where ``X`` represents the name of
the class):

1) ``X_from_iterparse`` reads from a stream of ``(event, element)`` tuples coming from
   :py:func:`xml.etree.ElementTree.iterparse` with the argument
   ``events=["start", "end"]``. If you do not trust the source, please consider
   using `defusedxml.ElementTree`_.
2) ``X_from_stream`` reads from the given text stream.
3) ``X_from_file`` reads from a file on disk.
4) ``X_from_str`` reads from the given string.

The functions ``X_from_stream``, ``X_from_file`` and ``X_from_str`` provide
an extra parameter, ``has_iterparse``, which allows you to use a parsing library
different from :py:mod:`xml.etree.ElementTree`. For example, you can pass in
`defusedxml.ElementTree`_.

.. _defusedxml.ElementTree: https://pypi.org/project/defusedxml/#defusedxml-elementtree

All XML elements are expected to live in the :py:attr:`~NAMESPACE`.

For writing, use the function :py:func:`test.xmlization.write` which
translates the instance of the model into an XML document and writes it in one pass
to the stream.

Here is an example usage how to de-serialize from a file:

.. code-block::

    import pathlib
    import xml.etree.ElementTree as ET

    import test.xmlization as aas_xmlization

    path = pathlib.Path(...)
    instance = aas_xmlization.read_list_of_primitives_from_file(
        path
    )

    # Do something with the ``instance``

Here is another code example where we serialize the instance:

.. code-block::

    import pathlib

    import test.types as aas_types
    import test.xmlization as aas_xmlization

    instance = ListOfPrimitives(
       ... # some constructor arguments
    )

    pth = pathlib.Path(...)
    with pth.open("wt") as fid:
        aas_xmlization.write(instance, fid)
"""


# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.


import base64
import io
import math
import os
import sys
from typing import (
    Any,
    Callable,
    Iterator,
    List,
    Mapping,
    Optional,
    Sequence,
    TextIO,
    Tuple,
    Union,
    TYPE_CHECKING,
)
import xml.etree.ElementTree

if sys.version_info >= (3, 8):
    from typing import Final, Protocol
else:
    from typing_extensions import Final, Protocol

import test.stringification as aas_stringification
import test.types as aas_types

# See: https://stackoverflow.com/questions/55076778/why-isnt-this-function-type-annotated-correctly-error-missing-type-parameters
if TYPE_CHECKING:
    PathLike = os.PathLike[Any]
else:
    PathLike = os.PathLike


#: XML namespace in which all the elements are expected to reside
NAMESPACE = "https://dummy.com"


# region De-serialization


#: XML namespace as a prefix specially tailored for
#: :py:mod:`xml.etree.ElementTree`
_NAMESPACE_IN_CURLY_BRACKETS = f"{{{NAMESPACE}}}"


class Element(Protocol):
    """Behave like :py:meth:`xml.etree.ElementTree.Element`."""

    @property
    def attrib(self) -> Optional[Mapping[str, str]]:
        """Attributes of the element"""
        raise NotImplementedError()

    @property
    def text(self) -> Optional[str]:
        """Text content of the element"""
        raise NotImplementedError()

    @property
    def tail(self) -> Optional[str]:
        """Tail text of the element"""
        raise NotImplementedError()

    @property
    def tag(self) -> str:
        """Tag of the element; with a namespace provided as a ``{...}`` prefix"""
        raise NotImplementedError()

    def clear(self) -> None:
        """Behave like :py:meth:`xml.etree.ElementTree.Element.clear`."""
        raise NotImplementedError()


class HasIterparse(Protocol):
    """Parse an XML document incrementally."""

    # NOTE (mristin, 2022-10-26):
    # ``self`` is not used in this context, but is necessary for Mypy,
    # see: https://github.com/python/mypy/issues/5018 and
    # https://github.com/python/mypy/commit/3efbc5c5e910296a60ed5b9e0e7eb11dd912c3ed#diff-e165eb7aed9dca0a5ebd93985c8cd263a6462d36ac185f9461348dc5a1396d76R9937

    def iterparse(
        self, source: TextIO, events: Optional[Sequence[str]] = None
    ) -> Iterator[Tuple[str, Element]]:
        """Behave like :py:func:`xml.etree.ElementTree.iterparse`."""


class ElementSegment:
    """Represent an element on a path to the erroneous value."""

    #: Erroneous element
    element: Final[Element]

    def __init__(self, element: Element) -> None:
        """Initialize with the given values."""
        self.element = element

    def __str__(self) -> str:
        """
        Render the segment as a tag without the namespace.

        We deliberately omit the namespace in the tag names. If you want to actually
        query with the resulting XPath, you have to insert the namespaces manually.
        We did not know how to include the namespace in a meaningful way, as XPath
        assumes namespace prefixes to be defined *outside* of the document. At least
        the path thus rendered is informative, and you should be able to descend it
        manually.
        """
        _, has_namespace, tag_wo_ns = self.element.tag.rpartition("}")
        if not has_namespace:
            return self.element.tag
        else:
            return tag_wo_ns


class IndexSegment:
    """Represent an element in a sequence on a path to the erroneous value."""

    #: Erroneous element
    element: Final[Element]

    #: Index of the element in the sequence
    index: Final[int]

    def __init__(self, element: Element, index: int) -> None:
        """Initialize with the given values."""
        self.element = element
        self.index = index

    def __str__(self) -> str:
        """Render the segment as an element wildcard with the index."""
        return f"*[{self.index}]"


Segment = Union[ElementSegment, IndexSegment]


class Path:
    """Represent the relative path to the erroneous element."""

    def __init__(self) -> None:
        """Initialize as an empty path."""
        self._segments = []  # type: List[Segment]

    @property
    def segments(self) -> Sequence[Segment]:
        """Get the segments of the path."""
        return self._segments

    def _prepend(self, segment: Segment) -> None:
        """Insert the :paramref:`segment` in front of other segments."""
        self._segments.insert(0, segment)

    def __str__(self) -> str:
        """Render the path as a relative XPath.

        We omit the leading ``/`` so that you can easily prefix it as you need.
        """
        return "/".join(str(segment) for segment in self._segments)


class DeserializationException(Exception):
    """Signal that the XML de-serialization could not be performed."""

    #: Human-readable explanation of the exception's cause
    cause: Final[str]

    #: Relative path to the erroneous value
    path: Final[Path]

    def __init__(self, cause: str) -> None:
        """Initialize with the given :paramref:`cause` and an empty path."""
        self.cause = cause
        self.path = Path()


def _with_elements_cleared_after_yield(
    iterator: Iterator[Tuple[str, Element]]
) -> Iterator[Tuple[str, Element]]:
    """
    Map the :paramref:`iterator` such that the element is ``clear()``'ed
    *after* every ``yield``.

    :param iterator: to be mapped
    :yield: event and element from :paramref:`iterator`
    """
    for event, element in iterator:
        yield event, element
        element.clear()


def list_of_primitives_from_iterparse(
    iterator: Iterator[Tuple[str, Element]]
) -> aas_types.ListOfPrimitives:
    """
    Read an instance of :py:class:`.types.ListOfPrimitives` from
    the :paramref:`iterator`.

    Example usage:

    .. code-block::

        import pathlib
        import xml.etree.ElementTree as ET

        import test.xmlization as aas_xmlization

        path = pathlib.Path(...)
        with path.open("rt") as fid:
            iterator = ET.iterparse(
                source=fid,
                events=['start', 'end']
            )
            instance = aas_xmlization.list_of_primitives_from_iterparse(
                iterator
            )

        # Do something with the ``instance``

    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return:
        Instance of :py:class:`.types.ListOfPrimitives` read from
        :paramref:`iterator`
    """
    next_event_element = next(iterator, None)
    if next_event_element is None:
        raise DeserializationException(
            # fmt: off
            "Expected the start element for ListOfPrimitives, "
            "but got the end-of-input"
            # fmt: on
        )

    next_event, next_element = next_event_element
    if next_event != "start":
        raise DeserializationException(
            f"Expected the start element for ListOfPrimitives, "
            f"but got event {next_event!r} and element {next_element.tag!r}"
        )

    try:
        return _read_list_of_primitives_as_element(next_element, iterator)
    except DeserializationException as exception:
        exception.path._prepend(ElementSegment(next_element))
        raise exception


def list_of_primitives_from_stream(
    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
) -> aas_types.ListOfPrimitives:
    """
    Read an instance of :py:class:`.types.ListOfPrimitives` from
    the :paramref:`stream`.

    Example usage:

    .. code-block::

        import test.xmlization as aas_xmlization

        with open_some_stream_over_network(...) as stream:
            instance = aas_xmlization.list_of_primitives_from_stream(
                stream
            )

        # Do something with the ``instance``

    :param stream:
        representing an instance of
        :py:class:`.types.ListOfPrimitives` in XML
    :param has_iterparse:
        Module containing ``iterparse`` function.

        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
        library. If you have to deal with malicious input, consider using
        a library such as `defusedxml.ElementTree`_.
    :raise: :py:class:`DeserializationException` if unexpected input
    :return:
        Instance of :py:class:`.types.ListOfPrimitives` read from
        :paramref:`stream`
    """
    iterator = has_iterparse.iterparse(stream, ["start", "end"])
    return list_of_primitives_from_iterparse(
        _with_elements_cleared_after_yield(iterator)
    )


def list_of_primitives_from_file(
    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
) -> aas_types.ListOfPrimitives:
    """
    Read an instance of :py:class:`.types.ListOfPrimitives` from
    the :paramref:`path`.

    Example usage:

    .. code-block::

        import pathlib
        import test.xmlization as aas_xmlization

        path = pathlib.Path(...)
        instance = aas_xmlization.list_of_primitives_from_file(
            path
        )

        # Do something with the ``instance``

    :param path:
        to the file representing an instance of
        :py:class:`.types.ListOfPrimitives` in XML
    :param has_iterparse:
        Module containing ``iterparse`` function.

        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
        library. If you have to deal with malicious input, consider using
        a library such as `defusedxml.ElementTree`_.
    :raise: :py:class:`DeserializationException` if unexpected input
    :return:
        Instance of :py:class:`.types.ListOfPrimitives` read from
        :paramref:`path`
    """
    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
        iterator = has_iterparse.iterparse(fid, ["start", "end"])
        return list_of_primitives_from_iterparse(
            _with_elements_cleared_after_yield(iterator)
        )


def list_of_primitives_from_str(
    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
) -> aas_types.ListOfPrimitives:
    """
    Read an instance of :py:class:`.types.ListOfPrimitives` from
    the :paramref:`text`.

    Example usage:

    .. code-block::

        import pathlib
        import test.xmlization as aas_xmlization

        text = "<...>...</...>"
        instance = aas_xmlization.list_of_primitives_from_str(
            text
        )

        # Do something with the ``instance``

    :param text:
        representing an instance of
        :py:class:`.types.ListOfPrimitives` in XML
    :param has_iterparse:
        Module containing ``iterparse`` function.

        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
        library. If you have to deal with malicious input, consider using
        a library such as `defusedxml.ElementTree`_.
    :raise: :py:class:`DeserializationException` if unexpected input
    :return:
        Instance of :py:class:`.types.ListOfPrimitives` read from
        :paramref:`text`
    """
    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
    return list_of_primitives_from_iterparse(
        _with_elements_cleared_after_yield(iterator)
    )


def from_iterparse(iterator: Iterator[Tuple[str, Element]]) -> aas_types.Class:
    """
    Read an instance from the :paramref:`iterator`.

    The type of the instance is determined by the very first start element.

    Example usage:

    .. code-block::

        import pathlib
        import xml.etree.ElementTree as ET

        import test.xmlization as aas_xmlization

        path = pathlib.Path(...)
        with path.open("rt") as fid:
            iterator = ET.iterparse(
                source=fid,
                events=['start', 'end']
            )
            instance = aas_xmlization.from_iterparse(
                iterator
            )

        # Do something with the ``instance``

    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return:
        Instance of :py:class:`.types.Class` read from the :paramref:`iterator`
    """
    next_event_element = next(iterator, None)
    if next_event_element is None:
        raise DeserializationException(
            # fmt: off
            "Expected the start element of an instance, "
            "but got the end-of-input"
            # fmt: on
        )

    next_event, next_element = next_event_element
    if next_event != "start":
        raise DeserializationException(
            f"Expected the start element of an instance, "
            f"but got event {next_event!r} and element {next_element.tag!r}"
        )

    try:
        return _read_as_element(next_element, iterator)
    except DeserializationException as exception:
        exception.path._prepend(ElementSegment(next_element))
        raise exception


def from_stream(
    stream: TextIO, has_iterparse: HasIterparse = xml.etree.ElementTree
) -> aas_types.Class:
    """
    Read an instance from the :paramref:`stream`.

    The type of the instance is determined by the very first start element.

    Example usage:

    .. code-block::

        import test.xmlization as aas_xmlization

        with open_some_stream_over_network(...) as stream:
            instance = aas_xmlization.from_stream(
                stream
            )

        # Do something with the ``instance``

    :param stream:
        representing an instance in XML
    :param has_iterparse:
        Module containing ``iterparse`` function.

        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
        library. If you have to deal with malicious input, consider using
        a library such as `defusedxml.ElementTree`_.
    :raise: :py:class:`DeserializationException` if unexpected input
    :return:
        Instance read from :paramref:`stream`
    """
    iterator = has_iterparse.iterparse(stream, ["start", "end"])
    return from_iterparse(_with_elements_cleared_after_yield(iterator))


def from_file(
    path: PathLike, has_iterparse: HasIterparse = xml.etree.ElementTree
) -> aas_types.Class:
    """
    Read an instance from the file at the :paramref:`path`.

    Example usage:

    .. code-block::

        import pathlib
        import test.xmlization as aas_xmlization

        path = pathlib.Path(...)
        instance = aas_xmlization.from_file(
            path
        )

        # Do something with the ``instance``

    :param path:
        to the file representing an instance in XML
    :param has_iterparse:
        Module containing ``iterparse`` function.

        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
        library. If you have to deal with malicious input, consider using
        a library such as `defusedxml.ElementTree`_.
    :raise: :py:class:`DeserializationException` if unexpected input
    :return:
        Instance read from the file at :paramref:`path`
    """
    with open(os.fspath(path), "rt", encoding="utf-8") as fid:
        iterator = has_iterparse.iterparse(fid, ["start", "end"])
        return from_iterparse(_with_elements_cleared_after_yield(iterator))


def from_str(
    text: str, has_iterparse: HasIterparse = xml.etree.ElementTree
) -> aas_types.Class:
    """
    Read an instance from the :paramref:`text`.

    Example usage:

    .. code-block::

        import pathlib
        import test.xmlization as aas_xmlization

        text = "<...>...</...>"
        instance = aas_xmlization.from_str(
            text
        )

        # Do something with the ``instance``

    :param text:
        representing an instance in XML
    :param has_iterparse:
        Module containing ``iterparse`` function.

        Default is to use :py:mod:`xml.etree.ElementTree` from the standard
        library. If you have to deal with malicious input, consider using
        a library such as `defusedxml.ElementTree`_.
    :raise: :py:class:`DeserializationException` if unexpected input
    :return:
        Instance read from :paramref:`text`
    """
    iterator = has_iterparse.iterparse(io.StringIO(text), ["start", "end"])
    return from_iterparse(_with_elements_cleared_after_yield(iterator))


# NOTE (mristin, 2022-10-08):
# Directly using the iterator turned out to result in very complex function
# designs. The design became much simpler as soon as we considered one look-ahead
# element. We came up finally with the following pattern which all the protected
# reading functions below roughly follow:
#
# ..code-block::
#
#    _read_*(
#       look-ahead element,
#       iterator
#    ) -> result
#
# The reading functions all read from the ``iterator`` coming from
# :py:func:`xml.etree.ElementTree.iterparse` with the argument
# ``events=["start", "end"]``. The exception :py:class:`.DeserializationException`
# is raised in case of unexpected input.
#
# The reading functions are responsible to read the end element corresponding to the
# start look-ahead element.
#
# When it comes to error reporting, we use exceptions. The exceptions are raised in
# the *callee*, as usual. However, the context of the exception, such as the error path,
# is added in the *caller*, as only the caller knows the context of
# the lookahead-element. In particular, prepending the path segment corresponding to
# the lookahead-element is the responsibility of the *caller*, and not of
# the *callee*.


def _parse_element_tag(element: Element) -> str:
    """
    Extract the tag name without the namespace prefix from :paramref:`element`.

    :param element: whose tag without namespace we want to extract
    :return: tag name without the namespace prefix
    :raise: :py:class:`DeserializationException` if unexpected :paramref:`element`
    """
    if not element.tag.startswith(_NAMESPACE_IN_CURLY_BRACKETS):
        namespace, got_namespace, tag_wo_ns = element.tag.rpartition("}")
        if got_namespace:
            if namespace.startswith("{"):
                namespace = namespace[1:]

            raise DeserializationException(
                f"Expected the element in the namespace {NAMESPACE!r}, "
                f"but got the element {tag_wo_ns!r} in the namespace {namespace!r}"
            )
        else:
            raise DeserializationException(
                f"Expected the element in the namespace {NAMESPACE!r}, "
                f"but got the element {tag_wo_ns!r} without the namespace prefix"
            )

    return element.tag[len(_NAMESPACE_IN_CURLY_BRACKETS) :]


def _raise_if_has_tail_or_attrib(element: Element) -> None:
    """
    Check that :paramref:`element` has no trailing text and no attributes.

    :param element: to be verified
    :raise:
        :py:class:`.DeserializationException` if trailing text or attributes;
        conforming to the convention about handling error paths,
        the exception path is left empty.
    """
    if element.tail is not None and len(element.tail.strip()) != 0:
        raise DeserializationException(
            f"Expected no trailing text, but got: {element.tail!r}"
        )

    if element.attrib is not None and len(element.attrib) > 0:
        raise DeserializationException(
            f"Expected no attributes, but got: {element.attrib}"
        )


def _read_end_element(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> Element:
    """
    Read the end element corresponding to the start :paramref:`element`
    from :paramref:`iterator`.

    :param element: corresponding start element
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    """
    next_event_element = next(iterator, None)
    if next_event_element is None:
        raise DeserializationException(
            f"Expected the end element for {element.tag}, " f"but got the end-of-input"
        )

    next_event, next_element = next_event_element
    if next_event != "end" or next_element.tag != element.tag:
        raise DeserializationException(
            f"Expected the end element for {element.tag!r}, "
            f"but got the event {next_event!r} and element {next_element.tag!r}"
        )

    _raise_if_has_tail_or_attrib(next_element)

    return next_element


def _read_text_from_element(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> str:
    """
    Extract the text from the :paramref:`element`, and read
    the end element from :paramref:`iterator`.

    The :paramref:`element` is expected to contain text. Otherwise,
    it is considered as unexpected input.

    :param element: start element enclosing the text
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    """
    _raise_if_has_tail_or_attrib(element)

    text = element.text

    end_element = _read_end_element(
        element,
        iterator,
    )

    if text is None:
        if end_element.text is None:
            raise DeserializationException(
                "Expected an element with text, but got an element with no text."
            )

        text = end_element.text

    return text


_XS_BOOLEAN_LITERAL_SET = {
    "1",
    "true",
    "0",
    "false",
}


def _read_bool_from_element_text(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> bool:
    """
    Parse the text of :paramref:`element` as a boolean, and
    read the corresponding end element from :paramref:`iterator`.

    :param element: start element
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return: parsed value
    """
    text = _read_text_from_element(element, iterator)

    if text not in _XS_BOOLEAN_LITERAL_SET:
        raise DeserializationException(
            f"Expected a boolean, " f"but got an element with text: {text!r}"
        )

    return text in ("1", "true")


def _read_int_from_element_text(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> int:
    """
    Parse the text of :paramref:`element` as an integer, and
    read the corresponding end element from :paramref:`iterator`.

    :param element: start element
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return: parsed value
    """
    text = _read_text_from_element(element, iterator)

    try:
        value = int(text)
    except ValueError:
        # pylint: disable=raise-missing-from
        raise DeserializationException(
            f"Expected an integer, " f"but got an element with text: {text!r}"
        )

    return value


_TEXT_TO_XS_DOUBLE_LITERALS = {
    "NaN": math.nan,
    "INF": math.inf,
    "-INF": -math.inf,
}


def _read_float_from_element_text(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> float:
    """
    Parse the text of :paramref:`element` as a floating-point number, and
    read the corresponding end element from :paramref:`iterator`.

    :param element: start element
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return: parsed value
    """
    text = _read_text_from_element(element, iterator)

    value = _TEXT_TO_XS_DOUBLE_LITERALS.get(text, None)
    if value is None:
        try:
            value = float(text)
        except ValueError:
            # pylint: disable=raise-missing-from
            raise DeserializationException(
                f"Expected a floating-point number, "
                f"but got an element with text: {text!r}"
            )

    return value


def _read_str_from_element_text(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> str:
    """
    Parse the text of :paramref:`element` as a string, and
    read the corresponding end element from :paramref:`iterator`.

    If there is no text, empty string is returned.

    :param element: start element
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return: parsed value
    """
    # NOTE (mristin, 2022-10-26):
    # We do not use ``_read_text_from_element`` as that function expects
    # the ``element`` to contain *some* text. In contrast, this function
    # can also deal with empty text, in which case it returns an empty string.

    text = element.text

    end_element = _read_end_element(element, iterator)

    if text is None:
        text = end_element.text

    _raise_if_has_tail_or_attrib(element)
    result = text if text is not None else ""

    return result


def _read_bytes_from_element_text(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> bytes:
    """
    Parse the text of :paramref:`element` as base64-encoded bytes, and
    read the corresponding end element from :paramref:`iterator`.

    :param element: look-ahead element
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return: parsed value
    """
    text = _read_text_from_element(element, iterator)

    try:
        value = base64.b64decode(text)
    except Exception:
        # pylint: disable=raise-missing-from
        raise DeserializationException(
            f"Expected a text as base64-encoded bytes, "
            f"but got an element with text: {text!r}"
        )

    return value


class _ReaderAndSetterForListOfPrimitives:
    """
    Provide a buffer for reading and setting the properties for the class
    :py:class:`ListOfPrimitives`.

    The properties correspond to the constructor arguments of
    :py:class:`ListOfPrimitives`. We use this buffer to facilitate dispatching when
    parsing the properties in a streaming fashion.
    """

    def __init__(self) -> None:
        """Initialize with all the properties unset."""
        self.strings: Optional[List[str]] = None
        self.integers: Optional[List[int]] = None
        self.booleans: Optional[List[bool]] = None

    def read_and_set_strings(
        self, element: Element, iterator: Iterator[Tuple[str, Element]]
    ) -> None:
        """
        Read :paramref:`element` as the property
        :py:attr:`.types.ListOfPrimitives.strings` and set it.
        """
        if element.text is not None and len(element.text.strip()) != 0:
            raise DeserializationException(
                f"Expected only item elements and whitespace text, "
                f"but got text: {element.text!r}"
            )

        result: List[PrimitiveType.STR] = []

        item_i = 0

        while True:
            next_event_element = next(iterator, None)
            if next_event_element is None:
                raise DeserializationException(
                    "Expected one or more items from a list or the end element, "
                    "but got end-of-input"
                )

            next_event, next_element = next_event_element
            if next_event == "end" and next_element.tag == element.tag:
                # We reached the end of the list.
                break

            if next_event != "start":
                raise DeserializationException(
                    "Expected a start element corresponding to an item, "
                    f"but got event {next_event!r} and element {next_element.tag!r}"
                )

            try:
                item = _read_str_from_element_text(next_element, iterator)
            except DeserializationException as exception:
                exception.path._prepend(IndexSegment(next_element, item_i))
                raise

            result.append(item)
            item_i += 1

        self.strings = result

    def read_and_set_integers(
        self, element: Element, iterator: Iterator[Tuple[str, Element]]
    ) -> None:
        """
        Read :paramref:`element` as the property
        :py:attr:`.types.ListOfPrimitives.integers` and set it.
        """
        if element.text is not None and len(element.text.strip()) != 0:
            raise DeserializationException(
                f"Expected only item elements and whitespace text, "
                f"but got text: {element.text!r}"
            )

        result: List[PrimitiveType.INT] = []

        item_i = 0

        while True:
            next_event_element = next(iterator, None)
            if next_event_element is None:
                raise DeserializationException(
                    "Expected one or more items from a list or the end element, "
                    "but got end-of-input"
                )

            next_event, next_element = next_event_element
            if next_event == "end" and next_element.tag == element.tag:
                # We reached the end of the list.
                break

            if next_event != "start":
                raise DeserializationException(
                    "Expected a start element corresponding to an item, "
                    f"but got event {next_event!r} and element {next_element.tag!r}"
                )

            try:
                item = _read_int_from_element_text(next_element, iterator)
            except DeserializationException as exception:
                exception.path._prepend(IndexSegment(next_element, item_i))
                raise

            result.append(item)
            item_i += 1

        self.integers = result

    def read_and_set_booleans(
        self, element: Element, iterator: Iterator[Tuple[str, Element]]
    ) -> None:
        """
        Read :paramref:`element` as the property
        :py:attr:`.types.ListOfPrimitives.booleans` and set it.
        """
        if element.text is not None and len(element.text.strip()) != 0:
            raise DeserializationException(
                f"Expected only item elements and whitespace text, "
                f"but got text: {element.text!r}"
            )

        result: List[PrimitiveType.BOOL] = []

        item_i = 0

        while True:
            next_event_element = next(iterator, None)
            if next_event_element is None:
                raise DeserializationException(
                    "Expected one or more items from a list or the end element, "
                    "but got end-of-input"
                )

            next_event, next_element = next_event_element
            if next_event == "end" and next_element.tag == element.tag:
                # We reached the end of the list.
                break

            if next_event != "start":
                raise DeserializationException(
                    "Expected a start element corresponding to an item, "
                    f"but got event {next_event!r} and element {next_element.tag!r}"
                )

            try:
                item = _read_bool_from_element_text(next_element, iterator)
            except DeserializationException as exception:
                exception.path._prepend(IndexSegment(next_element, item_i))
                raise

            result.append(item)
            item_i += 1

        self.booleans = result


def _read_list_of_primitives_as_sequence(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> aas_types.ListOfPrimitives:
    """
    Read an instance of :py:class:`.types.ListOfPrimitives`
    as a sequence of XML-encoded properties.

    The end element corresponding to the :paramref:`element` will be
    read as well.

    :param element: start element, parent of the sequence
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return: parsed instance
    """
    if element.text is not None and len(element.text.strip()) != 0:
        raise DeserializationException(
            f"Expected only XML elements representing the properties and whitespace text, "
            f"but got text: {element.text!r}"
        )

    _raise_if_has_tail_or_attrib(element)

    reader_and_setter = _ReaderAndSetterForListOfPrimitives()

    while True:
        next_event_element = next(iterator, None)
        if next_event_element is None:
            raise DeserializationException(
                "Expected one or more XML-encoded properties or the end element, "
                "but got the end-of-input"
            )

        next_event, next_element = next_event_element
        if next_event == "end" and next_element.tag == element.tag:
            # We reached the end element enclosing the sequence.
            break

        if next_event != "start":
            raise DeserializationException(
                "Expected a start element corresponding to a property, "
                f"but got event {next_event!r} and element {next_element.tag!r}"
            )

        try:
            tag_wo_ns = _parse_element_tag(next_element)
        except DeserializationException as exception:
            exception.path._prepend(ElementSegment(next_element))
            raise

        read_and_set_method = _READ_AND_SET_DISPATCH_FOR_LIST_OF_PRIMITIVES.get(
            tag_wo_ns, None
        )
        if read_and_set_method is None:
            an_exception = DeserializationException(
                f"Expected an element representing a property, "
                f"but got an element with unexpected tag: {tag_wo_ns!r}"
            )
            an_exception.path._prepend(ElementSegment(next_element))
            raise an_exception

        try:
            read_and_set_method(reader_and_setter, next_element, iterator)
        except DeserializationException as exception:
            exception.path._prepend(ElementSegment(next_element))
            raise

    if reader_and_setter.strings is None:
        raise DeserializationException("The required property 'strings' is missing")

    if reader_and_setter.integers is None:
        raise DeserializationException("The required property 'integers' is missing")

    if reader_and_setter.booleans is None:
        raise DeserializationException("The required property 'booleans' is missing")

    return aas_types.ListOfPrimitives(
        reader_and_setter.strings,
        reader_and_setter.integers,
        reader_and_setter.booleans,
    )


def _read_list_of_primitives_as_element(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> aas_types.ListOfPrimitives:
    """
    Read an instance of :py:class:`.types.ListOfPrimitives` from
    :paramref:`iterator`, including the end element.

    :param element: start element
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return: parsed instance
    """
    tag_wo_ns = _parse_element_tag(element)

    if tag_wo_ns != "listOfPrimitives":
        raise DeserializationException(
            f"Expected the element with the tag 'listOfPrimitives', "
            f"but got tag: {tag_wo_ns}"
        )

    return _read_list_of_primitives_as_sequence(element, iterator)


def _read_as_element(
    element: Element, iterator: Iterator[Tuple[str, Element]]
) -> aas_types.Class:
    """
    Read an instance from :paramref:`iterator`, including the end element.

    :param element: start element
    :param iterator:
        Input stream of ``(event, element)`` coming from
        :py:func:`xml.etree.ElementTree.iterparse` with the argument
        ``events=["start", "end"]``
    :raise: :py:class:`DeserializationException` if unexpected input
    :return: parsed instance
    """
    tag_wo_ns = _parse_element_tag(element)
    read_as_sequence = _GENERAL_DISPATCH.get(tag_wo_ns, None)

    if read_as_sequence is None:
        raise DeserializationException(
            f"Expected the element tag to be a valid model type "
            f"of a concrete instance, "
            f"but got tag {tag_wo_ns!r}"
        )

    return read_as_sequence(element, iterator)


#: Dispatch XML property name to read & set method in
#: :py:class:`_ReaderAndSetterForListOfPrimitives`
_READ_AND_SET_DISPATCH_FOR_LIST_OF_PRIMITIVES: Mapping[
    str,
    Callable[
        [_ReaderAndSetterForListOfPrimitives, Element, Iterator[Tuple[str, Element]]],
        None,
    ],
] = {
    "strings": _ReaderAndSetterForListOfPrimitives.read_and_set_strings,
    "integers": _ReaderAndSetterForListOfPrimitives.read_and_set_integers,
    "booleans": _ReaderAndSetterForListOfPrimitives.read_and_set_booleans,
}


#: Dispatch XML class names to read-as-sequence functions
#: corresponding to the concrete classes
_GENERAL_DISPATCH: Mapping[
    str, Callable[[Element, Iterator[Tuple[str, Element]]], aas_types.Class]
] = {
    "listOfPrimitives": _read_list_of_primitives_as_sequence,
}


# endregion


# region Serialization


class _Serializer(aas_types.AbstractVisitor):
    """Encode instances as XML and write them to :py:attr:`~stream`."""

    #: Stream to be written to when we visit the instances
    stream: Final[TextIO]

    #: Method pointer to be invoked for writing the start element with or without
    #: specifying a namespace (depending on the state of the serializer)
    _write_start_element: Callable[[str], None]

    #: Method pointer to be invoked for writing an empty element with or without
    #: specifying a namespace (depending on the state of the serializer)
    _write_empty_element: Callable[[str], None]

    # NOTE (mristin, 2022-10-14):
    # The serialization procedure is quite rigid. We leverage the specifics of
    # the serialization procedure to optimize the code a bit.
    #
    # Namely, we model the writing of the XML elements as a state machine.
    # The namespace is only specified for the very first element. All the subsequent
    # elements will *not* have the namespace specified. We implement that behavior by
    # using pointers to methods, as Python treats the methods as first-class citizens.
    #
    # The ``_write_start_element`` will point to
    # ``_write_first_start_element_with_namespace`` on the *first* invocation.
    # Afterwards, it will be redirected to ``_write_start_element_without_namespace``.
    #
    # Analogously for ``_write_empty_element``.
    #
    # Please see the implementation for the details, but this should give you at least
    # a rough overview.

    def _write_first_start_element_with_namespace(self, name: str) -> None:
        """
        Write the start element with the tag name :paramref:`name` and specify
        its namespace.

        The :py:attr:`~_write_start_element` is set to
        :py:meth:`~_write_start_element_without_namespace` after the first invocation
        of this method.

        :param name: of the element tag. Expected to contain no XML special characters.
        """
        self.stream.write(f'<{name} xmlns="{NAMESPACE}">')

        # NOTE (mristin, 2022-10-14):
        # Any subsequence call to `_write_start_element` or `_write_empty_element`
        # should not specify the namespace of the element as we specified now already
        # specified it.
        self._write_start_element = self._write_start_element_without_namespace
        self._write_empty_element = self._write_empty_element_without_namespace

    def _write_start_element_without_namespace(self, name: str) -> None:
        """
        Write the start element with the tag name :paramref:`name`.

        The first element, written *before* this one, is expected to have been
        already written with the namespace specified.

        :param name: of the element tag. Expected to contain no XML special characters.
        """
        self.stream.write(f"<{name}>")

    def _escape_and_write_text(self, text: str) -> None:
        """
        Escape :paramref:`text` for XML and write it.

        :param text: to be escaped and written
        """
        # NOTE (mristin, 2022-10-14):
        # We ran ``timeit`` on manual code which escaped XML special characters with
        # a dictionary, and on another snippet which called three ``.replace()``.
        # The code with ``.replace()`` was an order of magnitude faster on our computers.
        self.stream.write(
            text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
        )

    def _write_end_element(self, name: str) -> None:
        """
        Write the end element with the tag name :paramref:`name`.

        :param name: of the element tag. Expected to contain no XML special characters.
        """
        self.stream.write(f"</{name}>")

    def _write_first_empty_element_with_namespace(self, name: str) -> None:
        """
        Write the first (and only) empty element with the tag name :paramref:`name`.

        No elements are expected to be written to the stream afterwards. The element
        includes the namespace specification.

        :param name: of the element tag. Expected to contain no XML special characters.
        """
        self.stream.write(f'<{name} xmlns="{NAMESPACE}"/>')
        self._write_empty_element = self._rase_if_write_element_called_again
        self._write_start_element = self._rase_if_write_element_called_again

    def _rase_if_write_element_called_again(self, name: str) -> None:
        raise AssertionError(
            f"We expected to call ``_write_first_empty_element_with_namespace`` "
            f"only once. This is an unexpected second call for writing "
            f"an (empty or non-empty) element with the tag name: {name!r}"
        )

    def _write_empty_element_without_namespace(self, name: str) -> None:
        """
        Write the empty element with the tag name :paramref:`name`.

        The call to this method is expected to occur *after* the enclosing element with
        a specified namespace has been written.

        :param name: of the element tag. Expected to contain no XML special characters.
        """
        self.stream.write(f"<{name}/>")

    def _write_bool_property(self, name: str, value: bool) -> None:
        """
        Write the :paramref:`value` of a boolean property enclosed in
        the :paramref:`name` element.

        :param name: of the corresponding element tag
        :param value: of the property
        """
        self._write_start_element(name)
        self.stream.write("true" if value else "false")
        self._write_end_element(name)

    def _write_int_property(self, name: str, value: int) -> None:
        """
        Write the :paramref:`value` of an integer property enclosed in
        the :paramref:`name` element.

        :param name: of the corresponding element tag
        :param value: of the property
        """
        self._write_start_element(name)
        self.stream.write(str(value))
        self._write_end_element(name)

    def _write_float_property(self, name: str, value: float) -> None:
        """
        Write the :paramref:`value` of a floating-point property enclosed in
        the :paramref:`name` element.

        :param name: of the corresponding element tag
        :param value: of the property
        """
        self._write_start_element(name)

        if value == math.inf:
            self.stream.write("INF")
        elif value == -math.inf:
            self.stream.write("-INF")
        elif math.isnan(value):
            self.stream.write("NaN")
        elif value == 0:
            if math.copysign(1.0, value) < 0.0:
                self.stream.write("-0.0")
            else:
                self.stream.write("0.0")
        else:
            self.stream.write(str(value))

    def _write_str_property(self, name: str, value: str) -> None:
        """
        Write the :paramref:`value` of a string property enclosed in
        the :paramref:`name` element.

        :param name: of the corresponding element tag
        :param value: of the property
        """
        self._write_start_element(name)
        self._escape_and_write_text(value)
        self._write_end_element(name)

    def _write_bytes_property(self, name: str, value: bytes) -> None:
        """
        Write the :paramref:`value` of a binary-content property enclosed in
        the :paramref:`name` element.

        :param name: of the corresponding element tag
        :param value: of the property
        """
        self._write_start_element(name)

        # NOTE (mristin, 2022-10-14):
        # We need to decode the result of the base64-encoding to ASCII since we are
        # writing to an XML *text* stream. ``base64.b64encode(.)`` gives us bytes,
        # not a string.
        encoded = base64.b64encode(value).decode("ascii")

        # NOTE (mristin, 2022-10-14):
        # Base64 alphabet excludes ``<``, ``>`` and ``&``, so we can directly
        # write the ``encoded`` content to the stream as XML text.
        #
        # See: https://datatracker.ietf.org/doc/html/rfc4648#section-4
        self.stream.write(encoded)
        self._write_end_element(name)

    def __init__(self, stream: TextIO) -> None:
        """
        Initialize the visitor to write to :paramref:`stream`.

        The first element will include the :py:attr:`~.NAMESPACE`. Every other
        element will not have the namespace specified.

        :param stream: where to write to
        """
        self.stream = stream
        self._write_start_element = self._write_first_start_element_with_namespace
        self._write_empty_element = self._write_first_empty_element_with_namespace

    def _write_list_of_primitives_as_sequence(
        self, that: aas_types.ListOfPrimitives
    ) -> None:
        """
        Serialize :paramref:`that` to :py:attr:`~stream` as a sequence of
        XML elements.

        Each element in the sequence corresponds to a property. If no properties
        are set, nothing is written to the :py:attr:`~stream`.

        :param that: instance to be serialized
        """
        if len(that.strings) == 0:
            self._write_empty_element("strings")
        else:
            self._write_start_element("strings")
            for an_item in that.strings:
                self.visit(an_item)
            self._write_end_element("strings")

        if len(that.integers) == 0:
            self._write_empty_element("integers")
        else:
            self._write_start_element("integers")
            for another_item in that.integers:
                self.visit(another_item)
            self._write_end_element("integers")

        if len(that.booleans) == 0:
            self._write_empty_element("booleans")
        else:
            self._write_start_element("booleans")
            for yet_another_item in that.booleans:
                self.visit(yet_another_item)
            self._write_end_element("booleans")

    def visit_list_of_primitives(self, that: aas_types.ListOfPrimitives) -> None:
        """
        Serialize :paramref:`that` to :py:attr:`~stream` as an XML element.

        The enclosing XML element designates the class of the instance, where its
        children correspond to the properties of the instance.

        :param that: instance to be serialized
        """
        self._write_start_element("listOfPrimitives")
        self._write_list_of_primitives_as_sequence(that)
        self._write_end_element("listOfPrimitives")


def write(instance: aas_types.Class, stream: TextIO) -> None:
    """
    Write the XML representation of :paramref:`instance` to :paramref:`stream`.

    Example usage:

    .. code-block::

        import pathlib

        import test.types as aas_types
        import test.xmlization as aas_xmlization

        instance = ListOfPrimitives(
           ... # some constructor arguments
        )

        pth = pathlib.Path(...)
        with pth.open("wt") as fid:
            aas_xmlization.write(instance, fid)

    :param instance: to be serialized
    :param stream: to write to
    """
    serializer = _Serializer(stream)
    serializer.visit(instance)


def to_str(that: aas_types.Class) -> str:
    """
    Serialize :paramref:`that` to an XML-encoded text.

    :param that: instance to be serialized
    :return: :paramref:`that` serialized to XML serialized to text
    """
    writer = io.StringIO()
    write(that, writer)
    return writer.getvalue()


# endregion
