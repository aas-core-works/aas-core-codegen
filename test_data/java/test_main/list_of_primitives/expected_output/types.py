# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.


import abc
import enum
from typing import Generic, Iterator, Optional, TypeVar, List


T = TypeVar("T")
ContextT = TypeVar("ContextT")


class Class(abc.ABC):
    """Represent the most general class of an AAS model."""

    @abc.abstractmethod
    def descend_once(self) -> Iterator["Class"]:
        """Iterate over all the instances referenced from this one."""
        raise NotImplementedError()

    @abc.abstractmethod
    def descend(self) -> Iterator["Class"]:
        """Iterate recursively over all the instances referenced from this one."""
        raise NotImplementedError()

    @abc.abstractmethod
    def accept(self, visitor: "AbstractVisitor") -> None:
        """
        Dispatch the :paramref:`visitor` on this instance.

        :param visitor: to be dispatched
        """
        raise NotImplementedError()

    @abc.abstractmethod
    def accept_with_context(
        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
    ) -> None:
        """
        Dispatch the :paramref:`visitor` on this instance with :paramref:`context`.

        :param visitor: to be dispatched
        :param context: of the visitation
        """
        raise NotImplementedError()

    @abc.abstractmethod
    def transform(self, transformer: "AbstractTransformer[T]") -> T:
        """
        Dispatch the :paramref:`transformer` on this instance.

        :param transformer: to be dispatched
        :return: transformed self
        """
        raise NotImplementedError()

    @abc.abstractmethod
    def transform_with_context(
        self,
        transformer: "AbstractTransformerWithContext[ContextT, T]",
        context: ContextT,
    ) -> T:
        """
        Dispatch the :paramref:`transformer` on this instance with :paramref:`context`.

        :param transformer: to be dispatched
        :return: transformed self
        """
        raise NotImplementedError()


# pylint: disable=redefined-builtin


class ListOfPrimitives(Class):
    # pylint: disable=missing-class-docstring

    strings: List[str]

    integers: List[int]

    booleans: List[bool]

    def descend_once(self) -> Iterator[Class]:
        """
        Iterate over the instances referenced from this instance.

        We do not recurse into the referenced instance.

        :yield: instances directly referenced from this instance
        """
        # No descendable properties
        return
        # For this uncommon return-yield construction, see:
        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
        # noinspection PyUnreachableCode
        yield

    def descend(self) -> Iterator[Class]:
        """
        Iterate recursively over the instances referenced from this one.

        :yield: instances recursively referenced from this instance
        """
        # No descendable properties
        return
        # For this uncommon return-yield construction, see:
        # https://stackoverflow.com/questions/13243766/how-to-define-an-empty-generator-function
        # noinspection PyUnreachableCode
        yield

    def accept(self, visitor: "AbstractVisitor") -> None:
        """Dispatch the :paramref:`visitor` on this instance."""
        visitor.visit_list_of_primitives(self)

    def accept_with_context(
        self, visitor: "AbstractVisitorWithContext[ContextT]", context: ContextT
    ) -> None:
        """Dispatch the :paramref:`visitor` on this instance in :paramref:`context`."""
        visitor.visit_list_of_primitives_with_context(self, context)

    def transform(self, transformer: "AbstractTransformer[T]") -> T:
        """Dispatch the :paramref:`transformer` on this instance."""
        return transformer.transform_list_of_primitives(self)

    def transform_with_context(
        self,
        transformer: "AbstractTransformerWithContext[ContextT, T]",
        context: ContextT,
    ) -> T:
        """
        Dispatch the :paramref:`transformer` on this instance in :paramref:`context`.
        """
        return transformer.transform_list_of_primitives_with_context(self, context)

    def __init__(
        self, strings: List[str], integers: List[int], booleans: List[bool]
    ) -> None:
        """Initialize with the given values."""
        self.strings = strings
        self.integers = integers
        self.booleans = booleans


class AbstractVisitor:
    """Visit the instances of the model."""

    def visit(self, that: Class) -> None:
        """Double-dispatch on :paramref:`that`."""
        that.accept(self)

    @abc.abstractmethod
    def visit_list_of_primitives(self, that: ListOfPrimitives) -> None:
        """Visit :paramref:`that`."""
        raise NotImplementedError()


class AbstractVisitorWithContext(Generic[ContextT]):
    """Visit the instances of the model with context."""

    def visit_with_context(self, that: Class, context: ContextT) -> None:
        """Double-dispatch on :paramref:`that`."""
        that.accept_with_context(self, context)

    @abc.abstractmethod
    def visit_list_of_primitives_with_context(
        self, that: ListOfPrimitives, context: ContextT
    ) -> None:
        """Visit :paramref:`that` in :paramref:`context`."""
        raise NotImplementedError()


class PassThroughVisitor(AbstractVisitor):
    """
    Visit the instances of the model without action.

    This visitor is not meant to be directly used. Instead, you usually
    inherit from it, and implement only the relevant visit methods.
    """

    def visit(self, that: Class) -> None:
        """Double-dispatch on :paramref:`that`."""
        that.accept(self)

    def visit_list_of_primitives(self, that: ListOfPrimitives) -> None:
        """Visit :paramref:`that`."""
        for another in that.descend_once():
            self.visit(another)


class PassThroughVisitorWithContext(AbstractVisitorWithContext[ContextT]):
    """
    Visit the instances of the model without action and in context.

    This visitor is not meant to be directly used. Instead, you usually
    inherit from it, and implement only the relevant visit methods.
    """

    def visit_with_context(self, that: Class, context: ContextT) -> None:
        """Double-dispatch on :paramref:`that`."""
        that.accept_with_context(self, context)

    def visit_list_of_primitives_with_context(
        self, that: ListOfPrimitives, context: ContextT
    ) -> None:
        """Visit :paramref:`that` in :paramref:`context`."""
        for another in that.descend_once():
            self.visit_with_context(another, context)


class AbstractTransformer(Generic[T]):
    """Transform the instances of the model."""

    def transform(self, that: Class) -> T:
        """Double-dispatch on :paramref:`that`."""
        return that.transform(self)

    @abc.abstractmethod
    def transform_list_of_primitives(self, that: ListOfPrimitives) -> T:
        """Transform :paramref:`that`."""
        raise NotImplementedError()


class AbstractTransformerWithContext(Generic[ContextT, T]):
    """Transform the instances of the model in context."""

    def transform_with_context(self, that: Class, context: ContextT) -> T:
        """Double-dispatch on :paramref:`that`."""
        return that.transform_with_context(self, context)

    @abc.abstractmethod
    def transform_list_of_primitives_with_context(
        self, that: ListOfPrimitives, context: ContextT
    ) -> T:
        """Transform :paramref:`that` in :paramref:`context`."""
        raise NotImplementedError()


class TransformerWithDefault(AbstractTransformer[T]):
    """
    Transform the instances of the model.

    If you do not override the transformation methods, they simply
    return :py:attr:`.default`.
    """

    #: Default value which is returned if no override of the transformation
    default: T

    def __init__(self, default: T) -> None:
        """Initialize with the given :paramref:`default` value."""
        self.default = default

    def transform(self, that: Class) -> T:
        """Double-dispatch on :paramref:`that`."""
        return that.transform(self)

    def transform_list_of_primitives(self, that: ListOfPrimitives) -> T:
        """Transform :paramref:`that`."""
        return self.default


class TransformerWithDefaultAndContext(AbstractTransformerWithContext[ContextT, T]):
    """
    Transform the instances of the model in context.

    If you do not override the transformation methods, they simply
    return :py:attr:`.default`.
    """

    #: Default value which is returned if no override of the transformation
    default: T

    def __init__(self, default: T) -> None:
        """Initialize with the given :paramref:`default` value."""
        self.default = default

    def transform_with_context(self, that: Class, context: ContextT) -> T:
        """Double-dispatch on :paramref:`that`."""
        return that.transform_with_context(self, context)

    def transform_list_of_primitives_with_context(
        self, that: ListOfPrimitives, context: ContextT
    ) -> T:
        """Transform :paramref:`that` in :paramref:`context`."""
        return self.default


# This code has been automatically generated by aas-core-codegen.
# Do NOT edit or append.
