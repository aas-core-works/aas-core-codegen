/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */

package test.verification;

import java.lang.Iterable;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.Collections;
import java.util.function.Consumer;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Objects;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.Set;
import java.util.Spliterator;
import java.util.Spliterators;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import aas_core.aas3_0.constants.*;
import aas_core.aas3_0.reporting.Reporting;
import aas_core.aas3_0.types.enums.*;
import aas_core.aas3_0.types.model.*;
import aas_core.aas3_0.visitation.AbstractTransformer;

public class Verification {
  /**
   * Hash allowed enum values for efficient validation of enums.
   */
  private static class EnumValueSet {

  }

  private static final Transformer transformer = new Transformer();

  private static class Transformer extends AbstractTransformer<Stream<Reporting.Error>> {
    @Override
    public Stream<Reporting.Error> transformListOfPrimitives(
      IListOfPrimitives that) {
      Stream<Reporting.Error> errorStream = Stream.empty();

      // No verification has been defined for ListOfPrimitives.

      return errorStream;
    }
  }

  public static Stream<Reporting.Error> verifyToErrorStream(IClass that) {
    return transformer.transform(that);
  }

  private static class ValidationErrorIterable implements Iterable<Reporting.Error> {
    private final IClass element;

    public ValidationErrorIterable(IClass element) {
      this.element = element;
  }

    @Override
    public Iterator<Reporting.Error> iterator() {
      Stream<Reporting.Error> stream = stream();

      return stream.iterator();
    }

    @Override
    public void forEach(Consumer<? super Reporting.Error> action) {
      Stream<Reporting.Error> stream = stream();

      stream.forEach(action);
    }

    @Override
    public Spliterator<Reporting.Error> spliterator() {
      Stream<Reporting.Error> stream = stream();

      return stream.spliterator();
    }

    private Stream<Reporting.Error> stream() {
      return Verification.verifyToErrorStream(element);
    }
  }

  /**
   * Verify the constraints of {@code that} recursively.
   *
   * @param that The instance of the meta-model to be verified
   */
  public static Iterable<Reporting.Error> verify(IClass that) {
    return new ValidationErrorIterable(that);
  }

  private static class Pair<A, B> {
    private final A first;
    private final B second;

    public Pair(A first, B second) {
      this.first = first;
      this.second = second;
    }

    public A getFirst() {
      return first;
    }

    public B getSecond() {
      return second;
    }
  }

  // Java 8 doesn't provide a split operation out of the box, so we have to ship our own.
  // Adapted from: https://stackoverflow.com/a/23529010
  private static <A, B> Stream<Pair<A, B>> zip(
    Stream<? extends A> a,
    Stream<? extends B> b) {
    Spliterator<? extends A> aSplit = Objects.requireNonNull(a).spliterator();
    Spliterator<? extends B> bSplit = Objects.requireNonNull(b).spliterator();

    int characteristics = aSplit.characteristics() & bSplit.characteristics() &
      ~(Spliterator.DISTINCT | Spliterator.SORTED);

    long zipSize = ((characteristics & Spliterator.SIZED) != 0)
      ? Math.min(aSplit.getExactSizeIfKnown(), bSplit.getExactSizeIfKnown())
      : -1;

    Iterator<A> aIter = Spliterators.iterator(aSplit);
    Iterator<B> bIter = Spliterators.iterator(bSplit);
    Iterator<Pair<A, B>> cIter = new Iterator<Pair<A, B>>() {
      @Override
      public boolean hasNext() {
        return aIter.hasNext() && bIter.hasNext();
      }

      @Override
      public Pair<A, B> next() {
        return new Pair<>(aIter.next(), bIter.next());
      }
    };

    Spliterator<Pair<A, B>> split = Spliterators.spliterator(cIter, zipSize, characteristics);
    return StreamSupport.stream(split, false);
  }
}

/*
 * This code has been automatically generated by aas-core-codegen.
 * Do NOT edit or append.
 */
