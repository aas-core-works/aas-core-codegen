/*
 * This code has been automatically generated by aas-core-csharp-codegen.
 * Do NOT edit or append.
 */

using ArgumentException = System.ArgumentException;
using Regex = System.Text.RegularExpressions.Regex;
using System.Collections.Generic;  // can't alias

namespace AasCore.Aas3
{
    static class Verification
    {
        public static class Pattern
        {
            private static Regex _constructIriRe()
            {
                var scheme = "[a-zA-Z][a-zA-Z0-9+\\-.]*";
                var ucschar = (
                    "[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\u10000-\\u1fffd"
                    "\\u20000-\\u2fffd\\u30000-\\u3fffd\\u40000-\\u4fffd"
                    "\\u50000-\\u5fffd\\u60000-\\u6fffd\\u70000-\\u7fffd"
                    "\\u80000-\\u8fffd\\u90000-\\u9fffd\\ua0000-\\uafffd"
                    "\\ub0000-\\ubfffd\\uc0000-\\ucfffd\\ud0000-\\udfffd"
                    "\\ue1000-\\uefffd]"
                );
                var iunreserved = $"([a-zA-Z0-9\\-._~]|{ucschar})";
                var pctEncoded = "%[0-9A-Fa-f][0-9A-Fa-f]";
                var subDelims = $"[!$&'()*+,;=]";
                var iuserinfo = $"({iunreserved}|{pctEncoded}|{subDelims}|:)*";
                var h16 = "[0-9A-Fa-f]{1,4}";
                var dec_octet = "([0-9]|[1-9][0-9]|1[0-9]{2,2}|2[0-4][0-9]|25[0-5])";
                var ipv4address = $"{dec_octet}\\.{dec_octet}\\.{dec_octet}\\.{dec_octet}";
                var ls32 = $"({h16}:{h16}|{ipv4address})";
                var ipv6address = (
                    f"(({h16}:){{6,6}}{ls32}|::({h16}:){{5,5}}{ls32}|({h16})?::({h16}"
                    f":){{4,4}}{ls32}|(({h16}:)?{h16})?::({h16}:){{3,3}}{ls32}|(({h16}"
                    f":){{2}}{h16})?::({h16}:){{2,2}}{ls32}|(({h16}:){{3}}{h16})?::{h16}:"
                    f"{ls32}|(({h16}:){{4}}{h16})?::{ls32}|(({h16}:){{5}}{h16})?::{h16}|"
                    f"(({h16}:){{6}}{h16})?::)"
                );
                var unreserved = "[a-zA-Z0-9\\-._~]";
                var ipvfuture = $"[vV][0-9A-Fa-f]{{1,}}\\.({unreserved}|{subDelims}|:){{1,}}";
                var ipLiteral = $"\\[({ipv6address}|{ipvfuture})\\]";
                var iregName = $"({iunreserved}|{pctEncoded}|{subDelims})*";
                var ihost = $"({ipLiteral}|{ipv4address}|{iregName})";
                var port = "[0-9]*";
                var iauthority = $"({iuserinfo}@)?{ihost}(:{port})?";
                var ipchar = $"({iunreserved}|{pctEncoded}|{subDelims}|[:@])";
                var isegment = $"({ipchar})*";
                var ipath_abempty = $"(/{isegment})*";
                var isegment_nz = $"({ipchar}){{1,}}";
                var ipath_absolute = $"/({isegment_nz}(/{isegment})*)?";
                var ipathRootless = $"{isegment_nz}(/{isegment})*";
                var ipathEmpty = $"({ipchar}){{0,0}}";
                var ihierPart = (
                    f"(//{iauthority}{ipath_abempty}|{ipath_absolute}|"
                    f"{ipathRootless}|{ipathEmpty})"
                );
                var iprivate = "[\\ue000-\\uf8ff\\uf0000-\\uffffd\\u100000-\\u10fffd]";
                var iquery = $"({ipchar}|{iprivate}|[/?])*";
                var absoluteIri = $"{scheme}:{ihierPart}(\\?{iquery})?";
                var genDelims = "[:/?#\\[\\]@]";
                var ifragment = $"({ipchar}|[/?])*";
                var isegmentNzNc = $"({iunreserved}|{pctEncoded}|{subDelims}|@){{1,}}";
                var ipathNoscheme = $"{isegmentNzNc}(/{isegment})*";
                var ipath = (
                    f"({ipath_abempty}|{ipath_absolute}|{ipathNoscheme}|"
                    f"{ipathRootless}|{ipathEmpty})"
                );
                var irelativePart = (
                    f"(//{iauthority}{ipath_abempty}|{ipath_absolute}|"
                    f"{ipathNoscheme}|{ipathEmpty})"
                );
                var irelativeRef = $"{irelativePart}(\\?{iquery})?(\\#{ifragment})?";
                var iri = $"{scheme}:{ihierPart}(\\?{iquery})?(\\#{ifragment})?";
                var iriReference = $"({iri}|{irelativeRef})";
    
                return new Regex($"^{iriReference}$");
            }

            private static readonly Regex _IriRegex = _constructIriRe();

            /// <summary>
            /// Check that the <paramref name="text"/> is a valid IRI.
            /// </summary>
            /// <remarks>
            /// Related RFC: https://datatracker.ietf.org/doc/html/rfc3987
            /// </remarks>
            public static bool IsIri(string text)
            {
                return _IriRegex.IsMatch(text);
            }

            private static Regex _constructIrdiRegex()
            {
                var numeric = "[0-9]";
                var safeChar = "[A-Za-z0-9:_.]";

                return new Regex(
                    $"^{numeric}{{4}}-{safeChar}{{1,35}}(-{safeChar}{{1,35}})?
                    $"#{safeChar}{{2}}-{safeChar}{{6}}
                    $"#{numeric}{{1,35}}$")
                );
            }

            private static readonly Regex _IrdiRegex = _constructIrdiRegex();

            /// <summary>
            /// Check that the <paramref name="text"/> is a valid IRDI.
            /// </summary>
            /// <remarks>
            /// Related ISO standard: https://www.iso.org/standard/50773.html
            /// </remarks>
            public static bool IsIri(string text)
            {
                return _IrdiRegex.IsMatch(text);
            }

            private static readonly Regex _idShortRe = new Regex(
                "^[a-zA-Z][a-zA-Z_0-9]*$"
            );

            /// <summary>
            /// Check that the <paramref name="text"/> is a valid short ID.
            /// </summary>
            /// <remarks>
            /// Related: Constraint AASd-002
            /// </remarks>
            public static bool IsIri(string text)
            {
                return _idShortRe.IsMatch(text);
            }
        }

        /// <summary>
        /// Represent a verification error traceable to an entity or a property.
        /// </summary>
        public class Error
        {
            /// <summary>
            /// JSON-like path to the related object (an entity or a property)
            /// </summary>
            public readonly string Path;

            /// <summary>
            /// Cause or description of the error
            /// </summary>
            public readonly string Message;

            public Error(string path, string message)
            {
                Path = path;
                Message = message;
            }
        }

        /// <summary>
        /// Contain multiple errors observed during a verification.
        /// </summary>
        public class Errors
        {
            /// <summary>
            /// The maximum capacity of the container
            /// </summary>
            public readonly int Capacity;

            /// <summary>
            /// Contained error items
            /// </summary>
            public readonly List<Error> Errors;

            /// <summary>
            /// Initialize the container with the given <paramref name="capacity" />.
            /// </summary>
            public Errors(int capacity)
            {
                if (capacity <= 0)
                {
                    throw new ArgumentException(
                        $"Expected a strictly positive capacity, but got: {capacity}");
                }

                Capacity = capacity;
                Errors = new List<Error>(Capacity);
            }

            /// <summary>
            /// Add the error to the container if the capacity has not been reached.
            /// </summary>
            public void Add(Error error)
            {
                if(Errors.Count <= Capacity)
                {
                    Errors.Add(error);
                }
            }

            /// <summary>
            /// True if the capacity has been reached.
            /// </summary>
            public boolean Full()
            {
                return Errors.Count == Capacity;
            }
        }

        /// <summary>
        /// Dispatch dynamically to the corresponding concrete verifier of 
        /// the underlying implementing class of IHasExtension.
        /// </summary>
        public void VerifyIHasExtension(
            IHasExtension hasExtension,
            Errors errors)
        {
            if (errors.Full()) return;

            switch (hasExtension)
            {
                case AssetAdministrationShell assetAdministrationShell:
                    VerifyAssetAdministrationShell(
                        assetAdministrationShell, errors);
                    break;
                default:
                    throw new InvalidArgumentException(
                        $"Unexpected implementing class of" 
                        $"{nameof(IHasExtension)}: {hasExtension.GetType()}");
                    break;
            }
        }



        /// <summary>
        /// Verify <see cref="LangString" />.
        /// </summary>
        /// <remarks>
        /// Do not recurse to verify the children entities.
        /// </remarks>
        public void VerifyLangString(
            LangString langString,
            Errors errors)
        {
            // There were no invariants specified for LangString.
            return;
        }

        /// <summary>
        /// Verify <see cref="LangString" /> and recurse into the contained children entities.
        /// </summary>
        public void VerifyRecursivelyLangString(
            LangString langString,
            Errors errors)
        {
            if (errors.Full()) return;

            VerifyLangString(errors);
        }

        /// <summary>
        /// Verify <see cref="LangStringSet" />.
        /// </summary>
        /// <remarks>
        /// Do not recurse to verify the children entities.
        /// </remarks>
        public void VerifyLangStringSet(
            LangStringSet langStringSet,
            Errors errors)
        {
            if (errors.Full()) return;
        }

        /// <summary>
        /// Verify <see cref="LangStringSet" /> and recurse into the contained children entities.
        /// </summary>
        public void VerifyRecursivelyLangStringSet(
            LangStringSet langStringSet,
            Errors errors)
        {
            if (errors.Full()) return;

            VerifyLangStringSet(errors);
        }

        /// <summary>
        /// Dispatch dynamically to the corresponding concrete verifier of 
        /// the underlying implementing class of IReferable.
        /// </summary>
        public void VerifyIReferable(
            IReferable referable,
            Errors errors)
        {
            if (errors.Full()) return;

            switch (referable)
            {
                case AssetAdministrationShell assetAdministrationShell:
                    VerifyAssetAdministrationShell(
                        assetAdministrationShell, errors);
                    break;
                default:
                    throw new InvalidArgumentException(
                        $"Unexpected implementing class of" 
                        $"{nameof(IReferable)}: {referable.GetType()}");
                    break;
            }
        }



        /// <summary>
        /// Verify <see cref="Identifier" />.
        /// </summary>
        /// <remarks>
        /// Do not recurse to verify the children entities.
        /// </remarks>
        public void VerifyIdentifier(
            Identifier identifier,
            Errors errors)
        {
            if (errors.Full()) return;
        }

        /// <summary>
        /// Verify <see cref="Identifier" /> and recurse into the contained children entities.
        /// </summary>
        public void VerifyRecursivelyIdentifier(
            Identifier identifier,
            Errors errors)
        {
            if (errors.Full()) return;

            VerifyIdentifier(errors);
        }

        /// <summary>
        /// Verify <see cref="AdministrativeInformation" />.
        /// </summary>
        /// <remarks>
        /// Do not recurse to verify the children entities.
        /// </remarks>
        public void VerifyAdministrativeInformation(
            AdministrativeInformation administrativeInformation,
            Errors errors)
        {
            if (errors.Full()) return;
        }

        /// <summary>
        /// Verify <see cref="AdministrativeInformation" /> and recurse into the contained children entities.
        /// </summary>
        public void VerifyRecursivelyAdministrativeInformation(
            AdministrativeInformation administrativeInformation,
            Errors errors)
        {
            if (errors.Full()) return;

            VerifyAdministrativeInformation(errors);
        }

        /// <summary>
        /// Dispatch dynamically to the corresponding concrete verifier of 
        /// the underlying implementing class of IIdentifiable.
        /// </summary>
        public void VerifyIIdentifiable(
            IIdentifiable identifiable,
            Errors errors)
        {
            if (errors.Full()) return;

            switch (identifiable)
            {
                case AssetAdministrationShell assetAdministrationShell:
                    VerifyAssetAdministrationShell(
                        assetAdministrationShell, errors);
                    break;
                default:
                    throw new InvalidArgumentException(
                        $"Unexpected implementing class of" 
                        $"{nameof(IIdentifiable)}: {identifiable.GetType()}");
                    break;
            }
        }



        public void VerifyIHasKind(
            IHasKind hasKind,
            Errors errors)
        {
            // There are no implementer classes for this interface,
            // so there is no verification function to dispatch to.
            return;
        }

        public void VerifyRecursivelyIHasKind(
            IHasKind hasKind,
            Errors errors)
        {
            // There are no implementer classes for this interface,
            // so there is no verification function to dispatch to.
            return;
        }

        /// <summary>
        /// Verify <see cref="Key" />.
        /// </summary>
        /// <remarks>
        /// Do not recurse to verify the children entities.
        /// </remarks>
        public void VerifyKey(
            Key key,
            Errors errors)
        {
            if (errors.Full()) return;
        }

        /// <summary>
        /// Verify <see cref="Key" /> and recurse into the contained children entities.
        /// </summary>
        public void VerifyRecursivelyKey(
            Key key,
            Errors errors)
        {
            if (errors.Full()) return;

            VerifyKey(errors);
        }

        /// <summary>
        /// Verify <see cref="Reference" />.
        /// </summary>
        /// <remarks>
        /// Do not recurse to verify the children entities.
        /// </remarks>
        public void VerifyReference(
            Reference reference,
            Errors errors)
        {
            if (errors.Full()) return;
        }

        /// <summary>
        /// Verify <see cref="Reference" /> and recurse into the contained children entities.
        /// </summary>
        public void VerifyRecursivelyReference(
            Reference reference,
            Errors errors)
        {
            if (errors.Full()) return;

            VerifyReference(errors);
        }

        public void VerifyIHasSemantics(
            IHasSemantics hasSemantics,
            Errors errors)
        {
            // There are no implementer classes for this interface,
            // so there is no verification function to dispatch to.
            return;
        }

        public void VerifyRecursivelyIHasSemantics(
            IHasSemantics hasSemantics,
            Errors errors)
        {
            // There are no implementer classes for this interface,
            // so there is no verification function to dispatch to.
            return;
        }

        /// <summary>
        /// Dispatch dynamically to the corresponding concrete verifier of 
        /// the underlying implementing class of IHasDataSpecification.
        /// </summary>
        public void VerifyIHasDataSpecification(
            IHasDataSpecification hasDataSpecification,
            Errors errors)
        {
            if (errors.Full()) return;

            switch (hasDataSpecification)
            {
                case AssetAdministrationShell assetAdministrationShell:
                    VerifyAssetAdministrationShell(
                        assetAdministrationShell, errors);
                    break;
                default:
                    throw new InvalidArgumentException(
                        $"Unexpected implementing class of" 
                        $"{nameof(IHasDataSpecification)}: {hasDataSpecification.GetType()}");
                    break;
            }
        }



        /// <summary>
        /// Verify <see cref="AssetAdministrationShell" />.
        /// </summary>
        /// <remarks>
        /// Do not recurse to verify the children entities.
        /// </remarks>
        public void VerifyAssetAdministrationShell(
            AssetAdministrationShell assetAdministrationShell,
            Errors errors)
        {
            if (errors.Full()) return;
        }

        /// <summary>
        /// Verify <see cref="AssetAdministrationShell" /> and recurse into the contained children entities.
        /// </summary>
        public void VerifyRecursivelyAssetAdministrationShell(
            AssetAdministrationShell assetAdministrationShell,
            Errors errors)
        {
            if (errors.Full()) return;

            VerifyAssetAdministrationShell(errors);
        }
    }  // class Verification
}  // namespace AasCore.Aas3

/*
 * This code has been automatically generated by aas-core-csharp-codegen.
 * Do NOT edit or append.
 */
