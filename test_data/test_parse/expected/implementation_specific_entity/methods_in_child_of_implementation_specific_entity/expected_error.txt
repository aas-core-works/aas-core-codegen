We do not know how to parse the AST node: ClassDef(name='Something', bases=[Name(id='Abstract', ctx=Load())], keywords=[], body=[FunctionDef(name='do_something', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=None, type_comment=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Pass()], decorator_list=[], returns=Constant(value=None, kind=None), type_comment=None)], decorator_list=[])
The code matched no pattern for transpilation at the parse stage: Pass()
We do not know how to parse the AST node: ClassDef(name='Abstract', bases=[], keywords=[], body=[Pass()], decorator_list=[Name(id='abstract', ctx=Load()), Name(id='implementation_specific', ctx=Load())])
Abstract classes can not be implementation-specific at the same time (otherwise we can not convert them to interfaces etc.)