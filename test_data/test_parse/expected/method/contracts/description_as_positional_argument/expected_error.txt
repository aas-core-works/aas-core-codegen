We do not know how to parse the AST node: ClassDef(name='Something', bases=[], keywords=[], body=[FunctionDef(name='do_something', args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=None, type_comment=None), arg(arg='x', annotation=Name(id='int', ctx=Load()), type_comment=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=[Pass()], decorator_list=[Call(func=Name(id='require', ctx=Load()), args=[Lambda(args=arguments(posonlyargs=[], args=[arg(arg='self', annotation=None, type_comment=None), arg(arg='x', annotation=None, type_comment=None)], vararg=None, kwonlyargs=[], kw_defaults=[], kwarg=None, defaults=[]), body=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='y', ctx=Load()), ops=[Lt()], comparators=[Name(id='x', ctx=Load())])), Constant(value='some contract', kind=None)], keywords=[])], returns=Name(id='int', ctx=Load()), type_comment=None)], decorator_list=[])
The code matched no pattern for transpilation at the parse stage: Pass()