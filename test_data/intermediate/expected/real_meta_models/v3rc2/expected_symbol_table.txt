SymbolTable(
  symbols=[
    ConstrainedPrimitive(
      name='Non_empty_string',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body="Comparison(\n  left=FunctionCall(\n    name='len',\n    args=[\n      Name(\n        identifier='self',\n        original_node=...)],\n    original_node=...),\n  op='GE',\n  right=Constant(\n    value=1,\n    original_node=...),\n  original_node=...)",
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=SymbolDescription(
        summary='<paragraph>Represent a string with at least one character.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    Enumeration(
      name='Build_in_list_types',
      literals=[
        EnumerationLiteral(
          name='Entities',
          value='ENTITIES',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='ID_refs',
          value='IDREFS',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='N_M_tokens',
          value='NMTOKENS',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          12,
          1],
        index=1,
        fragment=None),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Decimal_build_in_types',
      literals=[
        EnumerationLiteral(
          name='Integer',
          value='integer',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Long',
          value='long',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Int',
          value='int',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Short',
          value='short',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Byte',
          value='byte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='NonNegativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='positiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_integer',
          value='unsignedInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='unsignedLong',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='unsignedInt',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='unsignedShort',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='unsignedByte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='nonPositiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='negativeInteger',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          12,
          1],
        index=2,
        fragment=None),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Duration_build_in_types',
      literals=[
        EnumerationLiteral(
          name='Day_time_duration',
          value='dayTimeDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='yearMonthDuration',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          12,
          1],
        index=3,
        fragment=None),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Primitive_types',
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='anyURI',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='base64Binary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='boolean',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date',
          value='date',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time',
          value='dateTime',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Decimal',
          value='decimal',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Double',
          value='double',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Duration',
          value='duration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Float',
          value='float',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_day',
          value='gDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month',
          value='gMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month_day',
          value='gMonthDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Hey_binary',
          value='heyBinary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Notation',
          value='NOTATION',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Q_name',
          value='QName',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='string',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='time',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          12,
          1],
        index=4,
        fragment=None),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='String_build_in_types',
      literals=[
        EnumerationLiteral(
          name='Normalized_string',
          value='normalizedString',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Token',
          value='token',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Language',
          value='Language',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='N_C_name',
          value='NCName',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='ENTITY',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='ID',
          value='ID',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='IDREF',
          value='IDREF',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          12,
          1],
        index=5,
        fragment=None),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Data_type_def',
      literals=[
        EnumerationLiteral(
          name='Entities',
          value='ENTITIES',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='ID_refs',
          value='IDREFS',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='N_M_tokens',
          value='NMTOKENS',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Integer',
          value='integer',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Long',
          value='long',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Int',
          value='int',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Short',
          value='short',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Byte',
          value='byte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='NonNegativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='positiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_integer',
          value='unsignedInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='unsignedLong',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='unsignedInt',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='unsignedShort',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='unsignedByte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='nonPositiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='negativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Day_time_duration',
          value='dayTimeDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='yearMonthDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Any_URI',
          value='anyURI',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='base64Binary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='boolean',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date',
          value='date',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time',
          value='dateTime',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Decimal',
          value='decimal',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Double',
          value='double',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Duration',
          value='duration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Float',
          value='float',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_day',
          value='gDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month',
          value='gMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month_day',
          value='gMonthDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Hey_binary',
          value='heyBinary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Notation',
          value='NOTATION',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Q_name',
          value='QName',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='string',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='time',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Normalized_string',
          value='normalizedString',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Token',
          value='token',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Language',
          value='Language',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='N_C_name',
          value='NCName',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='ENTITY',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='ID',
          value='ID',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='IDREF',
          value='IDREF',
          description=None,
          parsed=...)],
      is_superset_of=[
        'Reference to Enumeration Build_in_list_types',
        'Reference to Enumeration Decimal_build_in_types',
        'Reference to Enumeration Duration_build_in_types',
        'Reference to Enumeration Primitive_types',
        'Reference to Enumeration String_build_in_types'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration listing all xsd anySimpleTypes</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConstrainedPrimitive(
      name='MIME_typed',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body="Comparison(\n  left=FunctionCall(\n    name='len',\n    args=[\n      Name(\n        identifier='self',\n        original_node=...)],\n    original_node=...),\n  op='GE',\n  right=Constant(\n    value=1,\n    original_node=...),\n  original_node=...)",
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...),
        Invariant(
          description=None,
          body="FunctionCall(\n  name='is_MIME_type',\n  args=[\n    Name(\n      identifier='self',\n      original_node=...)],\n  original_node=...)",
          specified_for='Reference to ConstrainedPrimitive MIME_typed',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=SymbolDescription(
        summary='<paragraph>Represent a string that follows the pattern of a MIME type.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    AbstractClass(
      name='Reference',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Reference',
        name='Reference',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Global_reference',
          'Reference to ConcreteClass Model_reference'],
        properties=[],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>Reference to either a model element of the same or another AAs or to an external\nentity.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Global_reference',
        'Reference to ConcreteClass Model_reference'],
      properties=[],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=None,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          10],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Reference to either a model element of the same or another AAs or to an external\nentity.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_extensions',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_extensions',
        name='Has_extensions',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_Event',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_list',
          'Reference to ConcreteClass Submodel_element_struct',
          'Reference to ConcreteClass View'],
        properties=[
          Property(
            name='extensions',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>Element that can be extended by proprietary extensions.</paragraph>',
          remarks=[
            '<paragraph>Note: Extensions are proprietary, i.e. they do not support global interoperability.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_Event',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_list',
        'Reference to ConcreteClass Submodel_element_struct',
        'Reference to ConcreteClass View'],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          1],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Element that can be extended by proprietary extensions.</paragraph>',
        remarks=[
          '<paragraph>Note: Extensions are proprietary, i.e. they do not support global interoperability.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Referable',
      inheritances=[
        'Reference to AbstractClass Has_extensions'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Referable',
        name='Referable',
        inheritances=[
          'Reference to Interface Has_extensions'],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_Event',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_list',
          'Reference to ConcreteClass Submodel_element_struct',
          'Reference to ConcreteClass View'],
        properties=[
          Property(
            name='extensions',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
              remarks=[
                '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
              constraints_by_identifier=[
                [
                  'AASd-002',
                  '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
                [
                  'AASd-117',
                  '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
                [
                  'AASd-003',
                  '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
                [
                  'AASd-022',
                  '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
                [
                  'AASd-027',
                  '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
                '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
              remarks=[
                '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>An element that is referable by its <AttributeReference refuri="~ID_short">~ID_short</AttributeReference>.</paragraph>',
          remarks=[
            '<paragraph>This identifier is not globally unique.\nThis identifier is unique within the name space of the element.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_Event',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_list',
        'Reference to ConcreteClass Submodel_element_struct',
        'Reference to ConcreteClass View'],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An element that is referable by its <AttributeReference refuri="~ID_short">~ID_short</AttributeReference>.</paragraph>',
        remarks=[
          '<paragraph>This identifier is not globally unique.\nThis identifier is unique within the name space of the element.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_kind',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_kind',
        name='Has_kind',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_Event',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_list',
          'Reference to ConcreteClass Submodel_element_struct'],
        properties=[
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default Value = Instance</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>An element with a kind is an element that can either represent a template or an\ninstance.</paragraph>',
          remarks=[
            '<paragraph>Default for an element is that it is representing an instance.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_Event',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_list',
        'Reference to ConcreteClass Submodel_element_struct'],
      properties=[
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          4],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An element with a kind is an element that can either represent a template or an\ninstance.</paragraph>',
        remarks=[
          '<paragraph>Default for an element is that it is representing an instance.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_semantics',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_semantics',
        name='Has_semantics',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_Event',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass Extension',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Identifier_key_value_pair',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Qualifier',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_list',
          'Reference to ConcreteClass Submodel_element_struct',
          'Reference to ConcreteClass View'],
        properties=[
          Property(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>Element that can have a semantic definition.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_Event',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass Extension',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Identifier_key_value_pair',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Qualifier',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_list',
        'Reference to ConcreteClass Submodel_element_struct',
        'Reference to ConcreteClass View'],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          6],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Element that can have a semantic definition.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Qualifiable',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Qualifiable',
        name='Qualifiable',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_Event',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_list',
          'Reference to ConcreteClass Submodel_element_struct'],
        properties=[
          Property(
            name='qualifiers',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Constraint',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>The value of a qualifiable element may be further qualified by one or more\nqualifiers or complex formulas.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_Event',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_list',
        'Reference to ConcreteClass Submodel_element_struct'],
      properties=[
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          7],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>The value of a qualifiable element may be further qualified by one or more\nqualifiers or complex formulas.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_data_specification',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_data_specification',
        name='Has_data_specification',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Administrative_information',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_Event',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_list',
          'Reference to ConcreteClass Submodel_element_struct',
          'Reference to ConcreteClass View'],
        properties=[
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>Element that can be extended by using data specification templates.</paragraph>',
          remarks=[
            '<paragraph>A data specification template defines a named set of additional attributes an\nelement may or shall have. The data specifications used are explicitly specified\nwith their global ID.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Administrative_information',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_Event',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_list',
        'Reference to ConcreteClass Submodel_element_struct',
        'Reference to ConcreteClass View'],
      properties=[
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          12],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Element that can be extended by using data specification templates.</paragraph>',
        remarks=[
          '<paragraph>A data specification template defines a named set of additional attributes an\nelement may or shall have. The data specifications used are explicitly specified\nwith their global ID.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Submodel_element',
      inheritances=[
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_kind',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Submodel_element',
        name='Submodel_element',
        inheritances=[
          'Reference to Interface Referable',
          'Reference to Interface Has_kind',
          'Reference to Interface Has_semantics',
          'Reference to Interface Qualifiable',
          'Reference to Interface Has_data_specification'],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_Event',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel_element_list',
          'Reference to ConcreteClass Submodel_element_struct'],
        properties=[
          Property(
            name='extensions',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
              remarks=[
                '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
              constraints_by_identifier=[
                [
                  'AASd-002',
                  '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
                [
                  'AASd-117',
                  '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
                [
                  'AASd-003',
                  '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
                [
                  'AASd-022',
                  '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
                [
                  'AASd-027',
                  '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
                '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
              remarks=[
                '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default Value = Instance</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Constraint',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>A submodel element is an element suitable for the description and differentiation of\nassets.</paragraph>',
          remarks=[
            '<paragraph>It is recommended to add a semantic ID to a submodel element.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_Event',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel_element_list',
        'Reference to ConcreteClass Submodel_element_struct'],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          6],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A submodel element is an element suitable for the description and differentiation of\nassets.</paragraph>',
        remarks=[
          '<paragraph>It is recommended to add a semantic ID to a submodel element.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Qualifier',
      inheritances=[
        'Reference to AbstractClass Constraint',
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The qualifier type describes the type of the qualifier that is applied to\nthe element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Data type of the qualifier value.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The qualifier value is the value of the qualifier.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='type',\n  argument='type',\n  default=None)",
          "AssignArgument(\n  name='value_type',\n  argument='value_type',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)",
          "AssignArgument(\n  name='value_ID',\n  argument='value_ID',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          10],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A qualifier is a type-value-pair that makes additional statements w.r.t.  the value\nof the element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_element',
        name='Data_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element'],
        properties=[
          Property(
            name='extensions',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
              remarks=[
                '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
              constraints_by_identifier=[
                [
                  'AASd-002',
                  '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
                [
                  'AASd-117',
                  '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
                [
                  'AASd-003',
                  '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
                [
                  'AASd-022',
                  '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
                [
                  'AASd-027',
                  '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
                '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
              remarks=[
                '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default Value = Instance</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Constraint',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>A data element is a submodel element that is not further composed out of\nother submodel elements.</paragraph>',
          remarks=[
            '<paragraph>A data element is a submodel element that has a value. The type of value differs\nfor different subtypes of data elements.</paragraph>'],
          constraints_by_identifier=[
            [
              'AASd-090',
              '<field_body><paragraph>For data elements DataElement/category shall be one of the\nfollowing values: CONSTANT, PARAMETER or VARIABLE.\nException: File and Blob data elements.</paragraph></field_body>']],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          5],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A data element is a submodel element that is not further composed out of\nother submodel elements.</paragraph>',
        remarks=[
          '<paragraph>A data element is a submodel element that has a value. The type of value differs\nfor different subtypes of data elements.</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-090',
            '<field_body><paragraph>For data elements DataElement/category shall be one of the\nfollowing values: CONSTANT, PARAMETER or VARIABLE.\nException: File and Blob data elements.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Reference_element',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to any other referable element of the same of any other AAS or a\nreference to an external object or entity.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference_element',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          13],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A reference element is a data element that defines a logical reference to another\nelement within the same or another AAS or a reference to an external object or\nentity.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-054',
            '<field_body><paragraph>If the semanticId of a ReferenceElement submodel element\nreferences a ConceptDescription then the ConceptDescription/category shall be\none of following values: REFERENCE.</paragraph></field_body>'],
          [
            'AASd-082',
            '<field_body><paragraph>If the semanticId of a ReferenceElement references a\nConceptDescription then DataSpecificationIEC61360/dataType shall be one of:\nSTRING, IRI, IRDI.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Global_reference',
      inheritances=[
        'Reference to AbstractClass Reference'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='values',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Unique reference. The reference can be a concatenation of different identifiers,\nfor example to an IRDI path etc.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Global_reference',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='values',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='values',\n  argument='values',\n  default=None)"]),
      invariants=[
        Invariant(
          description=None,
          body="Comparison(\n  left=FunctionCall(\n    name='len',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='values',\n        original_node=...)],\n    original_node=...),\n  op='GE',\n  right=Constant(\n    value=1,\n    original_node=...),\n  original_node=...)",
          specified_for='Reference to ConcreteClass Global_reference',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          10],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Reference to an external entity.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Model_reference',
      inheritances=[
        'Reference to AbstractClass Reference'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='keys',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Key',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Unique references in their name space.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Model_reference',
          parsed=...),
        Property(
          name='referred_semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>SemanticId of the referenced model element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Model_reference',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='keys',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Key',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='referred_semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='keys',\n  argument='keys',\n  default=None)",
          "AssignArgument(\n  name='referred_semantic_ID',\n  argument='referred_semantic_ID',\n  default=None)"]),
      invariants=[
        Invariant(
          description=None,
          body="Comparison(\n  left=FunctionCall(\n    name='len',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='keys',\n        original_node=...)],\n    original_node=...),\n  op='GE',\n  right=Constant(\n    value=1,\n    original_node=...),\n  original_node=...)",
          specified_for='Reference to ConcreteClass Model_reference',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          10],
        index=2,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Reference to a model element of the same or another AAS.\nA model reference is an ordered list of keys, each key referencing an element.\nThe complete list of keys may for example be concatenated to a path that then gives\nunique access to an element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Key',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Key_elements',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Key',
          parsed=...),
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Key',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Key_elements',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='type',\n  argument='type',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          10],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A key is a reference to an element by its id.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Extension',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='name',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Name of the extension.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-077',
                '<field_body><paragraph>The name of an extension within HasExtensions needs to be unique.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Type of the value of the extension.</paragraph>',
            remarks=[
              '<paragraph>Default: xsd:string</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Value of the extension</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='refers_to',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to an element the extension refers to.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='name',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Data_type_def',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='refers_to',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='name',\n  argument='name',\n  default=None)",
          "AssignArgument(\n  name='value_type',\n  argument='value_type',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)",
          "AssignArgument(\n  name='refers_to',\n  argument='refers_to',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          1],
        index=2,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Single extension of an element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Identifiable',
      inheritances=[
        'Reference to AbstractClass Referable'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Identifiable',
        name='Identifiable',
        inheritances=[
          'Reference to Interface Referable'],
        implementers=[
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Submodel'],
        properties=[
          Property(
            name='extensions',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
              remarks=[
                '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
              constraints_by_identifier=[
                [
                  'AASd-002',
                  '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
                [
                  'AASd-117',
                  '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
                [
                  'AASd-003',
                  '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
                [
                  'AASd-022',
                  '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
                [
                  'AASd-027',
                  '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
                '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
              remarks=[
                '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='ID',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The globally unique identification of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Identifiable',
            parsed=...),
          Property(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
              remarks=[
                '<note><paragraph>Some of the administrative information like the version number might need to\nbe part of the identification.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Identifiable',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>An element that has a globally unique identifier.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Submodel'],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              '<note><paragraph>Some of the administrative information like the version number might need to\nbe part of the identification.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='ID',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='ID',\n  argument='ID',\n  default=None)",
          "AssignArgument(\n  name='administration',\n  argument='administration',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          3],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An element that has a globally unique identifier.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Modeling_kind',
      literals=[
        EnumerationLiteral(
          name='Template',
          value='TEMPLATE',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Software element which specifies the common attributes shared by all instances of\nthe template.</paragraph>',
            remarks=[
              '<paragraph>[SOURCE: IEC TR 62390:2005-01, 3.1.25] modified</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Instance',
          value='INSTANCE',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Concrete, clearly identifiable component of a certain template.</paragraph>',
            remarks=[
              '<note><paragraph>It becomes an individual entity of a  template,  for example a\ndevice model, by defining specific property values.</paragraph></note>',
              '<note><paragraph>In an object oriented view,  an instance denotes an object of a\ntemplate (class).</paragraph></note>',
              '<paragraph>[SOURCE: IEC 62890:2016, 3.1.16 65/617/CDV]  modified</paragraph>'],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          4],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration for denoting whether an element is a template or an instance.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Administrative_information',
      inheritances=[
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='version',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Version of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...),
        Property(
          name='revision',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Revision of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='version',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='revision',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='version',\n  argument='version',\n  default=None)",
          "AssignArgument(\n  name='revision',\n  argument='revision',\n  default=None)"]),
      invariants=[
        Invariant(
          description='Constraint AASd-005',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='revision',\n      original_node=...),\n    original_node=...),\n  consequent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='version',\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          5],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Administrative meta-information for an element like version information.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Constraint',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Constraint',
        name='Constraint',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Formula',
          'Reference to ConcreteClass Qualifier'],
        properties=[],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>A constraint is used to further qualify or restrict an element.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Formula',
        'Reference to ConcreteClass Qualifier'],
      properties=[],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=None,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          8],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A constraint is used to further qualify or restrict an element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Formula',
      inheritances=[
        'Reference to AbstractClass Constraint'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='depends_on',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>A formula may depend on referable or even external global elements that are used in\nthe logical expression.</paragraph>',
            remarks=[
              '<paragraph>The value of the referenced elements needs to be accessible so that it can be\nevaluated in the formula to true or false in the corresponding logical expression\nit is used in.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Formula',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='depends_on',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='depends_on',\n  argument='depends_on',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          2,
          11],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A formula is used to describe constraints by a logical expression.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Asset_administration_shell',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              '<note><paragraph>Some of the administrative information like the version number might need to\nbe part of the identification.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='derived_from',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Model_reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The reference to the AAS the AAS was derived from.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Property(
          name='asset_information',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Asset_information',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Meta-information about the asset the AAS is representing.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Property(
          name='submodels',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Model_reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>References to submodels of the AAS.</paragraph>',
            remarks=[
              '<paragraph>A submodel is a description of an aspect of the asset the AAS is representing.\nThe asset of an AAS is typically described by one or more submodels. Temporarily\nno submodel might be assigned to the AAS.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='ID',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='asset_information',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Asset_information',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='derived_from',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Model_reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodels',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Model_reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='ID',\n  argument='ID',\n  default=None)",
          "AssignArgument(\n  name='administration',\n  argument='administration',\n  default=None)",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='derived_from',\n  argument='derived_from',\n  default=None)",
          "AssignArgument(\n  name='asset_information',\n  argument='asset_information',\n  default=None)",
          "AssignArgument(\n  name='submodels',\n  argument='submodels',\n  default=None)"]),
      invariants=[
        Invariant(
          description='derived_from points to an Asset Administration Shell',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='derived_from',\n      original_node=...),\n    original_node=...),\n  consequent=FunctionCall(\n    name='is_model_reference_to',\n    args=[\n      Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='derived_from',\n        original_node=...),\n      Member(\n        instance=Name(\n          identifier='Key_elements',\n          original_node=...),\n        name='Submodel',\n        original_node=...)],\n    original_node=...),\n  original_node=...)",
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Invariant(
          description='Submodel references point to a submodel',
          body="Implication(\n  antecedent=IsNotNone(\n    value=Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='submodels',\n      original_node=...),\n    original_node=...),\n  consequent=All(\n    for_each=ForEach(\n      variable=Name(\n        identifier='submodel',\n        original_node=...),\n      iteration=Member(\n        instance=Name(\n          identifier='self',\n          original_node=...),\n        name='submodels',\n        original_node=...),\n      original_node=...),\n    condition=FunctionCall(\n      name='is_model_reference_to',\n      args=[\n        Name(\n          identifier='submodel',\n          original_node=...),\n        Member(\n          instance=Name(\n            identifier='Key_elements',\n            original_node=...),\n          name='Submodel',\n          original_node=...)],\n      original_node=...),\n    original_node=...),\n  original_node=...)",
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          3],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Structure a digital representation of an asset.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Asset_information',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='asset_kind',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Asset_kind',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Denotes whether the Asset is of kind "Type" or "Instance".</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='global_asset_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to either an Asset object or a global reference to the asset the AAS is\nrepresenting.</paragraph>',
            remarks=[
              '<paragraph>This attribute is required as soon as the AAS is exchanged via partners in the life\ncycle of the asset. In a first phase of the life cycle the asset might not yet have\na global ID but already an internal identifier. The internal identifier would be\nmodelled via <AttributeReference refuri="~specific_asset_ID">~specific_asset_ID</AttributeReference>.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='specific_asset_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Identifier_key_value_pair',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional domain-specific, typically proprietary, Identifier for the asset.</paragraph>',
            remarks=[
              '<paragraph>For example, serial number.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='default_thumbnail',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol File',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Thumbnail of the asset represented by the asset administration shell.</paragraph>',
            remarks=[
              '<paragraph>Used as default.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='asset_kind',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Asset_kind',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='global_asset_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='specific_asset_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Identifier_key_value_pair',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='default_thumbnail',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol File',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='asset_kind',\n  argument='asset_kind',\n  default=None)",
          "AssignArgument(\n  name='global_asset_ID',\n  argument='global_asset_ID',\n  default=None)",
          "AssignArgument(\n  name='specific_asset_ID',\n  argument='specific_asset_ID',\n  default=None)",
          "AssignArgument(\n  name='default_thumbnail',\n  argument='default_thumbnail',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          4],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Identifying meta data of the asset that is represented by an AAS.</paragraph>',
        remarks=[
          '<paragraph>The asset may either represent an asset type or an asset instance. The asset has\na globally unique identifier plus – if needed – additional domain-specific\n(proprietary) identifiers. However, to support the corner case of very first\nphase of lifecycle where a stabilised/constant global asset identifier does not\nalready exist, the corresponding attribute <AttributeReference refuri="~global_asset_ID">~global_asset_ID</AttributeReference> is optional.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Asset_kind',
      literals=[
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=EnumerationLiteralDescription(
            summary='<paragraph>hardware or software element which specifies the common attributes shared by all\ninstances of the type</paragraph>',
            remarks=[
              '<paragraph>[SOURCE: IEC TR 62390:2005-01, 3.1.25]</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=EnumerationLiteralDescription(
            summary='<paragraph>concrete, clearly identifiable component of a certain type</paragraph>',
            remarks=[
              '<note><paragraph>It becomes an individual entity of a type, for example a device, by defining\nspecific property values.</paragraph></note>',
              '<note><paragraph>In an object oriented view, an instance denotes an object of a class\n(of a type).</paragraph></note>',
              '<paragraph>[SOURCE: IEC 62890:2016, 3.1.16] 65/617/CDV</paragraph>'],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          4],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration for denoting whether an element is a type or an instance.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Identifier_key_value_pair',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='key',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Key of the identifier</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-116',
                '<field_body><paragraph>“globalAssetId” (case-insensitive) is a reserved key. If used\nas value for IdentifierKeyValuePair/key IdentifierKeyValuePair/value shall be\nidentical to AssetInformation/globalAssetId.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Identifier_key_value_pair',
          parsed=...),
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the identifier with the corresponding key.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Identifier_key_value_pair',
          parsed=...),
        Property(
          name='external_subject_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The (external) subject the key belongs to or has meaning to.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Identifier_key_value_pair',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='key',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='external_subject_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='key',\n  argument='key',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)",
          "AssignArgument(\n  name='external_subject_ID',\n  argument='external_subject_ID',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          4],
        index=2,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An IdentifierKeyValuePair describes a generic identifier as key-value pair.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_kind',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              '<note><paragraph>Some of the administrative information like the version number might need to\nbe part of the identification.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='submodel_elements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_element',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>A submodel consists of zero or more submodel elements.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='ID',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodel_elements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='ID',\n  argument='ID',\n  default=None)",
          "AssignArgument(\n  name='administration',\n  argument='administration',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='submodel_elements',\n  argument='submodel_elements',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          5],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A submodel defines a specific aspect of the asset represented by the AAS.</paragraph>',
        remarks=[
          '<paragraph>A submodel is used to structure the digital representation and technical\nfunctionality of an Administration Shell into distinguishable parts. Each submodel\nrefers to a well-defined domain or subject matter. Submodels can become\nstandardized and, thus, become submodels templates.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Relationship_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Relationship_element',
        name='Relationship_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element'],
        properties=[
          Property(
            name='extensions',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
              remarks=[
                '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
              constraints_by_identifier=[
                [
                  'AASd-002',
                  '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
                [
                  'AASd-117',
                  '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
                [
                  'AASd-003',
                  '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
                [
                  'AASd-022',
                  '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
                [
                  'AASd-027',
                  '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
                '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
              remarks=[
                '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default Value = Instance</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Constraint',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...),
          Property(
            name='first',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Relationship_element',
            parsed=...),
          Property(
            name='second',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Relationship_element',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>A relationship element is used to define a relationship between two referable\nelements.</paragraph>',
          remarks=[],
          constraints_by_identifier=[
            [
              'AASd-055',
              '<field_body><paragraph>If the semanticId of a RelationshipElement or an\nAnnotatedRelationshipElement submodel element references a ConceptDescription\nthen the ConceptDescription/category shall be one of following values:\nRELATIONSHIP.</paragraph></field_body>']],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='first',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Relationship_element',
          parsed=...),
        Property(
          name='second',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Relationship_element',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='first',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='second',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='first',\n  argument='first',\n  default=None)",
          "AssignArgument(\n  name='second',\n  argument='second',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          14],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A relationship element is used to define a relationship between two referable\nelements.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-055',
            '<field_body><paragraph>If the semanticId of a RelationshipElement or an\nAnnotatedRelationshipElement submodel element references a ConceptDescription\nthen the ConceptDescription/category shall be one of following values:\nRELATIONSHIP.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel_element_list',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='submodel_element_type_values',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Submodel_elements',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The submodel element type of the submodel elements contained in the list.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-108',
                '<field_body><paragraph>All first level child elements in a SubmodelElementList shall\nhave the same submodel element type as specified in\nSubmodelElementList/submodelElementTypeValues.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='values',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_element',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Submodel element contained in the struct.\nThe list is ordered.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='semantic_ID_values',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Semantic Id the submodel elements contained in the list match to.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-107',
                '<field_body><paragraph>If a first level child element in a SubmodelElementList has\na semanticId it shall be identical to SubmodelElementList/semanticIdValues.</paragraph></field_body>'],
              [
                'AASd-114',
                '<field_body><paragraph>If two first level child elements in a SubmodelElementList have\na semanticId then they shall be identical.</paragraph></field_body>'],
              [
                'AASd-115',
                '<field_body><paragraph>If a first level child element in a SubmodelElementList does\nnot specify a semanticId then the value is assumed to be identical to\nSubmodelElementList/semanticIdValues.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='value_type_values',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value type of the submodel element contained in the list.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-109',
                '<field_body><paragraph>If SubmodelElementList/submodelElementTypeValues equal to\nProperty or Range SubmodelElementList/valueTypeValues shall be set and all first\nlevel child elements in the SubmodelElementList shall have the the value type\nas specified</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='submodel_element_type_values',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_elements',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='values',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID_values',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_type_values',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Data_type_def',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='submodel_element_type_values',\n  argument='submodel_element_type_values',\n  default=None)",
          "AssignArgument(\n  name='values',\n  argument='values',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='semantic_ID_values',\n  argument='semantic_ID_values',\n  default=None)",
          "AssignArgument(\n  name='value_type_values',\n  argument='value_type_values',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          15],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A submodel element list is an ordered collection of submodel elements.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-093',
            '<field_body><paragraph>If the semanticId of a SubmodelElementList references\na ConceptDescription then the ConceptDescription/category shall be COLLECTION.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel_element_struct',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='values',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_element',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Submodel element contained in the struct.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_struct',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='values',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='values',\n  argument='values',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          16],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A submodel element struct is is a logical encapsulation of multiple values. It has\na number of of submodel elements.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-092',
            '<field_body><paragraph>If the semanticId of a SubmodelElementStruct references\na ConceptDescription then the ConceptDescription/category shall be ENTITY.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Property',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Data type of the value</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the property instance.</paragraph>',
            remarks=[
              '<paragraph>See <ConstraintReference refuri="AASd-065">AASd-065</ConstraintReference>\nSee <ConstraintReference refuri="AASd-007">AASd-007</ConstraintReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the global unique id of a coded value.</paragraph>',
            remarks=[
              '<paragraph>See <ConstraintReference refuri="AASd-065">AASd-065</ConstraintReference>\nSee <ConstraintReference refuri="AASd-007">AASd-007</ConstraintReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='value_type',\n  argument='value_type',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)",
          "AssignArgument(\n  name='value_ID',\n  argument='value_ID',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          11],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A property is a data element that has a single value.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-007',
            '<field_body><paragraph>If both, the Property/value and the Property/valueId are\npresent then the value of Property/value needs to be identical to the value of\nthe referenced coded value in Property/valueId.</paragraph></field_body>'],
          [
            'AASd-052a',
            '<field_body><paragraph>If the semanticId of a Property references a\nConceptDescription then the ConceptDescription/category shall be one of\nfollowing values: VALUE, PROPERTY.</paragraph></field_body>'],
          [
            'AASd-065',
            '<field_body><paragraph>If the semanticId of a Property or MultiLanguageProperty\nreferences a ConceptDescription with the category VALUE then the value of the\nproperty is identical to DataSpecificationIEC61360/value and the valueId of the\nproperty is identical to DataSpecificationIEC61360/valueId.</paragraph></field_body>'],
          [
            'AASd-066',
            '<field_body><paragraph>If the semanticId of a Property or MultiLanguageProperty\nreferences a ConceptDescription with the category PROPERTY and\nDataSpecificationIEC61360/valueList is defined the value and valueId of the\nproperty is identical to one of the value reference pair types references in the\nvalue list, i.e. ValueReferencePairType/value or ValueReferencePairType/valueId,\nresp.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Multi_language_property',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the property instance.\nSee <ConstraintReference refuri="AASd-012">AASd-012</ConstraintReference>\nSee <ConstraintReference refuri="AASd-065">AASd-065</ConstraintReference></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the global unique id of a coded value.\nSee <ConstraintReference refuri="AASd-012">AASd-012</ConstraintReference>\nSee <ConstraintReference refuri="AASd-065">AASd-065</ConstraintReference></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)",
          "AssignArgument(\n  name='value_ID',\n  argument='value_ID',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          9],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A property is a data element that has a multi-language value.</paragraph>',
        remarks=[
          '<paragraph>See <ConstraintReference refuri="AASd-065">AASd-065</ConstraintReference></paragraph>',
          '<paragraph>See <ConstraintReference refuri="AASd-066">AASd-066</ConstraintReference></paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-052b',
            '<field_body><paragraph>If the semanticId of a MultiLanguageProperty references\na ConceptDescription then the ConceptDescription/category shall be one of\nfollowing values: PROPERTY.</paragraph></field_body>'],
          [
            'AASd-012',
            '<field_body><paragraph>If both, the MultiLanguageProperty/value and the\nMultiLanguageProperty/valueId are present then for each string in a specific\nlanguage the meaning must be the same as specified in\nMultiLanguageProperty/valueId.</paragraph></field_body>'],
          [
            'AASd-067',
            '<field_body><paragraph>If the semanticId of a MultiLanguageProperty references a\nConceptDescription then DataSpecificationIEC61360/dataType shall be\nSTRING_TRANSLATABLE.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Range',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Data type of the min und max</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Property(
          name='min',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The minimum value of the range.\nIf the min value is missing, then the value is assumed to be negative infinite.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Property(
          name='max',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The maximum value of the range.\nIf the max value is missing,  then the value is assumed to be positive infinite.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='min',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='max',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='value_type',\n  argument='value_type',\n  default=None)",
          "AssignArgument(\n  name='min',\n  argument='min',\n  default=None)",
          "AssignArgument(\n  name='max',\n  argument='max',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          12],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A range data element is a data element that defines a range with min and max.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-053',
            '<field_body><paragraph>If the semanticId of a Range submodel element references a\nConceptDescription then the ConceptDescription/category shall be one of\nfollowing values: PROPERTY.</paragraph></field_body>'],
          [
            'AASd-068',
            '<field_body><paragraph>If the semanticId of a Range submodel element references a\nConceptDescription then DataSpecificationIEC61360/dataType shall be a numerical\none, i.e. REAL_* or RATIONAL_*.</paragraph></field_body>'],
          [
            'AASd-069',
            '<field_body><paragraph>If the semanticId of a Range references a ConceptDescription\nthen DataSpecificationIEC61360/levelType shall be identical to the set\n{Min, Max}.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Blob',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='MIME_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol MIME_typed',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Mime type of the content of the BLOB.\nThe mime type states which file extensions the file can have.\nValid values are e.g. “application/json”, “application/xls”, ”image/jpg”\nThe allowed values are defined as in RFC2046.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Blob',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=PrimitiveTypeAnnotation(
              a_type='BYTEARRAY',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the BLOB instance of a blob data element.</paragraph>',
            remarks=[
              '<note><paragraph>In contrast to the file property the file content is stored directly as value\nin the Blob data element.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Blob',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='MIME_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol MIME_typed',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=PrimitiveTypeAnnotation(
                a_type='BYTEARRAY',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='MIME_type',\n  argument='MIME_type',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)"]),
      invariants=[
        Invariant(
          description=None,
          body="FunctionCall(\n  name='is_MIME_type',\n  args=[\n    Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='MIME_type',\n      original_node=...)],\n  original_node=...)",
          specified_for='Reference to ConcreteClass Blob',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          4],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A BLOB is a data element that represents a file that is contained with its source\ncode in the value attribute.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-057',
            '<field_body><paragraph>The semanticId of a File or Blob submodel element shall only\nreference a ConceptDescription with the category DOCUMENT.</paragraph></field_body>'],
          [
            'AASd-083',
            '<field_body><paragraph>If the semanticId of a Blob references a ConceptDescription\nthen DataSpecificationIEC61360/dataType shall be one of: BLOB, HTML.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='File',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='MIME_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol MIME_typed',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>MIME type of the content of the BLOB.\nThe MIME type states which file extensions the file can have.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass File',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Path and name of the referenced file (with file extension).\nThe path can be absolute or relative.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass File',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='MIME_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol MIME_typed',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='MIME_type',\n  argument='MIME_type',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)"]),
      invariants=[
        Invariant(
          description=None,
          body="FunctionCall(\n  name='is_MIME_type',\n  args=[\n    Member(\n      instance=Name(\n        identifier='self',\n        original_node=...),\n      name='MIME_type',\n      original_node=...)],\n  original_node=...)",
          specified_for='Reference to ConcreteClass File',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          8],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A File is a data element that represents an address to a file.\nThe value is an URI that can represent an absolute or relative path.</paragraph>',
        remarks=[
          '<paragraph>See <ConstraintReference refuri="AASd-057">AASd-057</ConstraintReference></paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-079',
            '<field_body><paragraph>If the semanticId of a File references a\nConceptDescription then DataSpecificationIEC61360/dataType shall be one of:\nFILE.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Annotated_relationship_element',
      inheritances=[
        'Reference to AbstractClass Relationship_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='first',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Relationship_element',
          parsed=...),
        Property(
          name='second',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Relationship_element',
          parsed=...),
        Property(
          name='annotation',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Data_element',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>A reference to a data element that represents an annotation that holds for\nthe relationship between the two elements.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Annotated_relationship_element',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='first',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='second',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='annotation',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Data_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='first',\n  argument='first',\n  default=None)",
          "AssignArgument(\n  name='second',\n  argument='second',\n  default=None)",
          "AssignArgument(\n  name='annotation',\n  argument='annotation',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          1],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An annotated relationship element is a relationship element that can be annotated\nwith additional data elements.</paragraph>',
        remarks=[
          '<paragraph>See <ConstraintReference refuri="AASd-055">AASd-055</ConstraintReference></paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Entity_type',
      literals=[
        EnumerationLiteral(
          name='Co_managed_entity',
          value='COMANAGEDENTITY',
          description=EnumerationLiteralDescription(
            summary='<paragraph>For co-managed entities there is no separate AAS. Co-managed entities need to be\npart of a self-managed entity.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Self_managed_entity',
          value='SELFMANAGEDENTITY',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Self-Managed Entities have their own AAS but can be part of the bill of material of\na composite self-managed entity. The asset of an I4.0 Component is a self-managed\nentity per definition."</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          6],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration for denoting whether an entity is a self-managed entity or a co-managed\nentity.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Entity',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='entity_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Entity_type',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Describes whether the entity is a co- managed entity or a self-managed entity.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='statements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_element',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Describes statements applicable to the entity by a set of submodel elements,\ntypically with a qualified value.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='global_asset_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the asset the entity is representing.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-014',
                '<field_body><paragraph>Either the attribute globalAssetId or specificAssetId of an\nEntity must be set if Entity/entityType is set to “SelfManagedEntity”. They are\nnot existing otherwise.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='specific_asset_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Identifier_key_value_pair',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to an identifier key value pair representing a specific identifier\nof the asset represented by the asset administration shell.</paragraph>',
            remarks=[
              '<paragraph>See <ConstraintReference refuri="AASd-014">AASd-014</ConstraintReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='entity_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Entity_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='statements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='global_asset_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='specific_asset_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Identifier_key_value_pair',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='statements',\n  argument='statements',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='entity_type',\n  argument='entity_type',\n  default=None)",
          "AssignArgument(\n  name='global_asset_ID',\n  argument='global_asset_ID',\n  default=None)",
          "AssignArgument(\n  name='specific_asset_ID',\n  argument='specific_asset_ID',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          6],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An entity is a submodel element that is used to model entities.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-056',
            '<field_body><paragraph>If the semanticId of a Entity submodel element\nreferences a ConceptDescription then the ConceptDescription/category shall\nbe one of following values: ENTITY. The ConceptDescription describes\nthe elements assigned to the entity via Entity/statement.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Event',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Event',
        name='Event',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Basic_Event'],
        properties=[
          Property(
            name='extensions',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
              remarks=[
                '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
              constraints_by_identifier=[
                [
                  'AASd-002',
                  '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
                [
                  'AASd-117',
                  '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
                [
                  'AASd-003',
                  '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
                [
                  'AASd-022',
                  '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
                [
                  'AASd-027',
                  '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
                '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
              remarks=[
                '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default Value = Instance</paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Constraint',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>An event.</paragraph>',
          remarks=[],
          constraints_by_identifier=[
            [
              'AASd-061',
              '<field_body><paragraph>If the semanticId of a Event submodel element references a\nConceptDescription then the category of the ConceptDescription shall be one of\nthe following: EVENT.</paragraph></field_body>']],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Basic_Event'],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          7],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An event.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-061',
            '<field_body><paragraph>If the semanticId of a Event submodel element references a\nConceptDescription then the category of the ConceptDescription shall be one of\nthe following: EVENT.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Basic_Event',
      inheritances=[
        'Reference to AbstractClass Event'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='observed',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to a referable, e.g. a data element or a submodel, that is being\nobserved.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_Event',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='observed',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='observed',\n  argument='observed',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A basic event.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Operation',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='input_variables',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Operation_variable',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Input parameter of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Property(
          name='output_variables',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Operation_variable',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Output parameter of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Property(
          name='inoutput_variables',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Operation_variable',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Parameter that is input and output of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='input_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='output_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='inoutput_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='input_variables',\n  argument='input_variables',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='output_variables',\n  argument='output_variables',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='inoutput_variables',\n  argument='inoutput_variables',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          10],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An operation is a submodel element with input and output variables.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-060',
            '<field_body><paragraph>If the semanticId of a Operation submodel element\nreferences a ConceptDescription then the category of the ConceptDescription\nshall be one of the following values: FUNCTION.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Operation_variable',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Submodel_element',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Describes the needed argument for an operation via a submodel element</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation_variable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_element',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          10],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An operation variable is a submodel element that is used as input or output variable\nof an operation.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Capability',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default Value = Instance</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Constraint',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Constraint',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='kind',\n  argument='kind',\n  default=DefaultEnumLiteral(\n    node=...,\n    enum='Reference to Enumeration Modeling_kind',\n    literal='Reference to EnumerationLiteral Instance'))",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='qualifiers',\n  argument='qualifiers',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          7,
          3],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A capability is the implementation-independent description of the potential of an\nasset to achieve a certain effect in the physical or virtual world.</paragraph>',
        remarks=[
          '<note><paragraph>The semanticId of a capability is typically an ontology. Thus, reasoning on\ncapabilities is enabled.</paragraph></note>'],
        constraints_by_identifier=[
          [
            'AASd-058',
            '<field_body><paragraph>If the semanticId of a Capability submodel element references\na ConceptDescription then the ConceptDescription/category shall be CAPABILITY.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Concept_description',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='ID',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              '<note><paragraph>Some of the administrative information like the version number might need to\nbe part of the identification.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='is_case_of',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to an external definition the concept is compatible to or was derived from</paragraph>',
            remarks=[
              '<note><paragraph>Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360"</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='ID',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='is_case_of',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='ID',\n  argument='ID',\n  default=None)",
          "AssignArgument(\n  name='administration',\n  argument='administration',\n  default=None)",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='is_case_of',\n  argument='is_case_of',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          8],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>The semantics of a property or other elements that may have a semantic description\nis defined by a concept description. The description of the concept should follow a\nstandardized schema (realized as data specification template).</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-051',
            '<field_body><paragraph>A ConceptDescription shall have one of the following categories\nVALUE, PROPERTY, REFERENCE, DOCUMENT, CAPABILITY, RELATIONSHIP, COLLECTION,\nFUNCTION, EVENT, ENTITY, APPLICATION_CLASS, QUALIFIER, VIEW. Default: PROPERTY.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='View',
      inheritances=[
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='ID_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>In case of identifiables this attribute is a short name of the element.\nIn case of referable this ID is an identifying string of\nthe element within its name space.</paragraph>',
            remarks=[
              '<note><paragraph>In case the element is a property and the property has a semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) conformant to IEC61360 the idShort is typically\nidentical to the short name in English.</paragraph></note>'],
            constraints_by_identifier=[
              [
                'AASd-002',
                '<field_body><paragraph>idShort of Referables shall only feature letters, digits,\nunderscore ("_"); starting mandatory with a letter. I.e. <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>\nException: In case of direct submodel elements within a SubmodelElementList the\nidShort shall feature a sequence of digits representing an integer. I.e. <literal>[0]</literal>\nor <literal>[1-9][0-9]+</literal>.</paragraph></field_body>'],
              [
                'AASd-117',
                '<field_body><paragraph>For all Referables which are not Identifiables the idShort is mandatory.</paragraph></field_body>'],
              [
                'AASd-003',
                '<field_body><paragraph>idShort shall be matched case-sensitive.</paragraph></field_body>'],
              [
                'AASd-022',
                '<field_body><paragraph>idShort of non-identifiable referables shall be unique in its namespace.</paragraph></field_body>'],
              [
                'AASd-027',
                '<field_body><paragraph>idShort of Referables shall have a maximum length of 128 characters.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              '<paragraph>If no display name is defined in the language requested by the application,\nthen the display name is selected in the following order if available:</paragraph>',
              '<bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,\nthen the corresponding preferred name in the language is chosen\naccording to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining\nthe semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description-the idShort of the element</paragraph></list_item></bullet_list>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The category is a value that gives further meta information\nw.r.t. to the class of the element.\nIt affects the expected existence of attributes and the applicability of\nconstraints.</paragraph>',
            remarks=[
              '<note><paragraph>The category is not identical to the semantic definition\n(<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category\n<emphasis>e.g.</emphasis> could denote that the element is a measurement value whereas the\nsemantic definition of the element would\ndenote that it is the measured temperature.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages. If no description is defined,\nthen the definition of the concept description that defines the semantics\nof the element is used. Additional information can be provided,\n<emphasis>e.g.</emphasis>, if the element is qualified and which qualifier types can be expected\nin which context or which additional data specification templates are provided.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='semantic_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Identifier of the semantic definition of the element. It is called semantic ID\nof the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='contained_elements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to a referable element that is contained in the view.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass View',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ID_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='contained_elements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='extensions',\n  argument='extensions',\n  default=EmptyList(\n    node=...))",
          "AssignArgument(\n  name='ID_short',\n  argument='ID_short',\n  default=None)",
          "AssignArgument(\n  name='display_name',\n  argument='display_name',\n  default=None)",
          "AssignArgument(\n  name='category',\n  argument='category',\n  default=None)",
          "AssignArgument(\n  name='description',\n  argument='description',\n  default=None)",
          "AssignArgument(\n  name='semantic_ID',\n  argument='semantic_ID',\n  default=None)",
          "AssignArgument(\n  name='data_specifications',\n  argument='data_specifications',\n  default=None)",
          "AssignArgument(\n  name='contained_elements',\n  argument='contained_elements',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          9],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A view is a collection of referable elements w.r.t. to a specific viewpoint of one\nor more stakeholders.</paragraph>',
        remarks=[
          '<note><paragraph>Views are a projection of submodel elements for a given perspective.\nThey are not equivalent to submodels.</paragraph></note>'],
        constraints_by_identifier=[
          [
            'AASd-064',
            '<field_body><paragraph>If the semanticId of a View references a ConceptDescription\nthen the category of the ConceptDescription shall be VIEW.</paragraph></field_body>']],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Identifiable_elements',
      literals=[
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          11],
        index=8,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of all identifiable elements within an asset administration shell.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Referable_elements',
      literals=[
        EnumerationLiteral(
          name='Access_permission_rule',
          value='AccessPermissionRule',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset',
          value='Asset',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event',
          value='BasicEvent',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Data element.</paragraph>',
            remarks=[
              '<note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Data_element">~Data_element</AttributeReference>\nthe reference may be a Property, a File <emphasis>etc.</emphasis></paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event',
          value='Event',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event.</paragraph>',
            remarks=[
              '<note><paragraph>Event is abstract.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              '<note><paragraph>Submodel Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Submodel_element">~Submodel_element</AttributeReference>\nthe reference may be a Property, a SubmodelElementCollection,\nan Operation <emphasis>etc.</emphasis></paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=EnumerationLiteralDescription(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_struct',
          value='SubmodelElementStruct',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[
        'Reference to Enumeration Identifiable_elements'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          10],
        index=3,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of all referable elements within an asset administration shell</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Key_elements',
      literals=[
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=EnumerationLiteralDescription(
            summary='<paragraph>unique reference to an element within a file.</paragraph>',
            remarks=[
              '<paragraph>The file itself is assumed to be part of an asset administration shell.</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Access_permission_rule',
          value='AccessPermissionRule',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset',
          value='Asset',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event',
          value='BasicEvent',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Data element.</paragraph>',
            remarks=[
              '<note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Data_element">~Data_element</AttributeReference>\nthe reference may be a Property, a File <emphasis>etc.</emphasis></paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event',
          value='Event',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event.</paragraph>',
            remarks=[
              '<note><paragraph>Event is abstract.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Property with a value that can be provided in multiple languages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Range with min and max</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              '<note><paragraph>Submodel Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Submodel_element">~Submodel_element</AttributeReference>\nthe reference may be a Property, a SubmodelElementCollection`,\nan Operation <emphasis>etc.</emphasis></paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=EnumerationLiteralDescription(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_struct',
          value='SubmodelElementStruct',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[
        'Reference to Enumeration Referable_elements'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          10],
        index=2,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Submodel_elements',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Annotated relationship element</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Asset',
          value='Asset',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Asset</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Asset Administration Shell</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Basic_event',
          value='BasicEvent',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Basic Event</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Blob</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Capability</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Concept Description</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Data Element.</paragraph>',
            remarks=[
              '<note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses “DataElement” the reference may\nbe a Property, a File etc.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Entity</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Event',
          value='Event',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event</paragraph>',
            remarks=[
              '<note><paragraph>Event is abstract</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=EnumerationLiteralDescription(
            summary='<paragraph>File</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Property with a value that can be provided in multiple languages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Operation</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Property</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Range with min and max</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Reference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Relationship</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Submodel</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              '<note><paragraph>Submodel Element is abstract, i.e. if a key uses “SubmodelElement”\nthe reference may be a Property, a SubmodelElementList,\nan Operation etc.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=EnumerationLiteralDescription(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_struct',
          value='SubmodelElementStruct',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          10],
        index=7,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of all referable elements within an asset administration shell.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Lang_string_set',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=True,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=None,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          7,
          12,
          2],
        index=2,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A set of strings, each annotated by the language of the string.</paragraph>',
        remarks=[
          '<paragraph>The meaning of the string in each language shall be the same.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_specification_content',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_specification_content',
        name='Data_specification_content',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Data_specification_IEC61360',
          'Reference to ConcreteClass Data_specification_physical_unit'],
        properties=[],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>Missing summary.</paragraph>',
          remarks=[
            '<note><paragraph>The Data Specification Templates do not belong to the meta-model of the Asset\nAdministration Shell. In serializations that choose specific templates\nthe corresponding data specification content may be directly incorporated.</paragraph></note>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Data_specification_IEC61360',
        'Reference to ConcreteClass Data_specification_physical_unit'],
      properties=[],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=None,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          1],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Missing summary.</paragraph>',
        remarks=[
          '<note><paragraph>The Data Specification Templates do not belong to the meta-model of the Asset\nAdministration Shell. In serializations that choose specific templates\nthe corresponding data specification content may be directly incorporated.</paragraph></note>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Data_type_IEC61360',
      literals=[
        EnumerationLiteral(
          name='Date',
          value='DATE',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd\nExample from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:\n31 May 1999.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='STRING',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values consisting of sequence of characters but cannot be translated into other\nlanguages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='String_translatable',
          value='STRING_TRANSLATABLE',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing string but shall be represented as different string in different\nlanguages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_Measure',
          value='INTEGER_MEASURE',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing values that are measure of type INTEGER. In addition such a value\ncomes with a physical unit.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_count',
          value='INTEGER_COUNT',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing values of type INTEGER but are no currencies or measures</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_currency',
          value='INTEGER_CURRENCY',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing values of type INTEGER that are currencies</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_measure',
          value='REAL_MEASURE',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing values that are measures of type REAL. In addition such a value\ncomes with a physical unit.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_count',
          value='REAL_COUNT',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing numbers that can be written as a terminating or non-terminating\ndecimal; a rational or irrational number but are no currencies or measures</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_currency',
          value='REAL_CURRENCY',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing values of type REAL that are currencies</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='BOOLEAN',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values representing truth of logic or Boolean algebra (TRUE, FALSE)</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='IRI',
          value='IRI',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing values of type STRING conformant to Rfc 3987</paragraph>',
            remarks=[
              '<note><paragraph>In IEC61360-1 (2017) only URI is supported. An Iri type allows in particular to\nexpress a URL or an URI</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='IRDI',
          value='IRDI',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values conforming to ISO/IEC 11179 series global identifier sequences IRDI can be\nused instead of the more specific data types ICID or ISO29002_IRDI. ICID values are\nvalue conformant to an IRDI, where the delimiter between RAI and ID is “#” while the\ndelimiter between DI and VI is confined to “##” ISO29002_IRDI values are values\ncontaining a global identifier that identifies an administrated item in a registry.\nThe structure of this identifier complies with identifier syntax defined in ISO/TS\n29002-5. The identifier shall fulfill the requirements specified in ISO/TS 29002-5\nfor an "international registration data identifier" (IRDI).</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Rational',
          value='RATIONAL',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing values of type rational</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Rational_measure',
          value='RATIONAL_MEASURE',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing values of type rational.\nIn addition such a value comes with a physical unit.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='TIME',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing a time, conformant to ISO 8601:2004 but restricted to\nwhat is allowed in the corresponding type in xml.\nFormat hh:mm (ECLASS) Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME]\nrepresentation of: 1.20 p.m. for Eastern Standard Time,\nwhich is 5 hours behind Coordinated Universal Time (UTC).</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Timestamp',
          value='TIMESTAMP',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing a time, conformant to ISO 8601:2004 but restricted to\nwhat is allowed in the corresponding type in xml. Format yyyy-mm-dd hh:mm (ECLASS)</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='FILE',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing an address to a file. The values are of type URI and can represent\nan absolute or relative path. IEC61360 does not support the file type.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='HTML',
          value='HTML',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Values containing string with any sequence of characters, using the syntax of HTML5\n(see W3C Recommendation 28:2014)</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='BLOB',
          description=EnumerationLiteralDescription(
            summary='<paragraph>values containing the content of a file. Values may be binaries.\nHTML conformant to HTML5 is a special blob. In IEC61360 binary is for a sequence of\nbits, each bit being represented by “0” and “1” only. A binary is a blob but a blob\nmay also contain other source code.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=2,
        fragment=None),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Level_type',
      literals=[
        EnumerationLiteral(
          name='Min',
          value='Min',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Max',
          value='Max',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Nom',
          value='Nom',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=5,
        fragment=None),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Value_reference_pair',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the referenced concept definition of the value in valueId.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_reference_pair',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global unique id of the value.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-078',
                '<field_body><paragraph>If the valueId of a ValueReferencePair references a\nConceptDescription then the ConceptDescription/category shall be one of\nfollowing values: VALUE.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_reference_pair',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)",
          "AssignArgument(\n  name='value_ID',\n  argument='value_ID',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=4,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A value reference pair within a value list. Each value has a global unique id\ndefining its semantic.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Value_list',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value_reference_pairs',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Value_reference_pair',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>A pair of a value together with its global unique id.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_list',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_reference_pairs',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Value_reference_pair',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='value_reference_pairs',\n  argument='value_reference_pairs',\n  default=EmptyList(\n    node=...))"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=3,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A set of value reference pairs.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Data_specification_IEC61360',
      inheritances=[
        'Reference to AbstractClass Data_specification_content'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='preferred_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Preferred name</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-076',
                '<field_body><paragraph>For all ConceptDescriptions using data specification template\nIEC61360\n(<reference refuri="http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0">http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0</reference>)\nat least a preferred name in English shall be defined.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='short_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Short name</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='unit',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Unit</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='unit_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Unique unit id</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='source_of_definition',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Source of definition</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='symbol',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Symbol</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='data_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_IEC61360',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Data Type</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-070',
                '<field_body><paragraph>For a ConceptDescription with category PROPERTY or VALUE using\ndata specification template IEC61360\n(<reference refuri="http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0">http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0</reference>) -\nDataSpecificationIEC61360/dataType is mandatory and shall be defined.</paragraph></field_body>'],
              [
                'AASd-071',
                '<field_body><paragraph>For a ConceptDescription with category REFERENCE using data\nspecification template IEC61360\n(<reference refuri="http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0">http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0</reference>) -\nDataSpecificationIEC61360/dataType is STRING by default.</paragraph></field_body>'],
              [
                'AASd-072',
                '<field_body><paragraph>For a ConceptDescription with category DOCUMENT using data\nspecification template IEC61360\n(<reference refuri="http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0">http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0</reference>) -\nDataSpecificationIEC61360/dataType shall be one of the following values: STRING or\nURL.</paragraph></field_body>'],
              [
                'AASd-073',
                '<field_body><paragraph>For a ConceptDescription with category QUALIFIER using data\nspecification template IEC61360\n(<reference refuri="http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0">http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0</reference>) -\nDataSpecificationIEC61360/dataType is mandatory and shall be defined.</paragraph></field_body>'],
              [
                'AASd-103',
                '<field_body><paragraph>If DataSpecificationIEC61360/-dataType one of: INTEGER_MEASURE,\nREAL_MEASURE, RATIONAL_MEASURE, INTEGER_CURRENCY, REAL_CURRENCY, then\nDataSpecificationIEC61360/unit or DataSpecificationIEC61360/unitId shall be\ndefined.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='definition',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Definition in different languages</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-074',
                '<field_body><paragraph>For all ConceptDescriptions except for ConceptDescriptions of\ncategory VALUE using data specification template IEC61360\n(<reference refuri="http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0">http://admin-shell.io/DataSpecificationTemplates/DataSpecificationIEC61360/2/0</reference>) -\nDataSpecificationIEC61360/definition is mandatory and shall be defined at least\nin English.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='value_format',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Value Format</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='value_list',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Value_list',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>List of allowed values</paragraph>',
            remarks=[
              '<paragraph>See <ConstraintReference refuri="AASd-102">AASd-102</ConstraintReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Value</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-101',
                '<field_body><paragraph>If DataSpecificationIEC61360/category equal to VALUE then\nDataSpecificationIEC61360/value shall be set.</paragraph></field_body>'],
              [
                'AASd-102',
                '<field_body><paragraph>If DataSpecificationIEC61360/value or\nDataSpecificationIEC61360/valueId is not empty then\nDataSpecificationIEC61360/valueList shall be empty and vice versa.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='value_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Unique value id</paragraph>',
            remarks=[
              '<paragraph>See <ConstraintReference refuri="AASd-102">AASd-102</ConstraintReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...),
        Property(
          name='level_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Level_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Set of levels.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC61360',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='preferred_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='short_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='unit',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='unit_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='source_of_definition',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='symbol',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Data_type_IEC61360',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='definition',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_format',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_list',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Value_list',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='level_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Level_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='preferred_name',\n  argument='preferred_name',\n  default=None)",
          "AssignArgument(\n  name='short_name',\n  argument='short_name',\n  default=None)",
          "AssignArgument(\n  name='unit',\n  argument='unit',\n  default=None)",
          "AssignArgument(\n  name='unit_ID',\n  argument='unit_ID',\n  default=None)",
          "AssignArgument(\n  name='source_of_definition',\n  argument='source_of_definition',\n  default=None)",
          "AssignArgument(\n  name='symbol',\n  argument='symbol',\n  default=None)",
          "AssignArgument(\n  name='data_type',\n  argument='data_type',\n  default=None)",
          "AssignArgument(\n  name='definition',\n  argument='definition',\n  default=None)",
          "AssignArgument(\n  name='value_format',\n  argument='value_format',\n  default=None)",
          "AssignArgument(\n  name='value_list',\n  argument='value_list',\n  default=None)",
          "AssignArgument(\n  name='value',\n  argument='value',\n  default=None)",
          "AssignArgument(\n  name='value_ID',\n  argument='value_ID',\n  default=None)",
          "AssignArgument(\n  name='level_type',\n  argument='level_type',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          2,
          3],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Content of data specification template for concept descriptions conformant to\nIEC 61360.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Data_specification_physical_unit',
      inheritances=[
        'Reference to AbstractClass Data_specification_content'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='unit_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Unit Name</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='unit_symbol',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Unit Symbol</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='definition',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Definition</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='SI_notation',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>SI Notation</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='DIN_notation',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>DIN Notation</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='ECE_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>ECE Name</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='ECE_code',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>ECE Code</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='NIST_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>NIST Name</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='source_of_definition',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Source Of Definition</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='conversion_factor',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Conversion Factor</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='registration_authority_ID',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Registration Authority ID</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='supplier',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Supplier</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='unit_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='unit_symbol',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='definition',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='SI_notation',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='DIN_notation',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ECE_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ECE_code',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='NIST_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='source_of_definition',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='conversion_factor',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='registration_authority_ID',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplier',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='unit_name',\n  argument='unit_name',\n  default=None)",
          "AssignArgument(\n  name='unit_symbol',\n  argument='unit_symbol',\n  default=None)",
          "AssignArgument(\n  name='definition',\n  argument='definition',\n  default=None)",
          "AssignArgument(\n  name='SI_notation',\n  argument='SI_notation',\n  default=None)",
          "AssignArgument(\n  name='DIN_notation',\n  argument='DIN_notation',\n  default=None)",
          "AssignArgument(\n  name='ECE_name',\n  argument='ECE_name',\n  default=None)",
          "AssignArgument(\n  name='ECE_code',\n  argument='ECE_code',\n  default=None)",
          "AssignArgument(\n  name='NIST_name',\n  argument='NIST_name',\n  default=None)",
          "AssignArgument(\n  name='source_of_definition',\n  argument='source_of_definition',\n  default=None)",
          "AssignArgument(\n  name='conversion_factor',\n  argument='conversion_factor',\n  default=None)",
          "AssignArgument(\n  name='registration_authority_ID',\n  argument='registration_authority_ID',\n  default=None)",
          "AssignArgument(\n  name='supplier',\n  argument='supplier',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          8,
          3,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>TODO</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Environment',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='asset_administration_shells',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Asset_administration_shell',
                parsed=...),
              parsed=...),
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='submodels',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Submodel',
                parsed=...),
              parsed=...),
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='concept_descriptions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Concept_description',
                parsed=...),
              parsed=...),
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Environment',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='asset_administration_shells',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Asset_administration_shell',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodels',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='concept_descriptions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Concept_description',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          "AssignArgument(\n  name='asset_administration_shells',\n  argument='asset_administration_shells',\n  default=None)",
          "AssignArgument(\n  name='submodels',\n  argument='submodels',\n  default=None)",
          "AssignArgument(\n  name='concept_descriptions',\n  argument='concept_descriptions',\n  default=None)"]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=None,
      description=SymbolDescription(
        summary='<paragraph>Model the environment as the entry point for referencing and serialization.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...)],
  symbols_topologically_sorted=[
    'Reference to symbol Has_data_specification',
    'Reference to symbol Administrative_information',
    'Reference to symbol Has_extensions',
    'Reference to symbol Referable',
    'Reference to symbol Has_kind',
    'Reference to symbol Has_semantics',
    'Reference to symbol Qualifiable',
    'Reference to symbol Submodel_element',
    'Reference to symbol Relationship_element',
    'Reference to symbol Annotated_relationship_element',
    'Reference to symbol Identifiable',
    'Reference to symbol Asset_administration_shell',
    'Reference to symbol Asset_information',
    'Reference to symbol Event',
    'Reference to symbol Basic_Event',
    'Reference to symbol Data_element',
    'Reference to symbol Blob',
    'Reference to symbol Capability',
    'Reference to symbol Concept_description',
    'Reference to symbol Constraint',
    'Reference to symbol Data_specification_content',
    'Reference to symbol Data_specification_IEC61360',
    'Reference to symbol Data_specification_physical_unit',
    'Reference to symbol Entity',
    'Reference to symbol Environment',
    'Reference to symbol Extension',
    'Reference to symbol File',
    'Reference to symbol Formula',
    'Reference to symbol Reference',
    'Reference to symbol Global_reference',
    'Reference to symbol Identifier_key_value_pair',
    'Reference to symbol Key',
    'Reference to symbol Lang_string_set',
    'Reference to symbol Non_empty_string',
    'Reference to symbol MIME_typed',
    'Reference to symbol Model_reference',
    'Reference to symbol Multi_language_property',
    'Reference to symbol Operation',
    'Reference to symbol Operation_variable',
    'Reference to symbol Property',
    'Reference to symbol Qualifier',
    'Reference to symbol Range',
    'Reference to symbol Reference_element',
    'Reference to symbol Submodel',
    'Reference to symbol Submodel_element_list',
    'Reference to symbol Submodel_element_struct',
    'Reference to symbol Value_list',
    'Reference to symbol Value_reference_pair',
    'Reference to symbol View'],
  verification_functions=[
    PatternVerification(
      name='is_MIME_type',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of MIME type.</paragraph>',
        remarks=[],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+|"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*"))*'),
    ImplementationSpecificVerification(
      name='is_model_reference_to',
      arguments=[
        Argument(
          name='reference',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Model_reference',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='expected_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Key_elements',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that the target of the model reference matches the expected <literal>target</literal>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...)],
  verification_functions_by_name=...,
  meta_model=MetaModel(
    description=MetaModelDescription(
      summary='<paragraph>Provide the meta model for Asset Administration Shell V3 Release Candidate 1.</paragraph>',
      remarks=[],
      constraints_by_identifier=[],
      parsed=...),
    book_url='__book_url__',
    book_version='__book_version__'))