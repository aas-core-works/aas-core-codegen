SymbolTable(
  our_types=[
    ConstrainedPrimitive(
      name='Non_empty_string',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='Constraint AASd-100: An attribute with data type ``string`` is not allowed to be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent a string with at least one character.</paragraph>',
        remarks=[
          '<paragraph>This allows us to model the following constraint.</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-100',
            '<field_body><paragraph>An attribute with data type <literal>string</literal> is not allowed to be empty.</paragraph></field_body>']],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Date_time_stamp_UTC',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='The value must match the pattern of xs:dateTimeStamp with the time zone fixed to UTC.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_xs_date_time_stamp_utc',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Date_time_stamp_UTC',
          parsed=...),
        Invariant(
          description='The value must represent a valid xs:dateTimeStamp with the time zone fixed to UTC.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_xs_date_time_stamp_utc',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Date_time_stamp_UTC',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent an <literal>xs:dateTimeStamp</literal> with the time zone fixed to UTC.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Blob_type',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='BYTEARRAY',
      is_implementation_specific=False,
      invariants=[],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Group of bytes to represent file content (binaries and non-binaries)</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Identifier',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='Constraint AASd-100: An attribute with data type ``string`` is not allowed to be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>string</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='BCP_47_language_tag',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='The value must represent a value language tag conformant to BCP 47.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_BCP_47',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive BCP_47_language_tag',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent a language tag conformant to BCP 47.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://en.wikipedia.org/wiki/IETF_language_tag">https://en.wikipedia.org/wiki/IETF_language_tag</reference></paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Content_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='Constraint AASd-100: An attribute with data type ``string`` is not allowed to be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...),
        Invariant(
          description='The value must represent a valid content MIME type according to RFC 2046.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_MIME_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Content_type',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>string</paragraph>',
        remarks=[
          '<note><paragraph>Any content type as in RFC2046.</paragraph></note>',
          textwrap.dedent("""\
            <paragraph>A media type (also MIME type and content type) […] is a two-part
            identifier for file formats and format contents transmitted on
            the Internet. The Internet Assigned Numbers Authority (IANA) is
            the official authority for the standardization and publication of
            these classifications. Media types were originally defined in
            Request for Comments 2045 in November 1996 as a part of MIME
            (Multipurpose Internet Mail Extensions) specification, for denoting
            type of email message content and attachments.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Path_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='Constraint AASd-100: An attribute with data type ``string`` is not allowed to be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...),
        Invariant(
          description='The value must represent a valid file URI scheme according to RFC 8089.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_RFC_8089_path',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Path_type',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>string</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>Any string conformant to RFC8089 , the “file” URI scheme (for
            relative and absolute file paths)</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Qualifier_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='Constraint AASd-100: An attribute with data type ``string`` is not allowed to be empty.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>string</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Value_data_type',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=DescriptionOfOurType(
        summary='<paragraph>any xsd atomic type as specified via <ReferenceToOurType refuri=".Data_type_def_XSD">.Data_type_def_XSD</ReferenceToOurType></paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Id_short',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='Constraint AASd-027: ID-short shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Id_short',
          parsed=...),
        Invariant(
          description='ID-short of Referables shall only feature letters, digits, underscore (``_``); starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_id_short',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Id_short',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=DescriptionOfOurType(
        summary='<paragraph>Represent a short ID of an <ReferenceToOurType refuri=".Referable">.Referable</ReferenceToOurType>.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-002',
            textwrap.dedent("""\
              <field_body><paragraph>ID-short of <ReferenceToOurType refuri=".Referable">.Referable</ReferenceToOurType>'s shall only feature letters, digits,
              underscore (<literal>_</literal>); starting mandatory with a letter.
              <emphasis>I.e.</emphasis> <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>.</paragraph></field_body>""")],
          [
            'AASd-027',
            textwrap.dedent("""\
              <field_body><paragraph>ID-short of <ReferenceToOurType refuri=".Referable">.Referable</ReferenceToOurType>'s shall have a maximum length
              of 128 characters.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...),
    AbstractClass(
      name='Has_semantics',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_semantics',
        name='Has_semantics',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass Extension',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Qualifier',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Specific_asset_id',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>Element that can have a semantic definition plus some supplemental semantic
            definitions.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[
            [
              'AASd-118',
              textwrap.dedent("""\
                <field_body><paragraph>If there are ID <ReferenceToAttribute refuri="~Has_semantics.supplemental_semantic_ids">~Has_semantics.supplemental_semantic_ids</ReferenceToAttribute> defined
                then there shall be also a main semantic ID <ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>.</paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass Extension',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Qualifier',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Specific_asset_id',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          6],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Element that can have a semantic definition plus some supplemental semantic
          definitions.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-118',
            textwrap.dedent("""\
              <field_body><paragraph>If there are ID <ReferenceToAttribute refuri="~Has_semantics.supplemental_semantic_ids">~Has_semantics.supplemental_semantic_ids</ReferenceToAttribute> defined
              then there shall be also a main semantic ID <ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Extension',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='name',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Name of the extension.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-077',
                '<field_body><paragraph>The name of an extension within <ReferenceToOurType refuri=".Has_extensions">.Has_extensions</ReferenceToOurType> needs to be unique.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Type of the value of the extension.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Data_type_def_XSD.String">~Data_type_def_XSD.String</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Value of the extension</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='refers_to',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to an element the extension refers to.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='value_type_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Extension',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='name',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Data_type_def_XSD',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='refers_to',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='name',
              argument='name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='refers_to',
              argument='refers_to',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='The value must match the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_or_default',
                      original_node=...),
                    args=[],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          1],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Single extension of an element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_extensions',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_extensions',
        name='Has_extensions',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>Element that can be extended by proprietary extensions.</paragraph>',
          remarks=[
            '<note><paragraph>Extensions are proprietary, i.e. they do not support global interoperability.</paragraph></note>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          1],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Element that can be extended by proprietary extensions.</paragraph>',
        remarks=[
          '<note><paragraph>Extensions are proprietary, i.e. they do not support global interoperability.</paragraph></note>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Referable',
      inheritances=[
        'Reference to AbstractClass Has_extensions'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Referable',
        name='Referable',
        inheritances=[
          'Reference to Interface Has_extensions'],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                  the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>An element that is referable by its <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute>.</paragraph>',
          remarks=[
            textwrap.dedent("""\
              <paragraph>This ID is not globally unique.
              This ID is unique within the name space of the element.</paragraph>""")],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          2],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>An element that is referable by its <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>This ID is not globally unique.
            This ID is unique within the name space of the element.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Identifiable',
      inheritances=[
        'Reference to AbstractClass Referable'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Identifiable',
        name='Identifiable',
        inheritances=[
          'Reference to Interface Referable'],
        implementers=[
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Submodel'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                  the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>Some of the administrative information like the version number might need to
                  be part of the identification.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Identifiable',
            parsed=...),
          Property(
            name='id',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>The globally unique identification of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Identifiable',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>An element that has a globally unique identifier.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Submodel'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Administrative_information',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          3],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>An element that has a globally unique identifier.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Modeling_kind',
      literals=[
        EnumerationLiteral(
          name='Template',
          value='Template',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Software element which specifies the common attributes shared by all instances of
              the template.</paragraph>"""),
            remarks=[
              '<paragraph>[SOURCE: IEC TR 62390:2005-01, 3.1.25] modified</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Concrete, clearly identifiable component of a certain template.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>It becomes an individual entity of a  template,  for example a
                device model, by defining specific property values.</paragraph></note>"""),
              textwrap.dedent("""\
                <note><paragraph>In an object oriented view,  an instance denotes an object of a
                template (class).</paragraph></note>"""),
              '<paragraph>[SOURCE: IEC 62890:2016, 3.1.16 65/617/CDV]  modified</paragraph>'],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          4],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration for denoting whether an element is a template or an instance.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    AbstractClass(
      name='Has_kind',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_kind',
        name='Has_kind',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...)],
        signatures=[
          Signature(
            name='kind_or_default',
            arguments=[],
            returns=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            description=None,
            contracts=Contracts(
              preconditions=[],
              snapshots=[],
              postconditions=[]),
            parsed=...,
            arguments_by_name=...)],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>An element with a kind is an element that can either represent a template or an
            instance.</paragraph>"""),
          remarks=[
            '<paragraph>Default for an element is that it is representing an instance.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          4],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>An element with a kind is an element that can either represent a template or an
          instance.</paragraph>"""),
        remarks=[
          '<paragraph>Default for an element is that it is representing an instance.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_data_specification',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_data_specification',
        name='Has_data_specification',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Administrative_information',
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Embedded data specification.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>Element that can be extended by using data specification templates.</paragraph>',
          remarks=[
            textwrap.dedent("""\
              <paragraph>A data specification template defines a named set of additional attributes an
              element may or shall have. The data specifications used are explicitly specified
              with their global ID.</paragraph>""")],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Administrative_information',
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          9],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Element that can be extended by using data specification templates.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>A data specification template defines a named set of additional attributes an
            element may or shall have. The data specifications used are explicitly specified
            with their global ID.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Administrative_information',
      inheritances=[
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='version',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Version of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...),
        Property(
          name='revision',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Revision of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='version',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='revision',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='version',
              argument='version',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='revision',
              argument='revision',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-005: If version is not specified then also revision shall be unspecified. This means, a revision requires a version. If there is no version there is no revision either. Revision is optional.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='revision',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='version',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          5],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Administrative meta-information for an element like version
          information.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-005',
            textwrap.dedent("""\
              <field_body><paragraph>If <ReferenceToAttribute refuri="~version">~version</ReferenceToAttribute> is not specified then also <ReferenceToAttribute refuri="~revision">~revision</ReferenceToAttribute> shall be
              unspecified. This means, a revision requires a version. If there is no version
              there is no revision neither. Revision is optional.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Qualifiable',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Qualifiable',
        name='Qualifiable',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>The value of a qualifiable element may be further qualified by one or more
            qualifiers.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[
            [
              'AASd-119',
              textwrap.dedent("""\
                <field_body><paragraph>If any <ReferenceToAttribute refuri="~Qualifier.kind">~Qualifier.kind</ReferenceToAttribute> value of <ReferenceToAttribute refuri="~Qualifiable.qualifiers">~Qualifiable.qualifiers</ReferenceToAttribute> is
                equal to <ReferenceToAttribute refuri="~Qualifier_kind.Template_qualifier">~Qualifier_kind.Template_qualifier</ReferenceToAttribute> and the qualified element
                inherits from <ReferenceToOurType refuri=".Has_kind">.Has_kind</ReferenceToOurType> then the qualified element shall be of
                kind Template (<ReferenceToAttribute refuri="Has_kind.kind">Has_kind.kind</ReferenceToAttribute> = <ReferenceToAttribute refuri="Modeling_kind.Template">Modeling_kind.Template</ReferenceToAttribute>).</paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          7],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>The value of a qualifiable element may be further qualified by one or more
          qualifiers.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-119',
            textwrap.dedent("""\
              <field_body><paragraph>If any <ReferenceToAttribute refuri="~Qualifier.kind">~Qualifier.kind</ReferenceToAttribute> value of <ReferenceToAttribute refuri="~Qualifiable.qualifiers">~Qualifiable.qualifiers</ReferenceToAttribute> is
              equal to <ReferenceToAttribute refuri="~Qualifier_kind.Template_qualifier">~Qualifier_kind.Template_qualifier</ReferenceToAttribute> and the qualified element
              inherits from <ReferenceToOurType refuri=".Has_kind">.Has_kind</ReferenceToOurType> then the qualified element shall be of
              kind Template (<ReferenceToAttribute refuri="Has_kind.kind">Has_kind.kind</ReferenceToAttribute> = <ReferenceToAttribute refuri="Modeling_kind.Template">Modeling_kind.Template</ReferenceToAttribute>).</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Qualifier_kind',
      literals=[
        EnumerationLiteral(
          name='Value_qualifier',
          value='ValueQualifier',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>qualifies the value of the element and can change during run-time.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Value qualifiers are only applicable to elements with kind
                <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute>.</paragraph>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Concept_qualifier',
          value='ConceptQualifier',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>qualifies the semantic definition the element is referring to
              (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>)</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Template_qualifier',
          value='TemplateQualifier',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>qualifies the elements within a specific submodel on concept level.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Template qualifiers are only applicable to elements with kind
                <ReferenceToAttribute refuri="~Modeling_kind.Template">~Modeling_kind.Template</ReferenceToAttribute>.</paragraph>""")],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          8],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration for kinds of qualifiers.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Qualifier',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Qualifier_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The qualifier kind describes the kind of the qualifier that is applied to the
              element.</paragraph>"""),
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Qualifier_kind.Concept_qualifier">~Qualifier_kind.Concept_qualifier</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Qualifier_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The qualifier <emphasis>type</emphasis> describes the type of the qualifier that is applied to
              the element.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Data type of the qualifier value.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The qualifier value is the value of the qualifier.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Qualifier_kind',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Qualifier',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Qualifier_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Qualifier_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_id',
              argument='value_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-020: The value shall be consistent to the data type as defined in value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          8],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A qualifier is a type-value-pair that makes additional statements w.r.t. the value
          of the element.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-006',
            textwrap.dedent("""\
              <field_body><paragraph>If both the <ReferenceToAttribute refuri="~value">~value</ReferenceToAttribute> and the <ReferenceToAttribute refuri="~value_id">~value_id</ReferenceToAttribute> of
              a <ReferenceToOurType refuri=".Qualifier">.Qualifier</ReferenceToOurType> are present then the <ReferenceToAttribute refuri="~value">~value</ReferenceToAttribute> needs
              to be identical to the value of the referenced coded value
              in <ReferenceToAttribute refuri="~value_id">~value_id</ReferenceToAttribute>.</paragraph></field_body>""")],
          [
            'AASd-020',
            textwrap.dedent("""\
              <field_body><paragraph>The value of <ReferenceToAttribute refuri="~value">~value</ReferenceToAttribute> shall be consistent to the data type as
              defined in <ReferenceToAttribute refuri="~value_type">~value_type</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Asset_administration_shell',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Administrative_information',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='derived_from',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The reference to the AAS the AAS was derived from.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Property(
          name='asset_information',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Asset_information',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Meta-information about the asset the AAS is representing.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Property(
          name='submodels',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>References to submodels of the AAS.</paragraph>',
            remarks=[
              '<paragraph>A submodel is a description of an aspect of the asset the AAS is representing.</paragraph>',
              '<paragraph>The asset of an AAS is typically described by one or more submodels.</paragraph>',
              '<paragraph>Temporarily no submodel might be assigned to the AAS.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='asset_information',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Asset_information',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='derived_from',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodels',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='derived_from',
              argument='derived_from',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='asset_information',
              argument='asset_information',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodels',
              argument='submodels',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Submodels must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodels',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Invariant(
          description='Derived-from must be a model reference to an asset administration shell.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='derived_from',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='derived_from',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='Key_types',
                      original_node=...),
                    name='Asset_administration_shell',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Invariant(
          description='All submodels must be model references to a submodel.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='reference',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodels',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Name(
                      identifier='reference',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          3],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>An asset administration shell.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Asset_information',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='asset_kind',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Asset_kind',
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Denotes whether the Asset is of kind <ReferenceToAttribute refuri="~Asset_kind.Type">~Asset_kind.Type</ReferenceToAttribute> or
              <ReferenceToAttribute refuri="~Asset_kind.Instance">~Asset_kind.Instance</ReferenceToAttribute>.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='global_asset_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Global identifier of the asset the AAS is representing.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>This attribute is required as soon as the AAS is exchanged via partners in the life
                cycle of the asset. In a first phase of the life cycle the asset might not yet have
                a global ID but already an internal identifier. The internal identifier would be
                modelled via <ReferenceToAttribute refuri="~specific_asset_ids">~specific_asset_ids</ReferenceToAttribute>.</paragraph>"""),
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='specific_asset_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Specific_asset_id',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Additional domain-specific, typically proprietary identifier for the asset like
              e.g., serial number etc.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='default_thumbnail',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Resource',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Thumbnail of the asset represented by the Asset Administration Shell.</paragraph>',
            remarks=[
              '<paragraph>Used as default.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='asset_kind',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Asset_kind',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='global_asset_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='specific_asset_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Specific_asset_id',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='default_thumbnail',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Resource',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='asset_kind',
              argument='asset_kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='global_asset_id',
              argument='global_asset_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='specific_asset_ids',
              argument='specific_asset_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='default_thumbnail',
              argument='default_thumbnail',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Specific asset IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='specific_asset_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='specific_asset_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>In <ReferenceToOurType refuri=".Asset_information">.Asset_information</ReferenceToOurType> identifying meta data of the asset that is
          represented by an AAS is defined.</paragraph>"""),
        remarks=[
          '<paragraph>The asset may either represent an asset type or an asset instance.</paragraph>',
          textwrap.dedent("""\
            <paragraph>The asset has a globally unique identifier plus – if needed – additional domain
            specific (proprietary) identifiers. However, to support the corner case of very
            first phase of lifecycle where a stabilised/constant_set global asset identifier does
            not already exist, the corresponding attribute <ReferenceToAttribute refuri="~global_asset_id">~global_asset_id</ReferenceToAttribute> is optional.</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-116',
            textwrap.dedent("""\
              <field_body><paragraph><literal>globalAssetId</literal> (case-insensitive) is a reserved key. If used as value for
              <ReferenceToAttribute refuri="~Specific_asset_id.name">~Specific_asset_id.name</ReferenceToAttribute> then <ReferenceToAttribute refuri="~Specific_asset_id.value">~Specific_asset_id.value</ReferenceToAttribute> shall be
              identical to <ReferenceToAttribute refuri="~global_asset_id">~global_asset_id</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Resource',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='path',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Path_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Path and name of the resource (with file extension).</paragraph>',
            remarks=[
              '<paragraph>The path can be absolute or relative.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Resource',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Content_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Content type of the content of the file.</paragraph>',
            remarks=[
              '<paragraph>The content type states which file extensions the file can have.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Resource',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='path',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Path_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='content_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Content_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='path',
              argument='path',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Resource represents an address to a file (a locator). The value is an URI that
          can represent an absolute or relative path</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Asset_kind',
      literals=[
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>hardware or software element which specifies the common attributes shared by all
              instances of the type</paragraph>"""),
            remarks=[
              '<paragraph>[SOURCE: IEC TR 62390:2005-01, 3.1.25]</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>concrete, clearly identifiable component of a certain type</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>It becomes an individual entity of a type, for example a device, by defining
                specific property values.</paragraph></note>"""),
              textwrap.dedent("""\
                <note><paragraph>In an object oriented view, an instance denotes an object of a class
                (of a type).</paragraph></note>"""),
              '<paragraph>[SOURCE: IEC 62890:2016, 3.1.16] 65/617/CDV</paragraph>'],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=2,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration for denoting whether an asset is a type asset or an instance asset.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Specific_asset_id',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='name',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Name of the identifier</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_id',
          parsed=...),
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the specific asset identifier with the corresponding name.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_id',
          parsed=...),
        Property(
          name='external_subject_id',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The (external) subject the key belongs to or has meaning to.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_id',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='name',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='external_subject_id',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='name',
              argument='name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='external_subject_id',
              argument='external_subject_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=3,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A specific asset ID describes a generic supplementary identifying attribute of the
          asset.</paragraph>"""),
        remarks=[
          '<paragraph>The specific asset ID is not necessarily globally unique.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_kind',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Administrative_information',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='submodel_elements',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>A submodel consists of zero or more submodel elements.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodel_elements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodel_elements',
              argument='submodel_elements',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Submodel elements must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodel_elements',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='ID-shorts need to be defined for all the submodel elements.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='Constraint AASd-120: ID-short of non-identifiable referables shall be unique in its namespace.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='id_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          5],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>A submodel defines a specific aspect of the asset represented by the AAS.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>A submodel is used to structure the digital representation and technical
            functionality of an Administration Shell into distinguishable parts. Each submodel
            refers to a well-defined domain or subject matter. Submodels can become
            standardized and, thus, become submodels templates.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Submodel_element',
      inheritances=[
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_kind',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Submodel_element',
        name='Submodel_element',
        inheritances=[
          'Reference to Interface Referable',
          'Reference to Interface Has_kind',
          'Reference to Interface Has_semantics',
          'Reference to Interface Qualifiable',
          'Reference to Interface Has_data_specification'],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                  the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Embedded data specification.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>A submodel element is an element suitable for the description and differentiation of
            assets.</paragraph>"""),
          remarks=[
            '<paragraph>It is recommended to add a <ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute> to a submodel element.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          6],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A submodel element is an element suitable for the description and differentiation of
          assets.</paragraph>"""),
        remarks=[
          '<paragraph>It is recommended to add a <ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute> to a submodel element.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Relationship_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to ConcreteClass Relationship_element',
        name='Relationship_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Relationship_element'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                  the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Embedded data specification.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...),
          Property(
            name='first',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to ConcreteClass Relationship_element',
            parsed=...),
          Property(
            name='second',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to ConcreteClass Relationship_element',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>A relationship element is used to define a relationship between two elements
            being either referable (model reference) or external (global reference).</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='first',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='second',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='first',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='second',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='first',
              argument='first',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='second',
              argument='second',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          14],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A relationship element is used to define a relationship between two elements
          being either referable (model reference) or external (global reference).</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='AAS_submodel_elements',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=None,
          parsed=...)],
      reference_in_the_book=None,
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration of all possible elements of a <ReferenceToOurType refuri=".Submodel_element_list">.Submodel_element_list</ReferenceToOurType>.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Submodel_element_list',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='order_relevant',
          type_annotation=OptionalTypeAnnotation(
            value=PrimitiveTypeAnnotation(
              a_type='BOOL',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Defines whether order in list is relevant. If <ReferenceToAttribute refuri="~order_relevant">~order_relevant</ReferenceToAttribute> = <literal>False</literal>
              then the list is representing a set or a bag.</paragraph>"""),
            remarks=[
              '<paragraph>Default: <literal>True</literal></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Submodel element contained in the list.</paragraph>',
            remarks=[
              '<paragraph>The list is ordered.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='semantic_id_list_element',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Semantic ID the submodel elements contained in the list match to.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='type_value_list_element',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type AAS_submodel_elements',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The submodel element type of the submodel elements contained in the list.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='value_type_list_element',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value type of the submodel element contained in the list.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='order_relevant_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='BOOL',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Submodel_element_list',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type_value_list_element',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type AAS_submodel_elements',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='order_relevant',
            type_annotation=OptionalTypeAnnotation(
              value=PrimitiveTypeAnnotation(
                a_type='BOOL',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id_list_element',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_type_list_element',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Data_type_def_XSD',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='type_value_list_element',
              argument='type_value_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='order_relevant',
              argument='order_relevant',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id_list_element',
              argument='semantic_id_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type_list_element',
              argument='value_type_list_element',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-107: If a first level child element has a semantic ID it shall be identical to semantic ID list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='semantic_id_list_element',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='child',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='child',
                        original_node=...),
                      name='semantic_id',
                      original_node=...),
                    original_node=...),
                  consequent=FunctionCall(
                    name='reference_key_values_equal',
                    args=[
                      Member(
                        instance=Name(
                          identifier='child',
                          original_node=...),
                        name='semantic_id',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='semantic_id_list_element',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-114: If two first level child elements have a semantic ID then they shall be identical.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='submodel_elements_have_identical_semantic_ids',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-108: All first level child elements shall have the same submodel element type as specified in type value list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='submodel_element_is_of_type',
                  args=[
                    Name(
                      identifier='element',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type_value_list_element',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-109: If type value list element is equal to Property or Range value type list element shall be set and all first level child elements shall have the value type as specified in value type list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  Or(
                    values=[
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Property',
                          original_node=...),
                        original_node=...),
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Range',
                          original_node=...),
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              consequent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_list_element',
                      original_node=...),
                    original_node=...),
                  FunctionCall(
                    name='properties_or_ranges_have_value_type',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value_type_list_element',
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-120: ID-shorts of submodel elements within a SubmodelElementList shall not be specified.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          16],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>A submodel element list is an ordered list of submodel elements.</paragraph>',
        remarks=[
          '<paragraph>The numbering starts with zero (0).</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-107',
            textwrap.dedent("""\
              <field_body><paragraph>If a first level child element in a <ReferenceToOurType refuri=".Submodel_element_list">.Submodel_element_list</ReferenceToOurType> has
              a <ReferenceToAttribute refuri="~Submodel_element.semantic_id">~Submodel_element.semantic_id</ReferenceToAttribute> it
              shall be identical to <ReferenceToAttribute refuri="~Submodel_element_list.semantic_id_list_element">~Submodel_element_list.semantic_id_list_element</ReferenceToAttribute>.</paragraph></field_body>""")],
          [
            'AASd-114',
            textwrap.dedent("""\
              <field_body><paragraph>If two first level child elements in a <ReferenceToOurType refuri=".Submodel_element_list">.Submodel_element_list</ReferenceToOurType> have
              a <ReferenceToAttribute refuri="~Submodel_element.semantic_id">~Submodel_element.semantic_id</ReferenceToAttribute> then they shall be identical.</paragraph></field_body>""")],
          [
            'AASd-115',
            textwrap.dedent("""\
              <field_body><paragraph>If a first level child element in a <ReferenceToOurType refuri=".Submodel_element_list">.Submodel_element_list</ReferenceToOurType> does not
              specify a <ReferenceToAttribute refuri="~Submodel_element.semantic_id">~Submodel_element.semantic_id</ReferenceToAttribute> then the value is assumed to be
              identical to <ReferenceToAttribute refuri="~Submodel_element_list.semantic_id_list_element">~Submodel_element_list.semantic_id_list_element</ReferenceToAttribute>.</paragraph></field_body>""")],
          [
            'AASd-108',
            textwrap.dedent("""\
              <field_body><paragraph>All first level child elements in a <ReferenceToOurType refuri=".Submodel_element_list">.Submodel_element_list</ReferenceToOurType> shall have
              the same submodel element type as specified in <ReferenceToAttribute refuri="~type_value_list_element">~type_value_list_element</ReferenceToAttribute>.</paragraph></field_body>""")],
          [
            'AASd-109',
            textwrap.dedent("""\
              <field_body><paragraph>If <ReferenceToAttribute refuri="~type_value_list_element">~type_value_list_element</ReferenceToAttribute> is equal to
              <ReferenceToAttribute refuri="AAS_submodel_elements.Property">AAS_submodel_elements.Property</ReferenceToAttribute> or
              <ReferenceToAttribute refuri="AAS_submodel_elements.Range">AAS_submodel_elements.Range</ReferenceToAttribute>
              <ReferenceToAttribute refuri="~value_type_list_element">~value_type_list_element</ReferenceToAttribute> shall be set and all first
              level child elements in the <ReferenceToOurType refuri=".Submodel_element_list">.Submodel_element_list</ReferenceToOurType> shall have
              the value type as specified in <ReferenceToAttribute refuri="~value_type_list_element">~value_type_list_element</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel_element_collection',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Submodel element contained in the collection.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='ID-shorts need to be defined for all the elements.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                generator=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...),
        Invariant(
          description='ID-shorts of the value must be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='id_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          15],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A submodel element collection is a kind of struct, i.e. a a logical encapsulation
          of multiple named values. It has a fixed number of submodel elements.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_element',
        name='Data_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                  the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Embedded data specification.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[
          Signature(
            name='category_or_default',
            arguments=[],
            returns=PrimitiveTypeAnnotation(
              a_type='STR',
              parsed=...),
            description=None,
            contracts=Contracts(
              preconditions=[],
              snapshots=[],
              postconditions=[
                Contract(
                  args=[
                    'result'],
                  description=None,
                  body=textwrap.dedent("""\
                    IsIn(
                      member=Name(
                        identifier='result',
                        original_node=...),
                      container=Name(
                        identifier='Valid_categories_for_data_element',
                        original_node=...),
                      original_node=...)"""),
                  parsed=...)]),
            parsed=...,
            arguments_by_name=...)],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>A data element is a submodel element that is not further composed out of
            other submodel elements.</paragraph>"""),
          remarks=[
            textwrap.dedent("""\
              <paragraph>A data element is a submodel element that has a value. The type of value differs
              for different subtypes of data elements.</paragraph>""")],
          constraints_by_identifier=[
            [
              'AASd-090',
              textwrap.dedent("""\
                <field_body><paragraph>For data elements <ReferenceToAttribute refuri="~category">~category</ReferenceToAttribute> (inherited by <ReferenceToOurType refuri=".Referable">.Referable</ReferenceToOurType>) shall be
                one of the following values: <literal>CONSTANT</literal>, <literal>PARAMETER</literal> or <literal>VARIABLE</literal>.</paragraph><paragraph>Default: <literal>VARIABLE</literal></paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          5],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A data element is a submodel element that is not further composed out of
          other submodel elements.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <paragraph>A data element is a submodel element that has a value. The type of value differs
            for different subtypes of data elements.</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-090',
            textwrap.dedent("""\
              <field_body><paragraph>For data elements <ReferenceToAttribute refuri="~category">~category</ReferenceToAttribute> (inherited by <ReferenceToOurType refuri=".Referable">.Referable</ReferenceToOurType>) shall be
              one of the following values: <literal>CONSTANT</literal>, <literal>PARAMETER</literal> or <literal>VARIABLE</literal>.</paragraph><paragraph>Default: <literal>VARIABLE</literal></paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Property',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Data type of the value</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the property instance.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...),
        Property(
          name='value_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_id',
              argument='value_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...),
        Invariant(
          description='Value must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Property',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          11],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>A property is a data element that has a single value.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-007',
            textwrap.dedent("""\
              <field_body><paragraph>If both, the <ReferenceToAttribute refuri="~value">~value</ReferenceToAttribute> and the <ReferenceToAttribute refuri="~value_id">~value_id</ReferenceToAttribute> are
              present then the value of <ReferenceToAttribute refuri="~value">~value</ReferenceToAttribute> needs to be identical to
              the value of the referenced coded value in <ReferenceToAttribute refuri="~value_id">~value_id</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Multi_language_property',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the property instance.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...),
        Property(
          name='value_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_id',
              argument='value_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...),
        Invariant(
          description='Value specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...),
        Invariant(
          description='Value must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          9],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>A property is a data element that has a multi-language value.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-012',
            textwrap.dedent("""\
              <field_body><paragraph>If both the <ReferenceToAttribute refuri="~value">~value</ReferenceToAttribute> and the <ReferenceToAttribute refuri="~value_id">~value_id</ReferenceToAttribute> are present then for each
              string in a specific language the meaning must be the same as specified in
              <ReferenceToAttribute refuri="~value_id">~value_id</ReferenceToAttribute>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Range',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Data type of the min und max</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Property(
          name='min',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The minimum value of the range.</paragraph>',
            remarks=[
              '<paragraph>If the min value is missing, then the value is assumed to be negative infinite.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Property(
          name='max',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_data_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The maximum value of the range.</paragraph>',
            remarks=[
              '<paragraph>If the max value is missing,  then the value is assumed to be positive infinite.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='min',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='max',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='min',
              argument='min',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max',
              argument='max',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...),
        Invariant(
          description='Max must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='max',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Invariant(
          description='Min must be consistent with the value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='min',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='min',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Range',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          12],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>A range data element is a data element that defines a range with min and max.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Reference_element',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Global reference to an external object or entity or a logical reference to
              another element within the same or another AAS (i.e. a model reference to
              a Referable).</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          15],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A reference element is a data element that defines a logical reference to another
          element within the same or another AAS or a reference to an external object or
          entity.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Blob',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Blob_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the <ReferenceToOurType refuri=".Blob">.Blob</ReferenceToOurType> instance of a blob data element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In contrast to the file property the file content is stored directly as value
                in the <ReferenceToOurType refuri=".Blob">.Blob</ReferenceToOurType> data element.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Blob',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Content_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Content type of the content of the <ReferenceToOurType refuri=".Blob">.Blob</ReferenceToOurType>.</paragraph>',
            remarks=[
              '<paragraph>The content type (MIME type) states which file extensions the file can have.</paragraph>',
              textwrap.dedent("""\
                <paragraph>Valid values are content types like e.g. <literal>application/json</literal>, <literal>application/xls</literal>,
                <literal>image/jpg</literal>.</paragraph>"""),
              '<paragraph>The allowed values are defined as in RFC2046.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Blob',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='content_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Content_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Blob_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          3],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A <ReferenceToOurType refuri=".Blob">.Blob</ReferenceToOurType> is a data element that represents a file that is contained with its
          source code in the value attribute.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='File',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Path_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Path and name of the referenced file (with file extension).</paragraph>',
            remarks=[
              '<paragraph>The path can be absolute or relative.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass File',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Content_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Content type of the content of the file.</paragraph>',
            remarks=[
              '<paragraph>The content type states which file extensions the file can have.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass File',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_data_element',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='content_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Content_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Path_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_data_element',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          8],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>A File is a data element that represents an address to a file (a locator).</paragraph>',
        remarks=[
          '<paragraph>The value is an URI that can represent an absolute or relative path.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Annotated_relationship_element',
      inheritances=[
        'Reference to ConcreteClass Relationship_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='first',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='second',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='annotations',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Data_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>A data element that represents an annotation that holds for the relationship
              between the two elements</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Annotated_relationship_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='first',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='second',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='annotations',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Data_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='first',
              argument='first',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='second',
              argument='second',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='annotations',
              argument='annotations',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Annotations must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='annotations',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='annotations',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Annotated_relationship_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          1],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>An annotated relationship element is a relationship element that can be annotated
          with additional data elements.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Entity_type',
      literals=[
        EnumerationLiteral(
          name='Co_managed_entity',
          value='CoManagedEntity',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>For co-managed entities there is no separate AAS. Co-managed entities need to be
              part of a self-managed entity.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Self_managed_entity',
          value='SelfManagedEntity',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Self-Managed Entities have their own AAS but can be part of the bill of material of
              a composite self-managed entity.</paragraph>"""),
            remarks=[
              '<paragraph>The asset of an I4.0 Component is a self-managed entity per definition."</paragraph>'],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          6],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Enumeration for denoting whether an entity is a self-managed entity or a co-managed
          entity.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Entity',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='statements',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Describes statements applicable to the entity by a set of submodel elements,
              typically with a qualified value.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='entity_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Entity_type',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Describes whether the entity is a co-managed entity or a self-managed entity.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='global_asset_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Global identifier of the asset the entity is representing.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='specific_asset_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Specific_asset_id',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Reference to a specific asset ID representing a supplementary identifier
              of the asset represented by the Asset Administration Shell.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='entity_type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Entity_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='statements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='global_asset_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='specific_asset_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Specific_asset_id',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='statements',
              argument='statements',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='entity_type',
              argument='entity_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='global_asset_id',
              argument='global_asset_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='specific_asset_id',
              argument='specific_asset_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Statements must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='statements',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='statements',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Invariant(
          description="Constraint AASd-014: Either the attribute global asset ID or specific asset ID must be set if entity type is set to 'SelfManagedEntity'. They are not existing otherwise.",
          body=textwrap.dedent("""\
            Or(
              values=[
                And(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='entity_type',
                        original_node=...),
                      op='EQ',
                      right=Member(
                        instance=Name(
                          identifier='Entity_type',
                          original_node=...),
                        name='Self_managed_entity',
                        original_node=...),
                      original_node=...),
                    Or(
                      values=[
                        And(
                          values=[
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_id',
                                original_node=...),
                              original_node=...),
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_id',
                                original_node=...),
                              original_node=...)],
                          original_node=...),
                        And(
                          values=[
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_id',
                                original_node=...),
                              original_node=...),
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_id',
                                original_node=...),
                              original_node=...)],
                          original_node=...)],
                      original_node=...)],
                  original_node=...),
                And(
                  values=[
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='global_asset_id',
                        original_node=...),
                      original_node=...),
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='specific_asset_id',
                        original_node=...),
                      original_node=...)],
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          6],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>An entity is a submodel element that is used to model entities.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-014',
            textwrap.dedent("""\
              <field_body><paragraph>Either the attribute <ReferenceToAttribute refuri="~global_asset_id">~global_asset_id</ReferenceToAttribute> or <ReferenceToAttribute refuri="~specific_asset_id">~specific_asset_id</ReferenceToAttribute>
              of an <ReferenceToOurType refuri=".Entity">.Entity</ReferenceToOurType> must be set if <ReferenceToAttribute refuri="~entity_type">~entity_type</ReferenceToAttribute> is set to
              <ReferenceToAttribute refuri="~Entity_type.Self_managed_entity">~Entity_type.Self_managed_entity</ReferenceToAttribute>. They are not existing otherwise.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Direction',
      literals=[
        EnumerationLiteral(
          name='Input',
          value='INPUT',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Input direction.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Output',
          value='OUTPUT',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Output direction</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Direction</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='State_of_event',
      literals=[
        EnumerationLiteral(
          name='On',
          value='ON',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Event is on</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Off',
          value='OFF',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Event is off.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=2,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>State of an event</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Event_payload',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='source',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Reference to the source event element, including identification of
              <ReferenceToOurType refuri=".Asset_administration_shell">.Asset_administration_shell</ReferenceToOurType>, <ReferenceToOurType refuri=".Submodel">.Submodel</ReferenceToOurType>,
              <ReferenceToOurType refuri=".Submodel_element">.Submodel_element</ReferenceToOurType>'s.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='source_semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph><ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute> of the source event element, if available</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='observable_reference',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the referable, which defines the scope of the event.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Can be <ReferenceToOurType refuri=".Asset_administration_shell">.Asset_administration_shell</ReferenceToOurType>, <ReferenceToOurType refuri=".Submodel">.Submodel</ReferenceToOurType> or
                <ReferenceToOurType refuri=".Submodel_element">.Submodel_element</ReferenceToOurType>.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='observable_semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph><ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute> of the referable which defines the scope of
              the event, if available.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='topic',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Information for the outer message infrastructure for scheduling the event to
              the respective communication channel.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='subject_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Subject, who/which initiated the creation.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='time_stamp',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Date_time_stamp_UTC',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Timestamp in UTC, when this event was triggered.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='payload',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Event specific payload.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='source',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='observable_reference',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='time_stamp',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Date_time_stamp_UTC',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='source_semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='observable_semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='topic',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='subject_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='payload',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='source',
              argument='source',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observable_reference',
              argument='observable_reference',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='time_stamp',
              argument='time_stamp',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='source_semantic_id',
              argument='source_semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observable_semantic_id',
              argument='observable_semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='topic',
              argument='topic',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='subject_id',
              argument='subject_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='payload',
              argument='payload',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Source must be a model reference to a referable.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='source',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Invariant(
          description='Observable reference must be a model reference to a referable.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observable_reference',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=3,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Defines the necessary information of an event instance sent out or received.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Event_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Event_element',
        name='Event_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Basic_event_element'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                  the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=DescriptionOfProperty(
              summary='<paragraph>Embedded data specification.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=DescriptionOfOurType(
          summary='<paragraph>An event element.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Basic_event_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          7],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>An event element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Basic_event_element',
      inheritances=[
        'Reference to AbstractClass Event_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='observed',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Reference to the <ReferenceToOurType refuri=".Referable">.Referable</ReferenceToOurType>, which defines the scope of the event.
              Can be <ReferenceToOurType refuri=".Asset_administration_shell">.Asset_administration_shell</ReferenceToOurType>, <ReferenceToOurType refuri=".Submodel">.Submodel</ReferenceToOurType>, or
              <ReferenceToOurType refuri=".Submodel_element">.Submodel_element</ReferenceToOurType>.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>Reference to a referable, e.g., a data element or
                a submodel, that is being observed.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='direction',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Direction',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Direction of event.</paragraph>',
            remarks=[
              '<paragraph>Can be <literal>{ Input, Output }</literal>.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='state',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type State_of_event',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>State of event.</paragraph>',
            remarks=[
              '<paragraph>Can be <literal>{ On, Off }</literal>.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='message_topic',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Information for the outer message infrastructure for scheduling the event to the
              respective communication channel.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='message_broker',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Information, which outer message infrastructure shall handle messages for
              the <ReferenceToOurType refuri=".Event_element">.Event_element</ReferenceToOurType>. Refers to a <ReferenceToOurType refuri=".Submodel">.Submodel</ReferenceToOurType>,
              <ReferenceToOurType refuri=".Submodel_element_list">.Submodel_element_list</ReferenceToOurType>, <ReferenceToOurType refuri=".Submodel_element_collection">.Submodel_element_collection</ReferenceToOurType> or
              <ReferenceToOurType refuri=".Entity">.Entity</ReferenceToOurType>, which contains <ReferenceToOurType refuri=".Data_element">.Data_element</ReferenceToOurType>'s describing
              the proprietary specification for the message broker.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
                proprietary specification could be standardized by having respective Submodels.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='last_update',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Date_time_stamp_UTC',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Timestamp in UTC, when the last event was received (input direction) or sent
              (output direction).</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='min_interval',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Date_time_stamp_UTC',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>For input direction, reports on the maximum frequency, the software entity behind
              the respective Referable can handle input events.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>For output events, specifies the maximum frequency of outputting this event to
                an outer infrastructure.</paragraph>"""),
              '<paragraph>Might be not specified, that is, there is no minimum interval.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='max_interval',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Date_time_stamp_UTC',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>For input direction: not applicable.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>For output direction: maximum interval in time, the respective Referable shall send
                an update of the status of the event, even if no other trigger condition for
                the event was not met.</paragraph>"""),
              '<paragraph>Might be not specified, that is, there is no maximum interval</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='observed',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='direction',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Direction',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='state',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type State_of_event',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='message_topic',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='message_broker',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='last_update',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Date_time_stamp_UTC',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='min_interval',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Date_time_stamp_UTC',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='max_interval',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Date_time_stamp_UTC',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observed',
              argument='observed',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='direction',
              argument='direction',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='state',
              argument='state',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='message_topic',
              argument='message_topic',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='message_broker',
              argument='message_broker',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='last_update',
              argument='last_update',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='min_interval',
              argument='min_interval',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max_interval',
              argument='max_interval',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Max. interval is not applicable for input direction',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='direction',
                  original_node=...),
                op='EQ',
                right=Member(
                  instance=Name(
                    identifier='Direction',
                    original_node=...),
                  name='Input',
                  original_node=...),
                original_node=...),
              consequent=IsNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max_interval',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Invariant(
          description='Observed must be a model reference to a referable.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to_referable',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observed',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Invariant(
          description='Message broker must be a model reference to a referable.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='message_broker',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to_referable',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='message_broker',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>A basic event element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Operation',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='input_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Input parameter of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Property(
          name='output_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Output parameter of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Property(
          name='inoutput_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Parameter that is input and output of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='input_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='output_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='inoutput_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='input_variables',
              argument='input_variables',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='output_variables',
              argument='output_variables',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='inoutput_variables',
              argument='inoutput_variables',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Input variables must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='input_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='input_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Invariant(
          description='Output variables must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='output_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='output_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Invariant(
          description='Inoutput variables must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='inoutput_variables',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='inoutput_variables',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          10],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>An operation is a submodel element with input and output variables.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Operation_variable',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Submodel_element',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Describes an argument or result of an operation via a submodel element</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation_variable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Submodel_element',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          10],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>The value of an operation variable is a submodel element that is used as input
          and/or output variable of an operation.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Capability',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Modeling_kind',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <ReferenceToAttribute refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</ReferenceToAttribute></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            our_type='Reference to our type Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Supplemental semantic IDs must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='supplemental_semantic_ids',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Qualifiers must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  generator=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          4],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A capability is the implementation-independent description of the potential of an
          asset to achieve a certain effect in the physical or virtual world.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>The <ReferenceToAttribute refuri="~semantic_id">~semantic_id</ReferenceToAttribute> of a capability is typically an ontology.
            Thus, reasoning on capabilities is enabled.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Concept_description',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<ReferenceToOurType refuri=".Has_semantics">.Has_semantics</ReferenceToOurType>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Id_short',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<ReferenceToAttribute refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</ReferenceToAttribute>) conformant to IEC61360
                the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <ReferenceToAttribute refuri="~id_short">~id_short</ReferenceToAttribute> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Administrative_information',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Identifier',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='embedded_data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Embedded_data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Embedded data specification.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='is_case_of',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph>Reference to an external definition the concept is compatible to or was derived
              from.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>',
              '<note><paragraph>Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360"</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Concept_description',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  IsIn(
                    member=Name(
                      identifier='result',
                      original_node=...),
                    container=Name(
                      identifier='Valid_categories_for_concept_description',
                      original_node=...),
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Id_short',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='embedded_data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Embedded_data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='is_case_of',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='embedded_data_specifications',
              argument='embedded_data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='is_case_of',
              argument='is_case_of',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Extensions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='extensions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Description must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='description',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Description specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='description',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='description',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='display_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Display name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='display_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='display_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Invariant(
          description='Embedded data specifications must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='embedded_data_specifications',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Invariant(
          description='Is-case-of must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='is_case_of',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='is_case_of',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description="Constraint AASd-051: A concept description shall have one of the following categories: 'VALUE', 'PROPERTY', 'REFERENCE', 'DOCUMENT', 'CAPABILITY',; 'RELATIONSHIP', 'COLLECTION', 'FUNCTION', 'EVENT', 'ENTITY', 'APPLICATION_CLASS', 'QUALIFIER', 'VIEW'.",
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                container=Name(
                  identifier='Valid_categories_for_concept_description',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-003: For all concept descriptions with a category except VALUE using data specification IEC 61360, the definition of the data specification is mandatory and shall be defined at least in English.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='NE',
                    right=Constant(
                      value='VALUE',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_have_definition_at_least_in_english',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-008: For a concept description with category VALUE using data specification IEC 61360, the value of the data specification shall be set.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='VALUE',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_have_value',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-007: For a concept description with category QUALIFIER_TYPE using data specification IEC 61360, the data type of the data specification is mandatory and shall be defined.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='QUALIFIER_TYPE',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_have_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-006: For a concept description with category DOCUMENT using data specification IEC 61360, the data type of the data specification is mandatory and shall be one of: FILE, BLOB, HTML.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='DOCUMENT',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_document_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-005: For a concept description with category REFERENCE using data specification IEC 61360, the data type of the data specification is mandatory and shall be one of: STRING, IRI, IRDI.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='REFERENCE',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_reference_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...),
        Invariant(
          description='Constraint AASc-004: For a concept description with category PROPERTY or VALUE using data specification IEC 61360, the data type of the data specification is mandatory and shall be one of: DATE, STRING, STRING_TRANSLATABLE, INTEGER_MEASURE, INTEGER_COUNT, INTEGER_CURRENCY, REAL_MEASURE, REAL_COUNT, REAL_CURRENCY, BOOLEAN, RATIONAL, RATIONAL_MEASURE, TIME, TIMESTAMP.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    original_node=...),
                  Or(
                    values=[
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='category',
                          original_node=...),
                        op='EQ',
                        right=Constant(
                          value='PROPERTY',
                          original_node=...),
                        original_node=...),
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='category',
                          original_node=...),
                        op='EQ',
                        right=Constant(
                          value='VALUE',
                          original_node=...),
                        original_node=...)],
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='embedded_data_specifications',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=FunctionCall(
                name='data_specification_IEC_61360s_for_property_or_value_have_appropriate_data_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='embedded_data_specifications',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          8],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>The semantics of a property or other elements that may have a semantic description
          is defined by a concept description.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <paragraph>The description of the concept should follow a standardized schema (realized as
            data specification template).</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-051',
            textwrap.dedent("""\
              <field_body><paragraph>A <ReferenceToOurType refuri=".Concept_description">.Concept_description</ReferenceToOurType> shall have one of the following categories
              <literal>VALUE</literal>, <literal>PROPERTY</literal>, <literal>REFERENCE</literal>, <literal>DOCUMENT</literal>, <literal>CAPABILITY</literal>,
              <literal>RELATIONSHIP</literal>, <literal>COLLECTION</literal>, <literal>FUNCTION</literal>, <literal>EVENT</literal>, <literal>ENTITY</literal>,
              <literal>APPLICATION_CLASS</literal>, <literal>QUALIFIER</literal>, <literal>VIEW</literal>.</paragraph><paragraph>Default: <literal>PROPERTY</literal>.</paragraph></field_body>""")],
          [
            'AASc-004',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri=".Concept_description">.Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="~category">~category</ReferenceToAttribute> <literal>PROPERTY</literal> or
              <literal>VALUE</literal> using data specification IEC61360,
              the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.data_type">~Data_specification_IEC_61360.data_type</ReferenceToAttribute> is mandatory and shall be
              one of: <literal>DATE</literal>, <literal>STRING</literal>, <literal>STRING_TRANSLATABLE</literal>, <literal>INTEGER_MEASURE</literal>,
              <literal>INTEGER_COUNT</literal>, <literal>INTEGER_CURRENCY</literal>, <literal>REAL_MEASURE</literal>, <literal>REAL_COUNT</literal>,
              <literal>REAL_CURRENCY</literal>, <literal>BOOLEAN</literal>, <literal>RATIONAL</literal>, <literal>RATIONAL_MEASURE</literal>,
              <literal>TIME</literal>, <literal>TIMESTAMP</literal>.</paragraph></field_body>""")],
          [
            'AASc-005',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri=".Concept_description">.Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="~category">~category</ReferenceToAttribute> <literal>REFERENCE</literal>
              using data specification IEC61360,
              the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.data_type">~Data_specification_IEC_61360.data_type</ReferenceToAttribute> is mandatory and shall be
              one of: <literal>STRING</literal>, <literal>IRI</literal>, <literal>IRDI</literal>.</paragraph></field_body>""")],
          [
            'AASc-006',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri=".Concept_description">.Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="~category">~category</ReferenceToAttribute> <literal>DOCUMENT</literal>
              using data specification IEC61360,
              the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.data_type">~Data_specification_IEC_61360.data_type</ReferenceToAttribute> is mandatory and shall be
              defined.</paragraph></field_body>""")],
          [
            'AASc-007',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri=".Concept_description">.Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="~category">~category</ReferenceToAttribute> <literal>QUALIFIER_TYPE</literal>
              using data specification IEC61360,
              the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.data_type">~Data_specification_IEC_61360.data_type</ReferenceToAttribute> is mandatory and shall be</paragraph></field_body>""")],
          [
            'AASc-008',
            textwrap.dedent("""\
              <field_body><paragraph>For all <ReferenceToOurType refuri=".Concept_description">.Concept_description</ReferenceToOurType>'s with a category except
              <ReferenceToAttribute refuri="~category">~category</ReferenceToAttribute> <literal>VALUE</literal> using data specification IEC61360,
              <ReferenceToAttribute refuri="~Data_specification_IEC_61360.definition">~Data_specification_IEC_61360.definition</ReferenceToAttribute> is mandatory and shall be
              defined at least in English.</paragraph></field_body>""")],
          [
            'AASc-003',
            textwrap.dedent("""\
              <field_body><paragraph>For a <ReferenceToOurType refuri=".Concept_description">.Concept_description</ReferenceToOurType> with <ReferenceToAttribute refuri="~category">~category</ReferenceToAttribute> <literal>VALUE</literal>
              using data specification IEC61360,
              the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.value">~Data_specification_IEC_61360.value</ReferenceToAttribute> shall be set.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Reference_types',
      literals=[
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>GlobalReference.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Model_reference',
          value='ModelReference',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>ModelReference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          2],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>ReferenceTypes</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Reference',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference_types',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Type of the reference.</paragraph>',
            remarks=[
              '<paragraph>Denotes, whether reference is a global reference or a model reference.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Property(
          name='referred_semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary=textwrap.dedent("""\
              <paragraph><ReferenceToAttribute refuri="Has_semantics.semantic_id">Has_semantics.semantic_id</ReferenceToAttribute> of the referenced model element
              (<ReferenceToAttribute refuri="~Reference.type">~Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</ReferenceToAttribute>).</paragraph>"""),
            remarks=[
              '<paragraph>For global references there typically is no semantic ID.</paragraph>',
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Property(
          name='keys',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Key',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Unique references in their name space.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference_types',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='keys',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Key',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='referred_semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='keys',
              argument='keys',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='referred_semantic_id',
              argument='referred_semantic_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Keys must containt at least one item.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='keys',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-121: For References the type of the first key shall be one of Globally identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='Globally_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-122: For global references the type of the first key shall be one of Generic globally identifiables.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Global_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='Generic_globally_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-123: For model references the type of the first key shall be one of AAS identifiables',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=IsIn(
                member=Member(
                  instance=Index(
                    collection=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='keys',
                      original_node=...),
                    index=Constant(
                      value=0,
                      original_node=...),
                    original_node=...),
                  name='type',
                  original_node=...),
                container=Name(
                  identifier='AAS_identifiables',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-124: For global references the last key shall be either one of Generic globally identifiables or one of Generic fragment keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Global_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GE',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_globally_identifiables',
                      original_node=...),
                    original_node=...),
                  IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_fragment_keys',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-125: For model references with more than one key, the type of the keys following the first key shall be one of Fragment keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=1,
                    original_node=...),
                  end=FunctionCall(
                    name='len',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='keys',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                condition=IsIn(
                  member=Member(
                    instance=Index(
                      collection=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='keys',
                        original_node=...),
                      index=Name(
                        identifier='i',
                        original_node=...),
                      original_node=...),
                    name='type',
                    original_node=...),
                  container=Name(
                    identifier='Fragment_keys',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-126: For model references with more than one key, the type of the last key in the reference key chain may be one of Generic fragment keys or no key at all shall have a value out of Generic fragment keys.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=0,
                    original_node=...),
                  end=Sub(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...),
                condition=Not(
                  operand=IsIn(
                    member=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Name(
                          identifier='i',
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    container=Name(
                      identifier='Generic_fragment_keys',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-127: For model references with more than one key, a key with type Fragment reference shall be preceded by a key with type File or Blob.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-1,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Fragment_reference',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-2,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='File',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Constant(
                          value=-2,
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Blob',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Invariant(
          description='Constraint AASd-128: For model references, the value of a key preceded by a key with type Submodel element list is an integer number denoting the position in the array of the submodel element list.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Reference_types',
                        original_node=...),
                      name='Model_reference',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    op='GT',
                    right=Constant(
                      value=2,
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                generator=ForRange(
                  variable=Name(
                    identifier='i',
                    original_node=...),
                  start=Constant(
                    value=0,
                    original_node=...),
                  end=Sub(
                    left=FunctionCall(
                      name='len',
                      args=[
                        Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...)],
                      original_node=...),
                    right=Constant(
                      value=1,
                      original_node=...),
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=Comparison(
                    left=Member(
                      instance=Index(
                        collection=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='keys',
                          original_node=...),
                        index=Name(
                          identifier='i',
                          original_node=...),
                        original_node=...),
                      name='type',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel_element_list',
                      original_node=...),
                    original_node=...),
                  consequent=FunctionCall(
                    name='matches_xs_positive_integer',
                    args=[
                      Member(
                        instance=Index(
                          collection=Member(
                            instance=Name(
                              identifier='self',
                              original_node=...),
                            name='keys',
                            original_node=...),
                          index=Add(
                            left=Name(
                              identifier='i',
                              original_node=...),
                            right=Constant(
                              value=1,
                              original_node=...),
                            original_node=...),
                          original_node=...),
                        name='value',
                        original_node=...)],
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          2],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Reference to either a model element of the same or another AAS or to an external
          entity.</paragraph>"""),
        remarks=[
          '<paragraph>A reference is an ordered list of keys.</paragraph>',
          textwrap.dedent("""\
            <paragraph>A model reference is an ordered list of keys, each key referencing an element. The
            complete list of keys may for example be concatenated to a path that then gives
            unique access to an element.</paragraph>"""),
          '<paragraph>A global reference is a reference to an external entity.</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-121',
            textwrap.dedent("""\
              <field_body><paragraph>For <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>'s the <ReferenceToAttribute refuri="~Key.type">~Key.type</ReferenceToAttribute> of the first key of
              <ReferenceToAttribute refuri="~keys">~keys</ReferenceToAttribute> shall be one of <ReferenceToConstant refuri=".Globally_identifiables">.Globally_identifiables</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-122',
            textwrap.dedent("""\
              <field_body><paragraph>For global references, i.e. <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="~Reference.type">~Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Reference_types.Global_reference">~Reference_types.Global_reference</ReferenceToAttribute>, the type
              of the first key of <ReferenceToAttribute refuri="~Reference.keys">~Reference.keys</ReferenceToAttribute> shall be one of
              <ReferenceToConstant refuri=".Generic_globally_identifiables">.Generic_globally_identifiables</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-123',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="~Reference.type">~Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</ReferenceToAttribute>, the type
              of the first key of <ReferenceToAttribute refuri="~Reference.keys">~Reference.keys</ReferenceToAttribute> shall be one of
              <ReferenceToConstant refuri=".AAS_identifiables">.AAS_identifiables</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-124',
            textwrap.dedent("""\
              <field_body><paragraph>For global references, i.e. <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="~Reference.type">~Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Reference_types.Global_reference">~Reference_types.Global_reference</ReferenceToAttribute>, the last
              key of <ReferenceToAttribute refuri="~Reference.keys">~Reference.keys</ReferenceToAttribute> shall be either one of
              <ReferenceToConstant refuri=".Generic_globally_identifiables">.Generic_globally_identifiables</ReferenceToConstant> or one of
              <ReferenceToConstant refuri=".Generic_fragment_keys">.Generic_fragment_keys</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-125',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="~Reference.type">~Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</ReferenceToAttribute>, with more
              than one key in <ReferenceToAttribute refuri="~Reference.keys">~Reference.keys</ReferenceToAttribute> the type of the keys following the first
              key of  <ReferenceToAttribute refuri="~Reference.keys">~Reference.keys</ReferenceToAttribute> shall be one of <ReferenceToConstant refuri=".Fragment_keys">.Fragment_keys</ReferenceToConstant>.</paragraph><note><paragraph><ReferenceToConstraint refuri="AASd-125">AASd-125</ReferenceToConstraint> ensures that the shortest path is used.</paragraph></note></field_body>""")],
          [
            'AASd-126',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="~Reference.type">~Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</ReferenceToAttribute>, with more
              than one key in <ReferenceToAttribute refuri="~Reference.keys">~Reference.keys</ReferenceToAttribute> the type of the last key in the
              reference key chain may be one of <ReferenceToConstant refuri=".Generic_fragment_keys">.Generic_fragment_keys</ReferenceToConstant> or no key
              at all shall have a value out of <ReferenceToConstant refuri=".Generic_fragment_keys">.Generic_fragment_keys</ReferenceToConstant>.</paragraph></field_body>""")],
          [
            'AASd-127',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="~Reference.type">~Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</ReferenceToAttribute>, with more
              than one key in <ReferenceToAttribute refuri="~Reference.keys">~Reference.keys</ReferenceToAttribute> a key with <ReferenceToAttribute refuri="~Key.type">~Key.type</ReferenceToAttribute>
              <ReferenceToAttribute refuri="~Key_types.Fragment_reference">~Key_types.Fragment_reference</ReferenceToAttribute> shall be preceded by a key with
              <ReferenceToAttribute refuri="~Key.type">~Key.type</ReferenceToAttribute> <ReferenceToAttribute refuri="~Key_types.File">~Key_types.File</ReferenceToAttribute> or <ReferenceToAttribute refuri="~Key_types.Blob">~Key_types.Blob</ReferenceToAttribute>. All other
              AAS fragments, i.e. type values out of <ReferenceToConstant refuri=".AAS_submodel_elements_as_keys">.AAS_submodel_elements_as_keys</ReferenceToConstant>,
              do not support fragments.</paragraph><note><paragraph>Which kind of fragments are supported depends on the content type and the
              specification of allowed fragment identifiers for the corresponding resource
              being referenced via the reference.</paragraph></note></field_body>""")],
          [
            'AASd-128',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>'s with
              <ReferenceToAttribute refuri="~Reference.type">~Reference.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</ReferenceToAttribute>, the
              <ReferenceToAttribute refuri="~Key.value">~Key.value</ReferenceToAttribute> of a <ReferenceToOurType refuri=".Key">.Key</ReferenceToOurType> preceded by a <ReferenceToOurType refuri=".Key">.Key</ReferenceToOurType> with
              <ReferenceToAttribute refuri="~Key.type">~Key.type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Key_types.Submodel_element_list">~Key_types.Submodel_element_list</ReferenceToAttribute> is an integer
              number denoting the position in the array of the submodel element list.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Key',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Key_types',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Denotes which kind of entity is referenced.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>In case <ReferenceToAttribute refuri="~type">~type</ReferenceToAttribute> = <ReferenceToAttribute refuri="~Key_types.Fragment_reference">~Key_types.Fragment_reference</ReferenceToAttribute> the key represents
                a bookmark or a similar local identifier within its parent element as specified
                by the key that precedes this key.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>In all other cases the key references a model element of the same or of another AAS.
                The name of the model element is explicitly listed.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Key',
          parsed=...),
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The key value, for example an IRDI or an URI</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Key',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Key_types',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>A key is a reference to an element by its ID.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Key_types',
      literals=[
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Bookmark or a similar local identifier of a subordinate part of
              a primary resource</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Identifiable',
          value='Identifiable',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Identifiable.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Identifiable is abstract, i.e. if a key uses “Identifiable” the reference
                may be an Asset Administration Shell, a Submodel or a Concept Description.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Data element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses <ReferenceToAttribute refuri="~Data_element">~Data_element</ReferenceToAttribute>
                the reference may be a Property, a File etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Event.</paragraph>',
            remarks=[
              '<note><paragraph><ReferenceToOurType refuri=".Event_element">.Event_element</ReferenceToOurType> is abstract.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Property with a value that can be provided in multiple languages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Range with min and max</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Reference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Referable',
          value='Referable',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Relationship</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Submodel Element is abstract, <emphasis>i.e.</emphasis> if a key uses <ReferenceToAttribute refuri="~Submodel_element">~Submodel_element</ReferenceToAttribute>
                the reference may be a <ReferenceToOurType refuri=".Property">.Property</ReferenceToOurType>, an <ReferenceToOurType refuri=".Operation">.Operation</ReferenceToOurType> etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=1,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Data_type_def_XSD',
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time_stamp',
          value='xs:dateTimeStamp',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Day_time_duration',
          value='xs:dayTimeDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='xs:yearMonthDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:NonNegativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          11,
          3],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Enumeration listing all xsd anySimpleTypes</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Lang_string',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='language',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type BCP_47_language_tag',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Lang_string',
          parsed=...),
        Property(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Text in the <ReferenceToAttribute refuri="~language">~language</ReferenceToAttribute></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Lang_string',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='language',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type BCP_47_language_tag',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='text',
            type_annotation=PrimitiveTypeAnnotation(
              a_type='STR',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          1],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Strings with language tags</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Environment',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='asset_administration_shells',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Asset_administration_shell',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Asset administration shell</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='submodels',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Submodel',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Submodel</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='concept_descriptions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Concept_description',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Concept description</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='asset_administration_shells',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Asset_administration_shell',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodels',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Submodel',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='concept_descriptions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Concept_description',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='asset_administration_shells',
              argument='asset_administration_shells',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodels',
              argument='submodels',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='concept_descriptions',
              argument='concept_descriptions',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Concept descriptions must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='concept_descriptions',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='concept_descriptions',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Invariant(
          description='Submodels must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='submodels',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Invariant(
          description='Asset administration shells must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='asset_administration_shells',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='asset_administration_shells',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          9],
        index=0,
        fragment=None),
      description=DescriptionOfOurType(
        summary='<paragraph>Container for the sets of different identifiables.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>w.r.t. file exchange: There is exactly one environment independent on how many
            files the contained elements are split. If the file is split then there
            shall be no element with the same identifier in two different files.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_specification_content',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_specification_content',
        name='Data_specification_content',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Data_specification_IEC_61360',
          'Reference to ConcreteClass Data_specification_physical_unit'],
        properties=[],
        signatures=[],
        description=DescriptionOfOurType(
          summary=textwrap.dedent("""\
            <paragraph>Data specification content is part of a data specification template and defines
            which additional attributes shall be added to the element instance that references
            the data specification template and meta information about the template itself.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Data_specification_IEC_61360',
        'Reference to ConcreteClass Data_specification_physical_unit'],
      properties=[],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=None,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[]),
      invariants=[],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          2,
          1,
          1],
        index=1,
        fragment='6.2.1.1 Data Specification Template Attributes'),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Data specification content is part of a data specification template and defines
          which additional attributes shall be added to the element instance that references
          the data specification template and meta information about the template itself.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Embedded_data_specification',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='data_specification',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Reference to the data specification</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Embedded_data_specification',
          parsed=...),
        Property(
          name='data_specification_content',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_specification_content',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Actual content of the data specification</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Embedded_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='data_specification',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='data_specification_content',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Data_specification_content',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='data_specification',
              argument='data_specification',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specification_content',
              argument='data_specification_content',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          9,
          2,
          5],
        index=0,
        fragment='9.2.5 Embedded Data Specifications'),
      description=DescriptionOfOurType(
        summary='<paragraph>Embed the content of a data specification.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Data_type_IEC_61360',
      literals=[
        EnumerationLiteral(
          name='Date',
          value='DATE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing a calendar date, conformant to ISO 8601:2004 Format yyyy-mm-dd
              Example from IEC 61360-1:2017: "1999-05-31" is the [DATE] representation of:
              "31 May 1999".</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='STRING',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values consisting of sequence of characters but cannot be translated into other
              languages</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='String_translatable',
          value='STRING_TRANSLATABLE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing string but shall be represented as different string in different
              languages</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_measure',
          value='INTEGER_MEASURE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing values that are measure of type INTEGER. In addition such a value
              comes with a physical unit.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_count',
          value='INTEGER_COUNT',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type INTEGER but are no currencies or measures</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Integer_currency',
          value='INTEGER_CURRENCY',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type INTEGER that are currencies</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_measure',
          value='REAL_MEASURE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing values that are measures of type REAL. In addition such a value
              comes with a physical unit.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_count',
          value='REAL_COUNT',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing numbers that can be written as a terminating or non-terminating
              decimal; a rational or irrational number but are no currencies or measures</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Real_currency',
          value='REAL_CURRENCY',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type REAL that are currencies</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='BOOLEAN',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values representing truth of logic or Boolean algebra (TRUE, FALSE)</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='IRI',
          value='IRI',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type STRING conformant to Rfc 3987</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In IEC61360-1 (2017) only URI is supported.
                An IRI type allows in particular to express an URL or an URI.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='IRDI',
          value='IRDI',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values conforming to ISO/IEC 11179 series global identifier sequences</paragraph>',
            remarks=[
              '<paragraph>IRDI can be used instead of the more specific data types ICID or ISO29002_IRDI.</paragraph>',
              textwrap.dedent("""\
                <paragraph>ICID values are value conformant to an IRDI, where the delimiter between RAI and ID
                is “#” while the delimiter between DI and VI is confined to “##”</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>ISO29002_IRDI values are values containing a global identifier that identifies an
                administrated item in a registry. The structure of this identifier complies with
                identifier syntax defined in ISO/TS 29002-5. The identifier shall fulfil the
                requirements specified in ISO/TS 29002-5 for an "international registration data
                identifier" (IRDI).</paragraph>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Rational',
          value='RATIONAL',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing values of type rational</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Rational_measure',
          value='RATIONAL_MEASURE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing values of type rational. In addition such a value comes with a
              physical unit.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='TIME',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing a time, conformant to ISO 8601:2004 but restricted to what is
              allowed in the corresponding type in xml.</paragraph>"""),
            remarks=[
              '<paragraph>Format hh:mm (ECLASS)</paragraph>',
              textwrap.dedent("""\
                <paragraph>Example from IEC 61360-1:2017: "13:20:00-05:00" is the [TIME] representation of:
                1.20 p.m. for Eastern Standard Time, which is 5 hours behind Coordinated
                Universal Time (UTC).</paragraph>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Timestamp',
          value='TIMESTAMP',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing a time, conformant to ISO 8601:2004 but restricted to what is
              allowed in the corresponding type in xml.</paragraph>"""),
            remarks=[
              '<paragraph>Format yyyy-mm-dd hh:mm (ECLASS)</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='FILE',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>values containing an address to a file. The values are of type URI and can represent
              an absolute or relative path.</paragraph>"""),
            remarks=[
              '<note><paragraph>IEC61360 does not support the file type.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='HTML',
          value='HTML',
          description=DescriptionOfEnumerationLiteral(
            summary=textwrap.dedent("""\
              <paragraph>Values containing string with any sequence of characters, using the syntax of HTML5
              (see W3C Recommendation 28:2014)</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='BLOB',
          description=DescriptionOfEnumerationLiteral(
            summary='<paragraph>values containing the content of a file. Values may be binaries.</paragraph>',
            remarks=[
              '<paragraph>HTML conformant to HTML5 is a special blob.</paragraph>',
              textwrap.dedent("""\
                <paragraph>In IEC61360 binary is for a sequence of bits, each bit being represented by “0” and
                “1” only. A binary is a blob but a blob may also contain other source code.</paragraph>""")],
            parsed=...),
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          3,
          3,
          1],
        index=1,
        fragment='6.3.3.1 Data Specification IEC61360 Template Attributes'),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Level_type',
      literals=[
        EnumerationLiteral(
          name='Min',
          value='Min',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Max',
          value='Max',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Nom',
          value='Nom',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Typ',
          value='Typ',
          description=None,
          parsed=...)],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          3,
          3,
          1],
        index=4,
        fragment='6.3.3.1 Data Specification IEC61360 Template Attributes'),
      description=None,
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Value_reference_pair',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>The value of the referenced concept definition of the value in valueId.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_reference_pair',
          parsed=...),
        Property(
          name='value_id',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Global unique id of the value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_reference_pair',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value',
            type_annotation=PrimitiveTypeAnnotation(
              a_type='STR',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value_id',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_id',
              argument='value_id',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          3,
          3,
          1],
        index=3,
        fragment='4.8.2 Predefined Templates for Property and Value Descriptions'),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>A value reference pair within a value list. Each value has a global unique id
          defining its semantic.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Value_list',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value_reference_pair_types',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Value_reference_pair',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>A pair of a value together with its global unique id.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Value_list',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_reference_pair_types',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Value_reference_pair',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value_reference_pair_types',
              argument='value_reference_pair_types',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Value reference pair types must containt at least one item.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_reference_pair_types',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Value_list',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          3,
          3,
          1],
        index=2,
        fragment='6.3.3.1 Data Specification IEC61360 Template Attributes'),
      description=DescriptionOfOurType(
        summary='<paragraph>A set of value reference pairs.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Data_specification_IEC_61360',
      inheritances=[
        'Reference to AbstractClass Data_specification_content'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='preferred_name',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Lang_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Preferred name</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASc-002',
                '<field_body><paragraph><ReferenceToAttribute refuri="~preferred_name">~preferred_name</ReferenceToAttribute> shall be provided at least in English.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='short_name',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Short name</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='unit',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Unit</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='unit_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Reference',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Unique unit id</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph><ReferenceToAttribute refuri="~unit">~unit</ReferenceToAttribute> and <ReferenceToAttribute refuri="~unit_id">~unit_id</ReferenceToAttribute> need to be consistent if both attributes
                are set</paragraph>"""),
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>',
              textwrap.dedent("""\
                <note><paragraph>Although the <ReferenceToAttribute refuri="~unit_id">~unit_id</ReferenceToAttribute> is a global reference there might exist a
                <ReferenceToOurType refuri=".Concept_description">.Concept_description</ReferenceToOurType>
                with data specification <ReferenceToOurType refuri=".Data_specification_physical_unit">.Data_specification_physical_unit</ReferenceToOurType> with
                the same ID.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='source_of_definition',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Source of definition</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='symbol',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Symbol</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='data_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Data_type_IEC_61360',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Data Type</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='definition',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Definition in different languages</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='value_format',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Value Format</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='value_list',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Value_list',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>List of allowed values</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=PrimitiveTypeAnnotation(
              a_type='STR',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Value</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Property(
          name='level_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Level_type',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Set of levels.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='preferred_name',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='short_name',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='unit',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='unit_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Reference',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='source_of_definition',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='symbol',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Data_type_IEC_61360',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='definition',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  our_type='Reference to our type Lang_string',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_format',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_list',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Value_list',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=PrimitiveTypeAnnotation(
                a_type='STR',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='level_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Level_type',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='preferred_name',
              argument='preferred_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='short_name',
              argument='short_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='unit',
              argument='unit',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='unit_id',
              argument='unit_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='source_of_definition',
              argument='source_of_definition',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='symbol',
              argument='symbol',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_type',
              argument='data_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='definition',
              argument='definition',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_format',
              argument='value_format',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_list',
              argument='value_list',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='level_type',
              argument='level_type',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASc-010: If value is not empty then value list shall be empty and vice versa.',
          body=textwrap.dedent("""\
            Or(
              values=[
                And(
                  values=[
                    IsNotNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value',
                        original_node=...),
                      original_node=...),
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value_list',
                        original_node=...),
                      original_node=...)],
                  original_node=...),
                And(
                  values=[
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value',
                        original_node=...),
                      original_node=...),
                    IsNotNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value_list',
                        original_node=...),
                      original_node=...),
                    Comparison(
                      left=FunctionCall(
                        name='len',
                        args=[
                          Member(
                            instance=Member(
                              instance=Name(
                                identifier='self',
                                original_node=...),
                              name='value_list',
                              original_node=...),
                            name='value_reference_pair_types',
                            original_node=...)],
                        original_node=...),
                      op='GE',
                      right=Constant(
                        value=1,
                        original_node=...),
                      original_node=...)],
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Constraint AASc-009: If data type is a an integer, real or rational with a measure or currency, unit or unit ID shall be defined.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='data_type',
                      original_node=...),
                    original_node=...),
                  IsIn(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='data_type',
                      original_node=...),
                    container=Name(
                      identifier='IEC_61360_data_types_with_unit',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=Or(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='unit',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='unit_id',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Definition must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='definition',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='definition',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Definition specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='definition',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='definition',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Short name must be either not set or have at least one item',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='short_name',
                  original_node=...),
                original_node=...),
              consequent=Comparison(
                left=FunctionCall(
                  name='len',
                  args=[
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='short_name',
                      original_node=...)],
                  original_node=...),
                op='GE',
                right=Constant(
                  value=1,
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Short name specifies no duplicate languages',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='short_name',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='lang_strings_have_unique_languages',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='short_name',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Preferred name must have at least one item',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='preferred_name',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Preferred name specifies no duplicate languages',
          body=textwrap.dedent("""\
            FunctionCall(
              name='lang_strings_have_unique_languages',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='preferred_name',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...),
        Invariant(
          description='Constraint AASc-002: preferred name shall be provided at least in English.',
          body=textwrap.dedent("""\
            Any(
              generator=ForEach(
                variable=Name(
                  identifier='lang_string',
                  original_node=...),
                iteration=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='preferred_name',
                  original_node=...),
                original_node=...),
              condition=FunctionCall(
                name='is_BCP_47_for_english',
                args=[
                  Member(
                    instance=Name(
                      identifier='lang_string',
                      original_node=...),
                    name='language',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_IEC_61360',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          3,
          3,
          1],
        index=0,
        fragment='6.3.3.1 Data Specification IEC61360 Template Attributes'),
      description=DescriptionOfOurType(
        summary=textwrap.dedent("""\
          <paragraph>Content of data specification template for concept descriptions for properties,
          values and value lists conformant to IEC 61360.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>IEC61360 requires also a globally unique identifier for a concept
            description. This ID is not part of the data specification template.
            Instead the <ReferenceToAttribute refuri="~Concept_description.id">~Concept_description.id</ReferenceToAttribute> as inherited via
            <ReferenceToOurType refuri=".Identifiable">.Identifiable</ReferenceToOurType> is used. Same holds for administrative
            information like the version and revision.</paragraph></note>"""),
          textwrap.dedent("""\
            <note><paragraph><ReferenceToAttribute refuri="Concept_description.id_short">Concept_description.id_short</ReferenceToAttribute> and <ReferenceToAttribute refuri="~short_name">~short_name</ReferenceToAttribute> are very
            similar. However, in this case the decision was to add
            <ReferenceToAttribute refuri="~short_name">~short_name</ReferenceToAttribute> explicitly to the data specification. Same holds for
            <ReferenceToAttribute refuri="~Concept_description.display_name">~Concept_description.display_name</ReferenceToAttribute> and
            <ReferenceToAttribute refuri="~preferred_name">~preferred_name</ReferenceToAttribute>. Same holds for
            <ReferenceToAttribute refuri="Concept_description.description">Concept_description.description</ReferenceToAttribute> and <ReferenceToAttribute refuri="~definition">~definition</ReferenceToAttribute>.</paragraph></note>""")],
        constraints_by_identifier=[
          [
            'AASc-010',
            textwrap.dedent("""\
              <field_body><paragraph>If <ReferenceToAttribute refuri="~value">~value</ReferenceToAttribute> is not empty then <ReferenceToAttribute refuri="~value_list">~value_list</ReferenceToAttribute> shall be empty
              and vice versa.</paragraph></field_body>""")],
          [
            'AASc-009',
            textwrap.dedent("""\
              <field_body><paragraph>If <ReferenceToAttribute refuri="~data_type">~data_type</ReferenceToAttribute> one of:
              <ReferenceToAttribute refuri="~Data_type_IEC_61360.Integer_measure">~Data_type_IEC_61360.Integer_measure</ReferenceToAttribute>,
              <ReferenceToAttribute refuri="~Data_type_IEC_61360.Real_measure">~Data_type_IEC_61360.Real_measure</ReferenceToAttribute>,
              <ReferenceToAttribute refuri="~Data_type_IEC_61360.Rational_measure">~Data_type_IEC_61360.Rational_measure</ReferenceToAttribute>,
              <ReferenceToAttribute refuri="~Data_type_IEC_61360.Integer_currency">~Data_type_IEC_61360.Integer_currency</ReferenceToAttribute>,
              <ReferenceToAttribute refuri="~Data_type_IEC_61360.Real_currency">~Data_type_IEC_61360.Real_currency</ReferenceToAttribute>, then <ReferenceToAttribute refuri="~unit">~unit</ReferenceToAttribute> or
              <ReferenceToAttribute refuri="~unit_id">~unit_id</ReferenceToAttribute> shall be defined.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Data_specification_physical_unit',
      inheritances=[
        'Reference to AbstractClass Data_specification_content'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='unit_name',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Name of the physical unit</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='unit_symbol',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Non_empty_string',
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Symbol for the physical unit</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='definition',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Lang_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Definition in different languages</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='SI_notation',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Notation of SI physical unit</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='SI_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Name of SI physical unit</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='DIN_notation',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Notation of physical unit conformant to DIN</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='ECE_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Name of physical unit conformant to ECE</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='ECE_code',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Code of physical unit conformant to ECE</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='NIST_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Name of NIST physical unit</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='source_of_definition',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Source of definition</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='conversion_factor',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Conversion factor</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='registration_authority_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Registration authority ID</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Property(
          name='supplier',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            parsed=...),
          description=DescriptionOfProperty(
            summary='<paragraph>Supplier</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='unit_name',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='unit_symbol',
            type_annotation=OurTypeAnnotation(
              our_type='Reference to our type Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='definition',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                our_type='Reference to our type Lang_string',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='SI_notation',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='SI_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='DIN_notation',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ECE_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='ECE_code',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='NIST_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='source_of_definition',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='conversion_factor',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='registration_authority_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplier',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                our_type='Reference to our type Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultPrimitive(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='unit_name',
              argument='unit_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='unit_symbol',
              argument='unit_symbol',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='definition',
              argument='definition',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='SI_notation',
              argument='SI_notation',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='SI_name',
              argument='SI_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='DIN_notation',
              argument='DIN_notation',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ECE_name',
              argument='ECE_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='ECE_code',
              argument='ECE_code',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='NIST_name',
              argument='NIST_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='source_of_definition',
              argument='source_of_definition',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='conversion_factor',
              argument='conversion_factor',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='registration_authority_id',
              argument='registration_authority_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplier',
              argument='supplier',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Definition must have at least one item',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='definition',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...),
        Invariant(
          description='Definition specifies no duplicate languages',
          body=textwrap.dedent("""\
            FunctionCall(
              name='lang_strings_have_unique_languages',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='definition',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Data_specification_physical_unit',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          4,
          2,
          1],
        index=0,
        fragment='6.4.2.1 Data Specification Template Physical Unit Attributes'),
      description=None,
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...)],
  our_types_topologically_sorted=[
    'Reference to our type Has_data_specification',
    'Reference to our type Administrative_information',
    'Reference to our type Has_extensions',
    'Reference to our type Referable',
    'Reference to our type Has_kind',
    'Reference to our type Has_semantics',
    'Reference to our type Qualifiable',
    'Reference to our type Submodel_element',
    'Reference to our type Relationship_element',
    'Reference to our type Annotated_relationship_element',
    'Reference to our type Identifiable',
    'Reference to our type Asset_administration_shell',
    'Reference to our type Asset_information',
    'Reference to our type BCP_47_language_tag',
    'Reference to our type Event_element',
    'Reference to our type Basic_event_element',
    'Reference to our type Data_element',
    'Reference to our type Blob',
    'Reference to our type Blob_type',
    'Reference to our type Capability',
    'Reference to our type Concept_description',
    'Reference to our type Non_empty_string',
    'Reference to our type Content_type',
    'Reference to our type Data_specification_content',
    'Reference to our type Data_specification_IEC_61360',
    'Reference to our type Data_specification_physical_unit',
    'Reference to our type Date_time_stamp_UTC',
    'Reference to our type Embedded_data_specification',
    'Reference to our type Entity',
    'Reference to our type Environment',
    'Reference to our type Event_payload',
    'Reference to our type Extension',
    'Reference to our type File',
    'Reference to our type Id_short',
    'Reference to our type Identifier',
    'Reference to our type Key',
    'Reference to our type Lang_string',
    'Reference to our type Multi_language_property',
    'Reference to our type Operation',
    'Reference to our type Operation_variable',
    'Reference to our type Path_type',
    'Reference to our type Property',
    'Reference to our type Qualifier',
    'Reference to our type Qualifier_type',
    'Reference to our type Range',
    'Reference to our type Reference',
    'Reference to our type Reference_element',
    'Reference to our type Resource',
    'Reference to our type Specific_asset_id',
    'Reference to our type Submodel',
    'Reference to our type Submodel_element_collection',
    'Reference to our type Submodel_element_list',
    'Reference to our type Value_data_type',
    'Reference to our type Value_list',
    'Reference to our type Value_reference_pair'],
  constants=[
    ConstantSetOfPrimitives(
      name='Valid_categories_for_data_element',
      a_type='STR',
      literals=[
        PrimitiveSetLiteral(
          value='CONSTANT',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='PARAMETER',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='VARIABLE',
          a_type='STR',
          parsed=...)],
      literal_value_set=...,
      subsets=[],
      reference_in_the_book=None,
      description=DescriptionOfConstant(
        summary='<paragraph>Categories for :class:.Data_element` as defined in <ReferenceToConstraint refuri="AASd-090">AASd-090</ReferenceToConstraint></paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfPrimitives(
      name='Valid_categories_for_concept_description',
      a_type='STR',
      literals=[
        PrimitiveSetLiteral(
          value='VALUE',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='PROPERTY',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='REFERENCE',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='DOCUMENT',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='CAPABILITY',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='RELATIONSHIP',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='COLLECTION',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='FUNCTION',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='EVENT',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='ENTITY',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='APPLICATION_CLASS',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='QUALIFIER',
          a_type='STR',
          parsed=...),
        PrimitiveSetLiteral(
          value='VIEW',
          a_type='STR',
          parsed=...)],
      literal_value_set=...,
      subsets=[],
      reference_in_the_book=None,
      description=DescriptionOfConstant(
        summary='<paragraph>Categories for :class:.Concept_description` as defined in <ReferenceToConstraint refuri="AASd-051">AASd-051</ReferenceToConstraint></paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Generic_fragment_keys',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Fragment_reference'],
      literal_id_set=...,
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=9,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of all identifiable elements within an asset administration shell.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Generic_globally_identifiables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Global_reference'],
      literal_id_set=...,
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=8,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='AAS_identifiables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Asset_administration_shell',
        'Reference to EnumerationLiteral Concept_description',
        'Reference to EnumerationLiteral Identifiable',
        'Reference to EnumerationLiteral Submodel'],
      literal_id_set=...,
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=7,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='AAS_submodel_elements_as_keys',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Annotated_relationship_element',
        'Reference to EnumerationLiteral Basic_event_element',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral Capability',
        'Reference to EnumerationLiteral Data_element',
        'Reference to EnumerationLiteral Entity',
        'Reference to EnumerationLiteral Event_element',
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Multi_language_property',
        'Reference to EnumerationLiteral Operation',
        'Reference to EnumerationLiteral Property',
        'Reference to EnumerationLiteral Range',
        'Reference to EnumerationLiteral Reference_element',
        'Reference to EnumerationLiteral Relationship_element',
        'Reference to EnumerationLiteral Submodel_element',
        'Reference to EnumerationLiteral Submodel_element_list',
        'Reference to EnumerationLiteral Submodel_element_collection'],
      literal_id_set=...,
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=6,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of all referable elements within an asset administration shell.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='AAS_referable_non_identifiables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Annotated_relationship_element',
        'Reference to EnumerationLiteral Basic_event_element',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral Capability',
        'Reference to EnumerationLiteral Data_element',
        'Reference to EnumerationLiteral Entity',
        'Reference to EnumerationLiteral Event_element',
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Multi_language_property',
        'Reference to EnumerationLiteral Operation',
        'Reference to EnumerationLiteral Property',
        'Reference to EnumerationLiteral Range',
        'Reference to EnumerationLiteral Reference_element',
        'Reference to EnumerationLiteral Relationship_element',
        'Reference to EnumerationLiteral Submodel_element',
        'Reference to EnumerationLiteral Submodel_element_collection',
        'Reference to EnumerationLiteral Submodel_element_list'],
      literal_id_set=...,
      subsets=[
        'Reference to ConstantSetOfEnumerationLiterals AAS_submodel_elements_as_keys'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=4,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of different fragment key value types within a key.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='AAS_referables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Asset_administration_shell',
        'Reference to EnumerationLiteral Concept_description',
        'Reference to EnumerationLiteral Identifiable',
        'Reference to EnumerationLiteral Submodel',
        'Reference to EnumerationLiteral Annotated_relationship_element',
        'Reference to EnumerationLiteral Basic_event_element',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral Capability',
        'Reference to EnumerationLiteral Data_element',
        'Reference to EnumerationLiteral Entity',
        'Reference to EnumerationLiteral Event_element',
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Multi_language_property',
        'Reference to EnumerationLiteral Operation',
        'Reference to EnumerationLiteral Property',
        'Reference to EnumerationLiteral Range',
        'Reference to EnumerationLiteral Reference_element',
        'Reference to EnumerationLiteral Referable',
        'Reference to EnumerationLiteral Relationship_element',
        'Reference to EnumerationLiteral Submodel_element',
        'Reference to EnumerationLiteral Submodel_element_collection',
        'Reference to EnumerationLiteral Submodel_element_list'],
      literal_id_set=...,
      subsets=[
        'Reference to ConstantSetOfEnumerationLiterals AAS_referable_non_identifiables',
        'Reference to ConstantSetOfEnumerationLiterals AAS_identifiables'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=5,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of referables.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Globally_identifiables',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Global_reference',
        'Reference to EnumerationLiteral Asset_administration_shell',
        'Reference to EnumerationLiteral Concept_description',
        'Reference to EnumerationLiteral Identifiable',
        'Reference to EnumerationLiteral Submodel'],
      literal_id_set=...,
      subsets=[
        'Reference to ConstantSetOfEnumerationLiterals AAS_identifiables',
        'Reference to ConstantSetOfEnumerationLiterals Generic_globally_identifiables'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=3,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of all referable elements within an asset administration shell</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Fragment_keys',
      enumeration='Reference to Enumeration Key_types',
      literals=[
        'Reference to EnumerationLiteral Fragment_reference',
        'Reference to EnumerationLiteral Annotated_relationship_element',
        'Reference to EnumerationLiteral Basic_event_element',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral Capability',
        'Reference to EnumerationLiteral Data_element',
        'Reference to EnumerationLiteral Entity',
        'Reference to EnumerationLiteral Event_element',
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Multi_language_property',
        'Reference to EnumerationLiteral Operation',
        'Reference to EnumerationLiteral Property',
        'Reference to EnumerationLiteral Range',
        'Reference to EnumerationLiteral Reference_element',
        'Reference to EnumerationLiteral Relationship_element',
        'Reference to EnumerationLiteral Submodel_element',
        'Reference to EnumerationLiteral Submodel_element_list',
        'Reference to EnumerationLiteral Submodel_element_collection'],
      literal_id_set=...,
      subsets=[
        'Reference to ConstantSetOfEnumerationLiterals AAS_referable_non_identifiables',
        'Reference to ConstantSetOfEnumerationLiterals Generic_fragment_keys'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=2,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Data_type_IEC_61360_for_property_or_value',
      enumeration='Reference to Enumeration Data_type_IEC_61360',
      literals=[
        'Reference to EnumerationLiteral Date',
        'Reference to EnumerationLiteral String',
        'Reference to EnumerationLiteral String_translatable',
        'Reference to EnumerationLiteral Integer_measure',
        'Reference to EnumerationLiteral Integer_count',
        'Reference to EnumerationLiteral Integer_currency',
        'Reference to EnumerationLiteral Real_measure',
        'Reference to EnumerationLiteral Real_count',
        'Reference to EnumerationLiteral Real_currency',
        'Reference to EnumerationLiteral Boolean',
        'Reference to EnumerationLiteral Rational',
        'Reference to EnumerationLiteral Rational_measure',
        'Reference to EnumerationLiteral Time',
        'Reference to EnumerationLiteral Timestamp'],
      literal_id_set=...,
      subsets=[],
      reference_in_the_book=None,
      description=DescriptionOfConstant(
        summary='<paragraph>IEC 61360 data types for concept descriptions categorized with PROPERTY or VALUE.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Data_type_IEC_61360_for_reference',
      enumeration='Reference to Enumeration Data_type_IEC_61360',
      literals=[
        'Reference to EnumerationLiteral String',
        'Reference to EnumerationLiteral IRI',
        'Reference to EnumerationLiteral IRDI'],
      literal_id_set=...,
      subsets=[],
      reference_in_the_book=None,
      description=DescriptionOfConstant(
        summary='<paragraph>IEC 61360 data types for concept descriptions categorized with REFERENCE.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='Data_type_IEC_61360_for_document',
      enumeration='Reference to Enumeration Data_type_IEC_61360',
      literals=[
        'Reference to EnumerationLiteral File',
        'Reference to EnumerationLiteral Blob',
        'Reference to EnumerationLiteral HTML'],
      literal_id_set=...,
      subsets=[],
      reference_in_the_book=None,
      description=DescriptionOfConstant(
        summary='<paragraph>IEC 61360 data types for concept descriptions categorized with DOCUMENT.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...),
    ConstantSetOfEnumerationLiterals(
      name='IEC_61360_data_types_with_unit',
      enumeration='Reference to Enumeration Data_type_IEC_61360',
      literals=[
        'Reference to EnumerationLiteral Integer_measure',
        'Reference to EnumerationLiteral Real_measure',
        'Reference to EnumerationLiteral Rational_measure',
        'Reference to EnumerationLiteral Integer_currency',
        'Reference to EnumerationLiteral Real_currency'],
      literal_id_set=...,
      subsets=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=9,
        fragment=None),
      description=DescriptionOfConstant(
        summary='<paragraph>These data types imply that the unit is defined in the data specification.</paragraph>',
        remarks=[],
        parsed=...),
      parsed=...)],
  constants_by_name=...,
  verification_functions=[
    PatternVerification(
      name='matches_id_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid short ID.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[a-zA-Z][a-zA-Z0-9_]+$'),
    PatternVerification(
      name='matches_xs_date_time_stamp_utc',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:dateTimeStamp</literal>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The time zone must be fixed to UTC. We verify only that the <literal>text</literal> matches
            a pre-defined pattern. We <emphasis>do not</emphasis> verify that the day of month is
            correct nor do we check for leap seconds.</paragraph>"""),
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp">https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)Z$'),
    ImplementationSpecificVerification(
      name='is_xs_date_time_stamp_utc',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a <literal>xs:dateTimeStamp</literal> with time zone set to UTC.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The <literal>text</literal> is assumed to match a pre-defined pattern for <literal>xs:dateTimeStamp</literal> with
            the time zone set to UTC. In this function, we check for days of month (e.g.,
            February 29th).</paragraph>"""),
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp">https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid <literal>xs:dateTimeStamp</literal> in UTC</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_MIME_type',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of MIME type.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The definition has been taken from:
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1">https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1</reference>,
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3">https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3</reference> and
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6">https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6</reference>.</paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+|"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*"))*$'),
    PatternVerification(
      name='matches_RFC_8089_path',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a path conforming to the pattern of RFC 8089.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The definition has been taken from:
            <reference refuri="https://datatracker.ietf.org/doc/html/rfc8089">https://datatracker.ietf.org/doc/html/rfc8089</reference></paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern="^file:(//((localhost|(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)))?/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?)$"),
    PatternVerification(
      name='matches_BCP_47',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> is a valid BCP 47 language tag.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://en.wikipedia.org/wiki/IETF_language_tag">https://en.wikipedia.org/wiki/IETF_language_tag</reference></paragraph>'],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$'),
    ImplementationSpecificVerification(
      name='lang_strings_have_unique_languages',
      arguments=[
        Argument(
          name='lang_strings',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Lang_string',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToArgument refuri="lang_strings">lang_strings</ReferenceToArgument> do not have overlapping
          <ReferenceToAttribute refuri="~Lang_string.language">~Lang_string.language</ReferenceToAttribute>'s</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='qualifier_types_are_unique',
      arguments=[
        Argument(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Qualifier',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>\'s of <ReferenceToArgument refuri="qualifiers">qualifiers</ReferenceToArgument> are unique.</paragraph>',
        remarks=[],
        arguments_by_name=[
          [
            'qualifiers',
            '<field_body><paragraph>to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if all <ReferenceToAttribute refuri="~Qualifier.type">~Qualifier.type</ReferenceToAttribute>\'s are unique</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_xs_any_URI',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:anyURI</literal>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#anyURI">https://www.w3.org/TR/xmlschema11-2/#anyURI</reference> and
            <reference refuri="https://datatracker.ietf.org/doc/html/rfc3987">https://datatracker.ietf.org/doc/html/rfc3987</reference></paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern="^([a-zA-Z][a-zA-Z0-9+\\-.]*:(//((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|:)*@)?(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)(:[0-9]*)?(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|/(((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])){0})(\\?((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]|[/?])*)?(\\#((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[/?])*)?|(//((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|:)*@)?(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)(:[0-9]*)?(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|/(((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|@)+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])){0})(\\?((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]|[/?])*)?(\\#((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[/?])*)?)$"),
    PatternVerification(
      name='matches_xs_base_64_binary',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:base64Binary</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#base64Binary">https://www.w3.org/TR/xmlschema11-2/#base64Binary</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?)*(([A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/])|[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[AEIMQUYcgkosw048]\\x20?=|[A-Za-z0-9+/]\\x20?[AQgw]\\x20?= ?=))?$'),
    PatternVerification(
      name='matches_xs_boolean',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:boolean</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#boolean">https://www.w3.org/TR/xmlschema11-2/#boolean</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(true|false|1|0)$'),
    PatternVerification(
      name='matches_xs_date',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:date</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#date">https://www.w3.org/TR/xmlschema11-2/#date</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))(Z|(\\+|-)(0[0-9]|1[0-3]):[0-5][0-9]|14:00)?$'),
    PatternVerification(
      name='matches_xs_date_time',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:dateTime</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dateTime">https://www.w3.org/TR/xmlschema11-2/#dateTime</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|(\\+|-)(0[0-9]|1[0-3]):[0-5][0-9]|14:00)?$'),
    PatternVerification(
      name='matches_xs_date_time_stamp',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:dateTimeStamp</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp">https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|(\\+|-)(0[0-9]|1[0-3]):[0-5][0-9]|14:00)$'),
    PatternVerification(
      name='matches_xs_decimal',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:decimal</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#decimal">https://www.w3.org/TR/xmlschema11-2/#decimal</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^((\\+|-)?([0-9]+\\.[0-9]+|\\.[0-9]+)|(\\+|-)?[0-9]+)$'),
    PatternVerification(
      name='matches_xs_double',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:double</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#double">https://www.w3.org/TR/xmlschema11-2/#double</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN$'),
    PatternVerification(
      name='matches_xs_duration',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:duration</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#duration">https://www.w3.org/TR/xmlschema11-2/#duration</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$'),
    PatternVerification(
      name='matches_xs_float',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:float</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#float">https://www.w3.org/TR/xmlschema11-2/#float</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN$'),
    PatternVerification(
      name='matches_xs_g_day',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gDay</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gDay">https://www.w3.org/TR/xmlschema11-2/#gDay</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_g_month',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gMonth</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gMonth">https://www.w3.org/TR/xmlschema11-2/#gMonth</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_g_month_day',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gMonthDay</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gMonthDay">https://www.w3.org/TR/xmlschema11-2/#gMonthDay</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_g_year',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gYear</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gYear">https://www.w3.org/TR/xmlschema11-2/#gYear</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_g_year_month',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:gYearMonth</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gYearMonth">https://www.w3.org/TR/xmlschema11-2/#gYearMonth</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_hex_binary',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:hexBinary</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#hexBinary">https://www.w3.org/TR/xmlschema11-2/#hexBinary</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^([0-9a-fA-F]{2})*$'),
    PatternVerification(
      name='matches_xs_time',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:time</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#time">https://www.w3.org/TR/xmlschema11-2/#time</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_day_time_duration',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:dayTimeDuration</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration">https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?P((([0-9]+D)(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$'),
    PatternVerification(
      name='matches_xs_year_month_duration',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:yearMonthDuration</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#yearMonthDuration">https://www.w3.org/TR/xmlschema11-2/#yearMonthDuration</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?P((([0-9]+Y)([0-9]+M)?)|([0-9]+M))$'),
    PatternVerification(
      name='matches_xs_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:integer</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#integer">https://www.w3.org/TR/xmlschema11-2/#integer</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?[0-9]+$'),
    PatternVerification(
      name='matches_xs_long',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:long</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#long">https://www.w3.org/TR/xmlschema11-2/#long</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,20}$'),
    PatternVerification(
      name='matches_xs_int',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:int</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#int">https://www.w3.org/TR/xmlschema11-2/#int</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,10}$'),
    PatternVerification(
      name='matches_xs_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:short</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#short">https://www.w3.org/TR/xmlschema11-2/#short</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,5}$'),
    PatternVerification(
      name='matches_xs_byte',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:byte</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#byte">https://www.w3.org/TR/xmlschema11-2/#byte</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,3}$'),
    PatternVerification(
      name='matches_xs_non_negative_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:nonNegativeInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#nonNegativeInteger">https://www.w3.org/TR/xmlschema11-2/#nonNegativeInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?[0-9]+)$'),
    PatternVerification(
      name='matches_xs_positive_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:positiveInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#positiveInteger">https://www.w3.org/TR/xmlschema11-2/#positiveInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^\\+?0*[1-9][0-9]*$'),
    PatternVerification(
      name='matches_xs_unsigned_long',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:unsignedLong</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#unsignedLong">https://www.w3.org/TR/xmlschema11-2/#unsignedLong</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,20})$'),
    PatternVerification(
      name='matches_xs_unsigned_int',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:unsignedInt</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#unsignedInt">https://www.w3.org/TR/xmlschema11-2/#unsignedInt</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,10})$'),
    PatternVerification(
      name='matches_xs_unsigned_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:unsignedShort</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#unsignedShort">https://www.w3.org/TR/xmlschema11-2/#unsignedShort</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,5})$'),
    PatternVerification(
      name='matches_xs_unsigned_byte',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:unsignedByte</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#unsignedByte">https://www.w3.org/TR/xmlschema11-2/#unsignedByte</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,3})$'),
    PatternVerification(
      name='matches_xs_non_positive_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:nonPositiveInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#nonPositiveInteger">https://www.w3.org/TR/xmlschema11-2/#nonPositiveInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(\\+0|0|-[0-9]+)$'),
    PatternVerification(
      name='matches_xs_negative_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:negativeInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#negativeInteger">https://www.w3.org/TR/xmlschema11-2/#negativeInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0*[1-9][0-9]*)$'),
    PatternVerification(
      name='matches_xs_string',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern of an <literal>xs:string</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#string">https://www.w3.org/TR/xmlschema11-2/#string</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\u0001-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$'),
    ImplementationSpecificVerification(
      name='value_consistent_with_xsd_type',
      arguments=[
        Argument(
          name='value',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the <ReferenceToArgument refuri="value">value</ReferenceToArgument> conforms to its <ReferenceToArgument refuri="value_type">value_type</ReferenceToArgument>.</paragraph>',
        remarks=[],
        arguments_by_name=[
          [
            'value',
            '<field_body><paragraph>which needs to conform</paragraph></field_body>'],
          [
            'value_type',
            '<field_body><paragraph>pre-defined value type</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="value">value</ReferenceToArgument> conforms</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_global_asset_id_literally',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the <ReferenceToArgument refuri="text">text</ReferenceToArgument> matches <literal>globalAssetId</literal> case-insensitive.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The case-insensitivity depends on the culture. For example in Turkish, uppercase
            "i" is "İ", not "I". We assume the culture to be English, and explicitly check
            for English case-folding.</paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>which needs to match <literal>globalAssetId</literal> literally</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ReferenceToArgument refuri="text">text</ReferenceToArgument> matches case-insensitive</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[gG][lL][oO][bB][aA][lL][aA][sS][sS][eE][tT][iI][dD]$'),
    TranspilableVerification(
      name='is_model_reference_to',
      arguments=[
        Argument(
          name='reference',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='expected_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Key_types',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the target of the model reference matches the <ReferenceToArgument refuri="expected_type">expected_type</ReferenceToArgument>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    TranspilableVerification(
      name='is_model_reference_to_referable',
      arguments=[
        Argument(
          name='reference',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the target of the reference matches a <ReferenceToConstant refuri=".AAS_referables">.AAS_referables</ReferenceToConstant>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='id_shorts_are_unique',
      arguments=[
        Argument(
          name='referables',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Referable',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="~Referable.id_short">~Referable.id_short</ReferenceToAttribute>'s among the <ReferenceToArgument refuri="referables">referables</ReferenceToArgument> are
          unique.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='extension_names_are_unique',
      arguments=[
        Argument(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Extension',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the extension names are unique.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='submodel_elements_have_identical_semantic_ids',
      arguments=[
        Argument(
          name='elements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Submodel_element',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that all semantic IDs are identical, if specified.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='submodel_element_is_of_type',
      arguments=[
        Argument(
          name='element',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Submodel_element',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='element_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type AAS_submodel_elements',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the run-time type of the <ReferenceToArgument refuri="element">element</ReferenceToArgument> coincides with
          <ReferenceToArgument refuri="element_type">element_type</ReferenceToArgument>.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='properties_or_ranges_have_value_type',
      arguments=[
        Argument(
          name='elements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Submodel_element',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Data_type_def_XSD',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that all the <ReferenceToArgument refuri="elements">elements</ReferenceToArgument> have the <ReferenceToArgument refuri="value_type">value_type</ReferenceToArgument>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='reference_key_values_equal',
      arguments=[
        Argument(
          name='that',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='other',
          type_annotation=OurTypeAnnotation(
            our_type='Reference to our type Reference',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the two references are equal by comparing their key values.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_for_property_or_value_have_appropriate_data_type',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.data_type">~Data_specification_IEC_61360.data_type</ReferenceToAttribute> is defined
          appropriately for all data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_for_reference_have_appropriate_data_type',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.data_type">~Data_specification_IEC_61360.data_type</ReferenceToAttribute> is defined
          appropriately for all data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_for_document_have_appropriate_data_type',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.data_type">~Data_specification_IEC_61360.data_type</ReferenceToAttribute> is defined
          appropriately for all data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_have_data_type',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.data_type">~Data_specification_IEC_61360.data_type</ReferenceToAttribute> is defined for all
          data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_have_value',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.value">~Data_specification_IEC_61360.value</ReferenceToAttribute> is defined
          for all data specifications whose content is given as IEC 61360.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='data_specification_IEC_61360s_have_definition_at_least_in_english',
      arguments=[
        Argument(
          name='embedded_data_specifications',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              our_type='Reference to our type Embedded_data_specification',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ReferenceToAttribute refuri="~Data_specification_IEC_61360.definition">~Data_specification_IEC_61360.definition</ReferenceToAttribute> is defined
          for all data specifications whose content is given as IEC 61360 at least in English.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='is_BCP_47_for_english',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=DescriptionOfSignature(
        summary='<paragraph>Check that the <ReferenceToArgument refuri="text">text</ReferenceToArgument> corresponds to a BCP47 code for english.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(en|EN)(-.*)?$')],
  verification_functions_by_name=...,
  meta_model=MetaModel(
    description=DescriptionOfMetaModel(
      summary='<paragraph>Provide the meta-model for Asset Administration Shell V3.0 Release Candidate 2.</paragraph>',
      remarks=[
        '<paragraph>We had to diverge from the book in the following points.</paragraph>',
        textwrap.dedent("""\
          <paragraph>We could not implement the following constraints as they are too general and can not
          be formalized as part of the core library, but affects external components such as
          AAS registry or AAS server:</paragraph>"""),
        textwrap.dedent("""\
          <paragraph>We could not implement the following constraints since they depend on registry and
          de-referencing, so we can not formalize them with formalizing such external dependncies:</paragraph>"""),
        '<bullet_list bullet="*"><list_item><paragraph><ReferenceToConstraint refuri="AASd-006">AASd-006</ReferenceToConstraint></paragraph></list_item><list_item><paragraph><ReferenceToConstraint refuri="AASd-007">AASd-007</ReferenceToConstraint></paragraph></list_item></bullet_list>',
        textwrap.dedent("""\
          <paragraph>Some constraints are not enforceable as they depend on the wider context
          such as language understanding, so we could not formalize them:</paragraph>"""),
        '<bullet_list bullet="*"><list_item><paragraph><ReferenceToConstraint refuri="AASd-012">AASd-012</ReferenceToConstraint></paragraph></list_item></bullet_list>',
        textwrap.dedent("""\
          <paragraph>The constraint <ReferenceToConstraint refuri="AASd-116">AASd-116</ReferenceToConstraint> is ill-defined. The type of the
          <ReferenceToAttribute refuri="~Specific_asset_id.value">~Specific_asset_id.value</ReferenceToAttribute> is a string, but the type of
          <ReferenceToAttribute refuri="~Asset_information.global_asset_id">~Asset_information.global_asset_id</ReferenceToAttribute> is a <ReferenceToOurType refuri=".Reference">.Reference</ReferenceToOurType>. The comparison
          between a string and a reference is not defined, so we can not implement
          this constraint.</paragraph>"""),
        textwrap.dedent("""\
          <paragraph>Furthermore, we diverge from the book in the following points regarding
          the enumerations. We have to implement subsets of enumerations as sets as common
          programming languages do not support inheritance of enumerations. The relationship
          between the properties and the sets is defined through invariants. This causes
          the following divergences:</paragraph>"""),
        textwrap.dedent("""\
          <bullet_list bullet="*"><list_item><paragraph>We decided therefore to remove the enumerations <literal>DataTypeDef</literal> and <literal>DataTypeDefRDF</literal>
          and keep only <ReferenceToOurType refuri=".Data_type_def_XSD">.Data_type_def_XSD</ReferenceToOurType> as enumeration. Otherwise, we would have
          to write redundant invariants all over the meta-model because <literal>DataTypeDef</literal> and
          <literal>DataTypeDefRDF</literal> are actually never used in any type definition.</paragraph></list_item><list_item><paragraph>The enumeration <literal>AasSubmodelElements</literal> is used in two different contexts. One context
          is the definition of key types in a reference. Another context is the definition
          of element types in a <ReferenceToOurType refuri=".Submodel_element_list">.Submodel_element_list</ReferenceToOurType>. It is very counter-intuitive
          to see the type of <ReferenceToAttribute refuri="~Submodel_element_list.type_value_list_element">~Submodel_element_list.type_value_list_element</ReferenceToAttribute> as
          <ReferenceToOurType refuri=".Key_types">.Key_types</ReferenceToOurType> even though an invariant might specify that it is an element of
          <literal>AasSubmodelElements</literal>.</paragraph><paragraph>To avoid confusion, we introduce a set of <ReferenceToOurType refuri=".Key_types">.Key_types</ReferenceToOurType>,
          <ReferenceToConstant refuri=".AAS_submodel_elements_as_keys">.AAS_submodel_elements_as_keys</ReferenceToConstant> to represent the first context (key type
          in a reference). The enumeration <ReferenceToOurType refuri=".AAS_submodel_elements">.AAS_submodel_elements</ReferenceToOurType> is kept as designator
          for <ReferenceToAttribute refuri="~Submodel_element_list.type_value_list_element">~Submodel_element_list.type_value_list_element</ReferenceToAttribute>.</paragraph></list_item></bullet_list>"""),
        textwrap.dedent("""\
          <paragraph>Concerning the data specifications, we embed them within
          <ReferenceToOurType refuri=".Has_data_specification">.Has_data_specification</ReferenceToOurType> instead of referencing them <emphasis>via</emphasis> a global reference.
          The working group decided to change the rules for serialization <emphasis>after</emphasis> the book was
          published. The data specifications are critical in applications, but there is no
          possibility to access them through a data channel as they are not part of
          an environment.</paragraph>"""),
        '<paragraph>Since the data specifications are now embedded, the following constraints became futile:</paragraph>',
        '<bullet_list bullet="*"><list_item><paragraph><literal>AASd-050</literal></paragraph></list_item><list_item><paragraph><literal>AASd-050b</literal></paragraph></list_item></bullet_list>'],
      constraints_by_identifier=[
        [
          'AASd-120',
          textwrap.dedent("""\
            <field_body><paragraph><ReferenceToAttribute refuri="Referable.id_short">Referable.id_short</ReferenceToAttribute> of non-identifiable referables shall be unique in its
            namespace.</paragraph></field_body>""")],
        [
          'AASd-003',
          '<field_body><paragraph><ReferenceToAttribute refuri="Referable.id_short">Referable.id_short</ReferenceToAttribute> of <ReferenceToOurType refuri=".Referable">.Referable</ReferenceToOurType>\'s shall be matched case-sensitive.</paragraph></field_body>']],
      parsed=...),
    book_url='https://www.plattform-i40.de/IP/Redaktion/DE/Downloads/Publikation/Details_of_the_Asset_Administration_Shell_Part1_V3.pdf?__blob=publicationFile&v=10',
    book_version='V3.0RC02',
    xml_namespace='http://www.admin-shell.io/aas/3/0/RC02'))