SymbolTable(
  symbols=[
    ConstrainedPrimitive(
      name='Non_empty_string',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=SymbolDescription(
        summary='<paragraph>Represent a string with at least one character.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Date_time_stamp_UTC',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_xs_date_time_stamp_utc',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Date_time_stamp_UTC',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_xs_date_time_stamp_utc',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Date_time_stamp_UTC',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=SymbolDescription(
        summary='<paragraph>Represent an <literal>xs:dateTimeStamp</literal> with the time zone fixed to UTC.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Blob_type',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='BYTEARRAY',
      is_implementation_specific=False,
      invariants=[],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Group of bytes to represent file content (binaries and non-binaries)</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Identifier',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>string</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='BCP_47_language_tag',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_BCP_47',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive BCP_47_language_tag',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=SymbolDescription(
        summary='<paragraph>Represent a language tag conformant to BCP 47.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://en.wikipedia.org/wiki/IETF_language_tag">https://en.wikipedia.org/wiki/IETF_language_tag</reference></paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Content_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_MIME_type',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Content_type',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>string</paragraph>',
        remarks=[
          '<note><paragraph>Any content type as in RFC2046.</paragraph></note>',
          textwrap.dedent("""\
            <paragraph>A media type (also MIME type and content type) […] is a two-part
            identifier for file formats and format contents transmitted on
            the Internet. The Internet Assigned Numbers Authority (IANA) is
            the official authority for the standardization and publication of
            these classifications. Media types were originally defined in
            Request for Comments 2045 in November 1996 as a part of MIME
            (Multipurpose Internet Mail Extensions) specification, for denoting
            type of email message content and attachments.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Path_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_RFC_8089_path',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Path_type',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>string</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>Any string conformant to RFC8089 , the “file” URI scheme (for
            relative and absolute file paths)</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Qualifier_type',
      inheritances=[
        'Reference to ConstrainedPrimitive Non_empty_string'],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Non_empty_string',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>string</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Value_data_type',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=SymbolDescription(
        summary='<paragraph>any xsd atomic type as specified via <SymbolReference refuri=".Data_type_def_XSD">.Data_type_def_XSD</SymbolReference></paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...),
    ConstrainedPrimitive(
      name='Id_short',
      inheritances=[],
      inheritance_id_set=...,
      descendant_id_set=...,
      constrainee='STR',
      is_implementation_specific=False,
      invariants=[
        Invariant(
          description='Constraint AASd-027: ID-short shall have a maximum length of 128 characters.',
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Name(
                    identifier='self',
                    original_node=...)],
                original_node=...),
              op='LE',
              right=Constant(
                value=128,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Id_short',
          parsed=...),
        Invariant(
          description='ID-short of Referables shall only feature letters, digits, underscore (``_``); starting mandatory with a letter. *I.e.* ``[a-zA-Z][a-zA-Z0-9_]+``.',
          body=textwrap.dedent("""\
            FunctionCall(
              name='matches_id_short',
              args=[
                Name(
                  identifier='self',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConstrainedPrimitive Id_short',
          parsed=...)],
      invariant_id_set=...,
      reference_in_the_book=None,
      description=SymbolDescription(
        summary='<paragraph>Represent a short ID of an <SymbolReference refuri=".Referable">.Referable</SymbolReference>.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-002',
            textwrap.dedent("""\
              <field_body><paragraph>ID-short of <SymbolReference refuri=".Referable">.Referable</SymbolReference>'s shall only feature letters, digits,
              underscore (<literal>_</literal>); starting mandatory with a letter.
              <emphasis>I.e.</emphasis> <literal>[a-zA-Z][a-zA-Z0-9_]+</literal>.</paragraph></field_body>""")],
          [
            'AASd-027',
            textwrap.dedent("""\
              <field_body><paragraph>ID-short of <SymbolReference refuri=".Referable">.Referable</SymbolReference>'s shall have a maximum length
              of 128 characters.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...),
    AbstractClass(
      name='Has_semantics',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_semantics',
        name='Has_semantics',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass Extension',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Qualifier',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Specific_asset_id',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary=textwrap.dedent("""\
            <paragraph>Element that can have a semantic definition plus some supplemental semantic
            definitions.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[
            [
              'AASd-118',
              textwrap.dedent("""\
                <field_body><paragraph>If there are ID <AttributeReference refuri="~Has_semantics.supplemental_semantic_ids">~Has_semantics.supplemental_semantic_ids</AttributeReference> defined
                then there shall be also a main semantic ID <AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>.</paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass Extension',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Qualifier',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Specific_asset_id',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          6],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>Element that can have a semantic definition plus some supplemental semantic
          definitions.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-118',
            textwrap.dedent("""\
              <field_body><paragraph>If there are ID <AttributeReference refuri="~Has_semantics.supplemental_semantic_ids">~Has_semantics.supplemental_semantic_ids</AttributeReference> defined
              then there shall be also a main semantic ID <AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Extension',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='name',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Name of the extension.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-077',
                '<field_body><paragraph>The name of an extension within <SymbolReference refuri=".Has_extensions">.Has_extensions</SymbolReference> needs to be unique.</paragraph></field_body>']],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def_XSD',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Type of the value of the extension.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Data_type_def_XSD.String">~Data_type_def_XSD.String</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Value_data_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Value of the extension</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...),
        Property(
          name='refers_to',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to an element the extension refers to.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='value_type_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def_XSD',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Extension',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='name',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Data_type_def_XSD',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='refers_to',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='name',
              argument='name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='refers_to',
              argument='refers_to',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_or_default',
                      original_node=...),
                    args=[],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Extension',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          1],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Single extension of an element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_extensions',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_extensions',
        name='Has_extensions',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>Element that can be extended by proprietary extensions.</paragraph>',
          remarks=[
            '<note><paragraph>Extensions are proprietary, i.e. they do not support global interoperability.</paragraph></note>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          1],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Element that can be extended by proprietary extensions.</paragraph>',
        remarks=[
          '<note><paragraph>Extensions are proprietary, i.e. they do not support global interoperability.</paragraph></note>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Referable',
      inheritances=[
        'Reference to AbstractClass Has_extensions'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Referable',
        name='Referable',
        inheritances=[
          'Reference to Interface Has_extensions'],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                  the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>An element that is referable by its <AttributeReference refuri="~id_short">~id_short</AttributeReference>.</paragraph>',
          remarks=[
            textwrap.dedent("""\
              <paragraph>This ID is not globally unique.
              This ID is unique within the name space of the element.</paragraph>""")],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An element that is referable by its <AttributeReference refuri="~id_short">~id_short</AttributeReference>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>This ID is not globally unique.
            This ID is unique within the name space of the element.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Identifiable',
      inheritances=[
        'Reference to AbstractClass Referable'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Identifiable',
        name='Identifiable',
        inheritances=[
          'Reference to Interface Referable'],
        implementers=[
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Submodel'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                  the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>Some of the administrative information like the version number might need to
                  be part of the identification.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Identifiable',
            parsed=...),
          Property(
            name='id',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Identifier',
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The globally unique identification of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Identifiable',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>An element that has a globally unique identifier.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Submodel'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Identifier',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          3],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An element that has a globally unique identifier.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Modeling_kind',
      literals=[
        EnumerationLiteral(
          name='Template',
          value='Template',
          description=EnumerationLiteralDescription(
            summary=textwrap.dedent("""\
              <paragraph>Software element which specifies the common attributes shared by all instances of
              the template.</paragraph>"""),
            remarks=[
              '<paragraph>[SOURCE: IEC TR 62390:2005-01, 3.1.25] modified</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Concrete, clearly identifiable component of a certain template.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>It becomes an individual entity of a  template,  for example a
                device model, by defining specific property values.</paragraph></note>"""),
              textwrap.dedent("""\
                <note><paragraph>In an object oriented view,  an instance denotes an object of a
                template (class).</paragraph></note>"""),
              '<paragraph>[SOURCE: IEC 62890:2016, 3.1.16 65/617/CDV]  modified</paragraph>'],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          4],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration for denoting whether an element is a template or an instance.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    AbstractClass(
      name='Has_kind',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_kind',
        name='Has_kind',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...)],
        signatures=[
          Signature(
            name='kind_or_default',
            arguments=[],
            returns=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            description=None,
            contracts=Contracts(
              preconditions=[],
              snapshots=[],
              postconditions=[]),
            parsed=...,
            arguments_by_name=...)],
        description=SymbolDescription(
          summary=textwrap.dedent("""\
            <paragraph>An element with a kind is an element that can either represent a template or an
            instance.</paragraph>"""),
          remarks=[
            '<paragraph>Default for an element is that it is representing an instance.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          4],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>An element with a kind is an element that can either represent a template or an
          instance.</paragraph>"""),
        remarks=[
          '<paragraph>Default for an element is that it is representing an instance.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Has_data_specification',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Has_data_specification',
        name='Has_data_specification',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Administrative_information',
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Asset_administration_shell',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Concept_description',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[
                '<note><paragraph>This is a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>Element that can be extended by using data specification templates.</paragraph>',
          remarks=[
            textwrap.dedent("""\
              <paragraph>A data specification template defines a named set of additional attributes an
              element may or shall have. The data specifications used are explicitly specified
              with their global ID.</paragraph>""")],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Administrative_information',
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Asset_administration_shell',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Concept_description',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          9],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Element that can be extended by using data specification templates.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>A data specification template defines a named set of additional attributes an
            element may or shall have. The data specifications used are explicitly specified
            with their global ID.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Administrative_information',
      inheritances=[
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='version',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Version of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...),
        Property(
          name='revision',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Revision of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='version',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='revision',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='version',
              argument='version',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='revision',
              argument='revision',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-005: If version is not specified then also revision shall be unspecified. This means, a revision requires a version. If there is no version there is no revision either. Revision is optional.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='revision',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='version',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Administrative_information',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          5],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>Administrative meta-information for an element like version
          information.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-005',
            textwrap.dedent("""\
              <field_body><paragraph>If <AttributeReference refuri="~version">~version</AttributeReference> is not specified then also <AttributeReference refuri="~revision">~revision</AttributeReference> shall be
              unspecified. This means, a revision requires a version. If there is no version
              there is no revision neither. Revision is optional.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Qualifiable',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Qualifiable',
        name='Qualifiable',
        inheritances=[],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary=textwrap.dedent("""\
            <paragraph>The value of a qualifiable element may be further qualified by one or more
            qualifiers.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[
            [
              'AASd-119',
              textwrap.dedent("""\
                <field_body><paragraph>If any <AttributeReference refuri="~Qualifier.kind">~Qualifier.kind</AttributeReference> value of <AttributeReference refuri="~Qualifiable.qualifiers">~Qualifiable.qualifiers</AttributeReference> is
                equal to <AttributeReference refuri="~Qualifier_kind.Template_qualifier">~Qualifier_kind.Template_qualifier</AttributeReference> and the qualified element
                inherits from <SymbolReference refuri=".Has_kind">.Has_kind</SymbolReference> then the qualified element shell be of
                kind Template (<AttributeReference refuri="Has_kind.kind">Has_kind.kind</AttributeReference> = <AttributeReference refuri="Modeling_kind.Template">Modeling_kind.Template</AttributeReference>).</paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          7],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>The value of a qualifiable element may be further qualified by one or more
          qualifiers.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-119',
            textwrap.dedent("""\
              <field_body><paragraph>If any <AttributeReference refuri="~Qualifier.kind">~Qualifier.kind</AttributeReference> value of <AttributeReference refuri="~Qualifiable.qualifiers">~Qualifiable.qualifiers</AttributeReference> is
              equal to <AttributeReference refuri="~Qualifier_kind.Template_qualifier">~Qualifier_kind.Template_qualifier</AttributeReference> and the qualified element
              inherits from <SymbolReference refuri=".Has_kind">.Has_kind</SymbolReference> then the qualified element shell be of
              kind Template (<AttributeReference refuri="Has_kind.kind">Has_kind.kind</AttributeReference> = <AttributeReference refuri="Modeling_kind.Template">Modeling_kind.Template</AttributeReference>).</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Qualifier_kind',
      literals=[
        EnumerationLiteral(
          name='Value_qualifier',
          value='ValueQualifier',
          description=EnumerationLiteralDescription(
            summary='<paragraph>qualifies the value of the element and can change during run-time.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Value qualifiers are only applicable to elements with kind
                <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference>.</paragraph>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Concept_qualifier',
          value='ConceptQualifier',
          description=EnumerationLiteralDescription(
            summary=textwrap.dedent("""\
              <paragraph>qualifies the semantic definition the element is referring to
              (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>)</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Template_qualifier',
          value='TemplateQualifier',
          description=EnumerationLiteralDescription(
            summary='<paragraph>qualifies the elements within a specific submodel on concept level.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Template qualifiers are only applicable to elements with kind
                <AttributeReference refuri="~Modeling_kind.Template">~Modeling_kind.Template</AttributeReference>.</paragraph>""")],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          8],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration for kinds of qualifiers.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Qualifier',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Qualifier_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The qualifier kind describes the kind of the qualifier that is applied to the
              element.</paragraph>"""),
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Qualifier_kind.Concept_qualifier">~Qualifier_kind.Concept_qualifier</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Qualifier_type',
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The qualifier <emphasis>type</emphasis> describes the type of the qualifier that is applied to
              the element.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def_XSD',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Data type of the qualifier value.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Value_data_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The qualifier value is the value of the qualifier.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...),
        Property(
          name='value_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Qualifier_kind',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Qualifier',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Qualifier_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_id',
              argument='value_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-020: The value shall be consistent to the data type as defined in value type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Qualifier',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          2,
          8],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A qualifier is a type-value-pair that makes additional statements w.r.t. the value
          of the element.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-006',
            textwrap.dedent("""\
              <field_body><paragraph>If both the <AttributeReference refuri="~value">~value</AttributeReference> and the <AttributeReference refuri="~value_id">~value_id</AttributeReference> of
              a <SymbolReference refuri=".Qualifier">.Qualifier</SymbolReference> are present then the <AttributeReference refuri="~value">~value</AttributeReference> needs
              to be identical to the value of the referenced coded value
              in <AttributeReference refuri="~value_id">~value_id</AttributeReference>.</paragraph></field_body>""")],
          [
            'AASd-020',
            textwrap.dedent("""\
              <field_body><paragraph>The value of <AttributeReference refuri="~value">~value</AttributeReference> shall be consistent to the data type as
              defined in <AttributeReference refuri="~value_type">~value_type</AttributeReference>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Asset_administration_shell',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Identifier',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='derived_from',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The reference to the AAS the AAS was derived from.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Property(
          name='asset_information',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Asset_information',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Meta-information about the asset the AAS is representing.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Property(
          name='submodels',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>References to submodels of the AAS.</paragraph>',
            remarks=[
              '<paragraph>A submodel is a description of an aspect of the asset the AAS is representing.</paragraph>',
              '<paragraph>The asset of an AAS is typically described by one or more submodels.</paragraph>',
              '<paragraph>Temporarily no submodel might be assigned to the AAS.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='asset_information',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Asset_information',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='derived_from',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodels',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='derived_from',
              argument='derived_from',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='asset_information',
              argument='asset_information',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodels',
              argument='submodels',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='derived_from',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='derived_from',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='Key_types',
                      original_node=...),
                    name='Asset_administration_shell',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodels',
                  original_node=...),
                original_node=...),
              consequent=All(
                for_each=ForEach(
                  variable=Name(
                    identifier='reference',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodels',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='is_model_reference_to',
                  args=[
                    Name(
                      identifier='reference',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='Key_types',
                        original_node=...),
                      name='Submodel',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Asset_administration_shell',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          3],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An asset administration shell.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Asset_information',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='asset_kind',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Asset_kind',
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Denotes whether the Asset is of kind <AttributeReference refuri="~Asset_kind.Type">~Asset_kind.Type</AttributeReference> or
              <AttributeReference refuri="~Asset_kind.Instance">~Asset_kind.Instance</AttributeReference>.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='global_asset_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global identifier of the asset the AAS is representing.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>This attribute is required as soon as the AAS is exchanged via partners in the life
                cycle of the asset. In a first phase of the life cycle the asset might not yet have
                a global ID but already an internal identifier. The internal identifier would be
                modelled via <AttributeReference refuri="~specific_asset_id">~specific_asset_id</AttributeReference>.</paragraph>"""),
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='specific_asset_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Specific_asset_id',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Additional domain-specific, typically proprietary identifier for the asset like
              e.g., serial number etc.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...),
        Property(
          name='default_thumbnail',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Resource',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Thumbnail of the asset represented by the Asset Administration Shell.</paragraph>',
            remarks=[
              '<paragraph>Used as default.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Asset_information',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='asset_kind',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Asset_kind',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='global_asset_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='specific_asset_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Specific_asset_id',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='default_thumbnail',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Resource',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='asset_kind',
              argument='asset_kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='global_asset_id',
              argument='global_asset_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='specific_asset_id',
              argument='specific_asset_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='default_thumbnail',
              argument='default_thumbnail',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>In <SymbolReference refuri=".Asset_information">.Asset_information</SymbolReference> identifying meta data of the asset that is
          represented by an AAS is defined.</paragraph>"""),
        remarks=[
          '<paragraph>The asset may either represent an asset type or an asset instance.</paragraph>',
          textwrap.dedent("""\
            <paragraph>The asset has a globally unique identifier plus – if needed – additional domain
            specific (proprietary) identifiers. However, to support the corner case of very
            first phase of lifecycle where a stabilised/constant global asset identifier does
            not already exist, the corresponding attribute <AttributeReference refuri="~global_asset_id">~global_asset_id</AttributeReference> is optional.</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-116',
            textwrap.dedent("""\
              <field_body><paragraph><literal>globalAssetId</literal> (case-insensitive) is a reserved key. If used as value for
              <AttributeReference refuri="~Specific_asset_id.name">~Specific_asset_id.name</AttributeReference> then <AttributeReference refuri="~Specific_asset_id.value">~Specific_asset_id.value</AttributeReference> shall be
              identical to <AttributeReference refuri="~global_asset_id">~global_asset_id</AttributeReference>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Resource',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='path',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Path_type',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Path and name of the resource (with file extension).</paragraph>',
            remarks=[
              '<paragraph>The path can be absolute or relative.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Resource',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Content_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Content type of the content of the file.</paragraph>',
            remarks=[
              '<paragraph>The content type states which file extensions the file can have.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Resource',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='path',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Path_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='content_type',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Content_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='path',
              argument='path',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>Resource represents an address to a file (a locator). The value is an URI that
          can represent an absolute or relative path</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Asset_kind',
      literals=[
        EnumerationLiteral(
          name='Type',
          value='Type',
          description=EnumerationLiteralDescription(
            summary=textwrap.dedent("""\
              <paragraph>hardware or software element which specifies the common attributes shared by all
              instances of the type</paragraph>"""),
            remarks=[
              '<paragraph>[SOURCE: IEC TR 62390:2005-01, 3.1.25]</paragraph>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Instance',
          value='Instance',
          description=EnumerationLiteralDescription(
            summary='<paragraph>concrete, clearly identifiable component of a certain type</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>It becomes an individual entity of a type, for example a device, by defining
                specific property values.</paragraph></note>"""),
              textwrap.dedent("""\
                <note><paragraph>In an object oriented view, an instance denotes an object of a class
                (of a type).</paragraph></note>"""),
              '<paragraph>[SOURCE: IEC 62890:2016, 3.1.16] 65/617/CDV</paragraph>'],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=2,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration for denoting whether an asset is a type asset or an instance asset.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Specific_asset_id',
      inheritances=[
        'Reference to AbstractClass Has_semantics'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='name',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Name of the identifier</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_id',
          parsed=...),
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the specific asset identifier with the corresponding name.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_id',
          parsed=...),
        Property(
          name='external_subject_id',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The (external) subject the key belongs to or has meaning to.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Specific_asset_id',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='name',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='external_subject_id',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='name',
              argument='name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='external_subject_id',
              argument='external_subject_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          4],
        index=3,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A specific asset ID describes a generic supplementary identifying attribute of the
          asset.</paragraph>"""),
        remarks=[
          '<paragraph>The specific asset ID is not necessarily globally unique.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_kind',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Identifier',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='submodel_elements',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>A submodel consists of zero or more submodel elements.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodel_elements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodel_elements',
              argument='submodel_elements',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='ID-shorts need to be defined for all the submodel elements.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=All(
                for_each=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='Constraint AASd-120: ID-short of non-identifiable referables shall be unique in its namespace.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='submodel_elements',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='id_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='submodel_elements',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          5],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A submodel defines a specific aspect of the asset represented by the AAS.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>A submodel is used to structure the digital representation and technical
            functionality of an Administration Shell into distinguishable parts. Each submodel
            refers to a well-defined domain or subject matter. Submodels can become
            standardized and, thus, become submodels templates.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Submodel_element',
      inheritances=[
        'Reference to AbstractClass Referable',
        'Reference to AbstractClass Has_kind',
        'Reference to AbstractClass Has_semantics',
        'Reference to AbstractClass Qualifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Submodel_element',
        name='Submodel_element',
        inheritances=[
          'Reference to Interface Referable',
          'Reference to Interface Has_kind',
          'Reference to Interface Has_semantics',
          'Reference to Interface Qualifiable',
          'Reference to Interface Has_data_specification'],
        implementers=[
          'Reference to ConcreteClass Relationship_element',
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Basic_event_element',
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass Capability',
          'Reference to ConcreteClass Entity',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Operation',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element',
          'Reference to ConcreteClass Submodel_element_collection',
          'Reference to ConcreteClass Submodel_element_list'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                  the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[
                '<note><paragraph>This is a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary=textwrap.dedent("""\
            <paragraph>A submodel element is an element suitable for the description and differentiation of
            assets.</paragraph>"""),
          remarks=[
            '<paragraph>It is recommended to add a <AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference> to a submodel element.</paragraph>'],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Relationship_element',
        'Reference to ConcreteClass Annotated_relationship_element',
        'Reference to ConcreteClass Basic_event_element',
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass Capability',
        'Reference to ConcreteClass Entity',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Operation',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element',
        'Reference to ConcreteClass Submodel_element_collection',
        'Reference to ConcreteClass Submodel_element_list'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          6],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A submodel element is an element suitable for the description and differentiation of
          assets.</paragraph>"""),
        remarks=[
          '<paragraph>It is recommended to add a <AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference> to a submodel element.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Relationship_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to ConcreteClass Relationship_element',
        name='Relationship_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Annotated_relationship_element',
          'Reference to ConcreteClass Relationship_element'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                  the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[
                '<note><paragraph>This is a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...),
          Property(
            name='first',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to ConcreteClass Relationship_element',
            parsed=...),
          Property(
            name='second',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to ConcreteClass Relationship_element',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary=textwrap.dedent("""\
            <paragraph>A relationship element is used to define a relationship between two elements
            being either referable (model reference) or external (global reference).</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Annotated_relationship_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='first',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='second',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='first',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='second',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='first',
              argument='first',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='second',
              argument='second',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          14],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A relationship element is used to define a relationship between two elements
          being either referable (model reference) or external (global reference).</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel_element_list',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='order_relevant',
          type_annotation=OptionalTypeAnnotation(
            value=PrimitiveTypeAnnotation(
              a_type='BOOL',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Defines whether order in list is relevant. If <AttributeReference refuri="~order_relevant">~order_relevant</AttributeReference> = <literal>False</literal>
              then the list is representing a set or a bag.</paragraph>"""),
            remarks=[
              '<paragraph>Default: <literal>True</literal></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Submodel element contained in the list.</paragraph>',
            remarks=[
              '<paragraph>The list is ordered.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='semantic_id_list_element',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Semantic ID the submodel elements contained in the list match to.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='type_value_list_element',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol AAS_submodel_elements',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The submodel element type of the submodel elements contained in the list.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Property(
          name='value_type_list_element',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def_XSD',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value type of the submodel element contained in the list.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='order_relevant_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='BOOL',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Submodel_element_list',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type_value_list_element',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol AAS_submodel_elements',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='order_relevant',
            type_annotation=OptionalTypeAnnotation(
              value=PrimitiveTypeAnnotation(
                a_type='BOOL',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id_list_element',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_type_list_element',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Data_type_def_XSD',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='type_value_list_element',
              argument='type_value_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='order_relevant',
              argument='order_relevant',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id_list_element',
              argument='semantic_id_list_element',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type_list_element',
              argument='value_type_list_element',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-107: If a first level child element has a semantic ID it shall be identical to semantic ID list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='semantic_id_list_element',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              consequent=All(
                for_each=ForEach(
                  variable=Name(
                    identifier='child',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=Implication(
                  antecedent=IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='child',
                        original_node=...),
                      name='semantic_id',
                      original_node=...),
                    original_node=...),
                  consequent=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='child',
                        original_node=...),
                      name='semantic_id',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='semantic_id_list_element',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-114: If two first level child elements have a semantic ID then they shall be identical.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='submodel_elements_have_identical_semantic_ids',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-108: All first level child elements shall have the same submodel element type as specified in type value list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                for_each=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=FunctionCall(
                  name='submodel_element_is_of_type',
                  args=[
                    Name(
                      identifier='element',
                      original_node=...),
                    Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='type_value_list_element',
                      original_node=...)],
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-109: If type value list element is equal to Property or Range value type list element shall be set and all first level child elements shall have the value type as specified in value type list element.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value',
                      original_node=...),
                    original_node=...),
                  Or(
                    values=[
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Property',
                          original_node=...),
                        original_node=...),
                      Comparison(
                        left=Member(
                          instance=Name(
                            identifier='self',
                            original_node=...),
                          name='type_value_list_element',
                          original_node=...),
                        op='EQ',
                        right=Member(
                          instance=Name(
                            identifier='AAS_submodel_elements',
                            original_node=...),
                          name='Range',
                          original_node=...),
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              consequent=And(
                values=[
                  IsNotNone(
                    value=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='value_type_list_element',
                      original_node=...),
                    original_node=...),
                  FunctionCall(
                    name='properties_or_ranges_have_value_type',
                    args=[
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value',
                        original_node=...),
                      Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='value_type_list_element',
                        original_node=...)],
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...),
        Invariant(
          description='Constraint AASd-120: ID-shorts of submodel elements within a SubmodelElementList shall not be specified.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                for_each=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_list',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          16],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A submodel element list is an ordered list of submodel elements.</paragraph>',
        remarks=[
          '<paragraph>The numbering starts with zero (0).</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-107',
            textwrap.dedent("""\
              <field_body><paragraph>If a first level child element in a <SymbolReference refuri=".Submodel_element_list">.Submodel_element_list</SymbolReference> has
              a <AttributeReference refuri="~Submodel_element.semantic_id">~Submodel_element.semantic_id</AttributeReference> it
              shall be identical to <AttributeReference refuri="~Submodel_element_list.semantic_id_list_element">~Submodel_element_list.semantic_id_list_element</AttributeReference>.</paragraph></field_body>""")],
          [
            'AASd-114',
            textwrap.dedent("""\
              <field_body><paragraph>If two first level child elements in a <SymbolReference refuri=".Submodel_element_list">.Submodel_element_list</SymbolReference> have
              a <AttributeReference refuri="~Submodel_element.semantic_id">~Submodel_element.semantic_id</AttributeReference> then they shall be identical.</paragraph></field_body>""")],
          [
            'AASd-115',
            textwrap.dedent("""\
              <field_body><paragraph>If a first level child element in a <SymbolReference refuri=".Submodel_element_list">.Submodel_element_list</SymbolReference> does not
              specify a <AttributeReference refuri="~Submodel_element.semantic_id">~Submodel_element.semantic_id</AttributeReference> then the value is assumed to be
              identical to <AttributeReference refuri="~Submodel_element_list.semantic_id_list_element">~Submodel_element_list.semantic_id_list_element</AttributeReference>.</paragraph></field_body>""")],
          [
            'AASd-108',
            textwrap.dedent("""\
              <field_body><paragraph>All first level child elements in a <SymbolReference refuri=".Submodel_element_list">.Submodel_element_list</SymbolReference> shall have
              the same submodel element type as specified in <AttributeReference refuri="~type_value_list_element">~type_value_list_element</AttributeReference>.</paragraph></field_body>""")],
          [
            'AASd-109',
            textwrap.dedent("""\
              <field_body><paragraph>If <AttributeReference refuri="~type_value_list_element">~type_value_list_element</AttributeReference> is equal to
              <AttributeReference refuri="AAS_submodel_elements.Property">AAS_submodel_elements.Property</AttributeReference> or
              <AttributeReference refuri="AAS_submodel_elements.Range">AAS_submodel_elements.Range</AttributeReference>
              <AttributeReference refuri="~value_type_list_element">~value_type_list_element</AttributeReference> shall be set and all first
              level child elements in the <SymbolReference refuri=".Submodel_element_list">.Submodel_element_list</SymbolReference> shall have
              the value type as specified in <AttributeReference refuri="~value_type_list_element">~value_type_list_element</AttributeReference>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Submodel_element_collection',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Submodel element contained in the collection.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='ID-shorts need to be defined for all the elements.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=All(
                for_each=ForEach(
                  variable=Name(
                    identifier='element',
                    original_node=...),
                  iteration=Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  original_node=...),
                condition=IsNotNone(
                  value=Member(
                    instance=Name(
                      identifier='element',
                      original_node=...),
                    name='id_short',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='id_shorts_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Submodel_element_collection',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          15],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A submodel element collection is a kind of struct, i.e. a a logical encapsulation
          of multiple named values. It has a fixed number of submodel elements.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_element',
        name='Data_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Blob',
          'Reference to ConcreteClass File',
          'Reference to ConcreteClass Multi_language_property',
          'Reference to ConcreteClass Property',
          'Reference to ConcreteClass Range',
          'Reference to ConcreteClass Reference_element'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                  the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[
                '<note><paragraph>This is a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[
          Signature(
            name='category_or_default',
            arguments=[],
            returns=PrimitiveTypeAnnotation(
              a_type='STR',
              parsed=...),
            description=None,
            contracts=Contracts(
              preconditions=[],
              snapshots=[],
              postconditions=[]),
            parsed=...,
            arguments_by_name=...)],
        description=SymbolDescription(
          summary=textwrap.dedent("""\
            <paragraph>A data element is a submodel element that is not further composed out of
            other submodel elements.</paragraph>"""),
          remarks=[
            textwrap.dedent("""\
              <paragraph>A data element is a submodel element that has a value. The type of value differs
              for different subtypes of data elements.</paragraph>""")],
          constraints_by_identifier=[
            [
              'AASd-090',
              textwrap.dedent("""\
                <field_body><paragraph>For data elements <AttributeReference refuri="~category">~category</AttributeReference> (inherited by <SymbolReference refuri=".Referable">.Referable</SymbolReference>) shall be
                one of the following values: <literal>CONSTANT</literal>, <literal>PARAMETER</literal> or <literal>VARIABLE</literal>.</paragraph><paragraph>Default: <literal>VARIABLE</literal></paragraph></field_body>""")]],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Blob',
        'Reference to ConcreteClass File',
        'Reference to ConcreteClass Multi_language_property',
        'Reference to ConcreteClass Property',
        'Reference to ConcreteClass Range',
        'Reference to ConcreteClass Reference_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='CONSTANT',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='PARAMETER',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='VARIABLE',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          5],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A data element is a submodel element that is not further composed out of
          other submodel elements.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <paragraph>A data element is a submodel element that has a value. The type of value differs
            for different subtypes of data elements.</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-090',
            textwrap.dedent("""\
              <field_body><paragraph>For data elements <AttributeReference refuri="~category">~category</AttributeReference> (inherited by <SymbolReference refuri=".Referable">.Referable</SymbolReference>) shall be
              one of the following values: <literal>CONSTANT</literal>, <literal>PARAMETER</literal> or <literal>VARIABLE</literal>.</paragraph><paragraph>Default: <literal>VARIABLE</literal></paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Property',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def_XSD',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Data type of the value</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Value_data_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the property instance.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...),
        Property(
          name='value_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Property',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_id',
              argument='value_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='CONSTANT',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='PARAMETER',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='VARIABLE',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='value',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Property',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          11],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A property is a data element that has a single value.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-007',
            textwrap.dedent("""\
              <field_body><paragraph>If both, the <AttributeReference refuri="~value">~value</AttributeReference> and the <AttributeReference refuri="~value_id">~value_id</AttributeReference> are
              present then the value of <AttributeReference refuri="~value">~value</AttributeReference> needs to be identical to
              the value of the referenced coded value in <AttributeReference refuri="~value_id">~value_id</AttributeReference>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Multi_language_property',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the property instance.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...),
        Property(
          name='value_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the global unique ID of a coded value.</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Multi_language_property',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_id',
              argument='value_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='CONSTANT',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='PARAMETER',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='VARIABLE',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          9],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A property is a data element that has a multi-language value.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-012',
            textwrap.dedent("""\
              <field_body><paragraph>If both the <AttributeReference refuri="~value">~value</AttributeReference> and the <AttributeReference refuri="~value_id">~value_id</AttributeReference> are present then for each
              string in a specific language the meaning must be the same as specified in
              <AttributeReference refuri="~value_id">~value_id</AttributeReference>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Range',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def_XSD',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Data type of the min und max</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Property(
          name='min',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Value_data_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The minimum value of the range.</paragraph>',
            remarks=[
              '<paragraph>If the min value is missing, then the value is assumed to be negative infinite.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Property(
          name='max',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Value_data_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The maximum value of the range.</paragraph>',
            remarks=[
              '<paragraph>If the max value is missing,  then the value is assumed to be positive infinite.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Range',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Data_type_def_XSD',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='min',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='max',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Value_data_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value_type',
              argument='value_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='min',
              argument='min',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max',
              argument='max',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='CONSTANT',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='PARAMETER',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='VARIABLE',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='max',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Range',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='min',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='value_consistent_with_xsd_type',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='min',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='value_type',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Range',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          12],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A range data element is a data element that defines a range with min and max.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Reference_element',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Global reference to an external object or entity or a logical reference to
              another element within the same or another AAS (i.e. a model reference to
              a Referable).</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='CONSTANT',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='PARAMETER',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='VARIABLE',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          15],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A reference element is a data element that defines a logical reference to another
          element within the same or another AAS or a reference to an external object or
          entity.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Blob',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Blob_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The value of the <SymbolReference refuri=".Blob">.Blob</SymbolReference> instance of a blob data element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In contrast to the file property the file content is stored directly as value
                in the <SymbolReference refuri=".Blob">.Blob</SymbolReference> data element.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Blob',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Content_type',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Content type of the content of the <SymbolReference refuri=".Blob">.Blob</SymbolReference>.</paragraph>',
            remarks=[
              '<paragraph>The content type (MIME type) states which file extensions the file can have.</paragraph>',
              textwrap.dedent("""\
                <paragraph>Valid values are content types like e.g. <literal>application/json</literal>, <literal>application/xls</literal>,
                <literal>image/jpg</literal>.</paragraph>"""),
              '<paragraph>The allowed values are defined as in RFC2046.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Blob',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='content_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Content_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Blob_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='CONSTANT',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='PARAMETER',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='VARIABLE',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          3],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A <SymbolReference refuri=".Blob">.Blob</SymbolReference> is a data element that represents a file that is contained with its
          source code in the value attribute.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='File',
      inheritances=[
        'Reference to AbstractClass Data_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='value',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Path_type',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Path and name of the referenced file (with file extension).</paragraph>',
            remarks=[
              '<paragraph>The path can be absolute or relative.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass File',
          parsed=...),
        Property(
          name='content_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Content_type',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Content type of the content of the file.</paragraph>',
            remarks=[
              '<paragraph>The content type states which file extensions the file can have.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass File',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...),
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Data_element',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='content_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Content_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='value',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Path_type',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='content_type',
              argument='content_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Constraint AASd-090: For data elements category shall be one of the following values: CONSTANT, PARAMETER or VARIABLE',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=Or(
                values=[
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='CONSTANT',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='PARAMETER',
                      original_node=...),
                    original_node=...),
                  Comparison(
                    left=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='category',
                      original_node=...),
                    op='EQ',
                    right=Constant(
                      value='VARIABLE',
                      original_node=...),
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Data_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          8],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A File is a data element that represents an address to a file (a locator).</paragraph>',
        remarks=[
          '<paragraph>The value is an URI that can represent an absolute or relative path.</paragraph>'],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Annotated_relationship_element',
      inheritances=[
        'Reference to ConcreteClass Relationship_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='first',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the first element in the relationship taking the role of the subject.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='second',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the second element in the relationship taking the role of the object.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Relationship_element',
          parsed=...),
        Property(
          name='annotations',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Data_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>A data element that represents an annotation that holds for the relationship
              between the two elements</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Annotated_relationship_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='first',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='second',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='annotations',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Data_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='first',
              argument='first',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='second',
              argument='second',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='annotations',
              argument='annotations',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          1],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>An annotated relationship element is a relationship element that can be annotated
          with additional data elements.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Entity_type',
      literals=[
        EnumerationLiteral(
          name='Co_managed_entity',
          value='CoManagedEntity',
          description=EnumerationLiteralDescription(
            summary=textwrap.dedent("""\
              <paragraph>For co-managed entities there is no separate AAS. Co-managed entities need to be
              part of a self-managed entity.</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Self_managed_entity',
          value='SelfManagedEntity',
          description=EnumerationLiteralDescription(
            summary=textwrap.dedent("""\
              <paragraph>Self-Managed Entities have their own AAS but can be part of the bill of material of
              a composite self-managed entity.</paragraph>"""),
            remarks=[
              '<paragraph>The asset of an I4.0 Component is a self-managed entity per definition."</paragraph>'],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          6],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>Enumeration for denoting whether an entity is a self-managed entity or a co-managed
          entity.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Entity',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='statements',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Submodel_element',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Describes statements applicable to the entity by a set of submodel elements,
              typically with a qualified value.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='entity_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Entity_type',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Describes whether the entity is a co-managed entity or a self-managed entity.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='global_asset_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global identifier of the asset the entity is representing.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...),
        Property(
          name='specific_asset_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Specific_asset_id',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Reference to a specific asset ID representing a supplementary identifier
              of the asset represented by the Asset Administration Shell.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='entity_type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Entity_type',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='statements',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel_element',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='global_asset_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='specific_asset_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Specific_asset_id',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='statements',
              argument='statements',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='entity_type',
              argument='entity_type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='global_asset_id',
              argument='global_asset_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='specific_asset_id',
              argument='specific_asset_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description="Constraint AASd-014: Either the attribute global asset ID or specific asset ID must be set if entity type is set to 'SelfManagedEntity'. They are not existing otherwise.",
          body=textwrap.dedent("""\
            Or(
              values=[
                And(
                  values=[
                    Comparison(
                      left=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='entity_type',
                        original_node=...),
                      op='EQ',
                      right=Member(
                        instance=Name(
                          identifier='Entity_type',
                          original_node=...),
                        name='Self_managed_entity',
                        original_node=...),
                      original_node=...),
                    Or(
                      values=[
                        And(
                          values=[
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_id',
                                original_node=...),
                              original_node=...),
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_id',
                                original_node=...),
                              original_node=...)],
                          original_node=...),
                        And(
                          values=[
                            IsNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='global_asset_id',
                                original_node=...),
                              original_node=...),
                            IsNotNone(
                              value=Member(
                                instance=Name(
                                  identifier='self',
                                  original_node=...),
                                name='specific_asset_id',
                                original_node=...),
                              original_node=...)],
                          original_node=...)],
                      original_node=...)],
                  original_node=...),
                And(
                  values=[
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='global_asset_id',
                        original_node=...),
                      original_node=...),
                    IsNone(
                      value=Member(
                        instance=Name(
                          identifier='self',
                          original_node=...),
                        name='specific_asset_id',
                        original_node=...),
                      original_node=...)],
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Entity',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          6],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An entity is a submodel element that is used to model entities.</paragraph>',
        remarks=[],
        constraints_by_identifier=[
          [
            'AASd-014',
            textwrap.dedent("""\
              <field_body><paragraph>Either the attribute <AttributeReference refuri="~global_asset_id">~global_asset_id</AttributeReference> or <AttributeReference refuri="~specific_asset_id">~specific_asset_id</AttributeReference>
              of an <SymbolReference refuri=".Entity">.Entity</SymbolReference> must be set if <AttributeReference refuri="~entity_type">~entity_type</AttributeReference> is set to
              <AttributeReference refuri="~Entity_type.Self_managed_entity">~Entity_type.Self_managed_entity</AttributeReference>. They are not existing otherwise.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Direction',
      literals=[
        EnumerationLiteral(
          name='Input',
          value='INPUT',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Input direction.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Output',
          value='OUTPUT',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Output direction</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Direction</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='State_of_event',
      literals=[
        EnumerationLiteral(
          name='On',
          value='ON',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event is on</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Off',
          value='OFF',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event is off.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=2,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>State of an event</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Event_payload',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='source',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Reference to the source event element, including identification of
              <SymbolReference refuri=".Asset_administration_shell">.Asset_administration_shell</SymbolReference>, <SymbolReference refuri=".Submodel">.Submodel</SymbolReference>,
              <SymbolReference refuri=".Submodel_element">.Submodel_element</SymbolReference>'s.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='source_semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph><AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference> of the source event element, if available</paragraph>',
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='observable_reference',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Reference to the referable, which defines the scope of the event.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>Can be <SymbolReference refuri=".Asset_administration_shell">.Asset_administration_shell</SymbolReference>, <SymbolReference refuri=".Submodel">.Submodel</SymbolReference> or
                <SymbolReference refuri=".Submodel_element">.Submodel_element</SymbolReference>.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='observable_semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph><AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference> of the referable which defines the scope of
              the event, if available.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='topic',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Information for the outer message infrastructure for scheduling the event to
              the respective communication channel.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='subject_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Subject, who/which initiated the creation.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='time_stamp',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Date_time_stamp_UTC',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Timestamp in UTC, when this event was triggered.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Property(
          name='payload',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Event specific payload.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='source',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='observable_reference',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='time_stamp',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Date_time_stamp_UTC',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='source_semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='observable_semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='topic',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='subject_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='payload',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='source',
              argument='source',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observable_reference',
              argument='observable_reference',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='time_stamp',
              argument='time_stamp',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='source_semantic_id',
              argument='source_semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observable_semantic_id',
              argument='observable_semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='topic',
              argument='topic',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='subject_id',
              argument='subject_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='payload',
              argument='payload',
              default=None)""")]),
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='source',
                  original_node=...),
                Member(
                  instance=Name(
                    identifier='Key_types',
                    original_node=...),
                  name='Referable',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observable_reference',
                  original_node=...),
                Member(
                  instance=Name(
                    identifier='Key_types',
                    original_node=...),
                  name='Referable',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Event_payload',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=3,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Defines the necessary information of an event instance sent out or received.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Event_element',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Event_element',
        name='Event_element',
        inheritances=[
          'Reference to Interface Submodel_element'],
        implementers=[
          'Reference to ConcreteClass Basic_event_element'],
        properties=[
          Property(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>An extension of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_extensions',
            parsed=...),
          Property(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>The category is a value that gives further meta information
                w.r.t. to the class of the element.
                It affects the expected existence of attributes and the applicability of
                constraints.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>The category is not identical to the semantic definition
                  (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                  the element is a measurement value whereas the semantic definition of
                  the element would denote that it is the measured temperature.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>In case of identifiables this attribute is a short name of the element.
                In case of referable this ID is an identifying string of the element within
                its name space.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>In case the element is a property and the property has a semantic definition
                  (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                  the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <paragraph>If no display name is defined in the language requested by the application,
                  then the display name is selected in the following order if available:</paragraph>"""),
                textwrap.dedent("""\
                  <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                  then the corresponding preferred name in the language is chosen
                  according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                  the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Description or comments on the element.</paragraph>',
              remarks=[
                '<paragraph>The description can be provided in several languages.</paragraph>',
                textwrap.dedent("""\
                  <paragraph>If no description is defined, then the definition of the concept
                  description that defines the semantics of the element is used.</paragraph>"""),
                textwrap.dedent("""\
                  <paragraph>Additional information can be provided, e.g., if the element is
                  qualified and which qualifier types can be expected in which
                  context or which additional data specification templates are
                  provided.</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Checksum to be used to determine if an Referable (including its
                aggregated child elements) has changed.</paragraph>"""),
              remarks=[
                textwrap.dedent("""\
                  <paragraph>The checksum is calculated by the user's tool environment.
                  The checksum has no semantic meaning for an asset administration
                  shell model and there is no requirement for asset administration
                  shell tools to manage the checksum</paragraph>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Referable',
            parsed=...),
          Property(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
              remarks=[
                '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_kind',
            parsed=...),
          Property(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
                of the element or also main semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Identifier of a supplemental semantic definition of the element.
                It is called supplemental semantic ID of the element.</paragraph>"""),
              remarks=[
                '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_semantics',
            parsed=...),
          Property(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[
                [
                  'AASd-021',
                  textwrap.dedent("""\
                    <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                    <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
              parsed=...),
            specified_for='Reference to AbstractClass Qualifiable',
            parsed=...),
          Property(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
              remarks=[
                '<note><paragraph>This is a global reference.</paragraph></note>'],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Has_data_specification',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>An event element.</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[
        'Reference to ConcreteClass Basic_event_element'],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          7],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An event element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Basic_event_element',
      inheritances=[
        'Reference to AbstractClass Event_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='observed',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Reference to the <SymbolReference refuri=".Referable">.Referable</SymbolReference>, which defines the scope of the event.
              Can be <SymbolReference refuri=".Asset_administration_shell">.Asset_administration_shell</SymbolReference>, <SymbolReference refuri=".Submodel">.Submodel</SymbolReference>, or
              <SymbolReference refuri=".Submodel_element">.Submodel_element</SymbolReference>.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>Reference to a referable, e.g., a data element or
                a submodel, that is being observed.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='direction',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Direction',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Direction of event.</paragraph>',
            remarks=[
              '<paragraph>Can be <literal>{ Input, Output }</literal>.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='state',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol State_of_event',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>State of event.</paragraph>',
            remarks=[
              '<paragraph>Can be <literal>{ On, Off }</literal>.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='message_topic',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Information for the outer message infrastructure for scheduling the event to the
              respective communication channel.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='message_broker',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Information, which outer message infrastructure shall handle messages for
              the <SymbolReference refuri=".Event_element">.Event_element</SymbolReference>. Refers to a <SymbolReference refuri=".Submodel">.Submodel</SymbolReference>,
              <SymbolReference refuri=".Submodel_element_list">.Submodel_element_list</SymbolReference>, <SymbolReference refuri=".Submodel_element_collection">.Submodel_element_collection</SymbolReference> or
              <SymbolReference refuri=".Entity">.Entity</SymbolReference>, which contains <SymbolReference refuri=".Data_element">.Data_element</SymbolReference>'s describing
              the proprietary specification for the message broker.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>For different message infrastructure, e.g., OPC UA or MQTT or AMQP, this
                proprietary specification could be standardized by having respective Submodels.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='last_update',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Date_time_stamp_UTC',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Timestamp in UTC, when the last event was received (input direction) or sent
              (output direction).</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='min_interval',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Date_time_stamp_UTC',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>For input direction, reports on the maximum frequency, the software entity behind
              the respective Referable can handle input events.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>For output events, specifies the maximum frequency of outputting this event to
                an outer infrastructure.</paragraph>"""),
              '<paragraph>Might be not specified, that is, there is no minimum interval.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Property(
          name='max_interval',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Date_time_stamp_UTC',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>For input direction: not applicable.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>For output direction: maximum interval in time, the respective Referable shall send
                an update of the status of the event, even if no other trigger condition for
                the event was not met.</paragraph>"""),
              '<paragraph>Might be not specified, that is, there is no maximum interval</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='observed',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='direction',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Direction',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='state',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol State_of_event',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='message_topic',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='message_broker',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='last_update',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Date_time_stamp_UTC',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='min_interval',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Date_time_stamp_UTC',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='max_interval',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Date_time_stamp_UTC',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='observed',
              argument='observed',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='direction',
              argument='direction',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='state',
              argument='state',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='message_topic',
              argument='message_topic',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='message_broker',
              argument='message_broker',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='last_update',
              argument='last_update',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='min_interval',
              argument='min_interval',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='max_interval',
              argument='max_interval',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...),
        Invariant(
          description='Max. interval is not applicable for input direction',
          body=textwrap.dedent("""\
            Implication(
              antecedent=Comparison(
                left=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='direction',
                  original_node=...),
                op='EQ',
                right=Member(
                  instance=Name(
                    identifier='Direction',
                    original_node=...),
                  name='Input',
                  original_node=...),
                original_node=...),
              consequent=IsNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='max_interval',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='is_model_reference_to',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='observed',
                  original_node=...),
                Member(
                  instance=Name(
                    identifier='Key_types',
                    original_node=...),
                  name='Referable',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='message_broker',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='is_model_reference_to',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='message_broker',
                    original_node=...),
                  Member(
                    instance=Name(
                      identifier='Key_types',
                      original_node=...),
                    name='Referable',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Basic_event_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A basic event element.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Operation',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='input_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Input parameter of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Property(
          name='output_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Output parameter of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...),
        Property(
          name='inoutput_variables',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Operation_variable',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Parameter that is input and output of the operation.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='input_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='output_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='inoutput_variables',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Operation_variable',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='input_variables',
              argument='input_variables',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='output_variables',
              argument='output_variables',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='inoutput_variables',
              argument='inoutput_variables',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          10],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>An operation is a submodel element with input and output variables.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Operation_variable',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Submodel_element',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Describes an argument or result of an operation via a submodel element</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Operation_variable',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_element',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          10],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>The value of an operation variable is a submodel element that is used as input
          and/or output variable of an operation.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Capability',
      inheritances=[
        'Reference to AbstractClass Submodel_element'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='kind',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Modeling_kind',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Kind of the element: either type or instance.</paragraph>',
            remarks=[
              '<paragraph>Default: <AttributeReference refuri="~Modeling_kind.Instance">~Modeling_kind.Instance</AttributeReference></paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_kind',
          parsed=...),
        Property(
          name='semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of the semantic definition of the element. It is called semantic ID
              of the element or also main semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='supplemental_semantic_ids',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Identifier of a supplemental semantic definition of the element.
              It is called supplemental semantic ID of the element.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Property(
          name='qualifiers',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Qualifier',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Additional qualification of a qualifiable element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[
              [
                'AASd-021',
                textwrap.dedent("""\
                  <field_body><paragraph>Every qualifiable can only have one qualifier with the same
                  <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>.</paragraph></field_body>""")]],
            parsed=...),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='kind_or_default',
          arguments=[],
          returns=OurTypeAnnotation(
            symbol='Reference to symbol Modeling_kind',
            parsed=...),
          description=None,
          specified_for='Reference to AbstractClass Has_kind',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='kind',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Modeling_kind',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='supplemental_semantic_ids',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='qualifiers',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Qualifier',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='kind',
              argument='kind',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='semantic_id',
              argument='semantic_id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='supplemental_semantic_ids',
              argument='supplemental_semantic_ids',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='qualifiers',
              argument='qualifiers',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description='Constraint AASd-118: If there are supplemental semantic IDs defined then there shall be also a main semantic ID.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='supplemental_semantic_ids',
                  original_node=...),
                original_node=...),
              consequent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='semantic_id',
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_semantics',
          parsed=...),
        Invariant(
          description='Constraint AASd-021: Every qualifiable can only have one qualifier with the same type.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='qualifier_types_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='qualifiers',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Qualifiable',
          parsed=...),
        Invariant(
          description='Constraint AASd-119: If any qualifier kind value of a qualifiable qualifier is equal to template qualifier and the qualified element has kind then the qualified element shall be of kind template.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='qualifiers',
                  original_node=...),
                original_node=...),
              consequent=Implication(
                antecedent=Any(
                  for_each=ForEach(
                    variable=Name(
                      identifier='qualifier',
                      original_node=...),
                    iteration=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='qualifiers',
                      original_node=...),
                    original_node=...),
                  condition=Comparison(
                    left=Member(
                      instance=Name(
                        identifier='qualifier',
                        original_node=...),
                      name='kind',
                      original_node=...),
                    op='EQ',
                    right=Member(
                      instance=Name(
                        identifier='Qualifier_kind',
                        original_node=...),
                      name='Template_qualifier',
                      original_node=...),
                    original_node=...),
                  original_node=...),
                consequent=Comparison(
                  left=MethodCall(
                    member=Member(
                      instance=Name(
                        identifier='self',
                        original_node=...),
                      name='kind_or_default',
                      original_node=...),
                    args=[],
                    original_node=...),
                  op='EQ',
                  right=Member(
                    instance=Name(
                      identifier='Modeling_kind',
                      original_node=...),
                    name='Template',
                    original_node=...),
                  original_node=...),
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Submodel_element',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          7,
          4],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>A capability is the implementation-independent description of the potential of an
          asset to achieve a certain effect in the physical or virtual world.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>The <AttributeReference refuri="~semantic_id">~semantic_id</AttributeReference> of a capability is typically an ontology.
            Thus, reasoning on capabilities is enabled.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Concept_description',
      inheritances=[
        'Reference to AbstractClass Identifiable',
        'Reference to AbstractClass Has_data_specification'],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='extensions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Extension',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>An extension of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Property(
          name='category',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>The category is a value that gives further meta information
              w.r.t. to the class of the element.
              It affects the expected existence of attributes and the applicability of
              constraints.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>The category is not identical to the semantic definition
                (<SymbolReference refuri=".Has_semantics">.Has_semantics</SymbolReference>) of an element. The category e.g. could denote that
                the element is a measurement value whereas the semantic definition of
                the element would denote that it is the measured temperature.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='id_short',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Id_short',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>In case of identifiables this attribute is a short name of the element.
              In case of referable this ID is an identifying string of the element within
              its name space.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>In case the element is a property and the property has a semantic definition
                (<AttributeReference refuri="~Has_semantics.semantic_id">~Has_semantics.semantic_id</AttributeReference>) conformant to IEC61360
                the <AttributeReference refuri="~id_short">~id_short</AttributeReference> is typically identical to the short name in English.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='display_name',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Display name. Can be provided in several languages.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>If no display name is defined in the language requested by the application,
                then the display name is selected in the following order if available:</paragraph>"""),
              textwrap.dedent("""\
                <bullet_list bullet="*"><list_item><paragraph>the preferred name in the requested language of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>If there is a default language list defined in the application,
                then the corresponding preferred name in the language is chosen
                according to this order.</paragraph></list_item><list_item><paragraph>the English preferred name of the concept description defining
                the semantics of the element</paragraph></list_item><list_item><paragraph>the short name of the concept description</paragraph></list_item><list_item><paragraph>the <AttributeReference refuri="~id_short">~id_short</AttributeReference> of the element</paragraph></list_item></bullet_list>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Description or comments on the element.</paragraph>',
            remarks=[
              '<paragraph>The description can be provided in several languages.</paragraph>',
              textwrap.dedent("""\
                <paragraph>If no description is defined, then the definition of the concept
                description that defines the semantics of the element is used.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>Additional information can be provided, e.g., if the element is
                qualified and which qualifier types can be expected in which
                context or which additional data specification templates are
                provided.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='checksum',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Checksum to be used to determine if an Referable (including its
              aggregated child elements) has changed.</paragraph>"""),
            remarks=[
              textwrap.dedent("""\
                <paragraph>The checksum is calculated by the user's tool environment.
                The checksum has no semantic meaning for an asset administration
                shell model and there is no requirement for asset administration
                shell tools to manage the checksum</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Referable',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Identifier',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Identifiable',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Global reference to the data specification template used by the element.</paragraph>',
            remarks=[
              '<note><paragraph>This is a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Has_data_specification',
          parsed=...),
        Property(
          name='is_case_of',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Reference to an external definition the concept is compatible to or was derived
              from.</paragraph>"""),
            remarks=[
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>',
              '<note><paragraph>Compare to is-case-of relationship in ISO 13584-32 & IEC EN 61360"</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...)],
      methods=[
        ImplementationSpecificMethod(
          name='category_or_default',
          arguments=[],
          returns=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=None,
          specified_for='Reference to ConcreteClass Concept_description',
          contracts=Contracts(
            preconditions=[],
            snapshots=[],
            postconditions=[
              Contract(
                args=[
                  'result'],
                description=None,
                body=textwrap.dedent("""\
                  FunctionCall(
                    name='concept_description_category_is_valid',
                    args=[
                      Name(
                        identifier='result',
                        original_node=...)],
                    original_node=...)"""),
                parsed=...)]),
          parsed=...,
          arguments_by_name=...)],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='extensions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Extension',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='category',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='id_short',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Id_short',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='display_name',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='checksum',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Non_empty_string',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='is_case_of',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Reference',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='extensions',
              argument='extensions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id_short',
              argument='id_short',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='display_name',
              argument='display_name',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='category',
              argument='category',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='checksum',
              argument='checksum',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='is_case_of',
              argument='is_case_of',
              default=None)""")]),
      invariants=[
        Invariant(
          description='Constraint AASd-077: The name of an extension within Has-Extensions needs to be unique.',
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='extensions',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='extension_names_are_unique',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='extensions',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to AbstractClass Has_extensions',
          parsed=...),
        Invariant(
          description="Constraint AASd-051: A concept description shall have one of the following categories: 'VALUE', 'PROPERTY', 'REFERENCE', 'DOCUMENT', 'CAPABILITY',; 'RELATIONSHIP', 'COLLECTION', 'FUNCTION', 'EVENT', 'ENTITY', 'APPLICATION_CLASS', 'QUALIFIER', 'VIEW'.",
          body=textwrap.dedent("""\
            Implication(
              antecedent=IsNotNone(
                value=Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='category',
                  original_node=...),
                original_node=...),
              consequent=FunctionCall(
                name='concept_description_category_is_valid',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='category',
                    original_node=...)],
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Concept_description',
          parsed=...)],
      serialization=Serialization(
        with_model_type=True),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          8],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>The semantics of a property or other elements that may have a semantic description
          is defined by a concept description.</paragraph>"""),
        remarks=[
          textwrap.dedent("""\
            <paragraph>The description of the concept should follow a standardized schema (realized as
            data specification template).</paragraph>""")],
        constraints_by_identifier=[
          [
            'AASd-051',
            textwrap.dedent("""\
              <field_body><paragraph>A <SymbolReference refuri=".Concept_description">.Concept_description</SymbolReference> shall have one of the following categories
              <literal>VALUE</literal>, <literal>PROPERTY</literal>, <literal>REFERENCE</literal>, <literal>DOCUMENT</literal>, <literal>CAPABILITY</literal>,
              <literal>RELATIONSHIP</literal>, <literal>COLLECTION</literal>, <literal>FUNCTION</literal>, <literal>EVENT</literal>, <literal>ENTITY</literal>,
              <literal>APPLICATION_CLASS</literal>, <literal>QUALIFIER</literal>, <literal>VIEW</literal>.</paragraph><paragraph>Default: <literal>PROPERTY</literal>.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Reference_types',
      literals=[
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=EnumerationLiteralDescription(
            summary='<paragraph>GlobalReference.</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Model_reference',
          value='ModelReference',
          description=EnumerationLiteralDescription(
            summary='<paragraph>ModelReference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          2],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>ReferenceTypes</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Reference',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference_types',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Type of the reference.</paragraph>',
            remarks=[
              '<paragraph>Denotes, whether reference is a global reference or a model reference.</paragraph>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Property(
          name='referred_semantic_id',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Reference',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph><AttributeReference refuri="Has_semantics.semantic_id">Has_semantics.semantic_id</AttributeReference> of the referenced model element
              (<AttributeReference refuri="~Reference.type">~Reference.type</AttributeReference> = <AttributeReference refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</AttributeReference>).</paragraph>"""),
            remarks=[
              '<paragraph>For global references there typically is no semantic ID.</paragraph>',
              '<note><paragraph>It is recommended to use a global reference.</paragraph></note>'],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...),
        Property(
          name='keys',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Key',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Unique references in their name space.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Reference_types',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='keys',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Key',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='referred_semantic_id',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Reference',
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='keys',
              argument='keys',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='referred_semantic_id',
              argument='referred_semantic_id',
              default=None)""")]),
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='keys',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Reference',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>Reference to either a model element of the same or another AAS or to an external
          entity.</paragraph>"""),
        remarks=[
          '<paragraph>A reference is an ordered list of keys.</paragraph>',
          textwrap.dedent("""\
            <paragraph>A model reference is an ordered list of keys, each key referencing an element. The
            complete list of keys may for example be concatenated to a path that then gives
            unique access to an element.</paragraph>"""),
          '<paragraph>A global reference is a reference to an external entity.</paragraph>'],
        constraints_by_identifier=[
          [
            'AASd-121',
            textwrap.dedent("""\
              <field_body><paragraph>For <SymbolReference refuri=".Reference">.Reference</SymbolReference>'s the <AttributeReference refuri="~Key.type">~Key.type</AttributeReference> of the first key of
              <AttributeReference refuri="~keys">~keys</AttributeReference> shall be one of <SymbolReference refuri=".Globally_identifiables">.Globally_identifiables</SymbolReference>.</paragraph></field_body>""")],
          [
            'AASd-122',
            textwrap.dedent("""\
              <field_body><paragraph>For global references, i.e. <SymbolReference refuri=".Reference">.Reference</SymbolReference>'s with
              <AttributeReference refuri="~Reference.type">~Reference.type</AttributeReference> = <AttributeReference refuri="~Reference_types.Global_reference">~Reference_types.Global_reference</AttributeReference>, the type
              of the first key of <AttributeReference refuri="~Reference.keys">~Reference.keys</AttributeReference> shall be one of
              <SymbolReference refuri=".Generic_globally_identifiables">.Generic_globally_identifiables</SymbolReference>.</paragraph></field_body>""")],
          [
            'AASd-123',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <SymbolReference refuri=".Reference">.Reference</SymbolReference>'s with
              <AttributeReference refuri="~Reference.type">~Reference.type</AttributeReference> = <AttributeReference refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</AttributeReference>, the type
              of the first key of <AttributeReference refuri="~Reference.keys">~Reference.keys</AttributeReference> shall be one of
              <SymbolReference refuri=".AAS_identifiables">.AAS_identifiables</SymbolReference>.</paragraph></field_body>""")],
          [
            'AASd-124',
            textwrap.dedent("""\
              <field_body><paragraph>For global references, i.e. <SymbolReference refuri=".Reference">.Reference</SymbolReference>'s with
              <AttributeReference refuri="~Reference.type">~Reference.type</AttributeReference> = <AttributeReference refuri="~Reference_types.Global_reference">~Reference_types.Global_reference</AttributeReference>, the last
              key of <AttributeReference refuri="~Reference.keys">~Reference.keys</AttributeReference> shall be either one of
              <SymbolReference refuri=".Generic_globally_identifiables">.Generic_globally_identifiables</SymbolReference> or one of
              <SymbolReference refuri=".Generic_fragment_keys">.Generic_fragment_keys</SymbolReference>.</paragraph></field_body>""")],
          [
            'AASd-125',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <SymbolReference refuri=".Reference">.Reference</SymbolReference>'s with
              <AttributeReference refuri="~Reference.type">~Reference.type</AttributeReference> = <AttributeReference refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</AttributeReference>, with more
              than one key in <AttributeReference refuri="~Reference.keys">~Reference.keys</AttributeReference> the type of the keys following the first
              key of  <AttributeReference refuri="~Reference.keys">~Reference.keys</AttributeReference> shall be one of <SymbolReference refuri=".Fragment_keys">.Fragment_keys</SymbolReference>.</paragraph><note><paragraph><ConstraintReference refuri="AASd-125">AASd-125</ConstraintReference> ensures that the shortest path is used.</paragraph></note></field_body>""")],
          [
            'AASd-126',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <SymbolReference refuri=".Reference">.Reference</SymbolReference>'s with
              <AttributeReference refuri="~Reference.type">~Reference.type</AttributeReference> = <AttributeReference refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</AttributeReference>, with more
              than one key in <AttributeReference refuri="~Reference.keys">~Reference.keys</AttributeReference> the type of the last key in the
              reference key chain may be one of <SymbolReference refuri=".Generic_fragment_keys">.Generic_fragment_keys</SymbolReference> or no key
              at all shall have a value out of <SymbolReference refuri=".Generic_fragment_keys">.Generic_fragment_keys</SymbolReference>.</paragraph></field_body>""")],
          [
            'AASd-127',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <SymbolReference refuri=".Reference">.Reference</SymbolReference>'s with
              <AttributeReference refuri="~Reference.type">~Reference.type</AttributeReference> = <AttributeReference refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</AttributeReference>, with more
              than one key in <AttributeReference refuri="~Reference.keys">~Reference.keys</AttributeReference> a key with <AttributeReference refuri="~Key.type">~Key.type</AttributeReference>
              <AttributeReference refuri="~Key_types.Fragment_reference">~Key_types.Fragment_reference</AttributeReference> shall be preceded by a key with
              <AttributeReference refuri="~Key.type">~Key.type</AttributeReference> <AttributeReference refuri="~Key_types.File">~Key_types.File</AttributeReference> or <AttributeReference refuri="~Key_types.Blob">~Key_types.Blob</AttributeReference>. All other
              AAS fragments, i.e. type values out of <SymbolReference refuri=".AAS_submodel_elements">.AAS_submodel_elements</SymbolReference>, do not
              support fragments.</paragraph><note><paragraph>Which kind of fragments are supported depends on the content type and the
              specification of allowed fragment identifiers for the corrsponding resource
              being referenced via the reference.</paragraph></note></field_body>""")],
          [
            'AASd-128',
            textwrap.dedent("""\
              <field_body><paragraph>For model references, i.e. <SymbolReference refuri=".Reference">.Reference</SymbolReference>'s with
              <AttributeReference refuri="~Reference.type">~Reference.type</AttributeReference> = <AttributeReference refuri="~Reference_types.Model_reference">~Reference_types.Model_reference</AttributeReference>, the
              <AttributeReference refuri="~Key.value">~Key.value</AttributeReference> of a <SymbolReference refuri=".Key">.Key</SymbolReference> preceded by a <SymbolReference refuri=".Key">.Key</SymbolReference> with
              <AttributeReference refuri="~Key.type">~Key.type</AttributeReference> = <AttributeReference refuri="~Key_types.Submodel_element_list">~Key_types.Submodel_element_list</AttributeReference> is an integer
              number denoting the position in the array of the submodel element list.</paragraph></field_body>""")]],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Key',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Key_types',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Denotes which kind of entity is referenced.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <paragraph>In case <AttributeReference refuri="~type">~type</AttributeReference> = <AttributeReference refuri="~Key_types.Fragment_reference">~Key_types.Fragment_reference</AttributeReference> the key represents
                a bookmark or a similar local identifier within its parent element as specified
                by the key that precedes this key.</paragraph>"""),
              textwrap.dedent("""\
                <paragraph>In all other cases the key references a model element of the same or of another AAS.
                The name of the model element is explicitly listed.</paragraph>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Key',
          parsed=...),
        Property(
          name='value',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Non_empty_string',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The key value, for example an IRDI or an URI</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Key',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='type',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Key_types',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='value',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Non_empty_string',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='type',
              argument='type',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='value',
              argument='value',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>A key is a reference to an element by its ID.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    Enumeration(
      name='Generic_fragment_keys',
      literals=[
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Bookmark or a similar local identifier of a subordinate part of a primary resource</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=6,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of all identifiable elements within an asset administration shell.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Generic_globally_identifiables',
      literals=[
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=8,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='AAS_identifiables',
      literals=[
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=7,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='AAS_submodel_elements',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Data Element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Data_element">~Data_element</AttributeReference>
                the reference may be a <SymbolReference refuri=".Property">.Property</SymbolReference>, a <SymbolReference refuri=".File">.File</SymbolReference> etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event element</paragraph>',
            remarks=[
              '<note><paragraph><SymbolReference refuri=".Event_element">.Event_element</SymbolReference> is abstract.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Property with a value that can be provided in multiple languages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Range with min and max</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Reference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Relationship</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Submodel Element is abstract, i.e. if a key uses
                <AttributeReference refuri="Submodel_element">Submodel_element</AttributeReference> the reference may be a <SymbolReference refuri=".Property">.Property</SymbolReference>,
                a <SymbolReference refuri=".Submodel_element_list">.Submodel_element_list</SymbolReference>, an <SymbolReference refuri=".Operation">.Operation</SymbolReference> etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=EnumerationLiteralDescription(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=5,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of all referable elements within an asset administration shell.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='AAS_referable_non_identifiables',
      literals=[
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Data Element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Data_element">~Data_element</AttributeReference>
                the reference may be a <SymbolReference refuri=".Property">.Property</SymbolReference>, a <SymbolReference refuri=".File">.File</SymbolReference> etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event element</paragraph>',
            remarks=[
              '<note><paragraph><SymbolReference refuri=".Event_element">.Event_element</SymbolReference> is abstract.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Property with a value that can be provided in multiple languages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Range with min and max</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Reference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Relationship</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Submodel Element is abstract, i.e. if a key uses
                <AttributeReference refuri="Submodel_element">Submodel_element</AttributeReference> the reference may be a <SymbolReference refuri=".Property">.Property</SymbolReference>,
                a <SymbolReference refuri=".Submodel_element_list">.Submodel_element_list</SymbolReference>, an <SymbolReference refuri=".Operation">.Operation</SymbolReference> etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=EnumerationLiteralDescription(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[
        'Reference to Enumeration AAS_submodel_elements'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=4,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of all referable elements within an asset administration shell.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Globally_identifiables',
      literals=[
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...)],
      is_superset_of=[
        'Reference to Enumeration AAS_identifiables',
        'Reference to Enumeration Generic_globally_identifiables'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=3,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of all referable elements within an asset administration shell</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Fragment_keys',
      literals=[
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=EnumerationLiteralDescription(
            summary=textwrap.dedent("""\
              <paragraph>Bookmark or a similar local identifier of a subordinate part of
              a primary resource</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Data element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Data_element">~Data_element</AttributeReference>
                the reference may be a Property, a File etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event.</paragraph>',
            remarks=[
              '<note><paragraph><SymbolReference refuri=".Event_element">.Event_element</SymbolReference> is abstract.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Property with a value that can be provided in multiple languages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Range with min and max</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Reference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Relationship</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Submodel Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Submodel_element">~Submodel_element</AttributeReference>
                the reference may be a <SymbolReference refuri=".Property">.Property</SymbolReference>, an <SymbolReference refuri=".Operation">.Operation</SymbolReference> etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=EnumerationLiteralDescription(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[
        'Reference to Enumeration AAS_referable_non_identifiables',
        'Reference to Enumeration Generic_fragment_keys'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=2,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Key_types',
      literals=[
        EnumerationLiteral(
          name='Fragment_reference',
          value='FragmentReference',
          description=EnumerationLiteralDescription(
            summary=textwrap.dedent("""\
              <paragraph>Bookmark or a similar local identifier of a subordinate part of
              a primary resource</paragraph>"""),
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Global_reference',
          value='GlobalReference',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Annotated_relationship_element',
          value='AnnotatedRelationshipElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Asset_administration_shell',
          value='AssetAdministrationShell',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Basic_event_element',
          value='BasicEventElement',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Blob',
          value='Blob',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Capability',
          value='Capability',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Concept_description',
          value='ConceptDescription',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Data_element',
          value='DataElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Data element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Data Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Data_element">~Data_element</AttributeReference>
                the reference may be a Property, a File etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Entity',
          value='Entity',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Event_element',
          value='EventElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Event.</paragraph>',
            remarks=[
              '<note><paragraph><SymbolReference refuri=".Event_element">.Event_element</SymbolReference> is abstract.</paragraph></note>'],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='File',
          value='File',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Multi_language_property',
          value='MultiLanguageProperty',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Property with a value that can be provided in multiple languages</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Operation',
          value='Operation',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Property',
          value='Property',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Range',
          value='Range',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Range with min and max</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Referable',
          value='Referable',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Reference_element',
          value='ReferenceElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Reference</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Relationship_element',
          value='RelationshipElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Relationship</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel',
          value='Submodel',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element',
          value='SubmodelElement',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Submodel Element</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Submodel Element is abstract, <emphasis>i.e.</emphasis> if a key uses <AttributeReference refuri="~Submodel_element">~Submodel_element</AttributeReference>
                the reference may be a <SymbolReference refuri=".Property">.Property</SymbolReference>, an <SymbolReference refuri=".Operation">.Operation</SymbolReference> etc.</paragraph></note>""")],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_list',
          value='SubmodelElementList',
          description=EnumerationLiteralDescription(
            summary='<paragraph>List of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...),
        EnumerationLiteral(
          name='Submodel_element_collection',
          value='SubmodelElementCollection',
          description=EnumerationLiteralDescription(
            summary='<paragraph>Struct of Submodel Elements</paragraph>',
            remarks=[],
            parsed=...),
          parsed=...)],
      is_superset_of=[
        'Reference to Enumeration Fragment_keys',
        'Reference to Enumeration Globally_identifiables'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          10,
          3],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration of different key value types within a key.</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Data_type_def_XSD',
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time_stamp',
          value='xs:dateTimeStamp',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Day_time_duration',
          value='xs:dayTimeDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='xs:yearMonthDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:NonNegativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          11,
          3],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration listing all xsd anySimpleTypes</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Data_type_def_RDF',
      literals=[
        EnumerationLiteral(
          name='Lang_string',
          value='rdf:langString',
          description=EnumerationLiteralDescription(
            summary='<paragraph>String with a language tag</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>RDF requires IETF BCP 47  language tags, i.e. simple two-letter language tags
                for Locales like “de” conformant to ISO 639-1 are allowed as well as language
                tags plus extension like “de-DE” for country code, dialect etc. like in “en-US”
                or “en-GB” for English (United Kingdom) and English (United States).
                IETF language tags are referencing ISO 639, ISO 3166 and ISO 15924.</paragraph></note>""")],
            parsed=...),
          parsed=...)],
      is_superset_of=[],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          3],
        index=4,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Enumeration listing all RDF types</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    Enumeration(
      name='Data_type_def',
      literals=[
        EnumerationLiteral(
          name='Any_URI',
          value='xs:anyURI',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Base_64_binary',
          value='xs:base64Binary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Boolean',
          value='xs:boolean',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date',
          value='xs:date',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time',
          value='xs:dateTime',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Date_time_stamp',
          value='xs:dateTimeStamp',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Decimal',
          value='xs:decimal',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Double',
          value='xs:double',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Duration',
          value='xs:duration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Float',
          value='xs:float',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_day',
          value='xs:gDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month',
          value='xs:gMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_month_day',
          value='xs:gMonthDay',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_year',
          value='xs:gYear',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='G_year_month',
          value='xs:gYearMonth',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Hex_binary',
          value='xs:hexBinary',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='String',
          value='xs:string',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Time',
          value='xs:time',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Day_time_duration',
          value='xs:dayTimeDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Year_month_duration',
          value='xs:yearMonthDuration',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Integer',
          value='xs:integer',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Long',
          value='xs:long',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Int',
          value='xs:int',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Short',
          value='xs:short',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Byte',
          value='xs:byte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_negative_integer',
          value='xs:NonNegativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Positive_integer',
          value='xs:positiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_long',
          value='xs:unsignedLong',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_int',
          value='xs:unsignedInt',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_short',
          value='xs:unsignedShort',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Unsigned_byte',
          value='xs:unsignedByte',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Non_positive_integer',
          value='xs:nonPositiveInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Negative_integer',
          value='xs:negativeInteger',
          description=None,
          parsed=...),
        EnumerationLiteral(
          name='Lang_string',
          value='rdf:langString',
          description=None,
          parsed=...)],
      is_superset_of=[
        'Reference to Enumeration Data_type_def_XSD',
        'Reference to Enumeration Data_type_def_RDF'],
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>string with values of enumerations <SymbolReference refuri=".Data_type_def_XSD">.Data_type_def_XSD</SymbolReference>,
          <SymbolReference refuri=".Data_type_def_RDF">.Data_type_def_RDF</SymbolReference></paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      literals_by_name=...,
      literal_id_set=...,
      parsed=...),
    ConcreteClass(
      name='Lang_string',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='language',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol BCP_47_language_tag',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Language tag conforming to BCP 47</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Lang_string',
          parsed=...),
        Property(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Text in the <AttributeReference refuri="~language">~language</AttributeReference></paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Lang_string',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='language',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol BCP_47_language_tag',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='text',
            type_annotation=PrimitiveTypeAnnotation(
              a_type='STR',
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='language',
              argument='language',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='text',
              argument='text',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          1],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Strings with language tags</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Lang_string_set',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='lang_strings',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Strings in different languages</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Lang_string_set',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='lang_strings',
            type_annotation=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='lang_strings',
              argument='lang_strings',
              default=None)""")]),
      invariants=[
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            Comparison(
              left=FunctionCall(
                name='len',
                args=[
                  Member(
                    instance=Name(
                      identifier='self',
                      original_node=...),
                    name='lang_strings',
                    original_node=...)],
                original_node=...),
              op='GE',
              right=Constant(
                value=1,
                original_node=...),
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Lang_string_set',
          parsed=...),
        Invariant(
          description=None,
          body=textwrap.dedent("""\
            FunctionCall(
              name='lang_strings_have_unique_languages',
              args=[
                Member(
                  instance=Name(
                    identifier='self',
                    original_node=...),
                  name='lang_strings',
                  original_node=...)],
              original_node=...)"""),
          specified_for='Reference to ConcreteClass Lang_string_set',
          parsed=...)],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          12,
          2],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Array of elements of type langString</paragraph>',
        remarks=[
          '<note><paragraph>langString is a RDF data type.</paragraph></note>',
          textwrap.dedent("""\
            <paragraph>A langString is a string value tagged with a language code.
            It depends on the serialization rules for a technology how
            this is realized.</paragraph>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_specification_content',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_specification_content',
        name='Data_specification_content',
        inheritances=[],
        implementers=[],
        properties=[],
        signatures=[],
        description=SymbolDescription(
          summary=textwrap.dedent("""\
            <paragraph>Data specification content is part of a data specification template and defines
            which additional attributes shall be added to the element instance that references
            the data specification template and meta information about the template itself.</paragraph>"""),
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=None,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          2,
          1,
          1],
        index=1,
        fragment=None),
      description=SymbolDescription(
        summary=textwrap.dedent("""\
          <paragraph>Data specification content is part of a data specification template and defines
          which additional attributes shall be added to the element instance that references
          the data specification template and meta information about the template itself.</paragraph>"""),
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    AbstractClass(
      name='Data_specification',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=Interface(
        base='Reference to AbstractClass Data_specification',
        name='Data_specification',
        inheritances=[],
        implementers=[],
        properties=[
          Property(
            name='id',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Identifier',
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The globally unique identification of the element.</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Data_specification',
            parsed=...),
          Property(
            name='data_specification_content',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Data_specification_content',
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>The content of the template without meta data</paragraph>',
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Data_specification',
            parsed=...),
          Property(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
              remarks=[
                textwrap.dedent("""\
                  <note><paragraph>Some of the administrative information like the version number might need to
                  be part of the identification.</paragraph></note>""")],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Data_specification',
            parsed=...),
          Property(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            description=PropertyDescription(
              summary=textwrap.dedent("""\
                <paragraph>Description how and in which context the data specification template is applicable.
                The description can be provided in several languages.</paragraph>"""),
              remarks=[],
              constraints_by_identifier=[],
              parsed=...),
            specified_for='Reference to AbstractClass Data_specification',
            parsed=...)],
        signatures=[],
        description=SymbolDescription(
          summary='<paragraph>Data Specification Template</paragraph>',
          remarks=[],
          constraints_by_identifier=[],
          parsed=...),
        parsed=...,
        properties_by_name=...,
        property_id_set=...),
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='id',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Identifier',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The globally unique identification of the element.</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Data_specification',
          parsed=...),
        Property(
          name='data_specification_content',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_specification_content',
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>The content of the template without meta data</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Data_specification',
          parsed=...),
        Property(
          name='administration',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Administrative_information',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Administrative information of an identifiable element.</paragraph>',
            remarks=[
              textwrap.dedent("""\
                <note><paragraph>Some of the administrative information like the version number might need to
                be part of the identification.</paragraph></note>""")],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Data_specification',
          parsed=...),
        Property(
          name='description',
          type_annotation=OptionalTypeAnnotation(
            value=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string_set',
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary=textwrap.dedent("""\
              <paragraph>Description how and in which context the data specification template is applicable.
              The description can be provided in several languages.</paragraph>"""),
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to AbstractClass Data_specification',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='id',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Identifier',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='data_specification_content',
            type_annotation=OurTypeAnnotation(
              symbol='Reference to symbol Data_specification_content',
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='administration',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Administrative_information',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...),
          Argument(
            name='description',
            type_annotation=OptionalTypeAnnotation(
              value=OurTypeAnnotation(
                symbol='Reference to symbol Lang_string_set',
                parsed=...),
              parsed=...),
            default=None,
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='id',
              argument='id',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specification_content',
              argument='data_specification_content',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='administration',
              argument='administration',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='description',
              argument='description',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          6,
          2,
          1,
          1],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Data Specification Template</paragraph>',
        remarks=[],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...),
    ConcreteClass(
      name='Environment',
      inheritances=[],
      inheritance_id_set=...,
      is_implementation_specific=False,
      interface=None,
      descendant_id_set=...,
      concrete_descendants=[],
      properties=[
        Property(
          name='asset_administration_shells',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Asset_administration_shell',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Asset administration shell</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='submodels',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Submodel',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Submodel</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='concept_descriptions',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Concept_description',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Concept description</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...),
        Property(
          name='data_specifications',
          type_annotation=OptionalTypeAnnotation(
            value=ListTypeAnnotation(
              items=OurTypeAnnotation(
                symbol='Reference to symbol Data_specification',
                parsed=...),
              parsed=...),
            parsed=...),
          description=PropertyDescription(
            summary='<paragraph>Data specification</paragraph>',
            remarks=[],
            constraints_by_identifier=[],
            parsed=...),
          specified_for='Reference to ConcreteClass Environment',
          parsed=...)],
      methods=[],
      constructor=Constructor(
        name='__init__',
        arguments=[
          Argument(
            name='asset_administration_shells',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Asset_administration_shell',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='submodels',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Submodel',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='concept_descriptions',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Concept_description',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...),
          Argument(
            name='data_specifications',
            type_annotation=OptionalTypeAnnotation(
              value=ListTypeAnnotation(
                items=OurTypeAnnotation(
                  symbol='Reference to symbol Data_specification',
                  parsed=...),
                parsed=...),
              parsed=...),
            default=DefaultConstant(
              value=None,
              parsed=...),
            parsed=...)],
        returns=None,
        description=None,
        contracts=Contracts(
          preconditions=[],
          snapshots=[],
          postconditions=[]),
        parsed=...,
        arguments_by_name=...,
        is_implementation_specific=False,
        statements=[
          textwrap.dedent("""\
            AssignArgument(
              name='asset_administration_shells',
              argument='asset_administration_shells',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='submodels',
              argument='submodels',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='concept_descriptions',
              argument='concept_descriptions',
              default=None)"""),
          textwrap.dedent("""\
            AssignArgument(
              name='data_specifications',
              argument='data_specifications',
              default=None)""")]),
      invariants=[],
      serialization=Serialization(
        with_model_type=False),
      reference_in_the_book=ReferenceInTheBook(
        section=[
          5,
          7,
          9],
        index=0,
        fragment=None),
      description=SymbolDescription(
        summary='<paragraph>Container for the sets of different identifiables.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <note><paragraph>w.r.t. file exchange: There is exactly one environment independent on how many
            files the contained elements are split. If the file is split then there
            shall be no element with the same identifier in two different files.</paragraph></note>""")],
        constraints_by_identifier=[],
        parsed=...),
      parsed=...,
      properties_by_name=...,
      property_id_set=...,
      methods_by_name=...,
      invariant_id_set=...)],
  symbols_topologically_sorted=[
    'Reference to symbol Has_data_specification',
    'Reference to symbol Administrative_information',
    'Reference to symbol Has_extensions',
    'Reference to symbol Referable',
    'Reference to symbol Has_kind',
    'Reference to symbol Has_semantics',
    'Reference to symbol Qualifiable',
    'Reference to symbol Submodel_element',
    'Reference to symbol Relationship_element',
    'Reference to symbol Annotated_relationship_element',
    'Reference to symbol Identifiable',
    'Reference to symbol Asset_administration_shell',
    'Reference to symbol Asset_information',
    'Reference to symbol BCP_47_language_tag',
    'Reference to symbol Event_element',
    'Reference to symbol Basic_event_element',
    'Reference to symbol Data_element',
    'Reference to symbol Blob',
    'Reference to symbol Blob_type',
    'Reference to symbol Capability',
    'Reference to symbol Concept_description',
    'Reference to symbol Non_empty_string',
    'Reference to symbol Content_type',
    'Reference to symbol Data_specification',
    'Reference to symbol Data_specification_content',
    'Reference to symbol Date_time_stamp_UTC',
    'Reference to symbol Entity',
    'Reference to symbol Environment',
    'Reference to symbol Event_payload',
    'Reference to symbol Extension',
    'Reference to symbol File',
    'Reference to symbol Id_short',
    'Reference to symbol Identifier',
    'Reference to symbol Key',
    'Reference to symbol Lang_string',
    'Reference to symbol Lang_string_set',
    'Reference to symbol Multi_language_property',
    'Reference to symbol Operation',
    'Reference to symbol Operation_variable',
    'Reference to symbol Path_type',
    'Reference to symbol Property',
    'Reference to symbol Qualifier',
    'Reference to symbol Qualifier_type',
    'Reference to symbol Range',
    'Reference to symbol Reference',
    'Reference to symbol Reference_element',
    'Reference to symbol Resource',
    'Reference to symbol Specific_asset_id',
    'Reference to symbol Submodel',
    'Reference to symbol Submodel_element_collection',
    'Reference to symbol Submodel_element_list',
    'Reference to symbol Value_data_type'],
  verification_functions=[
    PatternVerification(
      name='matches_id_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> is a valid short ID.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[a-zA-Z][a-zA-Z0-9_]+$'),
    PatternVerification(
      name='matches_xs_date_time_stamp_utc',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:dateTimeStamp</literal>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The time zone must be fixed to UTC. We verify only that the <literal>text</literal> matches
            a pre-defined pattern. We <emphasis>do not</emphasis> verify that the day of month is
            correct nor do we check for leap seconds.</paragraph>"""),
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp">https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)Z$'),
    ImplementationSpecificVerification(
      name='is_xs_date_time_stamp_utc',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> is a <literal>xs:dateTimeStamp</literal> with time zone set to UTC.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The <literal>text</literal> is assumed to match a pre-defined pattern for <literal>xs:dateTimeStamp</literal> with
            the time zone set to UTC. In this function, we check for days of month (e.g.,
            February 29th).</paragraph>"""),
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp">https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> is a valid <literal>xs:dateTimeStamp</literal> in UTC</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_MIME_type',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of MIME type.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The definition has been taken from:
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1">https://www.rfc-editor.org/rfc/rfc7231#section-3.1.1.1</reference>,
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3">https://www.rfc-editor.org/rfc/rfc7230#section-3.2.3</reference> and
            <reference refuri="https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6">https://www.rfc-editor.org/rfc/rfc7230#section-3.2.6</reference>.</paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+/([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+([ \t]*;[ \t]*([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+=(([!#$%&\'*+\\-.^_`|~0-9a-zA-Z])+|"(([\t !#-\\[\\]-~]|[\\x80-\\xff])|\\\\([\t !-~]|[\\x80-\\xff]))*"))*$'),
    PatternVerification(
      name='matches_RFC_8089_path',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> is a path conforming to the pattern of RFC 8089.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The definition has been taken from:
            <reference refuri="https://datatracker.ietf.org/doc/html/rfc8089">https://datatracker.ietf.org/doc/html/rfc8089</reference></paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern="^file:(//((localhost|(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)))?/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|/((([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/(([a-zA-Z0-9\\-._~]|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?)$"),
    PatternVerification(
      name='matches_BCP_47',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> is a valid BCP 47 language tag.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://en.wikipedia.org/wiki/IETF_language_tag">https://en.wikipedia.org/wiki/IETF_language_tag</reference></paragraph>'],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([a-zA-Z]{2,3}(-[a-zA-Z]{3}(-[a-zA-Z]{3}){2})?|[a-zA-Z]{4}|[a-zA-Z]{5,8})(-[a-zA-Z]{4})?(-([a-zA-Z]{2}|[0-9]{3}))?(-(([a-zA-Z0-9]){5,8}|[0-9]([a-zA-Z0-9]){3}))*(-[0-9A-WY-Za-wy-z](-([a-zA-Z0-9]){2,8})+)*(-[xX](-([a-zA-Z0-9]){1,8})+)?|[xX](-([a-zA-Z0-9]){1,8})+|((en-GB-oed|i-ami|i-bnn|i-default|i-enochian|i-hak|i-klingon|i-lux|i-mingo|i-navajo|i-pwn|i-tao|i-tay|i-tsu|sgn-BE-FR|sgn-BE-NL|sgn-CH-DE)|(art-lojban|cel-gaulish|no-bok|no-nyn|zh-guoyu|zh-hakka|zh-min|zh-min-nan|zh-xiang)))$'),
    ImplementationSpecificVerification(
      name='lang_strings_have_unique_languages',
      arguments=[
        Argument(
          name='lang_strings',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Lang_string',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ArgumentReference refuri="lang_strings">lang_strings</ArgumentReference> do not have overlapping
          <AttributeReference refuri="~Lang_string.language">~Lang_string.language</AttributeReference>'s</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='qualifier_types_are_unique',
      arguments=[
        Argument(
          name='qualifiers',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Qualifier',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>\'s of <ArgumentReference refuri="qualifiers">qualifiers</ArgumentReference> are unique.</paragraph>',
        remarks=[],
        arguments_by_name=[
          [
            'qualifiers',
            '<field_body><paragraph>to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if all <AttributeReference refuri="~Qualifier.type">~Qualifier.type</AttributeReference>\'s are unique</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_xs_any_URI',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:anyURI</literal>.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#anyURI">https://www.w3.org/TR/xmlschema11-2/#anyURI</reference> and
            <reference refuri="https://datatracker.ietf.org/doc/html/rfc3987">https://datatracker.ietf.org/doc/html/rfc3987</reference></paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern="^([a-zA-Z][a-zA-Z0-9+\\-.]*:(//((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|:)*@)?(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)(:[0-9]*)?(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|/(((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])){0})(\\?((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]|[/?])*)?(\\#((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[/?])*)?|(//((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|:)*@)?(\\[((([0-9A-Fa-f]{1,4}:){6}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|::([0-9A-Fa-f]{1,4}:){5}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|([0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){4}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){3}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){2}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:){2}([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){4}[0-9A-Fa-f]{1,4})?::([0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|(([0-9A-Fa-f]{1,4}:){5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(([0-9A-Fa-f]{1,4}:){6}[0-9A-Fa-f]{1,4})?::)|[vV][0-9A-Fa-f]+\\.([a-zA-Z0-9\\-._~]|[!$&'()*+,;=]|:)+)\\]|([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=])*)(:[0-9]*)?(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|/(((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*)?|(([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|@)+(/((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@]))*)*|((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])){0})(\\?((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[\\ue000-\\uf8ff\\U000f0000-\\U000ffffd\\U00100000-\\U0010fffd]|[/?])*)?(\\#((([a-zA-Z0-9\\-._~]|[\\xa0-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\uffef\\U00010000-\\U0001fffd\\U00020000-\\U0002fffd\\U00030000-\\U0003fffd\\U00040000-\\U0004fffd\\U00050000-\\U0005fffd\\U00060000-\\U0006fffd\\U00070000-\\U0007fffd\\U00080000-\\U0008fffd\\U00090000-\\U0009fffd\\U000a0000-\\U000afffd\\U000b0000-\\U000bfffd\\U000c0000-\\U000cfffd\\U000d0000-\\U000dfffd\\U000e1000-\\U000efffd])|%[0-9A-Fa-f][0-9A-Fa-f]|[!$&'()*+,;=]|[:@])|[/?])*)?)$"),
    PatternVerification(
      name='matches_xs_base_64_binary',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:base64Binary</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#base64Binary">https://www.w3.org/TR/xmlschema11-2/#base64Binary</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?)*(([A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/])|[A-Za-z0-9+/]\\x20?[A-Za-z0-9+/]\\x20?[AEIMQUYcgkosw048]\\x20?=|[A-Za-z0-9+/]\\x20?[AQgw]\\x20?= ?=))?$'),
    PatternVerification(
      name='matches_xs_boolean',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:boolean</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#boolean">https://www.w3.org/TR/xmlschema11-2/#boolean</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(true|false|1|0)$'),
    PatternVerification(
      name='matches_xs_date',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:date</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#date">https://www.w3.org/TR/xmlschema11-2/#date</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))(Z|(\\+|-)(0[0-9]|1[0-3]):[0-5][0-9]|14:00)?$'),
    PatternVerification(
      name='matches_xs_date_time',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:dateTime</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dateTime">https://www.w3.org/TR/xmlschema11-2/#dateTime</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|(\\+|-)(0[0-9]|1[0-3]):[0-5][0-9]|14:00)?$'),
    PatternVerification(
      name='matches_xs_date_time_stamp',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:dateTimeStamp</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp">https://www.w3.org/TR/xmlschema11-2/#dateTimeStamp</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?(([1-9][0-9][0-9][0-9]+)|(0[0-9][0-9][0-9]))-((0[1-9])|(1[0-2]))-((0[1-9])|([12][0-9])|(3[01]))T(((([01][0-9])|(2[0-3])):[0-5][0-9]:([0-5][0-9])(\\.[0-9]+)?)|24:00:00(\\.0+)?)(Z|(\\+|-)(0[0-9]|1[0-3]):[0-5][0-9]|14:00)$'),
    PatternVerification(
      name='matches_xs_decimal',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:decimal</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#decimal">https://www.w3.org/TR/xmlschema11-2/#decimal</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^((\\+|-)?([0-9]+\\.[0-9]+|\\.[0-9]+)|(\\+|-)?[0-9]+)$'),
    PatternVerification(
      name='matches_xs_double',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:double</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#double">https://www.w3.org/TR/xmlschema11-2/#double</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN$'),
    PatternVerification(
      name='matches_xs_duration',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:duration</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#duration">https://www.w3.org/TR/xmlschema11-2/#duration</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$'),
    PatternVerification(
      name='matches_xs_float',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:float</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#float">https://www.w3.org/TR/xmlschema11-2/#float</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(\\+|-)?([0-9]+(\\.[0-9]*)?|\\.[0-9]+)([Ee](\\+|-)?[0-9]+)?|(\\+|-)?INF|NaN$'),
    PatternVerification(
      name='matches_xs_g_day',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:gDay</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gDay">https://www.w3.org/TR/xmlschema11-2/#gDay</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^---(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_g_month',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:gMonth</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gMonth">https://www.w3.org/TR/xmlschema11-2/#gMonth</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^--(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_g_month_day',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:gMonthDay</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gMonthDay">https://www.w3.org/TR/xmlschema11-2/#gMonthDay</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_g_year',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:gYear</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gYear">https://www.w3.org/TR/xmlschema11-2/#gYear</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_g_year_month',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:gYearMonth</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#gYearMonth">https://www.w3.org/TR/xmlschema11-2/#gYearMonth</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_hex_binary',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:hexBinary</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#hexBinary">https://www.w3.org/TR/xmlschema11-2/#hexBinary</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^([0-9a-fA-F]{2})*$'),
    PatternVerification(
      name='matches_xs_time',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:time</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#time">https://www.w3.org/TR/xmlschema11-2/#time</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\\.[0-9]+)?|(24:00:00(\\.0+)?))(Z|(\\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?$'),
    PatternVerification(
      name='matches_xs_day_time_duration',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:dayTimeDuration</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration">https://www.w3.org/TR/xmlschema11-2/#dayTimeDuration</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?P((([0-9]+D)(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$'),
    PatternVerification(
      name='matches_xs_year_month_duration',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:yearMonthDuration</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#yearMonthDuration">https://www.w3.org/TR/xmlschema11-2/#yearMonthDuration</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^-?P((([0-9]+Y)([0-9]+M)?)|([0-9]+M))$'),
    PatternVerification(
      name='matches_xs_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:integer</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#integer">https://www.w3.org/TR/xmlschema11-2/#integer</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?[0-9]+$'),
    PatternVerification(
      name='matches_xs_long',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:long</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#long">https://www.w3.org/TR/xmlschema11-2/#long</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,20}$'),
    PatternVerification(
      name='matches_xs_int',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:int</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#int">https://www.w3.org/TR/xmlschema11-2/#int</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,10}$'),
    PatternVerification(
      name='matches_xs_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:short</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#short">https://www.w3.org/TR/xmlschema11-2/#short</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,5}$'),
    PatternVerification(
      name='matches_xs_byte',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:byte</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#byte">https://www.w3.org/TR/xmlschema11-2/#byte</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\-+]?0*[0-9]{1,3}$'),
    PatternVerification(
      name='matches_xs_non_negative_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:nonNegativeInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#nonNegativeInteger">https://www.w3.org/TR/xmlschema11-2/#nonNegativeInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?[0-9]+)$'),
    PatternVerification(
      name='matches_xs_positive_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:positiveInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#positiveInteger">https://www.w3.org/TR/xmlschema11-2/#positiveInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^\\+?0*[1-9][0-9]*$'),
    PatternVerification(
      name='matches_xs_unsigned_long',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:unsignedLong</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#unsignedLong">https://www.w3.org/TR/xmlschema11-2/#unsignedLong</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,20})$'),
    PatternVerification(
      name='matches_xs_unsigned_int',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:unsignedInt</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#unsignedInt">https://www.w3.org/TR/xmlschema11-2/#unsignedInt</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,10})$'),
    PatternVerification(
      name='matches_xs_unsigned_short',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:unsignedShort</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#unsignedShort">https://www.w3.org/TR/xmlschema11-2/#unsignedShort</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,5})$'),
    PatternVerification(
      name='matches_xs_unsigned_byte',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:unsignedByte</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#unsignedByte">https://www.w3.org/TR/xmlschema11-2/#unsignedByte</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0|\\+?0*[0-9]{1,3})$'),
    PatternVerification(
      name='matches_xs_non_positive_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:nonPositiveInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#nonPositiveInteger">https://www.w3.org/TR/xmlschema11-2/#nonPositiveInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(\\+0|0|-[0-9]+)$'),
    PatternVerification(
      name='matches_xs_negative_integer',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:negativeInteger</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#negativeInteger">https://www.w3.org/TR/xmlschema11-2/#negativeInteger</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^(-0*[1-9][0-9]*)$'),
    PatternVerification(
      name='matches_xs_string',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern of an <literal>xs:string</literal>.</paragraph>',
        remarks=[
          '<paragraph>See: <reference refuri="https://www.w3.org/TR/xmlschema11-2/#string">https://www.w3.org/TR/xmlschema11-2/#string</reference></paragraph>'],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>Text to be checked</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> conforms to the pattern</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[\\u0001-\\uD7FF\\uE000-\\uFFFD\\U00010000-\\U0010FFFF]*$'),
    ImplementationSpecificVerification(
      name='value_consistent_with_xsd_type',
      arguments=[
        Argument(
          name='value',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def_XSD',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that the <ArgumentReference refuri="value">value</ArgumentReference> conforms to its <ArgumentReference refuri="value_type">value_type</ArgumentReference>.</paragraph>',
        remarks=[],
        arguments_by_name=[
          [
            'value',
            '<field_body><paragraph>which needs to conform</paragraph></field_body>'],
          [
            'value_type',
            '<field_body><paragraph>pre-defined value type</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="value">value</ArgumentReference> conforms</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    PatternVerification(
      name='matches_global_asset_id_literally',
      arguments=[
        Argument(
          name='text',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that the <ArgumentReference refuri="text">text</ArgumentReference> matches <literal>globalAssetId</literal> case-insensitive.</paragraph>',
        remarks=[
          textwrap.dedent("""\
            <paragraph>The case-insensitivity depends on the culture. For example in Turkish, uppercase
            "i" is "İ", not "I". We assume the culture to be English, and explicitly check
            for English case-folding.</paragraph>""")],
        arguments_by_name=[
          [
            'text',
            '<field_body><paragraph>which needs to match <literal>globalAssetId</literal> literally</paragraph></field_body>']],
        returns='<field_body><paragraph>True if the <ArgumentReference refuri="text">text</ArgumentReference> matches case-insensitive</paragraph></field_body>',
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...,
      pattern='^[gG][lL][oO][bB][aA][lL][aA][sS][sS][eE][tT][iI][dD]$'),
    ImplementationSpecificVerification(
      name='is_model_reference_to',
      arguments=[
        Argument(
          name='reference',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Reference',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='expected_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Key_types',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that the target of the model reference matches the expected <literal>target</literal>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='id_shorts_are_unique',
      arguments=[
        Argument(
          name='referables',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Referable',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <AttributeReference refuri="~Referable.id_short">~Referable.id_short</AttributeReference>'s among the <ArgumentReference refuri="referables">referables</ArgumentReference> are
          unique.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='extension_names_are_unique',
      arguments=[
        Argument(
          name='extensions',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Extension',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that the extension names are unique.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='submodel_elements_have_identical_semantic_ids',
      arguments=[
        Argument(
          name='elements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_element',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that all semantic IDs are identical, if specified.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='submodel_element_is_of_type',
      arguments=[
        Argument(
          name='element',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Submodel_element',
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='element_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol AAS_submodel_elements',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary=textwrap.dedent("""\
          <paragraph>Check that the run-time type of the <ArgumentReference refuri="element">element</ArgumentReference> coincides with
          <ArgumentReference refuri="element_type">element_type</ArgumentReference>.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='properties_or_ranges_have_value_type',
      arguments=[
        Argument(
          name='elements',
          type_annotation=ListTypeAnnotation(
            items=OurTypeAnnotation(
              symbol='Reference to symbol Submodel_element',
              parsed=...),
            parsed=...),
          default=None,
          parsed=...),
        Argument(
          name='value_type',
          type_annotation=OurTypeAnnotation(
            symbol='Reference to symbol Data_type_def_XSD',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary='<paragraph>Check that all the <ArgumentReference refuri="elements">elements</ArgumentReference> have the <ArgumentReference refuri="value_type">value_type</ArgumentReference>.</paragraph>',
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...),
    ImplementationSpecificVerification(
      name='concept_description_category_is_valid',
      arguments=[
        Argument(
          name='category',
          type_annotation=PrimitiveTypeAnnotation(
            a_type='STR',
            parsed=...),
          default=None,
          parsed=...)],
      returns=PrimitiveTypeAnnotation(
        a_type='BOOL',
        parsed=...),
      description=SignatureDescription(
        summary=textwrap.dedent("""\
          <paragraph>Check that the <ArgumentReference refuri="category">category</ArgumentReference> is a valid category for
          a <SymbolReference refuri=".Concept_description">.Concept_description</SymbolReference>.</paragraph>"""),
        remarks=[],
        arguments_by_name=[],
        returns=None,
        parsed=...),
      contracts=Contracts(
        preconditions=[],
        snapshots=[],
        postconditions=[]),
      parsed=...,
      arguments_by_name=...)],
  verification_functions_by_name=...,
  meta_model=MetaModel(
    description=MetaModelDescription(
      summary='<paragraph>Provide the meta model for Asset Administration Shell V3.0 Release Candidate 2.</paragraph>',
      remarks=[
        '<paragraph>The following constraints apply to the meta-model in general:</paragraph>',
        textwrap.dedent("""\
          <paragraph>We could not implement the following constraints since they depend on registry
          and can not be verified without it:</paragraph>"""),
        '<bullet_list bullet="*"><list_item><paragraph><ConstraintReference refuri="AASd-006">AASd-006</ConstraintReference></paragraph></list_item><list_item><paragraph><ConstraintReference refuri="AASd-007">AASd-007</ConstraintReference></paragraph></list_item></bullet_list>',
        textwrap.dedent("""\
          <paragraph>Some constraints are not enforceable as they depend on the wider context
          such as language understanding, so we could not formalize them:</paragraph>"""),
        '<bullet_list bullet="*"><list_item><paragraph><ConstraintReference refuri="AASd-012">AASd-012</ConstraintReference></paragraph></list_item></bullet_list>',
        textwrap.dedent("""\
          <paragraph>We could not formalize the constraints which prescribed how to deal with
          the default values as these are not really constraints in the strict sense, but more
          a guideline on how to resolve default values:</paragraph>"""),
        '<bullet_list bullet="*"><list_item><paragraph><ConstraintReference refuri="AASd-115">AASd-115</ConstraintReference></paragraph></list_item></bullet_list>',
        textwrap.dedent("""\
          <paragraph>The constraint <ConstraintReference refuri="AASd-116">AASd-116</ConstraintReference> is ill-defined. The type of the
          <AttributeReference refuri="~Specific_asset_id.value">~Specific_asset_id.value</AttributeReference> is a string, but the type of
          <AttributeReference refuri="~Asset_information.global_asset_id">~Asset_information.global_asset_id</AttributeReference> is a <SymbolReference refuri=".Reference">.Reference</SymbolReference>. The comparison
          between a string and a reference is not defined, so we can not implement
          this constraint.</paragraph>""")],
      constraints_by_identifier=[
        [
          'AASd-120',
          textwrap.dedent("""\
            <field_body><paragraph><AttributeReference refuri="Referable.id_short">Referable.id_short</AttributeReference> of non-identifiable referables shall be unique in its
            namespace.</paragraph></field_body>""")],
        [
          'AASd-003',
          '<field_body><paragraph><AttributeReference refuri="Referable.id_short">Referable.id_short</AttributeReference> of <SymbolReference refuri=".Referable">.Referable</SymbolReference>\'s shall be matched case-sensitive.</paragraph></field_body>']],
      parsed=...),
    book_url='__book_url__',
    book_version='__book_version__'))